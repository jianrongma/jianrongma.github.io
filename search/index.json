[{"content":"Python学习 第一章 一个基本的原理：计算机只认识二进制，即：0和1 img\r什么是编程语言 用于人类和计算机进行交流的一种专有领域语言，通过编写编程语言的代码，去指挥计算机工作。但它无法直接和计算机沟通，需要翻译工具（解释器****或编译器）将代码翻译成二进制，提交计算机执行，从而实现和计算机的顺畅沟通。\nimg\r注 IDE 集成开发环境，是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如Visual Studio\u0026hellip;\u0026hellip;\nPython解释器 一个基本的原理是：计算机只认识二进制，即0和1 其实，计算机是不会认识Python代码的，但是Python有解释器程序，如下图\nimg\r安装Python环境，本质上，就是在电脑中安装：Python解释器程序\n代码随时写，但是能不能运行，就要看电脑里有没有解释器程序了\nPython解释器，是一个计算机程序，用来翻译Python代码，并提交给计算机执行\n功能： 翻译代码为计算机认识的二进制（0和1）的形式并提交给计算机执行； 在解释器环境内可以一行行的执行我们输入的代码； 也可以使用解释器程序，去执行代码文件 解释器存放位置 \u0026lt;Python安装目录\u0026gt;/python.exe\nimg\r我们在CMD（命令提示符）程序内，执行的python，就是上图的python.exe程序\nimg\r不使用解释器，计算机就不认识Python代码\nimg\r使用Python解释器程序，就能执行Python代码了\nimg\r思考 在python解释器程序内，写完一行代码并回车后，会直接运行他\n如何一次性运行好多行代码？ 可以将代码，写入一个以”.py”结尾的文件中，使用python命令去运行它\n如，在Windows系统的某盘，新建一个名为：test.py 的文件，通过记事本程序打开，输入如下内容：\nimg\r在“命令提示符”程序内，使用python命令，运行，如图：\nimg\r第一个Python程序 print(\u0026ldquo;Hello World!!!\u0026rdquo;)\n含义：向屏幕上输出(显示)，Hello World!!!\n注 括号和引号都是英文状态下输入\n打开CMD（命令提示符）程序，输入Python并回车 然后，在里面输入代码回车即可立即执行\nimg\r练习 请在“命令提示符”（CMD）程序内，通过Python，向屏幕上输出：零基础，学Python，月薪过万，就来黑马程序员\nimg\r常见问题 找不到“命令提示符”程序在哪里 使用快捷键：win + r 打开运行框，输入cmd后回车即可打开命令提示符程序\n命令提示符内，输入python出现：\u0026lsquo;python\u0026rsquo; 不是内部或外部命令，也不是可运行的程序或批处理文件 img\r是因为在安装python的时候，没有勾选 add python 3.10 to PATH的选项\nimg\r卸载Python，重新安装python，勾选这个选项。 然后重新打开命令提示符程序，即可\n如果命令提示符内，出现 无法初始化设备 PRN img\r这是因为没有进入到python解释器环境内执行代码\n应该在命令提示符内\nimg\r执行出现：SyntaxError: invalid character \u0026lsquo;“\u0026rsquo; (U+201C) img\r这是因为，代码中的符号是中文符号。 请检查代码中的： - 双引号 - 小括号 这两个符号，应该是英文符号\nPython开发环境 Python程序的开发有许多种方式，一般我们常见的有：\nPython解释器环境内，执行单行代码； 使用Python解释器程序，执行Python代码文件； 使用第三方IDE（集成开发工具），如PyCharm软件开发Python程序 \u0026mdash; 最常用 PyCharm需要以“工程”为单元，供我们使用。想要写代码需要先创建一个工程\n常用快捷键 打开软件设置：ctrl + alt + s\n复制当前代码：ctrl + d\n将当前行代码上移或下移：shift+ alt + 上\\下\n重命名文件：ctrl + f6\n运行当前代码：ctrl + shift + f10\n第二章-Python入门语法\n一. 字面量 字面量的含义 在代码中，被写下来的固定的值，称之为字面量\n常见的字面量类型有 python中常用的有6种值（数据）的类型\n类型 描述 说明 数字（Number） 整数(int)浮点数(float)复数(complex)布尔(bool) 整数（int），如：10、-10浮点数（float），如：13.14、-13.14复数(complex)，如：4+3j，以j结尾表示复数布尔（bool）表达现实生活中的逻辑，即真和假，True表示真，False表示假。 True本质上是一个数字记作1，False记作0 字符串（String） 描述文本的一种数据类型 字符串（String）由任意数量的字符组成 列表（List） 元组（Tuple） 集合（Set） 字典（Dictionary） 字符串 字符串（String），又称文本，是由任意的中文、英文、各类符号、数字等组成的。\n在Python中，字符串需要用双引号（\u0026quot;\u0026quot;）包围起来，被双引号包围起来的，都是字符串\n基于print语句完成各类字面量的输出 print(字面量)，如：\nprint(10)，输出整数10 print(14.32)，输出浮点数14.32 print(\u0026ldquo;黑马程序员\u0026rdquo;)，输出字符串：黑马程序员 img\rimg\r二. 注释 注释的作用 注释：在程序代码中，对程序代码进行解释说明的文字\n作用：注释不是程序，不会被执行。只是对程序代码进行解释说明，让别人可以看懂程序代码的作用，能够 大大增强程序的可读性。\n单行注释和多行注释 单行注释 以 #开头，#右边 的所有文字当作说明，而不是真正要执行的程序，起辅助说明作用\n注意，#号和注释内容一般建议以一个空格隔开\n单行注释一般用于对一行或一小部分代码进行解释\n多行注释 以 一对三个双引号 引起来（\u0026ldquo;\u0026ldquo;\u0026ldquo;注释内容\u0026rdquo;\u0026quot;\u0026quot;）来解释说明一段代码的作用使用方法 多行注释一般对：Python文件、类或者方法进行解释\n拓展-关于注释的面试题-注释能否互相嵌套？ 单行注释中能否使用多行注释？\n可以\n多行注释中能否使用单行注释？ 可以\n多行注释中能否使用多行注释？ 不能！\nimg\rimg\r三. 变量 变量的作用与特征 作用 变量：就是程序在运行的时候，记录数据用的\n变量就像盒子 可以存放内容\nimg\r特征 变量存储的数据，是可以发生改变的\nimg\r变量的定义方式 变量名称 = 变量值\n变量名称：每一个变量都有自己的名称，称之为：变量名，也就是变量本身\n=：赋值，表示将右边的值，赋给左边的变量\n变量值：每一个变量都有自己存储的值（内容），称之为：变量值\n思考 为什么要使用变量？都是输出内容，直接输出不行吗？\n变量的目的是存储运行的过程的数据\n存储的目的是为了：重复使用\nprint语句如何输出多份内容？ print(内容1，内容2，\u0026hellip;，内容N)\n四. 数据类型及其转换 数据类型 使用什么语句可以查看数据的类型？ **type()**语句\n语法： type(被查看类型的数据)\ntype()语句的使用方式 在print语句中，直接输出类型信息\nprint(type(被查看类型的数据))\n用变量存储type()的结果（返回值） 变量名 = type(被查看类型的数据)\nprint(变量名)\ntype()语句也能查看变量中存储的数据的类型\n变量有类型嘛 变量无类型，但是它存储的数据有类型\nimg\r字符串变量：并不是变量是字符串，而是存储了字符串类型的数据\n数据类型转换 常见的转换语句 语句（函数） 说明 int(x) 将x转换为一个整数 float(x) 将x转换为一个浮点数 str(x) 将x转换为字符串 **这三个语句，同****type()**语句一样，都是有结果的（返回值），我们可以用print直接输出，或用变量存储结果值\n类型转换注意事项 任何类型，都可以通过str()转换成字符串类型 img\r字符串内必须真的是数字，才可以将字符串转换为数字 浮点数转换为整数会丢失精度，也就是小数部分 五. 标识符 什么是标识符 是用户在编程的时候所使用的一系列名字，用于给变量、类、方法等命名\n标识符命名规则 内容限定 标识符命名中，只允许出现： 英文 中文 数字 下划线（_） 这四类元素，其余的任何内容都不被允许 注意： 不推荐使用中文 数字不可以开头 大小写敏感 不可使用关键字 Python中有一系列单词，称之为关键字。关键字在Python中都有特定用途，我们不可以使用它们作为标识符\nimg\r标识符命名规范-变量的命名规范 见名知意 明了：尽量做到，看到名字，就知道是什么意思\nimg\r简洁：尽量在确保“明了”的前提下，减少名字的长度\nimg\r下划线命名法 多个单词组合变量名，要使用下划线做分隔\nimg\r英文字母全小写 img\r六. 运算符 算术（数学）运算符 运算符 描述 实例 + 加 - 减 * 乘 / 除 // 取整除 返回商的整数部分 9//2 输出结果是4，9.0//2.0 输出结果4.0 % 取余 9 % 2 = 1 ** 指数 2 ** 6，输出结果 2的六次方 赋值运算符 运算符 描述 实例 = 把 = 右边的结果 赋给 左边的变量 num = 1 + 2 * 3，结果num的值为7 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取余赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a 七. 字符串扩展 字符串类型的不同定义方式 字符串在Python中有3种不同的定义方式：\n双引号定义 \u0026ldquo;字符串\u0026rdquo;\n单引号定义 \u0026lsquo;字符串\u0026rsquo;\n三引号定义 \u0026ldquo;\u0026ldquo;\u0026ldquo;字符串\u0026rdquo;\u0026rdquo;\u0026rdquo;\nimg\r注意\n包含的范围是：从三个引号开始，到下一个三个引号结束 \u0026ldquo;\u0026ldquo;\u0026ldquo;字符串\u0026rdquo;\u0026rdquo;\u0026rdquo; 字符串\u0026rdquo;\u0026rdquo;\u0026quot;\n这部分是字符串\n三引号定义法，跟多行注释的写法一样，同样支持换行操作 使用变量接收它，它就是字符串 不使用变量接收它，就可以作为多行注释使用 字符串的引号嵌套 如果想要定义字符串本身，是包含：单引号、双引号自身呢？如何写？\n单引号定义法，可以内含双引号 双引号定义法，可以内含单引号 可以使用转义字符（\\）来将引号解除效用，变成普通字符串 字符串拼接 通过“+”连接字符串变量或者字符串字面量\nimg\rimg\r注意\n无法和非字符串类型进行拼接\nimg\rimg\r但是，用逗号 “，” 输出多项内容是可以的\nimg\rimg\r字符串格式化 格式化方式1 通过占位的形式拼接字符串（字符串格式化）\n%s：\n% 表示：我要占位 s 表示：将变量变成字符串放入占位的地方 所以，综合起来的意思是：我先占个位置，待会有个变量过来，我把它变成字符串放在占位的位置\n注意：多个变量占位，变量要用括号括起来，并按照占位的顺序填入\n在Python中，支持非常多类型的数据类型占位，最常用的三类有：\n格式符号 转化 %s 将内容转换为字符串，放入占位位置 %d 将内容转换为整数，放入占位位置 %f 将内容转换为浮点数，放入占位位置 在字符串格式化的过程中要做数字的精度控制 精度控制的语法 m.n的形式控制，如%5.3d、%6d、%.3f\n%5d：表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成：[空格][空格][空格]11，用三个空格补足宽度。 %5.2f：表示将宽度控制为5，将小数点精度设置为2 小数点和小数部分也算入宽度计算。如，对11.345设置了%7.2f 后，结果是：[空格][空格]11.35。2个空格补足宽度，小数部分限制2位精度后，四舍五入为 .35 %.2f：表示不限制宽度，只设置小数点精度为2，如11.345设置%.2f后，结果是11.35 m和.n均可省略\n如果 m 比数字本身宽度还小，则 m 无效 .n 在对小数部分做精度限制的同时还做四舍五入 格式化方式2 **f\u0026quot;内容{变量}\u0026quot;**的方式进行快速格式化\n这种方式不理会数据类型，不用做精度控制 img\rimg\r对表达式进行格式化 什么是表达式 一条具有明确执行结果的****代码语句\n如： 1 + 1、5 * 2，就是表达式，因为有具体的结果，结果是一个数字 又或者，常见的变量定义： name = “张三” age = 11 + 11 等号右侧的都是表达式呢，因为它们有具体的结果，结果赋值给了等号左侧的变量。\n对表达式进行字符串格式化 对于字符串可以格式化，也可以对表达式进行格式化\n语法：\nf\u0026quot;{表达式}\u0026quot; \u0026ldquo;%s%d%f\u0026rdquo; % (表达式，表达式，表达式) img\rimg\r八. 数据输入 input()\n功能：获取键盘的输入\n原理：\n使用input()语句接收使用键盘输入的内容；\n命名一个变量存储input语句获取的键盘输入数据\n数据输出：print()\nimg\rimg\r可以使用：input(提示信息)，用以在使用者输入内容之前显示提示信息\n注意：\n无论键盘输入什么类型的数据，获取到的数据永远都是字符串类型\nimg\rimg\r第三章-Python判断语句\n01_布尔类型和比较运算符 布尔类型 进行判断，只有两个结果：\n是 否 程序中，使用布尔类型描述：是或否 Python中常用的 6 种数字类型： img\r布尔类型的定义 布尔类型的字面量： True 表示真（是、肯定） False 表示假（否、否定） 定义变量存储布尔类型的数据 变量名称 = 布尔类型字面量\n注： 布尔类型****不仅可以自行定义，同时也可以通过计算的来。\n也就是使用比较运算符进行比较运算得到布尔类型的结果\n比较运算符 布尔类型的数据，不仅可以通过定义得到，也可以通过比较运算符得到\nimg\r02_if语句的基本格式 if语句的基本格式 if 要判断的条件:\n​ 条件成立时，要做的事情\nif语句的注意事项\n判断条件的结果一定是布尔类型 不要忘记判断条件后的 : 引号 归属于if语句的代码块，需在前方填充 4 个空格缩进 img\rimg\rimg\rimg\r04_if else组合判断 在 if else 语句中： if和其代码块，在条件满足时执行 else搭配if的判断条件，当条件不满足时执行 if else 注意事项： else 不需要判断语句，当if条件不满足时，else执行 else的代码块，同样要4个空格缩进 img\rimg\r06_if_elif_else组合使用 if elif else 语句的作用是 可以完成多个条件的判断\nimg\rimg\r使用 if elif else 的注意点有： elif 可以写多个 空格缩进同样不可省略 判断是互斥且有序的，上一个满足后面的就不会判断了 img\r可以在条件判断中，直接写input语句，节省代码量，使代码看起来更简洁 img\rimg\r07_案例—猜猜心里数字 题目 1. 定义一个变量，数字类型，内容随意。 2. 基于input语句输入猜想的数字，通过if和多次elif的组合，判断猜想数字是否和心里数字一致。 输出如下： \u0026quot; 请输入第一次猜想的数字:1 不对，再猜一次:2 不对，再猜最后一次:3 Sorry，全部猜错啦，我想的是:10 \u0026quot;\n误解： img\rimg\r正解： img\rimg\r08_判断语句的嵌套 基础语法格式 img\r嵌套判断语句可以用于多条件、多层次的逻辑判断 嵌套判断语句可以根据需求，自由组合if elif else 来构建多层次判断 嵌套判断语句，一定要注意空格缩进，Python通过空格缩进来决定层次关系 img\r嵌套有两层\n当外层if满足条件时，才会执行内层if判断 当外层if不满足时，直接执行外层else 第四章-Python循环语句\n01_while循环的基础应用 1.while循环的语法格式 while 条件：\n​ 条件满足时，做的事情1\n​ 条件满足时，做的事情2\n​ \u0026hellip;\u0026hellip;.\n只要条件满足会无限循环\n2.while循环的注意事项 While 循环的条件需得到布尔类型，True 表示继续循环；False 表示循环结束 需要设置循环终止的条件，如i += 1配合 i \u0026lt; 100，就能确保100次后停止，否则将无限循环 空格缩进和if判断一样，都需要设置 03_while循环猜数字案例 img\rimg\r04_while循环的嵌套应用 嵌套循环的语法格式 img\r嵌套循环要注意的地方 注意条件的控制，避免出现无限循环（除非真的需要无限循环） 多层嵌套，主要空格缩进来确定层次关系 嵌套循环的使用难点 循环条件的控制，层次越多越复杂，需要细心+耐心\nimg\r05_while循环案例—九九乘法表 补充知识 print 输出不换行 在print语句中加上 end=\u0026rsquo;\u0026rsquo; 即可输出不换行\nimg\rimg\r制表符\\t 字符串中，特殊符号：\\t，效果相当于在键盘上按下：Tab键\n可以让我们的多行字符串进行对齐\nimg\rimg\r案例 - 使用while循环打印九九乘法表 解析 两层循环 外层循环 - 控制行；循环条件为：i \u0026lt;= 9 内层循环 - 控制每行输出的内容；九九乘法表每行的个数与行数对应；循环条件为： j \u0026lt;= i img\rimg\r06_for循环的基础语法 for循环与while循环的区别 while循环的循环条件是自定义的，自行控制循环条件 for循环是一种**“轮询”机制，是对一批内容进行“逐个处理”；就是将“待办事项”逐个完成的循环机制** 语法格式 for 临时变量 in 待处理数据集：\n​ 循环满足条件时执行的代码\n在for循环语法中待处理的数据集，严格来说，称之为：可迭代类型 可迭代类型指的是：其内容可以一个个依次取出的一种类型，包括：\n字符串\n列表\n元组\n等\nimg\rimg\r从待处理数据集中：逐个取出数据，赋值给临时变量\nfor循环注意的点 同while循环不同，for循环是无法定义循环条件的，只能从被处理的数据集中，依次取出内容进行处理 循环内的语句，要有空格缩进 img\r08_range语句 语法1 range(num)\n获取一个从0开始，到num结束的数字序列（不含num本身）\n语法2 range(num1，num2)\n获取一个从num1开始，到num2结束的数字序列（不含num2本身）\n语法3 range(num1,num2,step)\n获取一个从num1开始，到num2结束的数字序列（不含num2本身），数字之间的步长，以step为准，（step默认为1）\nimg\rimg\r09_for循环临时变量作用域 在for循环中的临时变量，其作用域限定为：\n循环内\n这种限定\n是编程规范的限定，而非强制限定 不遵守也能正常运行，但是不建议这样做 如需访问临时变量，可以预先在循环外定义它 img\r在每次循环的时候，都会将取出的值赋值给i变量：\n由于i变量是在循环外定义的，所以在循环外访问i变量是合理的、允许的 10_for循环的嵌套应用 for循环的嵌套语法 img\r注意事项 注意缩进，嵌套for循环同样通过缩进确定层次关系 for循环和while循环可以相互嵌套使用 img\r11_for循环打印九九乘法表 img\r12_continue和break 循环都是重复性的执行特定操作，可以使用continue和break关键字对循环进行临时跳过和直接结束\ncontinue关键字 中断本次循环，直接进入下一次循环\n可以用于for和while循环，效果一致\nbreak关键字 直接结束所在循环\n可以用于for和while循环，效果一致\n在嵌套循环中的使用 continue和break都只可以控制：它所在的循环，无法对上层循环起到作用\n第五章-Python函数\n01_函数的初体验 函数：是组织好的，可以重复使用的，用来实现特定功能的代码段 我们使用过的input()、print()、str()、int()等都是Python的内置函数\n使用函数的好处 将功能封装在函数内，可供随时随地的重复利用 提高代码的复用性，减少重复代码，提高开发效率 02_函数的基础定义语法 函数的定义 Def 函数名(传入的参数):\n​ 函数体\n​ return 返回值\n函数的调用 函数名(参数)\n函数的使用步骤 先定义函数 再调用函数 注意事项 参数不需要，可以省略 返回值不需要，可以省略 img\rimg\r04_函数的传入参数 函数的传入参数的功能 在函数进行计算的时候，接受外部（调用时）提供的数据\nimg\rimg\r函数的功能非常局限，只能计算1 + 2。\n函数的传入参数 - 语法解析 img\r函数中，提供的a和b，称之为：形式参数（形参），表示函数声明将要使用的两个2个参数 参数之间用逗号进行分隔 函数调用中，提供的5和6，称之为：实际参数（实参），表示函数执行时真正使用的参数值 传入的时候按照顺序进行传入，使用逗号分隔 注意事项 函数定义中的参数，称之为形式参数（形参） 函数调用中的参数，称之为实际参数（实参） 函数的参数数量不限，使用逗号分开 传入参数的时候，要和形参一一对应，逗号隔开 传入的参数是不受限制的： 可以不使用参数 也可以使用任意N个参数 06_函数的返回值定义语法 什么是函数的返回值 函数在执行完成后，返回给调用者的结果\n返回值的应用语法 使用关键字：return 来返回结果\ndef 函数名(传入参数):\n​ 函数体\n​ return 返回值\n变量 = 函数(参数)\n变量就能接收函数的返回值 img\rimg\r注意 函数体在遇到return后结束了，所以写在return之后的代码不会被执行\n07_函数返回值之None类型 思考 如果函数没有使用return语句返回数据，那么函数有返回值吗？\n实际上是：有的\nPython中有一个特殊的字面量****：None，其类型是：\u0026lt;class\u0026rsquo;NoneType\u0026rsquo;\u0026gt;\n无返回值的函数，实际上是返回了：None这个字面量\nimg\rimg\rNone的含义 None表示：空的，无实际意义的意思\n函数返回的None，就表示，这个函数没有返回什么有意义的内容。 也就是返回了空的意思。\nNone类型的应用场景 None作为一个特殊的字面量，用于表示None：空、无意义，其有非常多的应用场景。\n用在函数无返回值上 img\rimg\r用在if判断上 在if判断中，None等同于False 一般用于在函数中主动返回None，配合if判断做相关处理 img\rimg\r用在声明无内容的变量上 定义变量，但是暂时不需要变量有具体值，可以用None来代替 img\r08_函数的说明文档 函数的说明文档的作用是 函数是纯代码语言，通过函数的说明文档对函数进行说明解释，帮助更好的理解函数功能\n语法 img\rparam：用于解释参数\nreturn：用于解释返回值\n在PyCharm中查看函数说明文档 在PyCharm编写代码时，可以通过鼠标悬停，查看调用函数的说明文档\nimg\r09_函数的嵌套调用 定义 指的是一个函数里面又调用了另外一个函数\nimg\rimg\r执行过程 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕后，继续执行 函数A的剩余内容\n10_变量在函数中的作用域 变量作用域指的是变量的作用范围（变量在哪里可以用，在哪里不可用） 主要分为：\n局部变量 全局变量 局部变量 定义 定义在函数体内部的变量，即只在函数体内部生效\n作用 在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量\nimg\rimg\rimg\r全局变量 定义 指的是，在函数体内、外都能生效的变量\nimg\rimg\rglobal关键字 在函数内修改全局变量 img\rimg\r函数test_b的num跟外部定义的num并不是同一个num， 函数test_b的num是函数test_b定义的一个局部变量\n使用global关键字，可以在函数内部声明变量为全局变量 img\rimg\r11_函数综合案例 第六章-Python数据容器\n01_数据容器入门 定义 一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素，每一个元素，可以是任意类型的数据，如：字符串、整数、布尔类型等\n分类 列表（list） 元组（tuple） 字符串（str） 集合（set） 字典（dict） 列表 02_列表的定义语法 字面量 [元素1，元素2，元素3，元素4，\u0026hellip;\u0026hellip;\u0026hellip;]\n变量 变量名称 = [元素1，元素2，元素3，元素4，\u0026hellip;\u0026hellip;\u0026hellip;.]\n定义空列表\n变量名称 = []\n变量名称 = list()\n说明 列表内的每一个数据称之为，元素\n以 [] 作为标识\n列表内的每一个元素之间用 ， 逗号隔开\n注意 列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套\n03_列表的下标索引 定义 列表的每一个元素，都有编号称之为下标索引\n从左往右（从前往后）的方向，编号从0开始递增\n从右往左（从后往前）的方向，编号从-1开始递减\n如何通过下标索引取出对应位置的元素 列表[下标]，即可取出 注意事项 要注意下标索引的取值范围，超出范围无法取出元素，并且会报错\nimg\rimg\r04_列表的常用操作（方法） 函数和方法 列表的查询功能（方法）\n函数：是一个封装的代码单元，可以提供特定的功能\n在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法\n方法和函数功能一样， 有传入参数，有返回值，只是方法的使用格式不同：\n函数的使用： num = add(1,2) 方法的使用： Student = Student()\nnum = student.add(1,2)\n总览 列表的特点 可以容纳多个元素（上限为2**63-1、9223372036854775807个） 可以容纳不同类型的元素（混装） 数据是有序存储的（有下标符号） 允许重复数据存在 可以修改列表中的元素（增删改查） 06_列表的循环遍历 什么是遍历 将数据容器内的元素依次取出，并处理，称之为遍历操作\n如何遍历列表的元素 可以使用while循环或for循环 while循环 使用列表[下标]的方式取出数据容器中的元素 循环条件如何控制？ 定义一个变量表示下标，从0开始 循环条件为 下标值 \u0026lt; 列表的元素数量\nfor循环 for 临时变量 in 数据容器：\n对临时变量进行处理\nfor循环和while循环的对比 在循环控制上 while循环可以自定循环条件，并自行控制 for循环不可以自定循环条件，只可以一个个从容器内取出数据 在无限循环上 while循环可以通过条件控制做到无限循环 for循环理论上不可以，因为被遍历的容器容量不是无限的 在使用场景上 while循环适用于任何想要循环的场景 for循环适用于，遍历数据容器的场景或简单的固定次数循环场景 07_元组的定义和操作 元组同列表一样，都是可以封装多个、不同类型的元素在内。\n定义语法 定义元组使用小括号，且用逗号隔开各个数据，数据可以是不同的数据类型\n(元素，元素，元素\u0026hellip;..)\n变量名称 = (元素，元素，元素\u0026hellip;..)\n注意事项1 元组只有一个数据，这个数据后面就要添加逗号 img\rimg\rimg\rimg\r元组也支持嵌套 元组的相关操作 由于元组不可修改的特性，所以操作方法很少 查找某个元素，如果元素存在返回对应的下标，否则报错 元组**.index（元素）**\n统计某数据在当前元组出现的次数 元组**.count(元素)**\n统计元组内的元素个数 len(元组)\n注意事项2 不可以修改元组中的内容，否则就会报错 可以修改元组内的 list 的内容（列表的增删改查） 不可以替换 list 为其他 list 或者其他类型 元组的遍历 使用for循环或者while循环\n元组的特点 可以容纳多个数据 可以容纳不同类型的数据（混装） 数据是有序存储的（下标索引） 允许重复数据的出现 不可以修改（增删改） 支持for循环和while循环 08_字符串的定义和操作 定义 字符串是字符的容器，一个字符串可以存储任意数量的字符\n字符串的下标索引 和其他容器一样：列表、元组，字符串也可以通过下标索引进行访问\n从前向后，下标从0开始递增 从后向前，下标从-1开始递减 字符串同元组一样，是一个不可修改的数据容器\n字符串的常用操作 查找特定字符的下标索引值 字符串.index（字符）\n字符串的替换 字符串.replace（字符串1，字符串2）\n将字符串内的全部内容：字符串1，替换为字符串2\n注意:不是修改字符串，而是得到了一个新的字符串\n字符串的分割 字符串.split（分隔符字符串）\n按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中\n注意：字符串本身不变，而是得到了一个列表对象\nimg\rimg\r拓展 字符串的切片 从字符串中提取一部分的操作\n使用索引来指定开始和结束的位置\n语法： [start:end:step]\nstart：开始位置的索引（包含） end：结束位置的索引（不包含） step：步长，每次移动的索引数 img\r字符串的规整操作 字符串.strip（）\n去前后指定字符串\n字符串.strip（字符串）\n统计字符串中某字符串的出现次数 字符串.count（字符串）\n统计字符串的长度 len（字符串）\n字符串的遍历 同样支持for循环和while循环\n字符串的特点 只可以存储字符串 长度任意（取决于内存大小） 支持下标索引 允许重复字符串存在 不可以修改（增加或删除元素等） 支持for循环 10_数据容器（序列)的切片 序列 序列是指：内容连续、有序，可以使用下标索引的一类数据容器\n那些数据类型可以视作序列 列表、元组、字符串 序列的常用操作：切片 序列支持切片，即：列表、元组、字符串，均支持进行切片操作\n切片：从一个序列中，取出一个子序列\n语法 序列[起始下标:结束下标:步长]\n说明： 表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列\n起始下标表示从何处开始，可以留空，留空视作从头开始； 结束下标（不含）表示从何处结束，可以留空，留空视作截取到结尾 步长表示：依次取出元素的间隔是多少，默认为1 步长1，表示一个个取出元 步长2，表示每次跳过1个元素取 步长N，表示每次跳过N-1个元素取 步长为负数，表示反向取（注意，起始下标和结束下标也要反向标记） 此操作不会影响序列本身，而是得到一个新的序列（列表、元组、字符串） 12_集合的定义和操作 集合的定义 基本语法 集合字面量 {元素，元素，元素\u0026hellip;..}\n集合变量 变量名称 = {元素，元素，元素}\n空集合 集合名称 = set()\n集合的特点 可以容纳多个数据 可以容纳不同类型的数据（混装） 数据是无序存储的（不支持下标索引） 不允许重复数据的存在 可以修改（增删改查） 只支持for循环 集合的操作 14_字典的定义 定义 同样使用 {}，不过存储的元素是一个个的：键值对\nimg\rimg\r语法 my_dict = {Key: value,key: value,\u0026hellip;.,key: value}\n使用{}存储元素，每一个元素是一个键值对 每一个键值对包含key和value（用冒号分隔） 键值对之间用逗号分隔 key和value可以是任意类型的数据(key不可为字典) key不可重复，重复会覆盖原有数据 img\r字典不可用下标索引，而是通过key检索value 字典的嵌套 字典的Key和Value可以是任意数据类型（Key不可为字典）。表明，字典是支持嵌套的\n嵌套字典的内容获取\nimg\r15_字典的常用操作 增删改查 新增 语法：字典[key] = value\n结果：字典被修改，新增了元素\n注意：字典key不可以重复，所以对已存的key执行上述操作，就是更新value值\n删 删除 语法：字典.pop(key)\n结果：获得指定key的value值，同时字典被修改，指定key的数据被删除\n清空字典 语法：字典.clear()\n结果：字典被修改，元素被清空\n修改 - 更新 语法：字典[key] = value\n结果：字典被修改，元素被更新\n查 语法：字典[key] 可以获取到对应的value 获取全部的key 语法：字典.keys()\n结果：得到字典中的全部key\n遍历字典 语法：for key in 字典.keys():\n注意：字典不支持下标索引，所以不可以使用while循环遍历\n计算字典内的全部元素（键值对）的数量 语法：len(字典)\n结果：得到一个整数，表示字典内元素（键值对）的数量\n字典的特点 可以容纳多个数据 可以容纳不同类型的数据 每一份数据是keyvalue键值对 可以通过key获取到value，key不可以重复（重复会覆盖） 不支持下标索引 可以修改（增删改查） 支持for循环遍历，不支持while循环遍历 17_5类数据容器的总结 数据容器特点对比 列表 元组 字符串 集合 字典 元素数量 支持多个 支持多个 支持多个 支持多个 支持多个 元素类型 任意 任意 字符 任意 Key: valuekey：除字典外的任意类型value：任意类型 下标索引 支持 支持 支持 不支持 不支持 重复元素 支持 支持 支持 不支持 不支持 可修改性 支持 不支持 不支持 支持 支持 数据有序 是 是 是 否 否 使用场景 可修改、可重复的一批数据 不可修改、可重复的一批数据 一串字符的记录场景 不可重复的数据记录场景 以key检索的value的数据记录场景 18_数据容器的通用操作 功能 描述 通用for循环遍历 遍历容器（字典是遍历key） len() 统计容器中的元素个数 max() 容器中最大元素 min() 容器中最小元素 list() 转换为列表 tuple() 转换为元组 str() 转换为字符串 set() 转换为集合 sorted(序列，[reverse=True]) 排序，reverse=True表示降序得到一个排好序的列表 19_拓展-字符串大小比较的方式 ASCII码表 在程序中，字符串所用的字符，如：\n大小写英文单词 数字 特殊符号 都有其对应的 ASCII表\n每一个字符都能对应上一个：数字的码值 字符串进行比较就是基于数字的码值大小进行比较的。\nimg\r字符串是按位比较，也就是一位位进行对比，只要有一位大，那么整体就大。\n第七章-Python函数进阶\n01_函数的多返回值 多个返回值书写代码：\ndef 函数名(形式参数):\n​ 函数体\n​ return 返回值1,返回值2\nimg\rimg\r在调用该函数的时候，按照返回值的顺序，写对应顺序的多个变量接收即可\n变量之间用逗号隔开\n支持不同类型的数据 return\n02_函数的多种参数使用形式 根据使用方式上的不同，函数有4种常见参数的使用方式：\n位置参数 调用函数时根据函数定义的参数位置来传递参数\n注意：传递的参数和定义的参数的顺序及个数必须一致\nimg\r关键字参数 函数调用的时候通过“键=值”形式传递参数\n作用：可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求\n注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序\nimg\r缺省参数 也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值‘\n注意：当调用函数时没有传递参数，就会使用默认是用缺省参数对应的值\n函数调用时，如果为缺省参数传值则修改默认参数值，否则使用这个默认值\nimg\r不定长参数 也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参也可以）的场景\n作用：当调用函数时不确定参数个数时，可以使用不定长参数\n类型：\n位置传递 以*号标记一个形式参数，以元组的形式接受参数，形式参数一般命名为****args\n关键字传递 以*号标记一个形式参数，以字典的形式接受参数，形式参数一般命名为kwargs*\nimg\r03_函数作为参数传递 函数本身是可以作为参数，传入另一个函数中进行使用的\n其作用在于：传入计算逻辑，而非传入数据\nimg\rimg\r04_lambda匿名函数 函数定义中，\ndef关键字，可以定义带有名称的函数，可以基于名称，重复使用 lambda关键字，可以定义匿名函数（无名称），只可临时使用一次 匿名函数的定义方法 lambda 传入参数：函数体（一行代码）\nlambda是关键字，表示定义匿名函数 传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数 函数体，函数的执行逻辑 注意：\n只能写一行函数体，无法写多行代码\nimg\r第九章-Python异常、模块与包\n01_了解异常 什么是异常 当检测到一个错误的时候，Python解释器就无法继续执行了，反而出现一些错误的提示，这就是所谓的“异常”，也就是我们常说的BUG\nbug是什么意思 bug就是指异常，历史上因为一个小虫子导致计算机失灵的案例，所以延续至今，bug就代表软件出现错误\n异常的演示 img\r02_异常的捕获 为什么要捕获异常 在可能发生异常的地方，进行捕获，当异常出现的时候，提供解决方案，而不是任由其导致程序无法运行\n捕获异常的语法 基本语法 try：\n可能发生错误的代码\nexcept：\n如果出现异常执行的代码\nimg\r捕获指定异常 try：\n可能发生错误的代码\nExcept 指定异常名称 as 别名：\n如果出现异常执行的代码\nimg\r注意：\n如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常 一般try下方只放一行尝试执行的代码 img\r捕获多个异常 当捕获多个异常的时候，可以把要捕获的异常类型的名字，放到except之后，并使用元组的方式进行书写\nimg\r捕获异常并输出描述信息 img\r捕获所有异常 try：\n可能发生错误的代码\nExcep Exception as 别名：\n如果出现异常执行的代码\nimg\r异常else else表示的是如果没有异常要执行的代码\nimg\r异常的finally finally表示的是无论是否一场都要执行的代码，例如关闭文件\nimg\r03_异常的传递性 异常是具有传递性的\nimg\rimg\rimg\r第一章-Python面向对象\n01_初识对象 使用对象完成数据组织的思路 生活中的数据组织\n学校开学，要求学生填写自己的基础信息，一人发一张白纸，让学生自己填，最后的结果是内容混乱\nimg\rimg\r改为登记表，打印出来让学生自行填写：整洁明了\nimg\r程序中使用对象组织数据 在程序中是可以做到像生活中那样，设计表格、打印表格、填写表格的组织形式的\n设计表格，称之为：设计类 class 打印表格，称之为：创建对象 填写表格，称之为：对象属性赋值 img\rimg\r02_类的成员方法 使用类去封装属性，并基于类创建出一个个对象来使用\n类的使用语法 class 类名称：\n类的属性\n类的行为\nclass是关键字，表示要定义类了 类的属性，是定义在类中的变量（成员变量） 类的行为，是定义在类中的函数（成员方法） 创建类对象的语法 对象名称 = 类名称（）\nimg\r成员变量和成员方法 成员方法的定义语法 Def 方法名(self,形参1,\u0026hellip;\u0026hellip;,形参N)：\n方法体\n其中self关键字是必须写的，\n表示类对象自身的意思 当使用类对象调用方法的时候，self会被python自动传入 在方法内部，想要访问类的成员变量，必须使用self 但是在传参的时候可以忽略 img\rimg\rimg\r注意 函数是写在类之外的，定义在类内部的，都称之为方法\n03_类和对象 现实世界的事物和类 img\r现实世界的事物也有属性和行为，类也有属性和行为\n使用程序中的类，可以完美的描述现实世界的事物\n类和对象 基于类创建对象的语法：对象名 = 类名称()\n为什么非要创建对象才能使用呢？ **类只是一种程序内的“设计图纸”，需要基于图纸生产实体“对象”，才能正常工作，这种套路，称之为：**面向对象编程\n使用类和对象描述现实事物 在现实中，生产事物 img\r在程序中通过类来描述 img\r基于类创建对象 img\r这就是面向对象编程，设计类，基于类去创建对象，由对象做具体的工作\nimg\rimg\r04_构造方法 为对象的属性赋值需要依次进行，略显繁琐，选择更加高效的构造方法的方式，使其一行代码就能完成\n语法 Python类可以使用：**_ init _()**方法，称之为构造方法\n可以实现：\n在创建类对象（构造类）的时候，会自动执行 在创建类对象（构造类）的时候，将传入参数自动传递给_ init _()方法使用 注意事项 构造方法名称：_ init _（）,千万不能忘记init前后都有2个下划线 构造方法也是成员方法，不要忘记在参数列表中提供：self 在构造方法内定义成员变量，需要使用self关键字 img\rimg\r05_魔术方法 Python内置的类方法，统称为：魔术方法\n常见的有：\n_ init _() 构造方法 _ str _() 字符串方法 当类对象需要被转换为字符串时，输出结果为：内存地址\nimg\r内存地址没有多大作用，我们可以通过__str__方法，控制类转换为字符串的行为。\nimg\r_ lt _() 小于、大于符号比较 直接对2个对象进行比较是不可以的\n但是在类中使用_ lt _()方法，即可同时完成：小于符号 和 大于符号的比较\n方法名：_ lt _\n传入参数：other，另一个类对象\n返回值：True或者False\n内容：自定义\nimg\rimg\r_ le _() 小于等于、大于等于符号比较 可用于 \u0026gt;=大于等于和 \u0026lt;=小于等于 两种比较运算符\n方法名：_ le _\n传入参数：other，另一个类对象\n返回值：True和False\n内容：自定义\nimg\rimg\r_ eq _() ==符号比较 不使用__eq__方法，对象之间可以比较，但是是比较内存地址，也即是：不同对象==比较一定是False结果。\nimg\r使用_ eq _方法，就可以按照自己的想法来决定2个对象是否相等了\nimg\r06_封装 面向对象的三大特性 基于模板（类）去创建实体（对象），使用对象完成功能开发\n封装 继承 多态 封装的定义 封装表示的是，将现实世界事物的：\n属性 行为 封装到类中，描述为：\n成员变量 成员方法 从而完成程序对现实世界事物的描述\nimg\r对用户隐藏的属性和行为 现实世界中，有属性和行为 但是不代表所有的属性和行为都是开放给用户使用的，如手机：\nimg\r苹果越狱、安卓root，也是为了突破权限使用这些对用户隐藏的属性和行为\n私有成员和私有方法 在现实世界中，事物不公开的属性和行为，那么作为现实事物在程序中映射的类，也同样支持\n定义方法 私有成员变量：变量名以_ _开头（两个下划线）\n私有成员方法：方法名以_ _开头（两个下划线）\n私有成员的访问限制 类对象无法访问私有成员 img\r类中的其他成员可以访问私有成员 img\rimg\r实际意义 在类中提供仅供内部使用的属性和方法，而不对外开放（类对象无法使用）\n07_封装的课后练习题讲解 08_继承的基础语法 继承的定义 继承就是一个类，继承另外一个类的成员变量和成员方法（不含私有）\n分类 单继承 多继承 单继承 语法 class 类名(父类名):\n类内容体\nimg\r多继承 一个类，可以继承多个父类\n语法 class 类名(父类1，父类2，\u0026hellip;.，父类N)\n类内容体\n注意事项 多个父类中，如果有同名的成员，那么默认以继承顺序（从左到右）为优先级\n即：先继承的保留，后继承的被覆盖\npass关键字 pass是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思\nimg\rimg\r09_复写父类成员和调用父类成员 复写 子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写\n即：在子类中重新定义同名的属性或方法即可\nimg\rimg\r调用父类同名成员 一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员\n如果需要使用被复写的父类的成员，需要特殊的调用方式：\n方式1 调用父类成员\n使用成员变量方法：父类名.成员变量 使用成员方法：父类名.成员方法(self) img\r方式2 使用**super()**调用父类成员\n使用成员变量：super().成员变量 使用成员方法：super().成员方法() img\r注意 只可以在子类内部调用父类的同名成员\n子类的实体对象调用默认是调用子类复写的\n10_变量的类型注解 什么是类型注解？有什么作用？ 在代码中涉及数据交互之时，对数据类型进行显示的说明，可以帮助:\nPyCharm等开发工具对代码做类型推断协助做代码提示 开发者自身做类型的备注 类型注解支持 变量的类型注解 函数（方法）的形参和返回值的类型注解 变量的类型注解语法 语法1：变量:类型 img\r语法2：在注释中，#type:类型 img\r注意事项 类型注解只是提示性的，并非决定性的，数据类型和注解类型无法对应也不会导致错误\nimg\r11_函数和方法类型注解 函数（方法）可以为哪里添加注解 形参的类型注解 返回值的类型注解 函数（方法）的类型注解语法 def 函数方法名（形参：类型，\u0026hellip;.，形参：类型） -\u0026gt; 返回值类型：\n​ pass\n注意：返回值类型注解的符号使用\n-\u0026gt;\nimg\r12_Union联合类型注解 什么是Union类型？ 使用Union可以定义联合类型注解\nUnion的使用方式\n导包：from typing import Union 使用：Union[类型，\u0026hellip;，类型] img\r13_多态 多态的定义 多态指的是，同一个行为，使用不同的对象获得不同的状态。 如，定义函数（方法），通过类型注解声明需要父类对象，实际传入子类对象进行工作，从而获得不同的工作状态\n什么是抽象类（接口） 包含抽象方法的类，称之为抽象类。\n抽象方法是指：没有具体实现的方法（pass）称之为抽象方法\n抽象类的作用 多用于做顶层设计（设计标准），以便子类做具体实现。 也是对子类的一种软性约束，要求子类必须复写（实现）父类的一些方法并配合多态使用，获得不同的工作状态。\nimg\r以父类做定义声明 以子类做实际工作 用以获得同一行为, 不同状态 img\rimg\r","date":"2024-04-10T23:47:37+08:00","permalink":"https://jianrongma.github.io/p/pythonlearning/","title":"PythonLearning"},{"content":"资源约束/生产能力不确定+订单优先级相关文献\n基于优先级的柔性车间调度算法 Research on Priority-based Flexible Job Shop Scheduling Algorithm\n研究对象 航空发动机制造过程中的柔性作业车间调度问题\n柔性作业车间调度问题（FJSP）定义 在一个加工过程中，工件的集合W（W1,W2,W3,\u0026hellip;\u0026hellip;.)在一组机器M（M1,M2,M3,\u0026hellip;..）上加工，每道工序可由一台或多台机床加工，且满足以下约束条件：(1)机床一次只能加工一个工件。(2)工件一次只能用一台机器加工。(3)工件必须按照工艺规定的顺序加工。(4)不得中断进程。(5)不同工件、不同工艺之间不相互干扰。(6)优先考虑具有强制交付节点的工件。当工件在交付期之前完成时，会产生存储和维护费用，当工件在交付期之后完成，则无法按期交付，建立了评价函数如下：\nimg\re 是逾期工件的评估权重，a 是提前交付工件的评估权重，l 为工件完成时间，d 为工件交付时间。调度目标是获得评价函数的最小值。\n解决了什么问题 当前车间作业调度过程中存在订单强制节点（一些重要的订单必须在某个时间点准时交付，这往往会影响车间调度结果的质量）、设备选择等真实需求。\n研究现状 现有的分支定界法[9]、整数规划法[10]、遗传算法[11]、禁止搜索[12]等算法在设备选型过程中没有考虑到加工工艺是否存在强制交货时间，也没有根据设备负荷对加工工艺进行进一步优化。\n研究方法 根据工件的优先级和加工过程中设备的负荷，分两个阶段解决柔性车间作业调度问题。第一阶段：确定当前要加工的工件，第二阶段：确定用于加工该工件的设备。\n设计了一种人工干预的订单优先级计算方法：引入强制交货节点提出优先级计算函数 准确衡量订单溢出的风险，其中计算出的订单优先级越大，该订单溢出的风险越大。同时，决策者能够提前为强制节点订单设置优先级，从而确保强制节点订单在优先级的基础上得到处理\nimg\r改进了应用于机加工过程的层次分析方法 设计了一种基于层次分析法的设备选型方法。该方法可以对每台机器进行综合评价，从而选择最合适的机器，达到提高调度效率的目的；\n基于矩阵构造方法[13]、作业调度和设备负荷满足一致性检验的信息，改进了层次分析法。改进的层次分析法可以自动构造满足一致性检验的比较矩阵。\n设备最早可以开始加工的点 C1，越早，工件逾期的概率越低，优先选择C1小的设备； 设备上的总负荷 C2，越大，工件等待的概率越大，超限的概率也越大，优先选择C2小的设备； 设备上所有工件可以加工的总时长 C3，越大，该设备的资源竞争概率越大(两个工件在同一时间段内需要同一台机器加工)，工件超限的概率越大，优先选择较C3小的设备。 贡献 实验表明，所提出的车间作业调度算法有效地提高了车间作业调度结果的质量\n与现有算法相比，本文提出的求解算法是有效的，保证了强制节点工件在评价值最小化的情况下按时交付，既保证了工件完成率，又显著降低了库存，提高了企业的生产率和资金流动性。\n客户订单优先级的决策框架建议：一家结构钢公司的案例研究 A decision framework proposal for customer order prioritization: A case study for a structural steel company\n当目前被授予的项目开始覆盖公司的大部分设计和制造能力时，公司面临着选择下一个客户订单来合理分配剩余稀缺能力的决策问题。\n由于钢结构行业的性质，绝大多数的工作，近90%，是在设计和制造阶段完成的;剩下的10%是用非常少的工艺完成的安装\n表 1 评估标准\n标准 解释 单位时间的潜在利润率 考虑一定时期内利润的潜在利润率 潜在订单与可用容量的兼容性 潜在订单在公司有限产能方面的适用性水平 利润更高的潜在未来订单水平 接受比考虑中的需求更有利可图的未来需求的可能性水平 未来商机的客户信用 成为制造公司忠实客户的水平 订单生产计划的可协商性级别 项目在项目进度方面的灵活性水平 利润最大化是企业营利性的强制性目标。与利润率较低但运营时间较短的订单相比，利润率较高但运营时间较长的订单可能无利可图。因此，可以定义\u0026quot;单位时间****潜在利润率\u0026ldquo;代替总利润作为订单优先级决策的评价标准。\n在具有外部到期日的按订单生产系统中，优先级排序决策对订单准时概率和预期延迟的影响 Impact of priority sequencing decisions on on-time probability and expected tardiness of orders in make-to-order production systems with external due-dates\n探讨了按订单制造（MTO）生产系统中的优先级排序问题，使用马尔可夫决策过程（MDP）对该问题进行建模。目标函数被定义为一个固定的和一个可变的延迟成本的和，分别考虑“订单准时率”和“订单预期延迟”两个绩效标准。\n通过基准测试和数值结果分析发现通过采用简单的基于到期日期的规则，可以实现接近最优的系统性能。\n然而，最优策略以及性能最接近的简单规则在很大程度上取决于延迟惩罚中固定成本的相对价值。出现了固定成本并且难以满足到期日期时，坚持使用到期日期的规则反而会导致超过56%的百分比成本差距。因此，提出将优先级排序决策推迟到下一个订单完成，而不是在订单到达时决定的建议\n资源约束和不同订单优先级下的作业车间调度 JOB SHOP SCHEDULING UNDER RESOURCE CONSTRAINTS AND VARYING ORDER PRIORITIES\n摘要 在资源约束下，基于客户重要性和订单优先级的动态调度规则的作业车间调度系统的开发。\n计划和调度的一个重要部分是能够预测未来的订单并平衡不同类别之间的工作量，其中客户重要性和订单优先级都是不同的\n生产调度中的作业车间调度问题，从而开发了作业车间调度系统，满足以下约束 A)每个中心的可用资源;\nB)每个订单的时间限制；\nC)顺序优先。\n根据优先级指数（PI）选择要处理的订单或作业，其中PI = F(剩余时间、客户或订单类别)。 生产调度系统包括 a)输入:机器、工装、人工、原材料、订单\nb)调度算法和到期日预测\nc)输出:机器、劳动力和订单的时间表文件\n输入和输出之间的联系是调度算法\n优先级指数PI的计算 img\rTR 剩余时间\nNO 剩余操作数\nCR 顾客抱怨(1,2,3,4)\nOR 排序(1,2,3,4,5)\nPI值越低，调度订单就越重要。客户排名越低，客户就越重要。OR值越大，表示订单变得越紧急或“匆忙”\n深入了解动态调度规则是如何工作的 对象：维护部门的研究结果\n历史的调度规则是静态的，分为五个基本组件：\n紧急情况(E) -立即启动\n紧急(C) -尽快开始。\n优先级1 -在1周内开始\n优先级2:在两周内开始工作\n优先级3:3周内开始工作\n利用遗传规划演化资源受限项目调度问题的优先级规则 On the use of genetic programming to evolve priority rules for resource constrained project scheduling problems\n针对资源受限的项目调度问题，提出一种基于遗传规划的超启发式算法来生成高效的优先级规则（来确定执行项目所需活动的顺序）。\n构建一个不断发展的优先级规则框架：\n两种类型的优先级规则：纯算术的优先级规则；算术和决策算子的组合优先级规则\n静态环境下资源受限项目调度问题的优先级规则研究 Using priority rules for resource-constrained project scheduling problem in static environment\n优先级规则启发式方法来解决资源约束项目调度问题\n双向规划:改进基于优先级规则的启发式调度资源受限项目 Bidirectional planning: improving priority rule-based heuristics for scheduling resource-constrained projects\n介绍了在项目管理中解决资源约束项目调度问题的启发式方法，启发式方法通过执行与优先约束相关的一组作业来尽早完成项目，并通过灵活使用包括双向规划在内的不同规划方向来扩展构建可行计划的串行和并行调度方案。通过逆向规划策略和双向规划策略，并将其纳入基于规则的优先程序进行验证。实验表明，规划方向对基于优先级规则的启发式算法的性能有相当大的影响，从而影响了所采用的调度方案。另外，双向规划也应该应用于其他启发式调度方案中，如抽样程序和基于元启发式的方法。 优先级规则 优先级规则用于选择下一个必须调度的作业。为每个作业计算一个优先级值，根据规则选择最小或者最大的优先级值。在本文评估了一共73个优先级规则。取决于规则所使用的信息、事件类型规则可以大致分为以下几类：\n基于网络的规则利用项目网络中包含的信息，从而丢弃资源数据。例如工作期限、继任者的数量等等。\n基于关键路径的规则是基于向前和向后传球的结果。最常见的是指最早和最晚的开始和结束时间。\n基于资源的规则是指作业对资源的需求。例如，他们可以计算一个作业从所有资源类型中需要的平均相对量。\n复合规则试图克服专注于单一类型信息的缺点。为此，它们通常通过计算各自规则获得的优先级值的加权和来组合基于网络、时间和资源的规则。\n静态规则在启动调度进程之祈安只计算一次优先级值。相反的，在每次调度作业时，动态规则会更新优先级值。\n随机资源约束项目调度问题的有效优先规则 Efficient priority rules for the stochastic resource-constrained project scheduling problem\n在本研究中，考察了17种优先级规则启发式方法和证明技术在随机资源约束项目调度问题(SRCPSP)上的性能。在这17个优先级规则中，有12个是从解决确定性资源约束项目调度问题(RCPSP)的文献中选择的，另外5个是基于确定性资源约束项目调度的随机信息而新设计的。我们评估了17个优先级规则在基准数据集PSPLIB上的效率，并分析了用于创建该数据集的项目特征的影响。最后的结果表明，RCPSP的最佳优先级规则并不适用于SRCPSP。当活动持续时间的方差为中等时，SRCPSP的最佳优先级规则执行得与最佳元启发式规则一样好，并且当该方差较大时优于所有现有算法。在SRCPSP上证明的有效性取决于优先级规则和活动持续时间的差异。项目特征、网络复杂性和资源因素对最优优先规则的选择没有影响，而资源强度对最优优先规则的选择有影响。我们的研究结果可以帮助管理者在面对不确定性时更有效地安排项目活动。 在满足优先级和资源约束的同时最小化项目持续时间 在现实世界中，项目受制于相当大的不确定性，可能来自于多方面：项目范围的变化、资源可用性的变化、天气条件导致某些活动的延迟等等 在SRCPSP中，项目活动具有已知的持续时间分布，其目标通常是最小化项目的预期完工时间。 将项目的执行视为一个多阶段决策过程，在每个决策点，策略充当调度规则，确定下一步要启动哪些活动。 优先级规则启发式算法在资源约束型多项目调度问题和资源约束型多项目调度问题中发挥着重要作用。它们之所以重要，有以下几个原因:(1)与其他启发式方法相比，pr速度快，需要的计算时间更少;(2)许多高级启发式方法和精确程序将pr作为其算法的组成部分，例如群优化方法通常使用pr构建初始解;(3)pr简单直观。由于它们的简单性，它们也被商业项目调度软件广泛使用。在实践中，即使没有计算机的帮助，项目经理也可以很容易地应用这种方法，并获得快速安排项目的解决方案。 资源约束和社区优先下的生产决策优化 Optimization of Production Decisions Under Resource Constraints and Community Priorities\n资源最优配置问题使得收益最大化\n一种复杂作业车间自主控制的新方法——集成订单释放、排序和产能控制以满足交货期 A new method for autonomous control of complex job shops – Integrating order release, sequencing and capacity control to meet due dates\n提出了自主生产控制方法(APC)，该方法集成了所有控制任务-订单释放，排序和产能控制-以满足交付日期\n网络物理生产系统（CPPS） 生产计划（调度）通常决定一个时间表，它包括操作开始或结束的确切日期，因此也决定了考虑可用资源的生产订单顺序。 在CPPS设想的自主控制的工厂中，生产控制将基于主计划的到期日期和产能限制分散/自主地控制生产。因此，生产控制具有排序(包括调度和队列处理顺序)、订单释放和产能控制的功能。 第3节介绍了APC方法的概念，考虑到ICT进步和CPPS发展的可能性和要求，APC方法包括CPPS中生产控制的三个任务-排序，订单释放和容量控制-用于作业车间制造。 概念：APC方法需要一定的计划数据作为决策依据:每个作业车间的计划加工开始时间和完成时间(截止日期)以及最终完成日期。不需要详细的生产计划，包括各工位的分配。 3.1.2. 负载平衡设置和截止日期导向的订单释放，调度，排序和容量控制与自我学习程序 APC方法的总体指导方针是保持到期日期，同时在定义的水平上平衡工作负载 完成了订单释放和调度之后，在接下来的步骤中，确定是否保留了到期日期和范围限制。顺序首先选择保留所有到期日的站点，然后是由于顺序而使总范围增加最少的站点。将截止日期遵守和完成时间导向作为第二个标准的高优先级。 产能不确定和随机成品率装配系统的零件排序策略 Component ordering strategies in assembly systems with uncertain capacity and random yield\n由于外包和供应链延伸的盛行，将大量零部件组装成最终产品的制造企业面临着严重的供应不确定性 在一个复杂的全球供应商网络中采购组件可能会导致高度的供应不确定性。诸如意外的生产缺陷或供应商能力不足等事件可能导致所需部件的意外短缺，并使最终产品的组装停止。因此，装配企业必须在零部件订购决策中有效地管理各种供应不确定性，以避免零部件短缺。在这些问题的指导下，本研究探讨了在两种供应不确定性情况下，装配商的最优订货策略:标准部件(组件1)的生产能力不确定和核心部件(组件2)的随机生产成品率。在这些供应不确定性实现之前，装配商做出了零件订购决策。对最优排序决策进行了刻画，发现装配商应按固定比例对组件1和组件2进行排序，该比例仅取决于组件2的随机产量和组件1的生产成本，而不取决于组件1的不确定产能。 组件排序策略分析 最优排序决策 基于混合MCDM技术的作业车间调度中最优优先级排序规则的评估与选择 Evaluation and Selection of Best Priority Sequencing Rule in Job Shop Scheduling using Hybrid MCDM Technique\n优先级排序规则为工作站上处理作业的顺序提供指导。在作业车间调度中应用不同的优先级规则，会产生不同的调度顺序。研究了作业车间调度中7种不同的优先级排序规则。对于最佳优先排序规则的评价和选择，考虑了一组8个标准。本研究的目的是通过使用混合多准则决策技术(MCDM)，即层次分析法(AHP)和理想解相似性排序偏好技术(TOPSIS)，展示评估和选择最佳优先排序规则的方法。采用层次分析法计算各优先级排序规则的权重，基于TOPSIS法计算各优先级排序规则的相对接近值，并利用某制造企业的车间数据。最后，根据本工作的发现，将优先排序规则从最重要到最不重要进行排序。本文所提出的综合方法对于工作站的管理是非常必要的，以便在可选方案中选择最佳优先级排序规则来处理最大效益的作业。 模型 在确定研究区域后，即作业车间排序，确定不同优先级排序规则。然后确定了最佳优先排序规则的评价和选择标准。根据这些标准，从相关工作站收集整个过程所需的数据。在建立评价标准层次结构后，运用层次分析法确定评价标准的权重。执行与评价准则相对应的备选方案的性能并将其制成表格。最后，利用MCDM技术TOPSIS得到最终的排序结果。 云制造下多供应链C2B订单决策 C2B Orders Decision-making in Multiple Supply Chains Under Cloud Manufacturing\n优先级规则 优先级规则是进行生产作业计划排序时适用的规则。有时生产作业计划排序可能很简单，仅根据一条数据就可对作业进行排序，如加工时间、交货日期或者到达的顺序。有时生产作业计划排序需要根据紧迫系数、最小单个工序平均时差、最早订单完成日期等因素来确定优先级别\n","date":"2023-08-10T23:57:10+08:00","permalink":"https://jianrongma.github.io/p/order_priority/","title":"Order_Priority"},{"content":"数字规律题 标序列号 把变量和序列号放在一起比较看看 公因式法 找出最小公因式 看看有无规律 对每一位数减去第一位数 替换掉第2\u0026hellip;.位 结合上面的看看有无规律 对每一位数同时加上/乘以/除以第一位数 结合上面看看有无规律 同时除以1/2/3 加法和减法可能性稍大 能否分成奇数和偶数数组 看增幅 是否有规律 +1 +2 +4 +8 等比或者等差 前两个和/积是后一个 类斐波那契数列 前一个数是后一个数的比例关系 图形推理题 是否间隔排列或者对称排列 寻找共同特征 顺时针/逆时针 变化 白*黑=白 重合的题目 对称与不对称 轴对称与中心对称 切割三角形 相交相切 一全一半 叠加 求同存异 相对位置 内部还是外部 ","date":"2023-07-23T11:52:38+08:00","permalink":"https://jianrongma.github.io/p/%E8%A1%8C%E4%B8%BA%E8%AE%A4%E7%9F%A5%E6%B5%8B%E8%AF%84%E6%8A%80%E5%B7%A7/","title":"行为认知测评技巧"},{"content":" 算法\n树 平衡二叉树 镜像二叉树 最低公共祖先 前序后续便利构造二叉树 节点和等于整数的路径 两个节点的最长距离 二叉查找树 链表 奇升偶降 如何有序 数组 二维数组旋转90° 2sum问题 位运算 动态规划 背包问题 0-1 背包问题 完全 排序 复杂度 冒泡 插入 归并 快排 希尔 堆排序 基数排序 桶排序 如何求中位数 大根堆与小根堆 优先队列 单调栈 单调队列 接雨水 最大矩形 滑动窗口 二分 DFS BFS 递归 回溯 LRU 辅助栈 并查集 堆栈\n内存中的堆、栈、静态区 ","date":"2023-07-18T16:34:40+08:00","permalink":"https://jianrongma.github.io/p/%E9%9D%A2%E8%AF%95%E8%96%84%E5%BC%B1%E5%A4%8D%E4%B9%A0/","title":"面试薄弱复习"},{"content":"1.供应链环境下基于Kriging模型的订单优先级评估 2021SCIQ2 IEEE Access Order Priority Evaluation Based on Kriging Model Under Supply Chain Environment\n关键词 order production priority;supply chain;make-to-order;Kriging model\n摘要 供应链环境下，传统的方法具有局限性； \u0026mdash;- 有哪些局限性？\n建立了供应链环境下订单生产优先级的评价指标体系；\n提出了基于Kriging模型的订单生产优先级评价模型来确定订单生产优先级。\n结果表明，该模型适用于小样本问题，**（什么是小样本问题？）**是一个可行、有效的订单优先级评估模型；\n与其他模型相比**（与其他哪些模型相比？），该模型提高了订单优先级的评估精度**。同时，该模型具有较高的可靠性和稳定性，扩充了订单生产优先级的计算方法。\nI.引言 第一段 对于按订单生产的企业来说，如何处理订单是生产调度中的一个关键问题。良好的订单处理速度和准确性不仅可以为客户提供更好的服务，还可以节省流动资金，降低成本。\n[1-3]\n探讨了按订单制造企业的订单接受和调度问题\n对核心供应商的订单进行选择和维护\n[4-6]\n对供应链环境下的订单处理进行了大量的研究工作\n[7]\n因此，需要确定接受哪些订单，按照什么顺序进行处理，而如何确定订单生产优先级是订单处理的关键步骤\n另一方面，次序优先问题是一个复杂而关键的过程，是多种标准可能相互冲突的结果。因此，不同的研究采用了理论、实践和建模等多种方法和技术来解决顺序优先级的确定问题。\n第二段 研究序求值问题的方法有很多。\n首先，提出一些传统方法 [8]\n使用混合整数线性规划(MILP)和包括遗传算法在内的各种启发式方法来解决订单接受问题\n[9]\n提出了一个混合整数规划公式，并使用数值分析来研究同时定价、订单接受、调度和提前期决策\n[10]\n利用层次分析法(AHP)的多属性专家支持系统对买方订单进行评估\n[11]\n将Dempster-Shafer理论与信念熵相结合，提出了一种新的证据模糊多准则决策方法(EFMCDM)来确定最优方案\n[12]\n提出了Atanassov型直觉模糊集来确定供给选择和排序\n[13]\n提出了一种基于模糊数的层次分析法\n[14]\n综合考虑了生产策略、约束理论和线性规划，提出了生产策略和生产调度相结合的综合方法\n总结传统方法的不足 这些方法从不同的角度讨论了订单优先级（跟订单优先级的关联在？），可以有效地**帮助制造商解决供应商排序中的多标准决策问题。**线性规划假设顺序优先级与其影响因素之间存在线性关系。实际上，订单优先级评价模型受多种因素影响，不能进行非线性推广。AHP的优点是为决策问题提供了一个结构化但相对简单的解决方案，但它严重依赖于人类对知识和经验的判断[15]。\n近年来，神经网络模型和支持向量机(SVM)等机器学习[16]-[18]因其相对于传统方法能够处理复杂性和不确定性而得到了广泛的应用 在介绍每种算法的同时就指出了其缺点，不适合于处理订单优先级问题 [19-21]\n采用支持向量机处理质量监控、质量评估。但是，Oh也指出，传统的SVM没有考虑到明确的缺陷类型和保修费用。此外，SVM的泛化能力很大程度上取决于参数的选择，选择参数[21]需要大量的计算。\n泛化能力：指的是机器学习算法对新鲜样本的适应能力 [22-24]\n提出了基于径向基函数(RBF)神经网络的非线性订单优先级评价模型\n总结其优缺点：\n优点：\n提高了评价精度； 不需要复杂的工艺决策，只依赖历史数据。 缺点：\n而RBF神经网络模型是一种基于经验风险最小化原则和“大样本”理论的机器学习算法 由于订单历史数据是一种小样本问题，因此不适合处理订单优先级问题 RBF模型网络结构复杂，容易过拟合 第三段 提出本文的方法——Kriging模型 Kriging模型的提出\n[25]\n近二十年来，Kriging模型作为计算机实验中常用的模型，具有极大的复杂性，是一种非线性泛函逼近器[25]。它吸引了工程、统计和供应链管理领域的广泛兴趣\nKriging模型的应用\n[26]\n使用Kriging模型开发了一种鲁棒方法，并通过经典的经济订货数量(EOQ)库存模型说明了该方法的验证\n[27]\n使用Kriging模型对(s, s)库存系统的仿真模型进行了近似，并证明了Kriging模型具有作为仿真工具的能力\n与传统的方法相比，Kriging模型可以处理复杂、不确定性和非线性[28]，[29]\n第四段 本文的主要贡献 首先，克里格模型目前尚未应用于供应链环境下的订单优先级。引入克里格元建模技术，建立了供应链订单优先级确定模型 其次，将本文提出的方法与订单处理中常用的RBF模型进行了比较，结果表明本文提出的方法更有效，更具优势。更重要的是，基于我们的方法得到的结果更接近实际情况 最后，该方法提供了一种新的研究思路，拓宽了供应链环境下订单优先级确定的研究领域 II.元建模方法概述 A. RBF B. Kriging model III.提出了一种基于kriging模型的排序优先级方法 A. 建立供应链环境下订单优先级评价指标体系 由于订单优先级受处理能力、订单利润、客户订单趋势等诸多因素的影响。在供应链环境下，信息共享也扮演着非常重要的角色。订单优先级的评价指标变得更加复杂。\n将影响订单优先级的相关因素大致分为三类\n第一个标准是订单条款\n主要包括订单数量、订单利润、交货时间、订购产品数量和订单产品类别\n第二个标准是从供应链的角度出发考虑信息共享的客户条款\n包括交易总额、客户信用等级、客户订单趋势、客户合作期限以及订单紧急能力\n第三个标准是生产方面\n由加工能力、生产成本和产品质量组成\n供应链信息共享由下游企业的营销信息、库存和客户订单决定，采用订单紧急度指标来衡量供应链信息共享。\nimage-20230330155622311\rB.基于kriging的订单优先级模型框架 C.我们提出的方法的实施步骤 image-20230330160012904\r1.量化指标值 根据订单优先级指标体系，首先对样本订单的指标值进行线性归一化。当指标为定性时，通过专家打分将其转化为定量指标，再对实际数据进行预处理得到定量指标。这些量化指标被用作输入变量(或向量)\n2.收集数据集 由专家对订单优先级评价指标体系进行综合分析，给出预期的总体评价y。y的值也是经过定量处理后给出的。总体评价值y越大，优先级越高，其中y∈(0,1)。然后给出用于构建顺序优先级模型的样本。\n为了消除指标维度差异的不利影响，对排序优先级评价样本(x, y)进行归一化处理\n3.建立基于Kriging模型的订单优先级模型 将步骤2获得的数据集分为两个子集，即训练数据集和测试数据集。利用训练样本，通过文献所采用的遗一交叉验证的估计方法，在训练集的基础上，通过交叉验证确定超参数θ，使预测均方误差(MSE)最小化，同时选择合适的回归模型和相关模型。为此，建立了基于Kriging模型的订单优先级评价模型。\n4.获取输出预测器 根据试验数据和步骤3给出的建立的Kriging模型，得到总体评价的预测值。\n5.确定排序顺序 IV.仿真实验 主要是给出了基于RBF和Kriging元建模技术的排序优先级的比较 V.结论 限制 尽管克里格模型在随机模拟中得到了广泛的应用，但有时它不能很好地处理随机模拟中的噪声，如何测量随机因素并采用随机克里格模型来确定订单优先级是我们未来的研究方向\n2.客户订单优先级的决策框架建议:一个结构钢公司的案例研究 2015 SCIQ1 International Journal of Production Economics A decision framework proposal for customer order prioritization: A case study for a structural steel company\n关键词 Structural steel industry 结构钢行业\nManufacturing company 制造公司\nOrder prioritization 优先级顺序\nMultiple criteria applications 多标准应用程序\nAnalytic Network Process 网络分析过程\n摘要 在制造公司的能力有限的前提下，确定客户订单的优先次序\n当前的项目已经占用了公司大部分的设计和制造能力，如何选择下一个客户订单来适当分配剩余的稀缺能力的决策问题\n确定相关标准：文献调查 + 决策者确认\n根据这些标准对客户订单进行评估\n多标准决策过程\n基于网络分析过程的决策框架\n这些标准被确定为单位时间的潜在利润率、潜在订单与可用产能的兼容性、未来利润更高的潜在订单水平、未来商业机会的客户信用以及订单生产计划的谈判水平。其中，未来商机标准中的客户信用是最重要的标准。根据客户订单的优先级，向案例公司提出了建议。根据这一建议，公司选择并实施了具有高优先级的订单。\n1.引言 介绍钢结构行业的发展、特点、性质等\n引出问题：由于钢结构行业的性质，绝大多数的工作，近90%，是在设计和制造阶段完成的;剩下的10%是用非常少的工艺完成的安装。因此，当设计和制造能力被陈述为这些公司的能力约束时，安装人力的需求并没有被陈述为一个。由于成本和产能的挑战，结构钢生产企业要想获得竞争优势，必须解决一些问题。\n第一个是能够有足够的订单来使用他们所有的能力，以避免处理每个产品单位额外的直接和间接成本。 当公司成功地解决了这个问题时，它还面临着另一个重要的问题:应该考虑哪个客户订单。 根据上述的问题提出具体的解决问题\n在竞争激烈的环境中，在满足公司要求和期望的同时，拥有有效的方法来决定是否接受或拒绝订单是非常重要的。因此，当公司必须做出订单优先级决定时，应该考虑基于这些需求和期望的几个评估标准。\n考虑订单的优先级是用来决定接受或拒绝订单\n提出本文中的评估标准\n提出：处理消费者订单优先排序的决策问题需要多标准决策(MCDM)方法。\n在本研究中，基于分析网络过程(ANP)的群体决策框架将允许公司在考虑评估标准的情况下，在有限的能力范围内选择最合适的项目。\n为什么要选择基于ANP的群体决策框架\n虽然层次分析法(AHP)是目前应用最广泛的标准和备选方案的优先排序方法之一，但当标准和备选方案之间存在依赖和反馈时，AHP就失效了。由于网络模型的这些相互联系，单独不那么重要的成分在集体评估时可能会变得更重要。这就是为什么Saaty(1996)介绍的ANP被选为研究方法。\n文献中ANP应用的一些例子\n本文旨在研究结构钢企业在潜在订单超过现有产能的情况下，面对上述产能问题时，如何优先考虑满足多个标准的一组潜在客户订单。此外，还揭示了用于排序订单的评价标准的重要性。\n2.背景 2.1钢铁行业客户订单优先排序 2.2 订单优先级的评估标准 3.研究方法 3.1决策过程 当客户的订单适合公司的能力，并且客户认为公司是合格的，该订单就成为几个潜在订单之一。如果潜在的订单超过了公司的能力，那么它必须在其中进行选择。\n3.2网络分析过程 3.2.1 选择ANP的原因 3.2.2. 网络分析过程的背景 3.2.3. 网络分析过程的基本步骤 4.案例研究 4.1. 案例公司和决策者 5.结论和进一步的建议 3.多产品制造系统中的优先级优化与制造-库存/制造-订单决策 2018 SCIQ2 International Transactions in Operational Research Priority optimization and make-to-stock/make-to-order decision in multiproduct manufacturing systems\n关键词 Priority optimization and make-to-stock/make-to-order decision in multiproduct manufacturing systems\nmake-to-stock(MTS) 按库存制造\nmake-to-order(MTO) 按订单制造\npriority level 优先级\nheterogeneous multiproduct production/inventory sysytem 异构多产品生产/库存系统\nqueuing model 排队模型\n摘要 研究对象：生产大量最终产品的单阶段多产品制造设施\n研究问题：项目优先级优化MTO/MTS决策中起着关键作用\n研究方法：\n制造设施 \u0026mdash;-\u0026gt; 多产品多优先级类排队系统\n提出了一个通用的优化过程，它选择了接近最优的优先级，给出了每个产品的相关流控制模式(MTO或MTS)，并提供了关于最优成本的下界和上界。\n与文献中的两种备选启发式方法进行比较\n1.引言 生产管理中的两类生产策略：MTS/MTO的解释\n通过一些混合生产行业的介绍，提出：有效的MTO/MTS分配取决于每个产品类型参数，例如需求行为(间歇vs定期，低量vs大批量)，所需的客户交货时间(长vs短)，或库存持有成本(高vs低)。\n除了产品参数以外，决策的可行性和相关的库存成本绩效还取决于：需求过程和生产订单之间的优先机制引起的拥塞效应\n为了直观地说明优先级影响的重要性，让我们从生产/库存设置开始，其中工作订单之间没有特定的优先级规则。在这种情况下，拥塞机制有效地对所有生产订单起类似的作用，并且具有非常短的允许交付提前期的项目必须自动在MTS中进行管理，因为MTO对它们来说是不可行的。相反，如果某些项目被优先考虑，这些项目的拥塞效应就会减少，这就可以允许在MTO政策下生产它们，同时仍然满足客户所需的交付提前时间。显然，权衡出现了，因为非优先级项目的拥堵效应将增加，这些项目将需要额外的库存。重点是，在典型的大规模问题中，当优先级分配优化时，可以预期权衡是显著正的。 本文的目的是提供一个通用的优化过程，在考虑与优化优先级分配策略相关的拥塞影响和库存成本时，将最优流量控制(MTO或MTS)关联到每个产品。\n在这里分析的战术MTO/MTS决策中，优先级机制的优化并不旨在解决操作层面的实时调度策略，而是捕获连接优先级、拥塞和MTO/MTS优化的主要全局效应。一旦做出了MTO/MTS决策，车间级别的操作流管理决策将在战术级别指定的框架内确定最佳的短期调度决策\n4.MTS/MTO混合生产模式下订单优先级及批量优化控制技术 2021 ICAL 2021：2021第八届国际自动化与物流会议 Order Priority and Batch Optimization Control Technology Under MTS/MTO Mixed Production Mode\n关键词 MTS/MTO mixed production mode MTS/MTO混合生产模式\nscheduling system 调度系统\norder priority control 订单优先级控制\nbatch optimization control 批量优化控制\n摘要 针对目前制造企业订单生产与库存生产相结合的生产模式，设计开发了MTS / MTO混合模式下的生产调度系统。深入探讨了MTS / MTO混合模式下如何处理订单优先级和批处理问题，并提出了具体的处理方法，从而在有限资源下快速形成优化的生产调度方案，实现交货时间最大化，提高企业效率。\n引言 1.1 MTS/MTO混合生产模式 分别介绍了制造型企业的四种生产模式：\n库存生产\n按订单组装生产\n按订单生产\n按订单设计生产\n克服不同生产模式的缺点和不足 研究新的生产方式 \u0026mdash; MTS/MTO混合生产模式，实现MTO和MTS生产方式的优势互补。从而显著提高生产效率和科学水平\n1.2 MTS/MTO混合模式下的生产调度特征 介绍了MTS/MTO混合生产模式的调度特点（1-7）\n1.3国内外研究现状 本文以MTS/MTO混合生产模式为基础，研究了MTS/MTO混合生产模式下的调度系统。该系统涉及混合生产模式下的订单优先级处理方法、混合生产模式下的批量处理方法、混合生产模式下的自动调度算法、混合生产模式下的扰动处理算法。\n2.MTS/MTO混合生产模式下调度系统的设计 2.1系统架构设计 2.2系统功能模块 2.3系统工作流程 3.MTS/MTO混合生产模式下的调度算法框架 调度算法包括，自动调度算法和扰动处理算法\n自动调度算法仅限于读取和处理调度所需的所有基本数据，然后使用顺序优先处理方法和批处理方法进行顺序优先处理和批处理;对生产工艺进行调度，按照顺序优先级排序后，按照设备选择规则将工艺安排到最优资源，计算开始和结束时间，直到所有工艺安排完成;最后保存结果数据。\n4.混合模式下MTS/MTO订单优先级处理技术 在调度生产时，在订单数据读取阶段，对订单进行订单优先级处理，根据混合企业独特的生产方式，将订单分为销售订单和库存订单，构建了适用于MTS/MTO混合生产模式的订单优先级处理模型\n5.具有外部到期日的按订单生产系统中优先级排序决策对订单准时概率和预期延迟的影响 2017 SCIQ1 European Journal of Operational Research Impact of Priority Sequencing Decisions on On-Time Probability and Expected Tardiness of Orders in Make-To-Order Production Systems with External Due-Dates\n关键词 马尔可夫过程\n优先排序\n按订单生产\n交货日期\n摘要 建模MTO系统中的优先级排序问题\n马尔可夫决策过程：订单交货期 \u0026mdash; 客户指定他们愿意等待订单完成的时间量\n目标函数：一个固定的和可变的延迟成本之和，结合了两个外部客户相关标准：“订单的准时性概率”和订单的预期延迟“\n将几种简单规则与最优策略进行比较，分析准时概率和预期延迟的有效前沿。结果表明，使用简单的规则就可以接近最优的性能。\n当涉及到延迟的固定成本时，最优优先级排序策略偏离最早到期( EDD )原则，但调整后的EDD规则表现良好。此外，将优先级排序决策推迟到下一次完成提高了性能。\n","date":"2023-05-07T23:34:19+08:00","permalink":"https://jianrongma.github.io/p/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","title":"论文阅读"},{"content":"智能优化混合算法是一种以某类优化算法为基础,融合其他智能算法或理论的混合算法,可用于求解各种工程问题最优解.\n智能算法在工程领域(如系统控制、生产调度、人工智能、模式识别等)的迅速推广和应用，作为一个重要的科学分支，智能优化算法激励人们从更广泛的生物或自然现象寻求启发，以构造新的只能算法或对算法不断地进行改进，从而更好地解决工程中存在的多数复杂问题。优势主要表现在：\n算法原理简单，易于推广和应用 良好的算法收敛性和搜索速度，优化问题较易取得满意结果 Chapter1 绪论\n智能优化算法即一种按照某规则或思想进行的搜索过程，用以得到满足用户要求的问题的解。\n遗传算法于1975年由美国密歇根大学的J.Holland教授等人受生物进化论的启发而提出[1]。遗传算法是以自然界中的生物进化过程为背景，将生物进化过程中的繁殖、选择、杂交、变异和竞争等概念引入算法中。它的基本思想来源于自然界中的生物从低级、简单，发展到高级、复杂，乃至进化成人类这样的一个漫长进化过程，并借鉴了达尔文提出的物竞天择、优胜劣汰、适者生存的自然法则。遗传算法的本质是一种对问题进行高效全局搜索的方法，它在搜索过程中有效的利用已有信息来自动获取和积累有关搜索空间的知识，并自适应地控制搜索方向使其最终走向最优解。\n遗传算法已经在数据挖掘、生产调度、图像处理以及函数优化等领域去的了令人鼓舞的成就，证明了其良好的性能。近年来，遗传算法被应用于诸如复杂的多目标规划问题、人工生命以及神经网络问题、机器学习问题、智能控制等问题中。\n自然界中的生物遗传物质的主要载体是染色体，基因是控制生物性状的遗传物质的功能单位和结构单位，是染色体的主要组成部分，即多个基因组成染色体。在染色体中，基因所占据的位置称为基因座。同一个基因座，可能有的全部基因称为等位基因。染色体的特征即生物个体的性状就是由基因和基因座决定的。与此对应染色体有两种相应的表示模式，即基因型和表现型。所谓表现形式是指生五个题外在所表现出来的性状，而基因型则是指与表现型密切相关的基因组成。同一种基因型的生物个体在不同的外在环境条件作用下可以存在不同的表现型，因此表现型是基因型与外在环境条件下相互作用的结果。染色体带有特征的实体称为个体，个体的集合就是种群。该集合内，个体数称为群体的大小。一个个体对环境的适应程度称为适应度，生物学家使用适应度这个属于来衡量某个物种将获得更多的繁殖后代的机会；而对外在生存环境适应程度较低的物种，其放置后代的机会就会相对较少，甚至逐渐走向灭绝。复制、选择、交叉和变异是自然界中的生物不断向前进化的最重要的组成部分。\n自然遗传学说与人工遗传算法中所使用的基本概念和术语之间的对应关系\n染色体 解的编码 基因 解中的每一个分量的特征 基因座 特性值 个体 解 种群 选定的一组解(解的个数为种群的规模) 适应度 适应度函数值 复制 根据适应度函数值选取的一组解的操作 选择 以一定概率从种群中选择若干个解的操作 交叉 通过交配原则产生一组新解的过程 变异 通过突变原则产生一组新解的过程 执行遗传算法时必须包含两个数据转换操作，一是表现型到基因型的转换，二是基因型到表现型的转换。前者是指把实际问题中的参数或解转换成遗传算法问题中的染色体或个体。这个过程定义为编码操作；后者是对前者的一个相反操作，即把遗传算法中的染色体或者个体转换为实际问题中的解或参数，这个过程叫做译码操作。当产生初始种群之后，就按照适者生存和优胜劣汰的原理，在每一代中根据每个个体的适应度函数值大小来挑选个体，并仿照自然遗传学说中的遗传算子来进行交叉和变异，并产生出代表新的解集的种群。以此类推逐代进化并产生出越来越优异的近似解，最后一代种群中的最优个体经过解码操作，就可以作为待解决问题的近似最优解。\n计算开始时，先将种群随机初始化，产生出一定数目的N个个体，并计算每个个体的适应度函数值，第一代初始种群就产生了。算法按照适应度值选择个体参与交叉编译运算，父代要通过基因重组（交叉）而产生子代，所有的子代按一定概率进行变异操作，然后子代的适应度值又被重新计算，从而产生新的下一代种群。如此反复，直到满足优化准则为止。\n近些年来，国内学者也发表了大量关于遗传算法的文章，如2004年，杨晓梅、曾建潮[5]为改善当时求解车间调度问题中的遗传算法的性能,提高搜索最优调度解的速度,并借鉴遗传算法的生物学基础,提出了基于多个体交叉的遗传算法。该算法在执行遗传过程中充分利用个体自身的优良性质，对不可行的调度解根据多个体修补原则进行修补改正，以此就可保证遗传后代的合法性和种群多样性，能够显著缩短最优调度解的搜索时间。在2005年，王凌、张亮[6]针对有限缓冲区的流水线调度问题,提出了一种基于多搜索模式的遗传算法,该算法使用多个交叉和变异操作来对解空间进行探索和改良,并采用面向有向图的领域结构来增强局部搜索性能。在2007年，吴尔飞、金烨等[7]针对当前研究较少的双边装配线平衡问题,研究双边装配中具有操作方位约束的任务,以及在工位上分配任务的操作顺序与平衡结果具有直接关系等特点,提出了相对应的符合该问题特性的遗传算法。该算法采用基于序列、任务机器分配方位相组合的编码方法，并改进了更加可行的交叉与变异算子，使最优解搜索过程仅在可行解的空间内进行，提高了搜索效率，节约了搜索时间。在2009年，莫巨华、黄敏、王兴伟[8]为实现系统的最优化设计，致力于研究以满足顾客满意率要求为主要约束的多目标规划，并提出了一种改进的遗传算法与过程仿真相结合的求解方法。在该求解方法中，多目标规划通过加权平均转化为单目标规划。\n遗传算法是一种模拟生物界的自然选择和自然遗传机制的随机搜索算法。在遗传算法提出之前，为解决各种优化问题，许多优化算法已经被提出，例如梯度法、单纯形法、动态规划法等。这些优化算法有各自的有点，也有各自的适用范围，同时又有各自的限制因素。遗传算法与这些传统的优化算法有很大的不同，大多数古典的优化算法是对一个单一的度量函数（评估函数）进行梯度或较高次统计，然后产生一个具有确定性的试验解序列。相反，遗传算法并不依赖于梯度信息，而是通过模拟自然界的进化过程来对最优解进行搜索，它利用某种编码技术，并作用于称为染色体的数字串上，对由这些串组成的群体的进化过程进行模拟。遗传算法通过有组织地、随机地交换信息来重新组合那些适应性较好的串，生成新的串并组成群体。\n遗传算法具有自组织性、自适应性和智能性。自然选择清楚了算法设计过程中的一个最大的障碍，即需要事先对问题的全部特点进行描述，并要说明针对问题的不同特点所应采取何种措施。遗传算法的这种自组织、自适应的特征，使它同时具有根据环境的变化而自动发现环境的特性和规律的能力，从而使遗传算法可以用来解决一些复杂的非结构化问题。 遗传算法具有并行性。遗传算法在种群中是按照并行方式进行搜索的，而不是在一个单点上进行寻优的，其并行性表现在两个方面： 遗传算法具有内在并行性，使它本身及其时候大规模并行，并适合在目前所有的并行机或分布式系统上进行并行的处理； 遗传算法具有内行并行性，由于它采用种群的方式来组织搜索，因此可以同时搜索解空间内的多个区域，并相互进行信息交流。许多传统的搜索方法都是从单点开始寻优的，因而在多峰函数优化中极容易陷入局部最优解。遗传算法是从一个种群开始进行搜索的，并且可以同时向不同的方向进行搜索，从而大大提高了遗传算法的全局搜索性能，并减少了陷入局部最优解的可能性。 遗传算法使用概率搜索技术。遗传算法在搜索过程中并不采用确定性规则，而采用概率的变迁规则来指引它的搜索方向，在优化过程中，使搜索的每一步都向最终结果靠近的机制或智能性称为搜索的探索性或启发性。传统搜索方法中从一个搜索点到另一个搜索点的转移有确定性的转移方法和转移关系，这种确定性也极有可能使搜索永远也达不到最优点，因而限制了算法的应用范围，制约了算法的应用效果。遗传算法以适应度数字作为标尺、以概率作为一种工具来指引搜索过程，虽然表面上看，遗传算法好像是一种盲目的搜索方法，但实际上它却是一种导向随机搜索方法。 遗传算法把决策变量的编码作为运算对象。 遗传算法直接把目标函数值作为搜索信息。传统的优化算法不仅需要利用目标函数值，并且还需要目标函数的导数值等其他一些辅助信息才能最终确定下一步的搜索方向和搜索范围，无需使用目标函数的导数值及其他一些辅助信息。这个特性使得遗传算法在很多目标函数无法求导或很难求导的优化问题，以及组合优化问题等应用中比较方便，因为它消除了导数求导这个障碍。另外，直接利用目标函数值或个体适应度值，也可使我们把搜索范围集中到适应度较高的那部分搜索空间中，从而大大提高了搜索的效率，节省了搜索时间。 ","date":"2022-12-25T10:46:00+08:00","permalink":"https://jianrongma.github.io/p/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"智能优化算法笔记"},{"content":"帆软FineReport笔记 帆软官网： [FineReport报表 - 专业的企业级Web报表工具](\n学习计划表：https://bbs.fanruan.com/thread-77147-1-1.html\n数据决策系统 (finereport.com)\nFineReport V10.0新手入门 - 视频课 - 帆软学院 (fanruan.com)\n28课时，3h49分；\nFineReport帮助文档 - 全面的报表使用教程和学习资料 (fanruan.com)\n视频课 - 帆软学院 (fanruan.com)\n新手入门视频：层次坐标-10‘40，动态格间运算\n超级链接；\n决策报表入门示例；快速搭建大屏\nTomcat部署包的下载\n各种例子；\n问题1：！！！SQL Server数据库连接常见错误（帆软文档）—https://help.fanruan.com/finereport/doc-view-306.html\n问题所在：让sqlserver支持以ip作为服务器名称，然后用sa用户名和密码登录服务器——https://blog.csdn.net/qq_42636010/article/details/89344993\nsqlserver身份验证登录如何设置：https://jingyan.baidu.com/article/0a52e3f4e0d6a6bf62ed7232.html\nSQL数据库、帆软自带的数据库属于模板数据集还是服务器数据集\n报表：普通报表；填报报表；决策报表\n一般 X 轴表示分类，系列表示图例，Y 轴表示分类下系列的值。\n当查询结果为空值/NULL时，如何在报表中显示为0？\n数据形态\u0026mdash;公式形态\u0026ndash;if($$$=null,0,$$$)\n超级链接\u0026ndash;当前报表决策 report0 \u0026mdash;\u0026ndash; \u0026gt; report1 超级链接-当前决策报表对象\n添加参数p 值的公式为$$$ 用户点击 report0 中的哪个订单ID 就将该ID作为参数传递给 report1\nreport1 在接收到 report0 的参数后 希望只对该参数对应的订单展示相关信息 设置对应的过滤条件\n随着标题联动\n塑胶部-生产线-三十天的产能\n逻辑：\n产能统计获取事业部与生产线参数\n产能趋势分析图标题接收参数\n趋势图折现趋势根据对应标题展示对应信息\n","date":"2022-12-10T23:27:40+08:00","permalink":"https://jianrongma.github.io/p/finebinote/","title":"FineBInote"},{"content":"计算机组成原理学习文档 CPU\n内存\n硬盘\n主板\n计算机硬件识别数据\n高低电平0/1\n通过电信号传递数据\n金属针脚：传递电信号用的通道\n通过很多条电路，可以传递多个二进制数位，每个二进制数位称为1bit比特\n文字、数字、图像如何用二进制表示\n如何存储二进制数\nCPU如何对二进制数字进行加减乘除\n如何从内存中取出想要的数据\nCPU如何识别和执行我们写的程序\n计算机系统 = 硬件 + 软件\n硬件是计算机的实体，软件由具有各类特殊功能的程序组成\n计算机性能的好坏取决于软硬件功能的总和\n软件\n系统软件：用来管理整个计算机系统\n操作系统、DBMS、标准程序库、网络软件、语言处理程序、服务程序 应用软件\n按照任务需要编制成的各种程序 硬件的发展\n第一台电子数字计算机 ENIAC1946 冯诺依曼\n逻辑元件：电子管\n第一代：电子管时代 纸带机编程\n第二代：晶体管 开始出现操作系统 开始出现高级语言\n第三代：中小规模集成电路 高级语言迅速发展 开始出现分时操作系统\n第四代：大规模、超大规模集成电路 出现微处理器、微型计算机、个人计算机PC萌芽 、 操作系统\n微处理器的发展：\n机器字长：计算机一次整数运算所能处理的二进制位数\n摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月就会增加一倍，整体性能也将提升一倍\n软件的发展：\n机器语言010101=\u0026gt;汇编语言=\u0026gt;FORTRAN/PASCAL/C++=\u0026gt;java、python\nDOC操作系统=\u0026gt;windows、android、ios\n目前的发展趋势：\n两极分化：\n1.微型计算机更微型化、网络化、高性能、多用途方向发展\n2.巨型化、超高速、并行处理、智能化方向发展\n计算机硬件的基本组成：\n1.早期冯诺依曼的结构\n2.现代计算机的结构\nENIAC手动接线来控制计算\n冯诺依曼：”存储程序“的概念是指将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n早期冯诺依曼机：\n数据/程序：即软件\n硬件：\n输入设备：将信息转换成机器能识别的形式\n存储器：存放数据和程序\n运算器：算术运算和逻辑运算\n控制器：指挥程序运行\n输出设备：将结果转换成人们熟悉的形式\n在计算机系统中，软件和硬件在逻辑上是等效的。\n冯诺依曼计算机的特点：\n计算机由5大部件组成：输入设备、输出设备、存储器、运算器、控制器 指令和数据以同等地位存储于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 输入/输出设备与存储器之间的数据传送通过运算器完成\n现代计算机的结构以存储器为中心\nCPU=运算器+控制器\n计算机组成原理中，主机的概念就是运算器+控制器（cpu）+存储器\n存储器：主存（内存）+辅存（硬盘）\n主机的存储器是内存也就是主存\n辅存是IO设备\n计算机硬件的基本组成：\n五大部分 输入设备：将信息转换成机器能识别的形式 输出设备：将结果转换成人们熟悉的形式 主存储器：存放数据和程序 运算器：算术运算、逻辑运算 控制器：指挥各部件，使程序运行 冯诺依曼结构 首次提出存储程序概念 以运算器为中心 现代计算机结构 以存储器为中心 CPU=运算器+控制器 主存储器的基本组成：\n主存储器：\n存储体 MAR memory address register 存储地址寄存器 MDR memory data register 存储数据寄存器 读和写\n存储器：\n存储单元：每个存储单元存放一串二进制代码 存储字：word 存储单元中二进制代码的组合 存储字长：存储单元中二进制代码的位数 存储元：存储二进制的电子原件，通常为电容，每个存储元可存1bit MAR位数反映存储单元的个数\nMDR位数=存储字长\nMAR4位 = 一共有2的四次方个存储单元\nMDR16位 = 每个存储单元可存放16bit 1个字word = 16bit\n混淆点\n1个字节=8bit\n1B=一个字节\n1b=1bit\n运算器的基本组成：用于实现算术运算和逻辑运算\nACC accumulator 累加器 用于存放操作数或运算结果 MQ multiple-quotient register 乘商寄存器 ， 在乘除运算时，用于存放操作数或运算结果 ALU arithmetic and logic unit 算术逻辑单元， 通过内部复杂的电路实现算术运算、逻辑运算 X 通用的操作数寄存器， 用于存放操作数 控制器的基本组成：\nCU： control unit控制单元，分析指令，给出控制信号 IR： instruction register 指令寄存器，存放当前执行的指令 PC： program counter 程序计数器 ， 存放下一条指令地址， 有自动加1功能 完成一条指令=取指令PC + 分析指令 IR + 执行指令CU\n各硬件部件：\n主存 MAR：内存地址寄存器，用于指明要读/写哪个存储单元。其位数反映存储单元的数量 MDR：内存数据寄存器，用于暂存要读/写的数据。其位数反映存储字长 存储体: 概念：存储元、存储单元、存储字、存储字长、地址 运算器 X 通用寄存器，存放操作数 ACC 累加计数器，存放操作数、运算结果 ALU 算术逻辑单元，用电路实现各种算术运算、逻辑运算 MQ 乘商寄存器，进行乘除法时用到 控制器 IR 指令寄存器，存放当前执行的指令 PC 程序计数器，存放下一条指令的地址 CU 控制单元，分析指令，给出控制信号 工作过程 初始：指令、数据存入主存，PC指向第一条指令 从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令 计算机系统的层次结构\n高级语言机器 用编译程序翻译成汇编语言程序\n汇编语言机器 用汇编程序翻译成机器语言程序\n操作系统机器 向上提供广义指令(系统调用)\n用机器语言的机器 执行二进制机器指令\n微指令系统 由硬件直接执行微指令\n三种级别的语言\n高级语言 汇编语言 机器语言 通常高级语言得翻译成汇编语言，汇编语言翻译成机器语言才可以执行\n但有时候高级语言可以直接通过编译程序直接翻译成机器语言进行执行\n编译程序：编译、汇编、解释程序\n解释程序的语言就是解释性语言\n编译的语言就是编译性语言\n编译程序是一次全部翻译成机器语言的程序，而后再执行机器语言程序，只需要翻译一次\n解释程序是将源程序的一条语句翻译成对应于机器语言的语句并立即执行。紧接着再翻译下一句，每次执行都要翻译\n计算机的性能指标\n存储器的性能指标\nMAR位数反映存储单元的个数（对多支持多少个）\nMDR位数=存储字长=每个存储单元的大小\n总容量=存储单元个数*存储字长 bit = 存储单元个数 * 存储字长/8 byte\n2的十次方 = K\n2的二十次方=M\n2的三十次方=G\n2的四是次方=T\nCPU的性能指标\nCPU主频：CPU内部数字脉冲信号振荡的概率 = 1/CPU时钟周期\nCPI:执行一条指令所需的时钟周期\n执行一条指令的耗时：CPI * CPU 时钟周期\nCPU执行时间：整个程序的耗时\nIPS： instructions per second 每秒执行多少条指令 = 主频/平均CPI\nFLOPS:每秒执行多少次浮点运算\n系统整体的性能指标\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n吞吐量：系统在单位时间内处理请求的数量\n响应时间：用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。\n基准程序：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。\n计算机的性能指标：\n存储器的容量 MAR的位数反映存储单元数量 MDR反映每个存储单元大小 CPU 主频 时钟频率 =1/时钟周期 单位:HZ 时钟周期 CPU中的最小单位，每个动作至少要一个时钟周期 CPU执行时间 运行一个程序所花费的时间 指令条数 * CPI /主频 CPI 执行一条指令所需的时钟周期数 IPS 每秒执行多少条指令 =主频/平均CPI FLOPS：每秒执行多少浮点运算 其他 数据通路宽度、吞吐量、响应时间、基准程序 常用数量单位 描述存储容量、文件大小时：K=2^10 M=2^20 G=2^30 t=2^40 描述频率、速率时：K=10^3 M=10^6 G=10^9 T=10^12 进位计数制\n十进制、二进制、八进制、十六进制 其他进制=\u0026gt;十进制 二进制、八进制、十六进制之间的相互转换 十进制=\u0026gt;其他进制 真值和机器数 基数：每个数码位所用到的不同符号的个数，r进制的基数为r\n二进制：0,1\n八进制：01234567\n十进制：0123456789\n十六进制：0123456789ABCDEF\n二进制优势：\n可以使用两个稳定状态的物理器件表示 01正好对应逻辑值的假真。方便实现逻辑运算 可以很方便地使用逻辑门电路实现算术运算 任意进制=\u0026gt;十进制\n二进制=\u0026gt;八进制、十六进制\n二进制基数为2\n八进制基数为8\n为了保证对应，应该将二进制的3位作为一组，每组转换位对应的八进制符号\n八进制=\u0026gt;二进制\n八进制基数为8\n二进制基数为2\n为了保证对应，应该将八进制的每位都用二进制的三位来代替，每3为转换位对应的二进制符号\n二进制表示 10101010B\n十六进制 349820347H 0x2234623876\n十进制 2134234D\n十进制=\u0026gt;二进制 使用 （整数部分）除基取余法+（小数部分）乘基取整法\n真值：符合人类习惯的数字\n机器数：数字实际存到机器里的形式，正负号需要被数字化\nBCD码：Binary-Coded Decimal ,用二进制编码的十进制\n8421码 余三法 2421码 原理：用4个二进制来表示一个十进制 ， 虽然这样会造成6种冗余，因为2的四次方=16 即能表示从0-15 ， 十进制表示从0-9 ， 所以会造成6个冗余\n8421码对应关系：\nX X X X\n8 4 2 1\n所以如果想表示985 ， 8421码应该这么写 1001 1000 0101 嘻嘻嘻！\n十进制的加法 8+5\n8421码加法 8+5 = 1000 + 0101 = 1101 但是这个落在1010~10010中，也就是8421码不允许或者说没有定义的范围内，为了让他有意义，需要+6，让它进一位，也即1101+0110 = 11011 = 0001 0011 也就是1 3\n余3码：8421码+（0011）B\n2421码：改变权值定义\nX X X X\n2 4 2 1\n如果想表示985 ， 则 1111 1110 1011\n规则：0-4 第一位不能为1 ； 5-9 第一位必须为1\nBCD码\n8421码 每4个二进制位对应一个十进制位（有6个冗余状态） 8、4、2、1分别对应每一位的权值 0000-1011 分别对应 0-9 ，进行加法后若超出该范围，则需要+0110B进行修正（强制向高位进1） 余3码 8421码 + 0011 2421码 2、4、2、1分别对应每一位的权值 表示0~4时最高位为0 ， 表示5~9时最高位为1 字符与字符串\n英文表示\nASCII码\n128位字符 用7位来表示就好 ，但1B=8bit 通常就用1B来表示一个字符\n可印刷字符：32-126 ， 其余为控制、通信字符\n97=01100001B\n122=01110110B\n汉字表示\n为了方便区分 ， 将1980版国标列出了常用的7000多个汉字，对应的是一个93 * 93 的矩阵，用矩阵的行和列来表示，即区码+位码\n区位码：94个区，每区94个位置\n但是前文提到ASCII码的0-32是用于控制和通信，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+20H （20H就是十六进制的20 ， 也就是32） 加上32之后就避开了通信和控制区域 ， 但是ASCII码32-125是可印刷字符，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+80H（80H就是十六进制的128）这样就可以越开ASCII码产生的冲突，因为ASCII码是1B，并且1B是以0xxx xxxx 表示的，高位不是1，但汉字的区位码，分为区码和位码，加上20H和80H之后，高位必然是1，如果高位是1，就代表他是汉字不是英文字符，所以要读两个B，也就是2B，所以为什么英文符号是1个字节而中文符号是2个字节了。\n汉字的输入：输入编码 例如nei2\n汉字的输出：汉字字形码\n字符串:某计算机按字节编址，编址即每个地址对应1B，从地址为2的单元开始，存储字符串为“abc\u0026quot;,那么，2-5的地址分别存，61H 62H 63H 00H（\\0） 最后一行使用\u0026rsquo;\\0\u0026rsquo;作为字符串结尾标识\n当存放”abc啊“的时候，因为汉字需要占用2B，所以2-6的地址分别存， 61H 62H 63H B0H A1H 00H 或者 61H 62H 63H A1H B0H 00H ，\n大端模式：将数据的最高有效字节存放在低地址单元中\n小端模式：将数据的最高有效字节存放在高地址当中\n字符与字符串\nASCII码 通常用8bit表示一个字符，最高位都为0 共128个字符。0-31为控制/通信字符；32-126为可印刷字符 所有大写字母、所有小写字母、所有数字的编码都连续 汉字 区位码、国标码、汉字内码、输入编码、字形码 国标码=区位码+2020H 机内码=国标码+8080H 字符串 从低地址到高地址逐个字符存储，常采用\u0026rsquo;\\0\u0026rsquo;作为结尾标志 对于多字节的数据（如汉字），可采取大/小端存储模式 大端模式：将数据的最高有效字节存放在低地址单元中 小端模式：将数据的最高有效字节存放在高地址单元中 奇偶校验码\n奇偶校验\n校验原理 奇偶校验 由若干位代码组成的一个字叫码字\n将两个码字逐位进行对比，具有不同的位的个数成为两个码字间的距离\n一种编码方案可能有若干个合法码字，各合法码字间的最小距离成为码距\n当码距=1时，无检错能力 ； 当码距=2时，有检错能力 ； 当码距\u0026gt;=3时，若设计合理，可能具有检错纠错能力\n奇校验码：整个校验码（有效信息位和校验位）中1的个数为奇数\n偶校验码：整个校验码（有效信息位和校验位）中1的个数为偶数\n奇偶校验中，如果偶数个位发生位错误，也就是位跳变的话是检测不出错误的\n如何求校验位：\n求偶校验位：对有效信息位进行异或运算，算的结果就是偶校验位的值\n如何进行校验：对偶校验来说，如果进行的是异或运算得到的结果是1就说明出错了\n海明校验码\n设计思路：将信息位分组进行偶校验=\u0026gt;多个校验位=\u0026gt;多个校验位标注出错位置\n多个校验位能够携带多种状态信息（对/错，错在哪里）\n1.确定海明码的位数：2^k \u0026gt;=n+k+1\nk代表多少位校验码\nn代表有效信息位\n2.确定校验位应该放在哪个位置\n将校验位放在海明位号为2^i-1次方的位置上\n3.确定校验位将和那几个有效位组成一组\n假设信息位：1010\n将一共有多少位从高到低排列，如H7 H6 H5 H4 H3 H2 H1\n将7654321转成二进制的数表示\n即0111 0110 0101 0100 0011 0010 0001\n找出有效位，也就是7653，也就是\nH7: 0111\nH6: 0110\nH5: 0101\nH3: 0011\n从尾巴开始对为1的有效位的实际值进行异或运算，得到每个校验位的值以及和那些有效位作为一组\n即P1=H7异或H5异或H3=D4异或D2异或D1=1异或1异或0=0\n即P2=H7 H6 H3 = D4 D3 D1 = 1 0 0 = 1\n即P3=H7 H6 H5 = D4 D3 D2 = 1 0 1 = 0\nH7 H6 H5 H4 H3 H2 H1 D4 D3 D2 P3 D1 P2 P1 1 0 1 0 分组结果就是：\nP1 D4 D2 D1\nP2 D4 D3 D1\nP3 D4 D3 D2\n4.纠错\n纠错就是对分组进行偶校验，若为1就说明有问题\n异或的结果从高到低排列 010 =\u0026gt;十进制就是2 ，就代表第二位出错了\n海明码的检错、纠错能力:\n纠错能力\u0026ndash;1位\n检错能力\u0026ndash;2位\n为了防止出现2位同时出现位错误判断错误位不对的情况，我们需要在前头加上全校验位，对整体进行偶校验\n1.若S3S2S1为000并且全体偶校验成功=\u0026gt;无错误\n2.若S3S2S1不为0并且全体偶校验失败=\u0026gt;有一位错误，纠正就可以了\n3.若S3S2S1不为0并且全体偶校验码成功=\u0026gt;有两位错误，需要重传\n海明码\n基本思想\n分组偶校验，多个校验位可反映出错位置 求解步骤\n确定校验位个数k个校验位，n个信息为 2^k\u0026gt;=n+k+1 确定校验位分布 P1、P2、P3\u0026hellip;分别在123416 空出来的其他位置一次填入信息位 求校验位 将信息位的位置序号用k位二进制数表示出来 校验位Pi 与位置序号第i位为1的信息为归为一组，进行偶校验 纠错 对P1、P2、P3\u0026hellip;所属各分组进行异或（相当于分组偶校验）求得S1、S2、S3 S3 S2 S1 = 000 说明无错误 S3 S2 S1 不等000 其值反映出错位置 补充\n海明码有1位纠错，2位检错能力 为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验 循环冗余校验码\n基本思想：数据发送、接受方约定一个“除数”\nK个信息位+R个校验位 作为“被除数” ， 添加校验位后需保证除法的余数为0\n若余数非0 说明出错，则进行重传或纠错\n构造 由生成多项式确定除数。若生成多项式中x的最高次为R，则除数有R+1位 K个信息位+R个0 ， 作为被除数 被除数、除数 进行模二除 ，得到R为余数 K个信息位+R位余数 = CRC码 校验 收到K+R位数据，与生成多项式模二除，计算R为余数 余数为0，说明无错误 余数非0，说明出错 检错、纠错能力 可以检测出所有奇数个错误 可以检测出所有双比特的错误 可以检测出所有小于等于校验位长度的连续错误 若选择合适的生成多项式，且2^R \u0026gt;=K +R +1，则可纠正单比特错 定点数与浮点数\n定点数：小数点的位置固定 \u0026ndash;常规计数法\n浮点数：小数点的位置不固定 \u0026ndash;科学计数法\n定点数的表示\n无符号数 有符号数 原码 反码 补码 移码 无符号数：整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。\n8位二进制数：2的八次方种不同状态，可以表示的是0到2的八次方-1这么多的十进制数。\nn为的无符号数表示范围为：0到2的n次方-1的十进制\n有符号数的定点表示：\n定点整数+定点小数\n最高位为符号位\n数值部分称为尾数\n注：可用原码、反码、补码三种方式来表示定点整数和定点小数。还可用移码表示定点整数。\n符号位0表示正数1表示负数\n原码：用尾码表示真值的绝对值，符号位0/1 ， 对应正负\n若机器字长为n+1位，则尾数占n位\n若机器字长为n+1位，原码整数的表示范围为：-（2^n-1)到2^n-1\n真值0有+0 和 -0 两种形式\n若机器字长为n+1位，原码小数的表示范围为-（1-2^-n）到1-2^-n\n真值0有+0 和 -0 两种形式\n反码：若符号位为0，则反码与原码相同\n​\t若符号位为1，则数值位全部取反\n补码：正数的补码=原码\n​\t负数的补码=反码+1\n移码：补码的基础上将符号位取反。注意：移码只能用于表示整数\n移码表示的整数很方便对比大小\n各种码的作用\n加减运算：\n无符号数的运算结果没有任何问题\n但是用原码表示有符号数的话，需要先判断符号位是不是负数，如果是负数的话，需要将负数的位改成正数位，然后将加法运算改成减法运算\n也即，使用原码运算：\n加法\u0026ndash;用加法器完成\n减法\u0026ndash;用减法器完成\n但减法器成本很高，所以考虑用加法来代替减法运算\n带余除法\u0026mdash;-设x，m属于z，m\u0026gt;0则存在唯一决定的整数q和r，使得：x=qm+r ， 0\u0026lt;=r\u0026lt;m\n实际上就是将整数分成r类，每类分别为余数从0到r-1\n模数相同的都是同一类，都是等价的\n二者绝对值之和=模的，互为补数\n模-a的绝对值=a的补数\n在mod m 的条件下，若能找到负数的补数，就可以用正数的加法来等价替代减法\n如果模数m为12的话，那么也就是余数0-11\n如果计算机的字长为8bit，也就是表示的范围是0-2^8-1，那么也就是实际上模数就是2^8呗\n所以只要模-a的绝对值=a的补数 =\u0026gt; 2^8-a的绝对值=a的补数 =\u0026gt; a的补码形式的原生定义\n补码\u0026mdash;就是让减法操作转变为加法操作，节省硬件成本 ， 这样ALU中只需要设计加法运算器就可以啦\n补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。\u0026mdash;-《数论》\n移码的作用：移码表示的整数很方便的对比大小\n定点数的表示和运算\n表示 无符号数 有符号数 原码 补码 反码 移码 运算 移位运算 加减运算 乘法运算 除法运算 移位运算\n算数移位 原码 补码 反码 逻辑移位 循环移位 原码 1 0010100. ==-20\n小数点位置是无法改变的，但是我们可以巧妙的改变数的位置，也就是\n原码 1 0001010. 也就是将尾数，整体右移一位，左边多出来的可以补0 ==-10\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补0，低位舍弃。若舍弃的位=0，则相当于除2；若舍弃的位不等于0，则会丢失精度\n左移：低位补0，高位舍弃。若舍弃的位=0，则相当于乘2；若舍弃的位不等于0，则会出现严重误差\n反码的算数移位\u0026ndash;正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。\n左移：低位补0，高位舍弃。\n反码的算数移位\u0026ndash;负数的反码数值位与原码相反，因此负数反码的移位运算规则如下，\n右移：高位补1，低位舍弃\n左移：低位补1，高位舍弃\n补码的算数移位\u0026ndash;正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。\n左移：低位补0，高位舍弃。\n补码的算数移位\u0026ndash;负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。\n规律\u0026ndash;负数补码中，最右边的1及其右边和原码相同。最右边的1的左边和反码相同\n所以，负数补码的算数移位规则如下：\n右移（同反码）：高位补1，低位舍弃\n左移（同原码）：低位补0，高位舍弃\n牛到家的例子\n-20*7\n可以理解为-20*（4+2+1）\n也就是-20左移两位，左移1位，和不移位三者之和\n逻辑移位：\n逻辑右移：高位补0，低位舍弃\n逻辑左移：低位补0，高位舍弃\n可以把逻辑移位看作是对无符号数的算数移位\n循环移位：\n循环左移和带进位位的循环左移\n应用：汉字的大端模式和小端模式相互转换的时候\n定点数移位运算\n算数移位 左移1位相当于x基数；右移以为相当于/基数 原码：符号位不参与移位。左移右移都补0 反码：符号位不参与移位。左移右移都补1 补码：负数补码的最右边的1及其右边与源码相同，最右边的1的左边与反码相同。符号位不参与移位，左移补0，右移补1。 逻辑移位 左移、右移都补0，移出的位舍弃。 循环移位 不带进位位：用移出的位补上空缺 带进位位：移出的位放到进位位，原进位位补上空缺 注：由于原、反、补码的数位有限，因此某些时候算数移位不能精确等效乘法、除法\n加减运算\n原码的加减法 补码的加减法 溢出判断 符号扩展 原码的加法运算：\n正+正：绝对值做加法，结果为正，可能溢出\n负+负：绝对值做加法，结果为负，可能溢出\n正+负：绝对值大的减绝对值小的，符号同绝对值大的数\n负+正：绝对值大的减绝对值小的，符号同绝对值大的数\n原码的减法运算，“减数”符号取反，转变为加法：\n正-负：正+正\n负-正：负+负\n正-正：正+负\n负+正：负-负\n太难了用减法器\n所以考虑用补码的加减运算\n负数补码=\u0026gt;原码：\n数值位取反+1 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码 对于补码来说，无论加法还是减法，最后都会转变为加法，由加法器实现运算，符号位也参与运算\n当数太大的时候，可能会发生溢出，所以要进行溢出判断\n溢出判断\n只有正数+正数才会上溢\u0026mdash;\u0026ndash;正+正=负 只有负数+负数才会下溢\u0026mdash;\u0026ndash;负+负=正 方法1：采用一位符号位 设A的符号位As，B的符号位Bs，运算结果的符号为Ss，则溢出逻辑表达式为\nV=AsBs（非Ss）+（非As）（非Bs）Ss\n若V=0，表示无溢出\n若V=1，表示有溢出\n方法2：采用一位符号位，根据数据位进位情况判断溢出，符号位的进位Cs 最高数值位的进位C1\n上溢：Cs=0，C1=1\n下溢：Cs=1，C1=0\n用异或来判断就好\n方法3：采用双符号位\n正数符号为00，负数符号为11\n记两个符号位为Ss1，Ss2，则V=Ss1异或Ss2\n若V=0，则表示无溢出，若V=1，表示有溢出\n双符号位补码称为：模4补码\n单符号位补码称为：模2补码\n符号扩展\n由于可能会出现溢出，所以可以考虑补位，即int-\u0026gt;long ， 如8位=\u0026gt;16位\n定点整数的符号扩展：\n在原符号位和数值位中间添加新位，正数都添0；负数原码添0，负数反、补码添1\n定点小数的符号扩展：\n在原符号位和数值位中间添加新位，正数都添0,；负数原码、补码添0，负数反码添1\n加减运算：\n原码 加法 减法 补码：总是要转变成加法，符号位参与运算 溢出判断（补码） Key：正+正=负（上溢）；负+负=正（下溢） 方法三：采用双符号位，正数符号为00，负数符号为11，加法运算后若双符号位=01则发生上溢错误；若双符号位为10则发生下溢错误，若两个符号位相同，则未发生错误 符号扩展 定点整数符号的扩展：在原符号位和数值位中间添加新位，正数都添0，负数原码添0，反码添1，补码添1 定点小数符号的扩展：在原符号为和数值位后面添加新位，正数都添0，负数原码、补码添0，反码添1 乘法运算\n乘法运算的实现思想 原码的一位乘法 补码的一位乘法 手算乘法：可以考虑用移位来实现，左移就是乘法，右移就是除法\n考虑用机器来实现：\n实际数字有正负，符号位如何处理 乘积的位数扩大一倍如何处理 4个位积都要保存下来最后统一相加吗？ 原码一位乘法\n符号单独处理：符号位=xs和ys进行异或操作\n数值位进行相乘就好了\n运算器：\nALU：算术逻辑单元\nX：通用寄存器（存放被乘数）\nACC：累加、存放乘积高位\nMQ：存放乘数和乘积低位\n机器字长为n+1\n实现方法：先加法再移位，重复n次\n首先，ACC置为0，X存被乘数，MQ存乘数\n当前位=1，则ACC加上被乘数\n当前位=0，则ACC加0\n如此再通过移位运算，达到错位的效果\n补码的乘法运算\n原码的一位乘法：\n进行n轮加法、移位\n每次加法可能是+0、+x的原码\n每次移位是逻辑右移\n符号位不参与运算\n符号位最后由一个异或运算来决定\n补码的一位乘法：\n进行n轮加法、移位，最后再多来一次加法\n每次加法可能+0，+x的补码，+-x的补码\n每次移位是补码的算数右移\n符号位参与运算\n辅助位-MQ中的最低位=1，ACC+x的补码\n辅助位-MQ中的最低位=0，ACC+0\n辅助位-MQ中的最低位=-1，ACC+-x的补码\n除法运算\n除法运算的思想 原码除法：恢复余数法 原码除法：加减交替法（不恢复余数法） 补码除法：加减交替法 恢复余数法：\n实现方法：上商0/1，得到余数，余数末尾补0\n强制类型转换：\n无符号数与有符号数：\n不改变数据内容，改变解释方式\n长整数变短整数：\n高位截断，保留低位\n短整型变长整数：\n符号扩展\n大小端模式：\n大端模式：便于人类阅读\n小段模式：便于机器处理\n边界对齐\n现代计算机通常是按字节编址，每个字节对应1个地址\n通常也支持按字、按半字、按字节寻址\n假设存储字长为32位，则1个字为=32bit ，半字=16bit 每次仿存只能读写1个字\n边界不对齐\n边界对齐访问一个字/半字都只需要一次访存 ， 即空间换时间，舍弃空间，换取最佳时间\n边界不对齐访问一个字/半字可能需要两次访存，即时间换空间，舍弃时间，换取空间密度最佳\n浮点数的表示\n浮点数的表示 浮点数的作用和基本原理 浮点数规格化 浮点数的表示范围 IEEE 754标准 浮点数的加减运算 定点数的局限性：\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n如何在位数不变的情况下增加数据的表示范围\n阶码+尾数\n阶码=阶符+阶码的数值部分\n尾数=数符+尾数的数值部分\n浮点数的表示\n定点数：如纯小数0.1011和纯整数11110\n浮点数：阶码+尾数\n阶码：常用补码或移码表示的定点整数\n尾数：常用原码或补码表示的定点小数\n浮点数的真值：N=r的E次方*M\n阶码的底通常为2\n阶码E反映浮点数的表示范围及小数点的实际位置；\n尾数M 的数值部分的位数n反映浮点数的精度\n之所以叫做浮点数，正是由于小数点可以通过阶码的值来对尾数进行调整，从而看起来像小数点在尾数中浮动，因此叫浮点数\n浮点数尾数的规格化\n使得尾数的最高位是有效值（左规），以免丢失精度\n规格化浮点数：规定尾数的最高数值位必须是一个有效值\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码则要减1\n右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位\n浮点数的表示范围也有极限\n浮点数的表示\n表示\n阶码：阶符+数值部分，尾数：数符+数值部分 阶码+尾数 尾数给出具体数值，阶码指明小数点前移、后移多少位 阶码通常是用补码、移码表示的定点整数 尾数通常是用补码、原码表示的定点小数 真值：N=r的E次方*M 规格化\n尾数的最高数值位必须是一个有效值（类比十进制科学计数法，通常我们会让数值部分最高位为非0） 左规：数值位最高位无效时，通过尾数算数左移、阶码-1的方法处理，直到尾数最高数值位有效时停止 右规：若采用双符号位表示尾数，则当运算后尾数假溢出时，可以通过尾数右移、阶码+1的方法处理 原码表示的尾数规格化：尾数的最高数值位必须是1 补码表示的尾数规格化：尾数的最高数值位必须和尾数符号位相反 表示范围\n浮点数标准\nIEEE754\n移码：补码基础上将符号位取反。注意：移码只能用于表示整数\n移码的定义是：移码=真值+偏置值\n以往的偏置值通常是2的n-1次方\n在IEEE754标准中，偏置值将设定为2的n-1次方-1\n那么移码就会有一点点改变\n分为数符、阶码部分（用移码表示）、尾数（用原码表示，隐藏表示最高位）\n阶码全1、全0用作特殊用途\n浮点数的运算\n加减运算 强制类型转换 1.对阶\n2.尾数加减\n3.规格化\n4.舍入\n5.判溢出\nchar-\u0026gt;int-\u0026gt;long-\u0026gt;double\nfloat-\u0026gt;double\n范围、精度从小到大，转换过程没有损失\n32位\nint：表示整数\nfloat：表示整数及小数\n因此，int-\u0026gt;float:可能损失精度\nfloat-\u0026gt;int:可能溢出及损失精度\n算数逻辑单元\n作用、大致原理 电路基础知识 加法器的实现 ALU:MQ ACC ALU X PSW\n基本逻辑运算：与或非\n优先级：与\u0026gt;或\n分配律结合律都满足的\n复合逻辑：与非、或非、异或、同或\n加法器：\n一位全加器：\nAi+Bi+Ci-1=Si和Ci\nAi是一个输入\nBi是一个输入\nCi-1是来自低位的进位\nSi是本位的输出\nCi是来自本位的进位\n串行加法器：\n只有一个全加器，数据诸位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。\n并行加法器：\n串行进位的并行加法器：把n个全加器串接起来，尽可以进行两个n位数的相加。\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。\n算数逻辑单元：\nALU\n实现算术运算、逻辑运算、辅助功能（移位、求补） 基本结构：输入、输出、控制CU 电路基础知识\n逻辑运算：与或非、与非、或非、异或、同或 门电路：最基础的逻辑元件，用于实现逻辑运算 逻辑表达式就是电路的数学化表示。根据逻辑运算的规则对逻辑表达式进行优化，也就是在优化电路 加法器的实现\n一位全加器的设计 本位和Si=Ai异或Bi异或Ci-1 本位向高位的进位Ci=AiBi+（Ai异或Bi）Ci-1 串行加法器 一位全加器+进位触发器，只能一位一位地加 串行进位的并行加法器 多个全加器简单串联，可多位同时相加 计算速度取决于进位产生和传递的速度 回忆\n各种门电路的图形，全加器的图形和输入输出信号 并新加法器的优化\n并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位\n串行加法器=\u0026gt;串行进位的并行加法器=\u0026gt;组内并行、组件串行进位的加法器=\u0026gt;组内并行、组件并行进位的加法器\n系统总线\n总线的基本概念\n总线的分类\n总线特性及性能指标\n总线结构\n总线控制\n总线是连接各个部件的信息传输线，是各个部件共享的传输机制。\n总线上信息的传送\n串行\u0026mdash;\u0026ndash;\n并行\u0026mdash;-\n总线结构\n1.单总线结构框图\n缺点：总线会成为瓶颈\n2.面向CPU的双总线结构框图\nCPU和主存之间加入M总线\n3.以存储器为中心的双总线结构框图\n总线的分类\n1.片内总线：芯片内部的总线\n2.系统总线：计算机各部件之间的信息传输线\n数据总线：双向 与机器字长、存储字长有关 地址总线：单向 与存储地址、IO地址有关 控制总线：有出有入 3.通信总线\n用于计算机系统质检或计算机系统与其他系统之间的通信\n传输方式\n串行通信总线 并行通信总线 总线特性及性能指标\n1.总线的物理实现\n实际上就是印刷电路板：主板\n2.总线特性\n机械特性\t尺寸、形状、管脚数、排列顺序 电气特性 传输方向和有效的电平范围 功能特性 每根传输线的功能：地址、数据、控制 时间特性 信号的时序关系 3.总线的性能指标\n1.总线宽度\t数据线的根数\n2.标准传输率 每秒传输的最大字节数（MBps）\n3.时钟同步、异步\t同步、不同步\n4.总线复用\t地址线与数据线复用\n5.信号线数\t地址线、数据线和控制线的总和\n6.总线控制方式\t突发、自动、仲裁、逻辑、计数\n7.其他指标\t负载能力\n4.总线标准\nISA EISA VESA PCI AGP RS-232 USB\n总线结构\n单总线结构 多总线结构 双总线结构 主存总线+通道+IO总线 CPU和主存之间加入M总线 三总线结构 主存总线、IO总线、DMA总线（IO设备和主存直接访问） CPU和cache之间的局部总线+系统总线+扩展总线 四总线结构 局部总线+系统总线+高速总线+扩展总线 多层PCI总线结构 总线控制\n总线判优控制\n主设备：对总线有控制权\n从设备：响应从主设备发来的总线命令\n总线判优控制：\n集中式 链式查询 计数器定时查询 独立请求方式 分布式 链式查询：\nBS\u0026ndash;总线忙\nBR\u0026ndash;总线请求\nBG\u0026ndash;总线同意\nbg的判断是串行的，所以是叫链式查询\n计数器定时查询：\n计数器放在总线控制部件内部，当可以让出总线占用权的时候，轮流向IO接口通过设备地址进行访问，少了BG总线，多了设备地址线，更加灵活设定优先级顺序\n独立请求方式：\n排队控制总线中设有排队器\n发起总线请求的时候，总线控制部件同时对外发起总线占用请求\n总线通信控制：\n1.目的：解决通信双方协调配合的问题\n2.总线传输周期\n申请分配阶段\t主模块申请，总线仲裁决定 寻址阶段 主模块向从模块给出地址和命令 传数阶段 主模块和从模块交换数据 结束阶段 主模块撤销有关信息 总线通信的四种方式\n同步通信 由统一时标控制数据传送 异步通信 采用应答方式，没有公共时钟标准 半同步通信 同步、异步结合 分离式通信 充分挖掘系统总线每个瞬间的潜力 同步式数据输入\n总线传输周期有四个\n在不同时钟周期上升沿给出信号\n在第一个时钟上升沿，给出地址信号\n在第二个时钟上升沿，给出读命令\n在第三个时钟上升沿，给出写数据信号\n在第四个时钟上升沿，撤销读命令以及写数据信号\n在第五个时钟上升沿，撤销地址信号\n同步式数据输出\n适用于总线比较短，不同模块读写速度近似的\n异步通信：\n主设备和从设备的请求和回答\n分为：不互锁、半互锁和全互锁方式\n半同步通信（同步、异步结合）\n同步：发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别\n异步：允许不同速度的模块和谐工作，增加一条“等待”响应信号\nT1 主模块发地址\nT2 主模块发命令\nTw 当WAIT为低电平时，等待一个T\nTw 当WAIT为低电平时，等待一个T\n当WAIT为高电平时，主模块开始向从模块对接\nT3 从模块提供数据\nT4 从模块撤销数据，主模块撤销命令\n以上三种通信的共同点：\n一个总线传输周期中:\n主模块发地址、命令\t占用总线 从模块准备数据 不占用总线 总线空闲 从模块向主模块发送数据 占用总线 第四种则是在总线空闲的时候，充分法诀系统总线每个瞬间的潜力，也就是分离式通信\n一个总线传输周期中，主模块申请占用总线，使用完后即放弃总线的使用权，在从模块准备好数据的时候，申请占用总线，将各种信息送至总线上\n分离式通信特点\n各模块有权申请占用总线 采用同步方式通信，不等对方回答 各模块准备数据时，不占用总线 总线被占用时，无空闲 存储器\n主存储器和高速缓冲存储器很重要\n存储器可分哪些类型 现代存储器的层次结构，为什么要分层 存储器分类\n按照存取方式分类\n存取时间与物理地址无关（随机访问） 随机存储器 在程序的执行过程中可读可写 只读存储器 在程序的执行过程中只读 存取时间与物理地址有关（串行访问） 顺序存取存储器\t磁带 直接存取存储器 磁盘 按在计算机中的作用分类\n主存储器\nRAM 随机存储器 可读可写 静态RAM 动态RAM ROM只读存储器 系统程序 不允许修改 MROM PROM EPROM EEPROM Flash Memory 例如U盘、固态\n高速缓冲存储器（Cache）\n辅助存储器：磁盘、磁带、光盘\n存储介质分类\n半导体存储器\tTTL、MOS 易失 磁表面存储器 磁头、载磁体 不易失 磁芯存储器 硬磁材料、环状元件 不易失 光盘存储器 激光、磁光材料 不易失 存储器的层次结构\n存储器的三个主要特性的关系 速度、容量、价格\n​\t寄存器\tCPU\t主机\t速度快\t容量小\t价格高\n​\t缓存\tCPU\t主机\n​\t主存\t主机\n​\t磁盘\t辅存\n​\t光盘\t辅存\n​\t磁带\t辅存\t速度慢\t容量大\t价格低\n软件、硬件相结合，多种存储器结合的形式，使得某一级的程序员看来，高速、大容量、低价格\n2.缓存\u0026ndash;主存层次和主存\u0026ndash;辅存层次\nCPU 缓存\t主存\t辅存\n10ns 20ns\t200ns\tms\n缓存\u0026ndash;主存 是由硬件绑定在一块儿的（主要为了解决速度问题）\n主存\u0026ndash;辅存 是由软硬件结合的形式弄在一块儿的（主要为了解决容量问题）\n缓存\u0026ndash;主存\n主存储器的地址 实地址 物理地址 主存\u0026ndash;辅存\n虚拟存储器 虚地址 逻辑地址 主存储器\u0026ndash;概述\n主存的基本组成 主存与CPU之间的联系 主存中的存储单元地址的分配 主存的技术指标 基本组成\nMAR地址寄存器\n译码器\n驱动器\n存储体\n读写电路\n控制电路\nMDR数据寄存器\n主存和CPU的联系\nMDR\u0026mdash;-数据总线（双向）\u0026mdash;-主存\nCPU\u0026mdash;-读写\u0026mdash;主存\nMAR\u0026mdash;地址总线（单向）\u0026mdash;主存\n主存中存储单元地址的分配\n高位字节放在前边\u0026mdash;大端模式、大尾模式\n低位字节放在前边\u0026mdash;小端模式、小尾模式\n主存的技术指标\n存储容量\t主存存放二进制代码的总位数 存储速度 存取时间\t存储器的访问时间 读出时间 写入时间 存取周期 连续两次独立的存储器操作（读或写）所需的最小间隔时间 读周期、写周期 存储器的带宽 位/秒 半导体存储芯片简介\n1.半导体存储芯片的基本结构\n译码驱动+存储矩阵+读写电路\n除此之外还有交互的数字线路，例如地址线（单向）、数据线（双向）、片选线、读写控制线\n地址线实际上是地址个数，例如地址线10条，也就是有2的10次方个地址\n数据线实际上是数据的位数，例如数据线有4条，也就是有4位的0101来表示一个数据\n所以芯片容量=地址线*数据线\n片选线 非CS 非CE chipselect chipenable 低电平有效\n读写控制线 非WE 写 非OE 读\n存储芯片片选线的作用\n用16K*1位的存储芯片组成64K * 8位的存储器\n那么就要求同时对8个芯片进行操作，每个芯片凑一个一位，8个同时工作就凑足8位，并且要同时凑足4组，因为1组只有2的16次方个地址，只有凑足4组才能够2的64次方这么多地址\n因此片选线的作用就是让几个存储芯片连接在一起同时工作\n半导体存储芯片的译码驱动方式\n1.线选法 通过输入的地址线，通过地址译码器来判断哪根线有效，然后将有效的线上的数据通过读写控制电路，也就是数据线输出，缺点在于如果地址线位数很多，那么也就是地址线需要很多，每根地址线要和不同的控制电路的块块相连，那么就会导致线很多\n2.重合法\t线选法使用矩阵来布线，而重合法使用二维矩阵来布线，布线的数量大大降低\n随机存取存储器RAM\n静态RAM（SRAM）\n保存0和1的原理是什么 通过触发器来实现存取，这部分涉及到数电的内容 基本单元单元电路的构成是什么 对单元电路如何读出和写入 通过片选信号将不同的芯片分组，通过重合法和地址线以及数据线，对低电平的地址进行选中后进行读写操作 典型芯片的结构是什么样子的 静态RAM芯片如何进行读出和写入操作 动态RAM(DRAM)\n保存0和1的原理是什么\n存在电容中，有电就是1，没电就是0 基本单元单元电路的构成是什么\n对单元电路如何读出和写入\n典型芯片的结构是什么样子的\n单管、三管 静态RAM芯片如何进行读出和写入操作\n动态RAM为什么要进行刷新，刷新方法\n防止电子丢失，刷新与行地址有关 集中刷新（存在死区和死时间率） 分散刷新（刷新过快了，没有死区） 集中刷新与分散刷新相结合（异步刷新） 动态RAM和静态RAM的比较\n​\tDRAM\tSRAM\n存储原理 电容 触发器\n集成度 高 低\n芯片引脚 少 多\n功耗 小 大\n价格\t低\t高\n速度\t慢\t快\n刷新\t有\t无\n​\t用作主存\t用作缓存\n只读存储器ROM\n早起只读存储器\u0026mdash;-不能修改\n改进1\u0026mdash;-用户可以自己写\u0026mdash;\u0026mdash;一次性\n改进2\u0026mdash;\u0026ndash;可以多次写\u0026mdash;\u0026mdash;-要能对信息进行擦除\n改进3\u0026mdash;\u0026mdash;电可擦写\u0026mdash;\u0026mdash;-特定设备\n改进4\u0026mdash;\u0026mdash;电可擦写\u0026mdash;\u0026mdash;-直接连接到计算机\n1.掩模ROM（MROM）\n行列选择线交叉处有MOS管为1\n2.PROM一次性编程\n3.EPROM（多次性编程）\nN型沟道浮动栅MOS电路\n紫外线擦除\n","date":"2022-04-14T00:26:49+08:00","permalink":"https://jianrongma.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"计算机组成原理学习文档"},{"content":"修改需求： 设备报警TOP 第二列加上DvcCd,搜索条件去掉故障说明，表格上方加入柱状图（按DvcCd分组计算）\n车身工艺参数 采集名称做下拉框\nANDON 1.Andon拉绳时长top10 --参考安驰报表-当天ANDON停线时长TOP10 select distinct PlineNm--”产线名称“ , sum(cast(SUBSTRING(SLContTm,1,2) as int) )*60+sum( cast(SUBSTRING(SLContTm,4,2) as int))+sum(cast(SUBSTRING(SLContTm,7,2) as int))/60as分--将停线持续时间转换为以“分“为单位 from BPIE_SLDoc --停线日志表 where sLContTm is not null --”持续时间“非空and Enabled=1 and datediff(day,sLStrtTm, \u0026#39;$igetdate} \u0026#39;)=o --将”停线开始时间“转换为参数面板中的查询时间的格式并与之对应group by PlineNm --以”产线名称“分组 order by分DESC --以处避”持续时间“为”分进行排序 查A_AndonManagement_Pro a LEFT JOIN A_AndonInfo_Record b ON a.AndonId =b.AndonId ，按照输入的时间范围以PlinCd分组查询，以累加的时长[AndonDurationTime]排序\nAndon的报表可以用产线编号查BBdbR_PlineBase把Enabled=1产线名称查出来作为横坐标\n数据结构分析\n在停线信息管理过程表中，“持续时间”\u0026ndash;AndonDurationTime 的单位为秒 在查询结果的处理中需要处理为分钟\n--SQL语句 无TOP 10 查询版本 --产线名称为横坐标 SELECT DISTINCT PlineNm,SUM(AndonDurationTime)/60 AS 分 FROM A_AndonManagement_Pro a LEFT JOIN BBdbR_PlineBase b ON a.PlineCd =b.PlineCd WHERE b.Enabled=\u0026#39;1\u0026#39; AND AndonDurationTime IS NOT NULL AND DATEDIFF(DAY, a.AndonStartTime, \u0026#39;2022-09-20\u0026#39;)=0 GROUP BY PlineNm ORDER BY 分 DESC ---DESC 降序排列 --SQL语句 TOP 10 查询版本 SELECT TOP 10 * FROM (SELECT DISTINCT PlineNm,SUM(AndonDurationTime)/60 AS 分 FROM A_AndonManagement_Pro a LEFT JOIN BBdbR_PlineBase b ON a.PlineCd =b.PlineCd WHERE a.Type=\u0026#39;产线\u0026#39; AND a.Enabled=\u0026#39;1\u0026#39; AND a.isFile=\u0026#39;1\u0026#39; AND AndonDurationTime IS NOT NULL AND DATEDIFF(DAY, a.AndonStartTime, \u0026#39;${getdate}\u0026#39;)=0 GROUP BY PlineNm) T ORDER BY 分 DESC 2.Andon拉绳次数TOP10 --拉停次数 SELECT TOP 10 * FROM (SELECT DISTINCT PlineNm,COUNT(*) AS 次数 FROM A_AndonManagement_Pro a LEFT JOIN BBdbR_PlineBase b ON a.PlineCd =b.PlineCd WHERE a.Enabled=\u0026#39;1\u0026#39; AND a.Type=\u0026#39;产线\u0026#39; AND a.isFile=\u0026#39;1\u0026#39; AND DATEDIFF(DAY, a.AndonStartTime, \u0026#39;2022-09-21\u0026#39;)=0 GROUP BY PlineNm) T ORDER BY 次数 DESC 设备报警 3.设备报警记录时长Top ‘n’ 需求分析 图表样式\u0026ndash;表格\n可以选择top的是 DvcCd 或者是FaultDsc\n还有TOP多少\nGROUP BY FaultDsc\nselect top ${textEditortopN} count(DefectId)缺陷数量,a.PlineNm,DefectNm,CarType from Q_CarPartQualityInspectionDefect_Pro a with (nolock) left join BBdbR_WcBase b on a.PostId=b.WcId left join BBdbR_PlineBase c on b.PlineId=c.PlineId where 1=1 and a.Enabled=\u0026#39;1\u0026#39; and a.PlineNm is not NULL and (len(\u0026#39;${startTm}\u0026#39;)=0 or a.CreTm \u0026gt;=\u0026#39;${startTm}\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or a.CreTm \u0026lt;=\u0026#39;${endTm}\u0026#39;) and (len(\u0026#39;${comboBoxPlineNm}\u0026#39;)=0 or a.PlineNm like \u0026#39;%${comboBoxPlineNm}%\u0026#39;) and (len(\u0026#39;${comboBoxCarType}\u0026#39;)=0 or CarType like \u0026#39;%${comboBoxCarType}%\u0026#39;) group by a.PlineNm,DefectNm,CarType order by 缺陷数量 desc --SQL 1.0 SELECT b.DvcId,FaultDsc,SUM(DurationTime) AS 分 FROM E_EquipmentFailureInfo_Pro a LEFT JOIN BBdbR_DvcBase b on a.DvcCd=b.DvcCd WHERE b.Enabled=\u0026#39;1\u0026#39; AND a.isFile=\u0026#39;1\u0026#39; AND DurationTime IS NOT NULL GROUP BY FaultDsc,b.DvcId ORDER BY 分 DESC --验证 SELECT b.DvcNm FROM E_EquipmentFailureInfo_Pro a LEFT JOIN BBdbR_DvcBase b on a.DvcCd=b.DvcCd WHERE a.isFile=\u0026#39;1\u0026#39; GROUP BY b.DvcNm --SQL 2.0 SELECT top ${textEditortopN} FaultDsc,SUM(DurationTime) AS 分 FROM E_EquipmentFailureInfo_Pro WHERE 1=1 AND isFile=\u0026#39;1\u0026#39; AND DurationTime IS NOT NULL and (len(\u0026#39;${comboBoxPlineNm}\u0026#39;)=0 or a.PlineNm like \u0026#39;%${comboBoxPlineNm}%\u0026#39;) and (len(\u0026#39;${comboBoxCarType}\u0026#39;)=0 or CarType like \u0026#39;%${comboBoxCarType}%\u0026#39;) GROUP BY FaultDsc ORDER BY 分 DESC 4.设备报警记录次数Top \u0026rsquo;n' -- 设备报警次数 SELECT top ${textEditortopN} DvcCd,FaultDsc,COUNT(*) AS 次数 FROM E_EquipmentFailureInfo_File WHERE 1=1 AND (len(\u0026#39;${startTm}\u0026#39;)=0 or FaultRecTime \u0026gt;=\u0026#39;${startTm}\u0026#39;) AND (len(\u0026#39;${endTm}\u0026#39;)=0 or FaultRecTime \u0026lt;=\u0026#39;${endTm}\u0026#39;) AND (len(\u0026#39;${comboBoxDvcCd}\u0026#39;)=0 or DvcCd like \u0026#39;%${comboBoxDvcCd}%\u0026#39;) GROUP BY DvcCd,FaultDsc ORDER BY 次数 DESC 5.车身工艺参数查询 -- WcNm select WcNm from dbo.BBdbR_WcBase where Enabled=1 -- 记录 --实现参数框联动 SELECT * FROM P_CarProcessParametersRecord WHERE 1=1 and [Enabled]=\u0026#39;1\u0026#39; and GetItemTm between \u0026#39;${StartTm}\u0026#39; and \u0026#39;${EndTm}\u0026#39; and (BodyNo like\u0026#39;%${BodyNo}%\u0026#39; or ISNULL(\u0026#39;${BodyNo}\u0026#39;,\u0026#39;\u0026#39;)=\u0026#39;\u0026#39;) and (GetItemNm like\u0026#39;%${GetItemNm}%\u0026#39; or ISNULL(\u0026#39;${GetItemNm}\u0026#39;,\u0026#39;\u0026#39;)=\u0026#39;\u0026#39;) and (WcNm like\u0026#39;%${WcNm}%\u0026#39; or ISNULL(\u0026#39;${WcNm}\u0026#39;,\u0026#39;\u0026#39;)=\u0026#39;\u0026#39;) ORDER BY [GetItemTm] DESC 能源报表 6.工况累计流量-比例分析 --参考 电度-比例分析 SELECT a.Class,a.EnergyProp,b.EnergyVal/(SELECT SUM(EnergyVal) FROM [P_EquipmentEnergyConsumptionRecord] WHERE [EnergyNm]=\u0026#39;工况累计流量\u0026#39;) FROM [E_EnergyConfig] a LEFT JOIN (SELECT Class,SUM(EnergyVal) AS EnergyVal FROM [P_EquipmentEnergyConsumptionRecord] WHERE [EnergyNm]=\u0026#39;工况累计流量\u0026#39; GROUP BY Class) b ON a.Class=b.Class WHERE a.Enabled=1 ORDER BY Class 7.工况累计流量-趋势分析 8.气-比例分析 9.气-趋势分析 能源 一个表格：管控区域，管控区域分配的能源比例，管控区域实际的能源比例\n一个折线图：按照选择的管控区域展示一个月的电度趋势\n1662549372222\r查出来这个表的Class和EnergyProp\n1662549409182\r联合查询这个表条件是Class相同\n1662549449290\r查这个表的时候要把Class相同的总有功电度加起来，再除以所有的总有功电度的和，\n1662549517209\r---电度趋势图 SELECT every_time as 日期,ISNULL(Class,\u0026#39;${Class}\u0026#39;) as 管控区域区域,ISNULL(EnergyVal,0) AS 电度 FROM( SELECT CONVERT (VARCHAR (10), dateadd(dd,number, dateadd(dd,-day(getdate())+1,getdate())),120) AS every_time --日期 FROM master..spt_values n WHERE n.type = \u0026#39;p\u0026#39; and number\u0026lt;datediff(day,dateadd(dd,-day(getdate())+1,getdate()),dateadd(mm,+1,dateadd(dd,-day(getdate())+1,getdate()))) )R LEFT JOIN( select a.Class,a.EnergyVal,convert(varchar(10),a.CreTm,120)as t FROM P_EquipmentEnergyConsumptionRecord_File a LEFT JOIN E_EnergyConfig b ON a.Class=b.Class WHERE 1=1 AND (len(\u0026#39;${Class}\u0026#39;)=0 or a.Class like \u0026#39;%${Class}%\u0026#39;) AND a.EnergyNm=\u0026#39;总有功电度\u0026#39; AND a.Enabled=\u0026#39;1\u0026#39; AND b.Enabled=\u0026#39;1\u0026#39; AND (select DateName(Hour,a.CreTm))=20 and (select DateName(Hour,a.CreTm))=20 AND Day(a.CreTm)\u0026gt;=1 and Day(a.CreTm)\u0026lt;=31 GROUP BY a.Class,EnergyVal,convert(varchar(10),a.CreTm,120) )TAB ON TAB.t=R.every_time order BY every_time 一个表格：管控区域，管控区域分配的能源比例，管控区域实际的能源比例 SELECT a.Class,a.EnergyProp,b.EnergyVal/(SELECT SUM(EnergyVal) FROM [P_EquipmentEnergyConsumptionRecord] WHERE [EnergyNm]=\u0026#39;总有功电度\u0026#39;) FROM [E_EnergyConfig] a LEFT JOIN (SELECT Class,SUM(EnergyVal) AS EnergyVal FROM [P_EquipmentEnergyConsumptionRecord] WHERE [EnergyNm]=\u0026#39;总有功电度\u0026#39; GROUP BY Class) b ON a.Class=b.Class WHERE a.Enabled=1 ORDER BY Class 生产报表 JPH 注释时间 去重？是站点去重嘛？ 不是有过点信息就展示 需要展示所有的站点信息 没有过点信息的展示为0 ab点只取一个点\n--Jph为当天的平均每小时产量 select AviNm,count(BodyNo)过点数量,时间=convert(varchar(10),PastTime,120) from P_CarPastRecordInfo where datediff(day,PastTime,\u0026#39;2022-05-15\u0026#39;)=0 group by AviNm,convert(varchar(10),PastTime,120) order by convert(varchar(10),PastTime,120) --时间筛查 select 时间=convert(varchar(10),PastTime,120) from P_CarPastRecordInfo where datediff(day,PastTime,\u0026#39;2022-05-15\u0026#39;)=0 --时间筛查2 select 时间=convert(varchar(19),PastTime,120) from P_CarPastRecordInfo where PastTime between \u0026#39;2022-05-15 08:00:00\u0026#39; and (DATEADD(day,1,\u0026#39;2022-05-15 08:00:00\u0026#39;)) select distinct AviNm from BBdbR_AVIBase where AviCd !=\u0026#39;AVI_638\u0026#39; AND AviCd !=\u0026#39;AVI_636\u0026#39; AND AviCd !=\u0026#39;AVI_619\u0026#39; AND AviCd !=\u0026#39;AVI_621\u0026#39; AND AviCd !=\u0026#39;AVI_606\u0026#39; AND AviCd !=\u0026#39;AVI_610\u0026#39;AND AviCd!=\u0026#39;AVI_602\u0026#39;AND AviCd!=\u0026#39;AVI_614\u0026#39; AND AviCd!=\u0026#39;AVI_641\u0026#39;AND AviCd!=\u0026#39;AVI_605\u0026#39;AND AviCd!=\u0026#39;AVI_655\u0026#39;AND AviCd!=\u0026#39;AVI_644\u0026#39; AND AviCd!=\u0026#39;AVI_645\u0026#39;AND AviCd!=\u0026#39;AVI_646\u0026#39;AND AviCd!=\u0026#39;AVI_647\u0026#39;AND AviCd!=\u0026#39;AVI_648\u0026#39; AND AviCd!=\u0026#39;AVI_649\u0026#39;AND AviCd!=\u0026#39;AVI_650\u0026#39; --尝试1 select distinct a.AviNm,count(BodyNo)过点数量,时间=convert(varchar(19),PastTime,120) from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; AND PastTime between \u0026#39;2022-05-15 08:00:00\u0026#39; and (DATEADD(day,1,\u0026#39;2022-05-15 08:00:00\u0026#39;)) group by a.AviNm,PastTime --尝试2 select distinct a.AviNm,count(BodyNo)过点数量 from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; group by a.AviNm --尝试3 select distinct a.AviNm,ISNULL(COUNT(BodyNo),0)过点数量 from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where PastTime between \u0026#39;2022-05-15 08:00:00\u0026#39; and (DATEADD(day,1,\u0026#39;2022-05-15 08:00:00\u0026#39;)) and a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; group by a.AviNm --尝试4 select distinct a.AviNm,时间=convert(varchar(19),PastTime,120) from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; group by a.AviNm,PastTime --尝试5 select A.AviNm,ISNULL(T.过点数量,0)过点数量 FROM ( select distinct a.AviNm from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; ) A LEFT JOIN ( select distinct a.AviNm,COUNT(BodyNo)过点数量 from BBdbR_AVIBase a left join P_CarPastRecordInfo b on a.AviId=b.AviId where PastTime between \u0026#39;2022-05-15 08:00:00\u0026#39; and (DATEADD(day,1,\u0026#39;2022-05-15 08:00:00\u0026#39;)) and a.AviCd !=\u0026#39;AVI_638\u0026#39; AND a.AviCd !=\u0026#39;AVI_636\u0026#39; AND a.AviCd !=\u0026#39;AVI_619\u0026#39; AND a.AviCd !=\u0026#39;AVI_621\u0026#39; AND a.AviCd !=\u0026#39;AVI_606\u0026#39; AND a.AviCd !=\u0026#39;AVI_610\u0026#39;AND a.AviCd!=\u0026#39;AVI_602\u0026#39;AND a.AviCd!=\u0026#39;AVI_614\u0026#39; AND a.AviCd!=\u0026#39;AVI_641\u0026#39;AND a.AviCd!=\u0026#39;AVI_605\u0026#39;AND a.AviCd!=\u0026#39;AVI_655\u0026#39;AND a.AviCd!=\u0026#39;AVI_644\u0026#39; AND a.AviCd!=\u0026#39;AVI_645\u0026#39;AND a.AviCd!=\u0026#39;AVI_646\u0026#39;AND a.AviCd!=\u0026#39;AVI_647\u0026#39;AND a.AviCd!=\u0026#39;AVI_648\u0026#39; AND a.AviCd!=\u0026#39;AVI_649\u0026#39;AND a.AviCd!=\u0026#39;AVI_650\u0026#39; group by a.AviNm ) T ON A.AviNm=T.AviNm 生产日报 八点0000000到第二天七点59.59.59\n说明也要加 算法也加 不要车型选择控件 按照日期查询展示所有车型 实际上下线不在一列\n年月日三张报表\n生产月报2.0 SQL语句1\nUSE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[produceYear] Script Date: 2022/6/22 15:41:54 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[produceYear] (\t@SearchYear varchar(20) ,@AviCd varchar(50) ) RETURNS @Data Table ( indexrow varchar(20),CarType varchar(50),Num int ) AS BEGIN declare @DATE_START datetime=convert(varchar(4),@SearchYear)+\u0026#39;-01-01 00:00:00.000\u0026#39; declare\t@DATE_ENDadd datetime=dateadd (YEAR,1,convert(varchar(10),@DATE_START)) declare\t@DATE_END datetime=dateadd (DAY,-1,convert(varchar(10),@DATE_ENDadd)) declare @IndexTable table ( DateInfo varchar(20)\t) declare @BeforeData table ( indexrow varchar(20),CarType varchar(50),Num int ) declare @InnerData table (\t[AviCd] varchar(50), CarType varchar(50), [PastTime] datetime ) insert into @IndexTable --每月X SELECT distinct convert(char(7), DATEADD(D, number, @DATE_START),120) AS DATA_DATE FROM master.dbo.spt_values as spt WHERE type = \u0026#39;p\u0026#39; AND number \u0026lt;= DATEDIFF(DAY, @DATE_START, @DATE_END) insert into @InnerData select [AviCd],CarType,[PastTime] from P_CarPastRecordInfo\twhere [PastTime] between @DATE_START and @DATE_END insert into @BeforeData select convert(varchar(7),PastTime,120),CarType,count(*) from @InnerData where [AviCd]=@AviCd group by convert(varchar(7),PastTime,120),CarType --声明一个游标 declare dy CURSOR for select DateInfo from @IndexTable --打开游标 open dy --提取游标1第一行内容 declare @daycol varchar(20); fetch next from dy into @daycol --循环提取游标1内容 WHILE @@FETCH_STATUS=0 BEGIN declare @col varchar(20),--每天 @IsNull\tint\tselect @col = DateInfo from @IndexTable where DateInfo=@daycol set @IsNull=(select count(*) from (select * from @BeforeData where indexrow=@col) a) if(@IsNull=0) begin insert into @Data (indexrow,CarType,Num) values (@col,null,null) end else begin insert into @Data select * from @BeforeData where indexrow=@col end fetch next from dy into @daycol end CLOSE dy --关闭游标 DEALLOCATE dy --释放游标资源 RETURN END SQL语句1.1\nUSE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[produceYear] Script Date: 2022/6/22 15:54:11 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[produceYear] (\t@SearchYear varchar(20) ) RETURNS @Data Table ( indexrow varchar(20),CarType varchar(50),Num int ) AS BEGIN declare @DATE_START datetime=convert(varchar(4),@SearchYear)+\u0026#39;-01-01 00:00:00.000\u0026#39; declare\t@DATE_ENDadd datetime=dateadd (YEAR,1,convert(varchar(10),@DATE_START)) declare\t@DATE_END datetime=dateadd (DAY,-1,convert(varchar(10),@DATE_ENDadd)) declare @IndexTable table ( DateInfo varchar(20)\t) declare @BeforeData table ( indexrow varchar(20),CarType varchar(50),Num int ) declare @InnerData table (\tCarType varchar(50), [PastTime] datetime ) insert into @IndexTable --每月X SELECT distinct convert(char(7), DATEADD(D, number, @DATE_START),120) AS DATA_DATE FROM master.dbo.spt_values as spt WHERE type = \u0026#39;p\u0026#39; AND number \u0026lt;= DATEDIFF(DAY, @DATE_START, @DATE_END) insert into @InnerData select CarType,[PastTime] from P_CarPastRecordInfo\twhere [PastTime] between @DATE_START and @DATE_END insert into @BeforeData select convert(varchar(7),PastTime,120),CarType,count(*) from @InnerData group by convert(varchar(7),PastTime,120),CarType --声明一个游标 declare dy CURSOR for select DateInfo from @IndexTable --打开游标 open dy --提取游标1第一行内容 declare @daycol varchar(20); fetch next from dy into @daycol --循环提取游标1内容 WHILE @@FETCH_STATUS=0 BEGIN declare @col varchar(20),--每天 @IsNull\tint\tselect @col = DateInfo from @IndexTable where DateInfo=@daycol set @IsNull=(select count(*) from (select * from @BeforeData where indexrow=@col) a) if(@IsNull=0) begin insert into @Data (indexrow,CarType,Num) values (@col,null,null) end else begin insert into @Data select * from @BeforeData where indexrow=@col end fetch next from dy into @daycol end CLOSE dy --关闭游标 DEALLOCATE dy --释放游标资源 RETURN END SQL语句\u0026ndash;datachart\nselect SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;01-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;02-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;03-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;04-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;05-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;06-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;07-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;08-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;09-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;10-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;11-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol union select SUM(onlinenum) as 实际上线,SUM(offlinenum) as 实际下线,CONVERT(VARCHAR(2),MONTH(daycol)) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;12-01\u0026#39;) --from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) where 1=1 and cartype !=\u0026#39;\u0026#39; group by daycol SQL语句\nselect sum(实际上线) 实际上线,sum(实际下线) 实际下线 ,a.daycol 月份 from ( select ISNULL(SUM(onlinenum), 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;01-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;01-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;02-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;02-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;03-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;03-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;04-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;04-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;05-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;05-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;06-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;06-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;07-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;07-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;08-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;08-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;09-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;09-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;10-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;10-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;11-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;11-01\u0026#39;) group by daycol union all select ISNULL(NULLIF(SUM(onlinenum), 0) , 0) as 实际上线,ISNULL(SUM(offlinenum), 0) as 实际下线,CONVERT(VARCHAR(2),MONTH(convert(VARCHAR(20),LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;12-01\u0026#39;,120))) daycol from fineReportDailyTable(LEFT(\u0026#39;${searchDate}\u0026#39;, 5)+\u0026#39;12-01\u0026#39;) group by daycol ) a GROUP BY a.daycol ; 质量报表 FTT 说明：计算FTT公式：（总数量-不合格数量）/总数据。其中总数量为这一段时间内过点车辆，且在这段时间之前没有过点，如果车辆过了两次或两次以上只算1次，且取的是第一次过点的数据。不合格数据为这段时间内，过点车辆但是任然有未修复的缺陷+过点车辆缺陷也已经修复但是是在下线（下线AVI站点，对于没有下线AVI站点的取的是上线AVI站点）之后修复的。 DPU DPU计算公试：缺陷总数/车辆总数。缺陷总数为这段时间内该线体发生的缺陷总合。车辆总数为这段时间内第一次经过该线体AVI站点的车辆，同一辆车重复或多次多点只算一次。 生产报表 SQL语句 --建表语句 USE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[fineReportDailyTable] Script Date: 2022/5/18 9:30:20 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[fineReportDailyTable] (\t@searchDate varchar(25)\t) RETURNS @Data Table ( rowindex int,daycol datetime,cartype varchar(10),plannum int,onlinenum int,offlinenum int ) AS BEGIN --声明表变量临时存储 declare @cartype varchar(10)--车型 declare @planonline int--计划上线 declare @actonline int--实际上线 declare @actoffline int--实际下线 declare @dayData table ( daycol datetime--月中的每天 ) declare @CarTpData table ( cartyp varchar(10)--车型 ) insert into @dayData select CAST(CONVERT(varchar(7),@searchDate)+\u0026#39;-\u0026#39;+CONVERT(VARCHAR(2),number+1) as datetime) as daycol from master..spt_values where type=\u0026#39;p\u0026#39; and DATEADD(day,number,cast(CONVERT(varchar(7),@searchDate)+\u0026#39;-01\u0026#39; as datetime))\u0026lt; DATEADD(MONTH,1,cast(CONVERT(varchar(7),@searchDate)+\u0026#39;-01\u0026#39; as datetime)) insert into @CarTpData select left(CarType,3) as cartyp from P_CarPastRecordInfo where DATEDIFF(month, PastTime, @searchDate)=0 group by left(CarType,3) declare @index int --序号建立 set @index=1 --声明一个游标1,2 declare dy CURSOR for select daycol from @dayData declare car CURSOR for select cartyp from @CarTpData --打开游标1 open dy --提取游标1第一行内容 declare @daycol datetime; fetch next from dy into @daycol --循环提取游标1内容 WHILE @@FETCH_STATUS=0 BEGIN declare @col datetime select @col = daycol from @dayData where daycol=@daycol --打开游标2 open car --提取游标2第一行内容 declare @cartyp varchar(10); fetch next from car into @cartyp --循环提取游标2内容 WHILE @@FETCH_STATUS=0 begin select @cartype = cartyp from @CarTpData where cartyp=@cartyp set @planonline = (select COUNT(*) from P_ProducePlan_Pro where convert(varchar(10),PlanTime,120)= convert(varchar(10),@col,120)and CarType like @cartyp+\u0026#39;%\u0026#39;) set @actonline = (select COUNT(*) from P_CarPastRecordInfo where convert(varchar(10),PastTime,120)= convert(varchar(10),@col,120) and CarType like @cartyp+\u0026#39;%\u0026#39;and AviCd=\u0026#39;AVI_601\u0026#39;)\tset @actoffline =(select COUNT(*) from P_CarPastRecordInfo where convert(varchar(10),PastTime,120)= convert(varchar(10),@col,120) and CarType like @cartyp+\u0026#39;%\u0026#39;and AviCd=\u0026#39;AVI_655\u0026#39;) insert into @Data (rowindex,daycol,cartype,plannum,onlinenum,offlinenum) values (@index,@col,@cartype,@planonline,@actonline,@actoffline)\tfetch next from car into @cartyp end CLOSE car --关闭游标 --DEALLOCATE car --释放游标资源 set @index = @index+1 fetch next from dy into @daycol END\tCLOSE dy --关闭游标 DEALLOCATE dy --释放游标资源\tDEALLOCATE car --释放游标资源 RETURN END --有误-月报多语句建表函数 USE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[fineReportDailyTable] Script Date: 2022/5/18 9:50:33 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[fineReportMonthTable] (\t@searchDate varchar(25)\t) RETURNS @Data Table ( rowindex int ,cartype varchar(10),plannum int,onlinenum int,offlinenum int ) AS BEGIN --声明表变量临时存储 declare @cartype varchar(10)--车型 declare @planonline int--计划上线 declare @actonline int--实际上线 declare @actoffline int--实际下线 declare @CarTpData table ( cartyp varchar(10)--车型 ) insert into @CarTpData select left(CarType,3) as cartyp from P_CarPastRecordInfo where DATEDIFF(month, PastTime, @searchDate)=0 group by left(CarType,3) declare @index int --序号建立 set @index=1 --声明一个游标 declare car CURSOR for select cartyp from @CarTpData --打开游标2 open car --提取游标2第一行内容 declare @cartyp varchar(10); fetch next from car into @cartyp --循环提取游标2内容 WHILE @@FETCH_STATUS=0 begin select @cartype = cartyp from @CarTpData where cartyp=@cartyp set @planonline = (select COUNT(*) from P_ProducePlan_Pro where convert(varchar(10),PlanTime,120)= substring(convert(varchar(10),PlanTime,120),1,7) and CarType like @cartyp+\u0026#39;%\u0026#39;) set @actonline = (select COUNT(*) from P_CarPastRecordInfo where convert(varchar(10),PastTime,120)= substring(convert(varchar(10),PastTime,120),1,7) and CarType like @cartyp+\u0026#39;%\u0026#39;and AviCd=\u0026#39;AVI_601\u0026#39;)\tset @actoffline =(select COUNT(*) from P_CarPastRecordInfo where convert(varchar(10),PastTime,120)= substring(convert(varchar(10),PastTime,120),1,7) and CarType like @cartyp+\u0026#39;%\u0026#39;and AviCd=\u0026#39;AVI_655\u0026#39;) insert into @Data (rowindex,cartype,plannum,onlinenum,offlinenum) values (@index,@cartype,@planonline,@actonline,@actoffline)\tfetch next from car into @cartyp end CLOSE car --关闭游标 --DEALLOCATE car --释放游标资源 set @index = @index+1 DEALLOCATE car --释放游标资源 RETURN END 问题点：\nselect * from fineReportDailyTable(\u0026#39;2022-05-04\u0026#39;) select * from fineReportDailyTable(\u0026#39;${searchDate}\u0026#39;) sql语句：多语句建表函数为什么select * 是按照车型（加空白共六种车型）分组 共31组 这个数据就很奇怪；\nselect sum 也就是不太对了\n质量报表 数据查询 一些摘抄：\n需得做好该做的从中获取价值意义 然后再去心安理得的去做无意义又愉悦身心的事 才叫闲暇\n相反 如果闲暇是建立在摒弃一切有价值有意义的事物躺下 则全然不觉得愉快\n车身质量检查过程表：所有过检车辆的信息记录\u0026mdash;过检车辆总数\n车身部位质检缺陷过程表：过检后出现问题的车辆具体缺陷信息\u0026mdash;缺陷问题数\n车身质量检查销项过程表：有问题车辆的修理数据记录\n缺陷问题点分类表：将检查到的缺陷问题按照固定类别进行分类\n联合查询 字段对应 1.产线基础信息表：产线主键\u0026ndash;PlineId；产线名称\u0026ndash;PlineNm 2.工位基础信息表：产线主键\u0026ndash;PlineId；工位主键\u0026ndash;WcId 3.车身质量过程表：质控点主键\u0026ndash;WcId 4.车身部位质检缺陷过程表：质控点主键\u0026ndash;WcId；：缺陷主键\u0026ndash;DefectId 5.缺陷问题点分类表：缺陷主键\u0026ndash;DefectId 逻辑分析 质量TOP分类DPU 数据集要求：\n产线-缺陷数量-车型-创建时间-缺陷名称-过检车辆数目\nSQL语句：\n多表联合查询：缺陷数量联合查询；\n过检车辆数联合查询\n单点问题趋势 数据处理问题点\n没有统计车身质量检查过程表数据，只联合车身部位质检缺陷过程表、产线基础信息表、工位基础信息表三表查询。过点车辆数为count(CarType)、当日缺陷数为count(DefectId)且Enabled=\u0026lsquo;1\u0026rsquo;\nSQL语句存档 质量TOP分类DPU及单点问题趋势 --缺陷数量及过检车辆数（无关产线、时间、车型） select count(a.BodyNo)当日过检车辆总数,count(DefectId)当日缺陷总数 from Q_CarQualityInspection_Pro a left join Q_CarPartQualityInspectionDefect_Pro b on a.WcId=b.WcId where a.Enabled=1 --当日过检车辆总数 select count(BodyNo)当日过检车辆总数 from Q_CarQualityInspection_Pro where Enabled=1 ---缺陷数量联合查询 select count(DefectId)当日缺陷数量,y.CreTm,PlineNm,DefectNm,y.CarType from Q_CarQualityInspection_Pro x left join Q_CarPartQualityInspectionDefect_Pro y on x.WcId=y.WcId left join BBdbR_WcBase z on y.WcId=z.WcId left join BBdbR_PlineBase w on z.PlineId=w.PlineId where 1=1 and (x.Enabled=1 and y.Enabled=1) and PlineNm is not NULL group by y.CreTm,PlineNm,DefectNm,y.CarType ---过检车辆联合查询 select count(d.BodyNo)当日过检车辆总数,d.CreTm,PlineNm,d.CarType from Q_CarQualityInspection_Pro d left join Q_CarPartQualityInspectionDefect_Pro e on d.WcId=e.WcId left join BBdbR_WcBase f on e.WcId=f.WcId left join BBdbR_PlineBase g on f.PlineId=g.PlineId where 1=1 and d.Enabled=1 and PlineNm is not NULL group by d.CreTm,PlineNm,d.CarType --合并1 select count(DefectId)当日缺陷数量,y.CreTm,PlineNm,DefectNm,y.CarType,(select count(d.BodyNo) from Q_CarQualityInspection_Pro d left join Q_CarPartQualityInspectionDefect_Pro e on d.WcId=e.WcId left join BBdbR_WcBase f on e.WcId=f.WcId left join BBdbR_PlineBase g on f.PlineId=g.PlineId where 1=1 and d.Enabled=1 and PlineNm is not NULL and g.PlineNm=w.PlineNm and e.DefectNm=y.DefectNm and e.CreTm=y.CreTm and d.CarType=y.CarType group by d.CreTm,PlineNm,d.CarType)当日过检车辆总数 from Q_CarQualityInspection_Pro x left join Q_CarPartQualityInspectionDefect_Pro y on x.WcId=y.WcId left join BBdbR_WcBase z on y.WcId=z.WcId left join BBdbR_PlineBase w on z.PlineId=w.PlineId where 1=1 and PlineNm is not NULL group by y.CreTm,PlineNm,DefectNm,y.CarType ---合并2 select count(DefectId)当日缺陷数量,a.CreTm,PlineNm,DefectNm,CarType,(select count(d.BodyNo) from Q_CarQualityInspection_Pro d left join Q_CarPartQualityInspectionDefect_Pro e on d.WcId=e.WcId left join BBdbR_WcBase f on e.WcId=f.WcId left join BBdbR_PlineBase g on f.PlineId=g.PlineId where 1=1 and (d.Enabled=1 and e.Enabled=1) and PlineNm is not NULL and g.PlineNm=c.PlineNm and e.DefectNm=a.DefectNm and e.CreTm=a.CreTm group by d.CreTm,PlineNm,d.CarType)当日过检车辆总数 from Q_CarPartQualityInspectionDefect_Pro a left join BBdbR_WcBase b on a.WcId=b.WcId left join BBdbR_PlineBase c on b.PlineId=c.PlineId where 1=1 and a.Enabled=1 and PlineNm is not NULL group by a.CreTm,PlineNm,DefectNm,CarType ---一些数据筛选 select * from Q_CarPartQualityInspectionDefect_Pro where CreTm=\u0026#39;2021-12-31 15:08:58.630\u0026#39; and WcId=\u0026#39;8e7d9e9d-4e4d-4150-a5d7-24001e87d624\u0026#39; select * from Q_CarQualityInspection_Pro where CreTm=\u0026#39;2021-12-31 15:08:58.630\u0026#39; and WcId=\u0026#39;8e7d9e9d-4e4d-4150-a5d7-24001e87d624\u0026#39; ---筛选12.31的划伤数据 select * from Q_CarPartQualityInspectionDefect_Pro where CreTm=\u0026#39;2021-12-31 15:08:58.630\u0026#39; and DefectNm=\u0026#39;划伤\u0026#39; and WcId=\u0026#39;7a7a468e-e25a-4f89-b462-957aa7b2a71\u0026#39; select * from Q_CarQualityInspection_Pro where CreTm=\u0026#39;2021-12-31 15:08:58.630\u0026#39; and WcId=\u0026#39;7a7a468e-e25a-4f89-b462-957aa7b2a71\u0026#39; select * from BBdbR_WcBase where WcId=\u0026#39;7a7a468e-e25a-4f89-b462-957aa7b2a71\u0026#39; select * from BBdbR_PlineBase where PlineId=\u0026#39;30a5209d-d850-4156-841b-684465b518658\u0026#39; select * from BBdbR_WcBase where PlineId=\u0026#39;30a5209d-d850-4156-841b-684465b518658\u0026#39; --筛选2021-1-05、2021-11-28凹陷数据 select * from Q_CarPartQualityInspectionDefect_Pro where CreTm=\u0026#39;2021-01-05 09:09:11.087\u0026#39; and DefectNm=\u0026#39;凹\u0026#39; and WcId=\u0026#39;d66bfaec-4328-4802-aa6e-c1b49cf676ca\u0026#39; select * from Q_CarQualityInspection_Pro where CreTm=\u0026#39;2021-01-05 09:09:11.087\u0026#39; and WcId=\u0026#39;d66bfaec-4328-4802-aa6e-c1b49cf676ca\u0026#39; select * from BBdbR_WcBase where WcId=\u0026#39;d66bfaec-4328-4802-aa6e-c1b49cf676ca\u0026#39; select * from BBdbR_PlineBase where PlineId=\u0026#39;59a51f72-55b0-4a02-b713-4e9281f9f6919\u0026#39; select * from BBdbR_WcBase where PlineId=\u0026#39;59a51f72-55b0-4a02-b713-4e9281f9f6919\u0026#39; ---如果Enabled无效则数据为0 select Enabled=case when Enabled=\u0026#39;0\u0026#39; then 0 else count(Enabled) end from Q_CarPartQualityInspectionDefect_Pro group by Enabled select count(Enabled) from Q_CarPartQualityInspectionDefect_Pro where Enabled=\u0026#39;1\u0026#39; 质量问题分类 select count(CarType) from Q_CarPartQualityInspectionDefect_Pro where Enabled=1 select DefectIssuesTypeNm,Dsc,count(Dsc)缺陷数 from BBdbR_DefectIssuesType where Enabled=1 group by DefectIssuesTypeNm,Dsc 单点问题趋势 样式表 select count(CarType)当日过点车数量,PlineNm,d.CreTm,DefectNm,CarType,(select count(DefectId) from Q_CarPartQualityInspectionDefect_Pro a left join BBdbR_WcBase b on a.WcId=b.WcId left join BBdbR_PlineBase c on b.PlineId=c.PlineId where 1=1 and a.Enabled=\u0026#39;1\u0026#39; and PlineNm is not NULL and (len(\u0026#39;${startTm}\u0026#39;)=0 or a.CreTm \u0026gt;=\u0026#39;${startTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or a.CreTm \u0026lt;=\u0026#39;${endTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${comboBoxMatter}\u0026#39;)=0 or DefectNm like \u0026#39;%${comboBoxMatter}%\u0026#39;) and (len(\u0026#39;${comboBoxCarType}\u0026#39;)=0 or CarType like \u0026#39;%${comboBoxCarType}%\u0026#39;) and c.PlineNm=e.PlineNm and d.DefectNm=a.DefectNm and d.CreTm=a.CreTm group by a.CreTm,PlineNm,DefectNm,CarType)当日问题总数 from Q_CarPartQualityInspectionDefect_Pro d left join BBdbR_WcBase b on d.WcId=b.WcId left join BBdbR_PlineBase e on b.PlineId=e.PlineId where 1=1 and PlineNm is not NULL and (len(\u0026#39;${startTm}\u0026#39;)=0 or d.CreTm \u0026gt;=\u0026#39;${startTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or d.CreTm \u0026lt;=\u0026#39;${endTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${comboBoxMatter}\u0026#39;)=0 or DefectNm like \u0026#39;%${comboBoxMatter}%\u0026#39;) and (len(\u0026#39;${comboBoxCarType}\u0026#39;)=0 or CarType like \u0026#39;%${comboBoxCarType}%\u0026#39;) group by d.CreTm,PlineNm,DefectNm,CarType 9.按时段质量问题对比分析、查重 要求 根据时间段搜索质量问题的对比以及分析，并且可以根据相似的问题找到该问题以前出现的时间段。\n逻辑 饼状图 ；\n按照时间按查询；\n展示缺陷占比（某缺陷数量/总缺陷数量）；\n点击饼状图问题区域，链接跳转到该问题明细表-展示出现该问题的所有时间段、车型等信息\nSQL语句 select DefectNm,count(DefectNm)缺陷数量,CreTm from [dbo].[Q_CarPartQualityInspectionDefect_Pro] where Enabled=\u0026#39;1\u0026#39; group by DefectNm,CreTm --数据集语句 比例： select DefectNm,count(DefectNm)缺陷数量 from [dbo].[Q_CarPartQualityInspectionDefect_Pro] where 1=1 and (len(\u0026#39;${startTm}\u0026#39;)=0 or CreTm \u0026gt;=\u0026#39;${startTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or CreTm \u0026lt;=\u0026#39;${endTm} 00:00:00.000\u0026#39;) and Enabled=\u0026#39;1\u0026#39; group by DefectNm 时间段： select DefectNm,CreTm from [dbo].[Q_CarPartQualityInspectionDefect_Pro] where 1=1 and (len(\u0026#39;${startTm}\u0026#39;)=0 or CreTm \u0026gt;=\u0026#39;${startTm} 00:00:00.000\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or CreTm \u0026lt;=\u0026#39;${endTm} 00:00:00.000\u0026#39;) and Enabled=\u0026#39;1\u0026#39; group by DefectNm,CreTm SQL笔记 如果Enabled无效则数据为0 ---如果Enabled无效则数据为0 select Enabled=case when Enabled=\u0026#39;0\u0026#39; then 0 else count(Enabled) end from Q_CarPartQualityInspectionDefect_Pro group by Enabled 6.车身所有过程质量问题查询, 质量明细、无代码问题录入统计 建表思路 图表为甘特图\n设备报表 1.AVI车身过点信息追溯及查询 SQL查询语句 select PastTime,AviNm,PastNo,OrderCd,a.BodyNo,a.CarType,a.VIN,AviCd from P_CarPastInfo_Pro a left join P_ProducePlan_Pro b on a.ProducePlanCd=b.ProducePlanCd where 1=1 and AviCd like \u0026#39;%AVI%\u0026#39; and (len(\u0026#39;${startTm}\u0026#39;)=0 or PastTime \u0026gt;=\u0026#39;${startTm}\u0026#39;) and (len(\u0026#39;${endTm}\u0026#39;)=0 or PastTime \u0026lt;=\u0026#39;${endTm}\u0026#39;) and (len(\u0026#39;${bodyno}\u0026#39;)=0 or a.BodyNo like \u0026#39;%${bodyno}%\u0026#39;) and (len(\u0026#39;${avicd}\u0026#39;)=0 or AviNm like \u0026#39;%${avicd}%\u0026#39;) and Enabled=\u0026#39;1\u0026#39; order by ${sort} ${sortstyle} 2.设备报警信息文本显示及优先级分类 SQL查询语句 --新建多语句表值函数： --月 --[dbo].[DvcTypeDay]： USE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[DvcTypeDay] Script Date: 2022/4/18 11:01:36 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[DvcTypeDay] (\t@StartTm datetime, @EndTm datetime, @PlineNm varchar(50) ) RETURNS @Data Table ( indexrow datetime,DvcNm varchar(20),SumTm float,StopNum varchar(50) ) AS BEGIN\tdeclare @InnerData table ( FaultStartTime datetime, DurationTime float, DvcNm varchar(20), PlineNm varchar(50) ) insert into @InnerData select FaultStartTime,DurationTime,DvcNm,PlineNm from [E_EquipmentFailureInfo_Pro] a inner join BBdbR_PlineBase b on a.WorkSectionId=b.WorkSectionId\twhere FaultStartTime between @StartTm and @EndTm and PlineNm=@PlineNm insert into @Data select convert(varchar(10),FaultStartTime,120),DvcNm,Sum(DurationTime)/60 SumTm,count(*) StopNum from @InnerData group by DvcNm,convert(varchar(10),FaultStartTime,120)\tRETURN END --新建多语句表值函数： --周 USE [JAC_PaintingFAS] GO /****** Object: UserDefinedFunction [dbo].[DvcTypeWeek] Script Date: 2022/4/19 15:58:50 ******/ SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER FUNCTION [dbo].[DvcTypeWeek] (\t@StartTm datetime, @EndTm datetime, @PlineNm varchar(50) ) RETURNS @Data Table ( indexrow varchar(10),DvcNm varchar(20),SumTm float,StopNum varchar(10) ) AS BEGIN\tdeclare @InnerData table ( FaultStartTime datetime, DurationTime float, DvcNm varchar(20), PlineNm varchar(50) ) insert into @InnerData select FaultStartTime,DurationTime,DvcNm,PlineNm from [E_EquipmentFailureInfo_Pro] a inner join BBdbR_PlineBase b on a.WorkSectionId=b.WorkSectionId\twhere FaultStartTime between @StartTm and @EndTm and PlineNm=@PlineNm insert into @Data select DATEPART(WEEK,FaultStartTime),DvcNm,Sum(DurationTime)/60 SumTm,count(*) StopNum from @InnerData group by DvcNm,DATEPART(WEEK,FaultStartTime),DvcNm RETURN END 3.设备运行趋势曲线报表展示 思路分析 折线图\n分类：设备名称\n系列：异常时长及异常次数\nSQL语句 select DvcNm,Sum(DurationTime)/60 SumTm,count(*) StopNum from [E_EquipmentFailureInfo_Pro] group by DvcNm ","date":"2022-04-10T10:31:06+08:00","permalink":"https://jianrongma.github.io/p/%E6%B1%9F%E6%B7%AE%E8%94%9A%E6%9D%A5%E6%B6%82%E8%A3%85fas%E6%8A%A5%E8%A1%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","title":"江淮蔚来涂装FAS报表过程记录"},{"content":"leetBook_冲刺攻略 image-20220227100312893\r根据提示的数据范围推定时间复杂度 根据时间复杂度推定算法集合 根据题目特征确定算法\nimage-20220227100007364\r没有给出数据范围通常使用枚举 枚举通常是n~nlog(n)的时间复杂度 然后再确定算法集合\nimage-20220227100056863\rimage-20220228103152097\rimage-20220228103157567\r","date":"2022-02-28T12:11:37+08:00","permalink":"https://jianrongma.github.io/p/leetbook_%E5%86%B2%E5%88%BA%E6%94%BB%E7%95%A5/","title":"leetBook_冲刺攻略"},{"content":"数据结构与算法 解决问题方法的效率，跟数据的组织方式有关。\n循环和递归\n解决问题方法的效率，跟空间的利用效率有关。\nimage-20210818161452286\rimage-20210818162018882\r解决问题方法的效率，跟算法的巧妙程度有关\n数据结构 数据对象在计算机中的组织方式\n逻辑结构：线性结构和树结构、图结构 物理存储结构：数组、链表 数据对象必定与一系列加在其上的操作相关联\n完成这些操作所用的方法就是算法\n抽象数据类型(Abstract Data Type) 数据类型 数据对象集 数据集合相关联的操作集 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关 只描述数据对象集和相关操作集是什么，并不涉及如何做到的问题\n抽象 image-20210818163548512\r算法 一个有限指令集 接收一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖与任何一种计算机语言以及具体的实现手段 image-20210818164049310\r什么是好算法 空间复杂度sn 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。\n时间复杂度Tn 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。\n递归的时候会占用内存，因为递归下一层的时候要暂存上一层的结果\nSn = C*N\nimage-20210818164648695\r加减比乘除算的快\nimage-20210818164842726\r在分析一般算法的效率时，我们经常关注下面两种复杂度\n最坏情况复杂度T worst(n) 平均复杂度T avg(n) 基本上就是第一种：最坏情况复杂度\nimage-20210818165255964\rimage-20210818165445992\rimage-20210818165457903\rimage-20210818165643710\rimage-20210818165759487\rimage-20210818191956566\rimage-20210818193405280\rimage-20210818193945679\rimage-20210818194726647\r什么是线性表 多项式表示问题的启示 同一个问题可以有不同的表示（存储）方法 有一类共性问题：有序线性序列的组织和管理 线性表 由同类型数据元素构成有序序列的线性结构\n表中元素个数成为线性表的长度 线性表没有元素时，称为空表 表起始位置称表头，表结束位置称表尾 image-20210818195144256\r链式存储实现\nimage-20210818200032485\r广义表 广义表是线性表的推广 对于线性表而言，n个元素都是基本的单元素 广义表中，这些元素不仅可以是单元素也可以是另一个广义表 image-20210818201230986\r多重链表 多重链表：链表中的节点可能同时隶属于多个链\n多重链表中结点的指针域会有多个，如前面例子包含了netx和sublist两个指针域 但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表 多重链表有广泛的用途：\n基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储\n堆栈 image-20210818203628155\r堆栈stack ：具有一定操作约束的线性表\n只有一端（栈顶，top）做插入、删除 插入数据：push入栈 删除数据：pop出栈 后入先出：LIFO image-20210818203949646\rimage-20210818204030156\r中缀表达式转成后缀表达式\nimage-20210818210009984\r堆栈的其他应用：\n函数调用及递归实现 深度优先搜索 回溯算法 队列及实现\n队列：queue具有一定操作约束的线性表\n插入和删除操作：只能在一端插入，而在另一端删除 数据插入 入队列 AddQ 数据删除 出队列DeleteQ 先来先服务 先进先出 FIFO image-20210819200815843\rimage-20210819200925663\rimage-20210819201437552\rimage-20210819201758339\rimage-20210819202139270\rimage-20210819202326934\rimage-20210819203439780\rimage-20210819203707397\r什么是树 分层次组织在管理上具有更高的效率\n数据管理的基本操作之一：查找\n如何实现有效率的查找\nsearching\nimage-20210819205601090\rimage-20210819205951769\r二分查找\nimage-20210819210521234\rimage-20210819211054628\rimage-20210819212247115\rimage-20210819212402458\rimage-20210819212620945\rimage-20210819212737409\rimage-20210819213128752\rimage-20210819213227642\rimage-20210819213322280\rimage-20210819213454497\rimage-20210819214643681\rimage-20210819214812719\rimage-20210819215245013\rimage-20210819215345900\rimage-20210819215519052\rimage-20210819220012636\rDBEFAGHCI\nimage-20210819220312388\rDEFBHGICA\nimage-20210819220547376\r路线是一样的， 第一次碰到就输出的叫做先序、第二次的叫做中序、第三次的叫做后序\nimage-20210819220744178\rimage-20210822092825462\rimage-20210822093926951\r​\timage-20210822094347290\rimage-20210822094920689\rimage-20210822095028474\rimage-20210822095125615\rimage-20210822095254235\rimage-20210822095400071\rimage-20210822095400133\rimage-20210822095600852\rimage-20210822095753944\rimage-20210822095955430\rimage-20210822100108869\rimage-20210822100248441\r判断同构\nimage-20210822100435562\rimage-20210822100843208\rimage-20210822101301912\r判断有没有哪个节点没有被指向 哪个节点就是根\n例如231被指向了,那么意思就是0这个节点是根节点\nimage-20210822101644943\rimage-20210822101656356\rimage-20210822102023363\r使用check来判断根节点\nimage-20210822102155154\rimage-20210822102200845\rimage-20210822102407846\rimage-20210822102550689\rimage-20210822102618697\rimage-20210822102638201\rimage-20210822102736696\r尾递归可以用循环实现\nimage-20210822102824536\r查找的效率决定于树的高度\nimage-20210822102911459\rimage-20210822102930132\rimage-20210822103127572\rimage-20210822103450196\r​\timage-20210822103701343\rimage-20210822103721215\rimage-20210822103850804\rimage-20210822104154455\rimage-20210822104407357\rimage-20210822104658392\rimage-20210822105311867\rimage-20210822105726331\r所以走台阶问题我大概懂了\n只能一次走一阶台阶或者一次走两阶台阶\n一阶台阶有1种走法\n二阶台阶有2种走法\n那么三阶台阶无非就是1阶台阶的走法+走2阶的走法(2)\n或者2阶台阶的走法+走1阶的走法(1)\n那么四阶台阶无非就是2阶台阶的走法+走2阶的走法(2)\n或者3阶台阶的走法+走1阶的走法(1)\n所以也就是斐波那契数列的性质\nF(n)=F(n-1)+1+F(n-2)+2\nimage-20210822110716637\rimage-20210822111522588\rimage-20210822112334232\rimage-20210822112657646\r必须保证是查找树 也就是左边小右边大\nimage-20210822113538123\rimage-20210822113732802\rimage-20210822113938703\rimage-20210822114002650\rimage-20210822114101318\rimage-20210822114324854\rimage-20210822114521287\rimage-20210822114826316\rimage-20210822115039320\rimage-20210822151804901\rimage-20210822151947780\rimage-20210822152334294\rimage-20210822152933725\rimage-20210822153108950\rimage-20210822153304689\rimage-20210822153425949\rimage-20210822153713250\rimage-20210822153929001\r实现堆用完全二叉树\n根节点是最大的完全二叉树\nimage-20210822154053219\rimage-20210822154254474\rimage-20210822154337334\rimage-20210822154516519\rimage-20210822154705009\rimage-20210822154842548\ri/2就是完全二叉树的父节点\nimage-20210822155046618\rimage-20210822155243748\r因为是完全二叉树,所以要用最后一个元素替补删除掉的那个元素,才能满足完全二叉树的性质\nimage-20210822155357876\r时间复杂性就是树的高度 log2n\nimage-20210822160108019\rimage-20210822160408516\rimage-20210822160720461\r从倒数第二层开始建立堆,建完之后逐层往上建立,\nimage-20210822160834924\rimage-20210822160855127\rimage-20210822161110159\rimage-20210822161247647\rimage-20210822161303788\r如何根据节点不同的查找效率构造更有效的搜索树\nimage-20210822161422536\rimage-20210822161529534\rimage-20210822161639103\rimage-20210822161818080\rimage-20210822161934722\r由于度为1的节点就是只有一个儿子的节点\n没有度为1的节点\n那么就是n2+n1+n0=n0-1+0+n0=2n0-1\nimage-20210824222513996\rimage-20210824222657220\r第二种的意思是, 我用2的三次方也就是8种不同的符号来表示7个字符绰绰有余\nimage-20210824222809811\rimage-20210824222844586\r当所以的值都在叶节点上的时候就不可能出现一个字符的编码是另一个字符的前缀\nimage-20210824223228402\rimage-20210824223351755\rimage-20210824223520102\rimage-20210824223656627\r用数组实现\nimage-20210824223823443\rimage-20210824224033563\rimage-20210824224257684\rimage-20210824224312615\r这样做会导致一边倒,会让高度增加 find操作很难效率查\n可以尝试把集合小的挂到集合大的下面\nimage-20210824224547703\rimage-20210824225642477\rimage-20210824230108245\rimage-20210824230311976\r直接简化成把值为3对应为下标为3的数组中的,数组里存的值是他的父节点\nimage-20210824230758030\rimage-20210824231016070\rimage-20210824231230324\rimage-20210824231506693\rimage-20210824231623358\rimage-20210824232012169\rimage-20210824232158793\rimage-20210824232344637\rimage-20210824232443313\rimage-20210824232956745\rimage-20210824233747366\rimage-20210824233929998\rimage-20210827150052047\rimage-20210827150132906\rimage-20210827150336396\r无向图 对称 那么会不会空间浪费呢\nimage-20210827151040590\rimage-20210827161401937\rimage-20210827161523060\rimage-20210827161721941\rimage-20210827161814110\rimage-20210827162026003\r访问完所有的之后一定是原路返回\nimage-20210827162605593\r利用堆栈\nimage-20210827163115572\r明白为啥是深度优先了\nimage-20210827163414973\r会走的比较深\n一圈一圈的搜索\nimage-20210827163440795\rimage-20210827163728923\rimage-20210827163907704\rimage-20210827164150229\rimage-20210827164252208\rimage-20210827164800507\rimage-20210827165034266\rimage-20210827165238415\r六度空间\nimage-20210827165619918\rimage-20210827165905518\r","date":"2022-01-30T00:22:19+08:00","permalink":"https://jianrongma.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"数据结构与算法学习文档"},{"content":"C#5.0+学习文档 特点：\n通用性语言 类型安全 面向对象 目标：生产力\n简洁性 表达力 高性能 平台中立，与平台无关\n封装、继承、多态\n统一的类型系统：\n类型 共同的基类 类和接口\nclass interface 属性property、方法method和事件event\n唯一一种函数成员(Function Member):方法(method)\n方法还包括：属性(Property)和事件(Event)还有其他的\n属性\n事件\nC#主要是一种面向对象的语言，但是也借用了不少函数式编程的特性\n函数可以当做值来对待\n委托Delegate 支持纯(purity)模式\n避免使用值可变的变量 类型安全\nc#主要来说是类型安全的 静态类型 static typing 动态类型 dynamic 强类型 strongly typed language 内存管理\n依赖于运行时来执行自动内存管理 CLR:Common Language Runtime (公共语言运行时) GC： Garbage Collector (垃圾收集器) c#没有消灭指针 通常情况下不需要使用指针 unsafe 平台支持\n原来c#主要是在window上面运行\n现在可以在所有的平台上运行\nwindows macs linux ios android \u0026hellip; .Net Core\n.Net/.Net Core 的核心就是CLR: Comman Language Runtime\nCLR和语言无关\nc#是一种托管语言\n会被编译成托管代码(IL : Intermediate Language) CLR把IL转化成机器的原生代码 JIT(Just in time)编译 Ahead-of-time编译 托管代码的容器：Assembly 或portable Executable\n.exe 或dll 包含IL 和类型信息(metadata) IIdasm\n支持c#的框架\n.net framework .net core unity xamarin uwp winrt windows phone xna silverlight .net micro framework mono sql server .net Core\n编译 c#编译器把.cs结尾的源码文件编译成Assembly assembly是.net core里包装和部署的单元 assembly可以是应用程序，也可以是库 .exe .dll 构造函数和实例化 数据是通过实例化一个类型来创建的 预定义的类型直接写literal就可以被实例化了 而自定义类型则通过new操作符来创建实例 实例成员vs静态成员 操作于实例类型的数据成员和函数成员都叫做实例成员 操作于类型而不是类型实例的数据成员和函数成员叫做静态成员 static 静态类static class 的所有成员都是静态的 静态类不可以创建实例。 例如console ，他在整个程序里就一个 public\npublic关键字可以把成员暴露给其他的类 如果没有public关键字的话就是private 无法暴露给其他类 值类型与引用类型 值类型包括所有的内置类型（数值、字符、bool）和自定义的struct和enum\n引用类型包含所有的class，数组，delegate，interface类型。包括字符串\n他们的根本区别在于处理内存的方式\n值类型 值类型变量/常量的内容就是一个值 使用struct关键字就可以自定义创建值类型 Point p = new Point() ; p.x = 7 ; Point p1 = p ; System.Console.WriteLine(p.x); System.Console.WriteLine(p1.x); p1.x = 9 ; System.Console.WriteLine(p1.x); System.Console.WriteLine(p.x); } public struct Point { public int x ; public int y ; } 值类型的赋值\n值类型实例的赋值动作总是复制了该实例 引用类型 引用类型比值类型复杂\n分为两个部分：1.一个对象2.到该对象的引用\n引用类型的变量/常量的内容就是到一个含有值的对象的引用\n引用类型赋值 给引用类型的变量赋值：复制引用， 而不是对象实例\n允许多个变量引用同一个对象（值类型就没有这种可能）\n相当于指向内存里的同一个地址块\nPoint1 p2 = new Point1() ; p2.x = 7 ; Point1 p3 = p2 ; System.Console.WriteLine(p2.x); System.Console.WriteLine(p3.x); p3.x = 9 ; System.Console.WriteLine(p3.x); System.Console.WriteLine(p2.x); } public class Point1 { public int x ; public int y ; } NULL null是一个literal\n可以把null赋值给引用， 表示该引用不指向任何一个对象\nnull.property会抛出nullreferenceException也就是空指针异常\n普通的值类型不可以为null\nc#有一种可空类型（nullable types）来表示值类型的null\n存储开销 值类型的实例所占内存= 他的字段需要内存的总和\nclr会把类型内的字段大小设置为该字段实际大小的整数倍\n引用类型需要为引用和对象单独分配内存\n对象所占内存= 其字段所占内存总和+额外的管理开销（最少8字节）\n每个对象的引用还需要额外的4或8个字节，（根据平台是32位还是64位的）\n内置类型的分类 值类型：sybte /short / int / long / byte / ushort / uint / ulong / folat / double / decimal / bool / char 引用类型：string / object / c#7.0引入了可以使用下划线来增加可读性 使用二进制、十进制、十六进制、指数来表示数\nint a = 1_000_000 ; var b = 0b10101_10101 ; double c = 1.5 ; double million = 1E06 ; int a1 = 0xf00000 ; float e = 1.0f ; decimal d= -1.23m ; 数值literal的类型推断 默认情况下，编译器会推断一个数值literal是double还是整数类型： 如果包含小数点，或以指数形式展现，那么就是double类型 否则literal的类型就是下面列表里的第一个能容纳该数值的类型：int , uint , long , ulong , 数值的后缀 F和M比较有用，当指定float或decimal的literal的时候，应该加上 数值转换 当浮点型转为整型时，小数部分是被截断的，没有舍入。 把一个很大的整数隐式的转换为浮点类型之后，会保证量级不变，但是偶尔会丢失精度。 这是因为浮点类型有很更多的量级，而精度可能不足。 overflowChecked操作符 检查是否会超出类型极限，进而抛出异常\n对++、\u0026ndash;、+、-。*、/起作用\n可以用于表达式或语句\nchecked对float、double不起作用，因为他们有无限值\nint a = 10000000 ; int b = 10000000 ; int c = checked(a*b) ; checked{ int d = a*b ; } float min = float.NegativeInfinity ; double max = double.PositiveInfinity ; int f = unchecked(a*b) ; unchecked{ int e = a*b ; } 按位操作符 ~取反\n\u0026amp;与\n|或\n^异或\n\u0026laquo;左移\n\u0026lt; \u0026raquo;右移\ndouble适用于科学计算，例如计算坐标\ndecimal适用于财务计算，或者是人造数据\ndouble和decimal不能标识循环数据\nbool无法和数值类型进行转换\n||和\u0026amp;\u0026amp;有短路机制，为了避免空指针异常\n\u0026amp;和|没有短路机制\n当使用于数值的时候，\u0026amp;和|执行的是按位操作\n@做前缀，在双引号外边，就不支持转义字符了，且支持多行输出\nimage-20210120192441256\r字符串插值：加上${}就行了\nimage-20210120192847666\rstring的比较，不支持\u0026gt;\u0026lt;等等比较操作符，需要使用comparerto方法\n数组的长度固定不可改变，但是system.collection和其子命名空间提供了更高级的数据结构，包括可变长度的数组和字典\n创建数组时，所有的元素都会被初始化，其值为该类型的默认值\n类型的默认值就是内存按位归零的结果\n值类型和引用类型的性能有区别\n值类型：每个元素都作为数组的一部分进行分配内存\n引用类型：创建数组时就是创建了一堆null引用，因此如果为空的时候可能会抛异常\n建议对元素是引用类型的数组初始化后对元素都进行初始化 边界检查 所有数组的索引都会被运行时检查的\n如果使用了不合理的索引，会抛出indexoutofrangeexception ， 索引越界异常\n通常边界检查对性能的影响很小，jit编译器可执行一些优化，例如在进入循环前预先对所有的索引进行安全检查，避免在迭代中检查\nc#还提供了unsafe代码，可以绕过边界检查\nstack栈和heap堆 stack一块内存存储本地变量和参数 随着函数的进入和退出，stack也会随之增大和缩小 heap一块内存，对象所在的地方（引用类型的实例） 当新的对象被创建之后，他就会被分配在heap上，到该对象的一个引用被返回 程序执行时，随着新对象的不断建立，heap会慢慢被填满。运行时的gc会周期性的把对象从heap上面释放出来，所以不会导致内存耗尽 一旦一个对象不再被任何存活的东西所引用，那么它就可以被释放了 static字段 在heap上，它们会存活到应用程序域停止为止\nimage-20210120195453978\r参数传递：值传递、ref传递、out传递\n值传递：\nimage-20210120195838267\rref传递：复制的是引用而不是值\nimage-20210120200027202\rimage-20210120201653417\r按引用传递out 和ref差不多，除了\n进入函数前不需要被赋值 离开函数前必须被赋值 通常用来从方法中返回多个值\nimage-20210120203541523\r从c#7开始，调用方法适，可以使用out临时声明变量\n当调用的方法有多个out参数时，你不需要其中一些out参数，可以使用下划线_来discard弃用他们\nimage-20210120203948953\rimage-20210120204041448\rparams修饰符 可以在方法的最后一个参数使用params参数修饰符\n可以接受任意数量的该类型的参数\n参数（parameters）类型必须是数组\n也可以使用数组作为arguments\nimage-20210120205539611\r可选参数 从c#4.0开始，方法、构造函数、索引器都可以声明可选参数\n可选参数需要在声明的时候提供默认值\n调用的时候不可以填写可选的parameters\nimage-20210120212044993\r往public方法里添加可选参数，若该方法被其他的assembly调用，那么两个assemblies都需要重新编译，就和添加了一个必填参数是一样的\n可选参数的默认值是常量表达式或拥有无参构造函数的值类型\n可选参数不可以使用ref和out\n必填参数必须在可选参数前面（方法声明时和方法调用时）\n例外是：params的参数仍然放在最后边\nimage-20210120212612888\r定位参数，根据位置来判断，不要求输入的顺序和定位的顺序保持一致 image-20210120212814635\rvar 隐式强类型本地变量\n声明和初始化变量通常一步完成，如果编译器能从初始化表达式推断出类型，就可以使用var\n但是会降低代码的可读性\n右结合的操作符\n赋值、lambda、null合并和条件操作符是右结合的\n从右向左估算\nx=y=3\nnull操作符 c#提供了两种操作符，他们可以更容易的处理null\nnull合并操作符 ？？ 如果操作数不是null，就把左边的给我，如果操作数是null，就把右边的给我 null条件操作符 ？.方法 image-20210120214033193\rimage-20210120214329392\r合在一起用哦哦哦哦\nimage-20210120214520840\rimage-20210120214741402\rswitch语句 当指定常量的时候，只能使用内置的整数类型、bool、char、enum和string类型\n每个case子句的结尾，必须使用跳转语句来表名下一步往哪里执行\nbreak 跳转到switch语句的结尾 goto case x 跳转到其他的case goto default 跳转到default子句 其他的跳转语句 return , throw ,continue , goto label image-20210120215931777\rswitch with patterns c#7 object类型允许任何类型的变量 每个case子句指定一个类型，如果变量的类型与该类型一样，那么就匹配成功 可以使用when来断言一个case case子句的顺序是有关系的 可以是case null image-20210120220321250\rimage-20210120220731178\r复习一下：有用的 ref和out关键字，一个赋值的是引用的地址块，一个是作为不用传入的参数，传出多个参数使用，后者可以使用传入时定义临时变量来，并且不需要传出参数的时候可以使用下划线来discard他们 数字为了区分可读性，可以使用下划线1_000_000这样 @“\u0026hellip;\u0026hellip;.”这样可以不拆解转义字符 parameter格式定义的是数组，且是数量可变的，但必须作为方法的最后一个参数传入 可以构造可选的参数方式，在构造方法的时候预先传入参数默认值，且放在方法的最后边 如int sum (int x =1, int y = 0 ) \u0026hellip; null的合并操作符和条件操作符，防止空指针异常 switch case的新操作:判断类型和使用when进一步判断 以及 goto case , goto default \u0026hellip; 按位操作 ，||和\u0026amp;\u0026amp;的短路机制 ， ${s}插值 checked ， unchecked ， overflowcheck操作符 ， default（int） params修饰符 以及定位修饰符 跳转语句 break ； 结束迭代或switch语句的代码体\ncontinue ; 放弃当前迭代中剩余的语句执行， 直接从下一次迭代开始\ngoto ; 把执行跳转到另一个label的语句块 ， goto语句label ， 当用于switch语句内时，goto case\n3（只能用于常量） ， label相当于是一个代码块的占位符， 放在语句前边，使用冒号：做后缀\nreturn ; 退出方法，并返回一个表达式，类型和方法的返回类型一致，如果是void就return； return可以放在任何地方，除了finally里\nthrow ; 抛出异常 ， 相当于输出了错误\ntyr catch finally\n不可以从finally块里面跳转到外边，除了throw\nimage-20210121093843103\rint i = 1 ; gotoloop: if(i \u0026lt;=5) System.Console.WriteLine(i); i++ ; goto gotoloop ; using static 从c# 6开始， 不仅可以引入命名空间，还可以引入具体的类型，这就需要使用using static\n被引入类型的所有静态成员可被直接使用， 无需使用类名\n所有可访问的静态成员都会被引入，字段、属性、嵌套类型\n也可用于enum ， 这样的话它的成员就被引入了\n如果多个static引入存在歧义的话，将会发生错误\n命名空间 可以使用重复的命名空间，只要类型不相互干扰\n给命名空间起别名，防止他和其他命名空间下的其他类型相互干扰\nusing System; using static System.Console ; using P = System.Reflection ; namespace FirstCSharp { class Program { static void Main(string[] args) { WriteLine(\u0026#34;你搞笑呢\u0026#34;); } class a { private P.PropertyInfo p; } } extern alias 命名空间，解决两个程序集内部命名空间和类型完全一致的问题， 实际上就是给他们在添加一层最外层的用于区分\n命名空间别名限定符\n内层命名空间的类型名会把外层命名空间下的类型名隐藏， 有时即使使用全名也无法解决冲突\n1.使用global命名空间：也就是 ::\nnamespace FirstCSharp { class Program { public class A { public class B { } private static void Main(string[] args) { new global::A.B(); } } } } namespace A { class B { } } 可空值null类型 nullable\n例如 nullable 不仅可以表示 true； false； 还可以表示null ；\nstatic void Main(string[] args) { string str = \u0026#34;sdfhasdfkjsaf\u0026#34;; Nullable\u0026lt;int\u0026gt; indexOf = null; //或者用这种来表达 int? lalala = str.IndexOf(\u0026#39;m\u0026#39;); Nullable\u0026lt;DateTime\u0026gt; lastLogDateTime = null; DateTime? lasTime = null; Console.WriteLine(indexOf?.ToString()); Console.ReadKey(); } null 和 空， 空白 string string name = \u0026ldquo;Nick\u0026rdquo; string name = null string name =\u0026quot;\u0026quot; string name = \u0026quot; \u0026quot; 判断 if(name == null ) \u0026hellip; if(string.isNullOrEmpty(name)) \u0026hellip; if(string.isNullOrWhiteSpace(name)) \u0026hellip; nullable的常用属性和方法 hasvalue .value .getvalueordefault（） .getvalueordefault(默认值) int? num = 3; Console.WriteLine(num.HasValue); Console.WriteLine(num.Value); int? number = null; Console.WriteLine(number.HasValue); Console.WriteLine(number.GetValueOrDefault()); Console.WriteLine(number.GetValueOrDefault(1997)); nullable和T的转换 int? i = 3; int j; j = (int)i; Console.WriteLine(j); int m = 3; int? k; k = m; Console.WriteLine(k); 防止可空索引应该有的做法 string[] a = null; string b = a?[0].Trim(); 第三章 class field：是class和struct的成员，他是一个变量 readonly修饰符 readonly修饰符防止字段在构造之后被改变 readonly字段只能在声明的时候被赋值，或在构造函数里被赋值 字段初始化 字段可以可选初始化\n未初始化的字段有一个默认值\n字段的初始化在构造函数之前运行\n同时声明多个字段，用逗号隔开\n方法 执行某个动作 参数 返回类型 void ref/out作为数据的返回格式 方法的签名 类型内方法的签名必须唯一 签名：方法名、参数类型（含顺序，但与参数名称和返回类型无关） Expression-bodied方法:仅适用于单表达式的方法 void foo() =\u0026gt; Console.WriteLine(\u0026#34;hello world\u0026#34;); foo(); 方法的重载 类型里的方法可以进行重载（允许多个同名的方法同时存在），只要这些方法的签名不同就行\n参数按值传递和按引用传递，也可以进行方法重载\n本地方法 C#7 方法里有方法 void zhendeyoufooma() { void foo() =\u0026gt; Console.WriteLine(\u0026#34;hello world\u0026#34;); foo(); } zhendeyoufooma(); 本地方法适用于其他类呀方法里不需要使用的，也就是这个方法只为这个类服务的，另外可以在构造函数里写， 可以在属性的选择器里写\n不需要写static关键字 构造函数 运行class或struct的初始化代码\n和方法差不多，方法名和类型一致，返回类型也和类型一致，但不写了\nc# 7 ，允许单语句的构造函数写成 expression-bodied成员的形式\npublic class panda { public panda(string n) =\u0026gt; name = n; private string name; } 构造函数重载 在class和struct里可以重载构造函数 调用重载构造函数时使用this 当同一个类型下的构造函数A调用构造函数B的时候，B先执行 public class panda { public panda(string n) =\u0026gt; name = n; public panda(string n, int age):this(n) { this.age = age; } private string name; private int age; } 构造函数和字段的初始化顺序 字段的初始化发生在构造函数执行之前 字段按照声明的先后顺序进行初始化 构造类似单例模式:让类返回最多一个实例\nvar instance = Wine.CreateInstance(); public class Wine{ Wine() { } public static Wine CreateInstance() { return new Wine(); } } 析构函数 c# 7 deconstructor c# 7 引入了deconstructor模式\n作用基本和构造函数相反， 他会把字段反赋给一堆变量\n方法名必须是deconstructor ，有一个或者多个out参数\ndeconstructor可以被重载\ndeconstructor这个方法可以是扩展方法\nvar rectangle = new Rectangle(3,4); rectangle.Deconstruct(out var a , out var b ); var (c, d) = rectangle; rectangle.Deconstruct(out var e,out var f); Extensions.Deconstruct(rectangle,out var k , out var m ); Console.WriteLine(a); Console.WriteLine(b); Console.WriteLine(c); Console.WriteLine(d); public Rectangle(int W, int H) { width = W; height = H; } public void Deconstruct(out int outWidth, out int outHeight) { outWidth = width; outHeight = height; } public void Deconstruct(out int outWidth) { outWidth = width; } public static class Extensions { public static void Deconstruct(this Rectangle rect, out int width, out int height) { width = rect.width; height = rect.height; } } 属性 属性的声明和字段的声明很像，但多了一个get set快 只读和计算的属性 如果属性只有get访问器，那么他就是只读的 如果只有set访问器，那么他就是只写的 属性通常拥有一个专用的幕后字段 ， 这个幕后字段用来存储数据 属性初始化器 从c#6开始，你可以为自动属性添加属性初始化器 只读的自动属性也可以使用（也可以在构造函数里被赋值） public class panda { public panda(string n) =\u0026gt; name = n; public string sex { get =\u0026gt; sex; set =\u0026gt; sex=value; } //相当于 public string sex1 { get; set; } public string sex2 { get; set; } = \u0026#34;linjianshu\u0026#34;; public panda(string n, int age):this(n) { this.age = age; Console.WriteLine(2); } private string name; private int age; } 静态构造函数 静态构造函数，每个类型执行一次 非静态构造函数，每个实例执行一次 一个类型只能定义一个静态构造函数 必须无参 方法名与类型一致 初始化顺序 ​\t静态字段的初始化器在静态都早函数被调用之前的一瞬间运行\n静态类 类也可以是静态的 其成员必须全是静态的 不可以有子类 finalizer终结器 finalizer是class专有的一种方法 在gc回收未引用对象的内存之前运行 其实就是对object的finalize（）方法重写的一种语法 class a { ~class a{ } } partial type 每个分布的类都必须使用partial来声明\n每个分布类的成员不能冲突，不能有同样参数的构造函数\n各分布类完全靠编译器来进行解析：每个分布类在编译时必须可用，且在同一个assembly里\n如果有父类，可以在一个或多个分布类上指明，但必须一致\npartial method 由两部分构成：定义和实现 定义部分通常是生成的 实现部分通常是手动编写的 如果partial method 只有定义，没有实现，那么编译的时候该方法定义就没有了，调用该方法的代码也没有了。这就允许自动生成的代码可以自由的提供钩子，不用担心代码膨胀 partial method 必须是void，并且隐式private的 image-20210124193847516\rnameof 操作符 string name = nameof (count)\n继承 多态 引用是多态的，类型为x的变量可以引用子类的对象 因为子类具有父类的全部功能特性，所以参数可以是子类 反过来则不行 引用转换 一个对象的引用可以隐式的转换到其父类的引用（向上转换） 想转换到子类的引用则需要显示转换（向下转换） 引用转换： 创建了一个新的引用，他也指向同一个对象 向下转换可能会失败，如果失败了就会抛出invalidCastException异常 As操作符 as操作符会执行向下转换，如果转换失败，不会抛出异常，值会变为null\nas操作符无法做自定义转换\nis操作符 is操作符会检验引用的转换是否成功。换句话说，判断对象是否派生于某个类（或者实现了某个接口） 通常用于向下转换前的验证 如果拆箱转换可以成功的话，那么使用is操作符的结果会是true is操作符合模式变量 在c#7 里， 使用is操作符的时候，可以引入一个变量 引入的变量可以立即消费 var person = new Person(); var student = new Student(); //隐式转换 Person p = student; //显示转换 可能会发生类型转换错误 Student s = (Student)p; //如果异常s1就是null Student s1 = p as Student; if (s1 is Student) { //判断 } //判断并引入变量 if (s1 is Student s2) { s2.StuId = \u0026#34;2020170281\u0026#34;; } virtual函数成员 标记为virtual的函数可以被子类重写，包括属性、方法、索引器、事件等等 使用override修饰符，子类可以重写父类的函数 override virtual方法和重写方法的签名、返回类型、可访问程度必须是一样的 重写方法里使用base关键字可以调用父类的实现 var person = new Person(); var student = new Student(); student.jobbb = \u0026#34;student\u0026#34;; Console.WriteLine(person.job); Console.WriteLine(student.job); Person p = student; Console.WriteLine(p.job); } public class Person { public string Name { get; set; } public virtual string job =\u0026gt; \u0026#34;person\u0026#34;; } public class Student : Person { public string StuId { get; set; } public override string job =\u0026gt; jobbb; public string jobbb { get; set; } } 抽象类和抽象成员 使用abstract声明的类是抽象类 抽象类不可以被实例化，只有其具体的子类才可以被实例化 抽象类可以定义抽象成员 抽象成员和virtual成员很像，但是不提供具体的实现。子类必须提供实现，除非子类也是抽象的 public abstract class Person1 { public abstract string Name { get; } } public class Student1:Person1 { public override string Name =\u0026gt; job; public string job { get; set; } } new 和 override的区别 用new的话， 编译时对A的引用就会绑定到A的字段上 //new 和 override 的区别 var b = new B(); A a1 = b; b.lalala(); a1.lalala(); var c = new C(); A a2 = c; c.lalala(); a2.lalala(); } public class A { public virtual void lalala() { Console.WriteLine(\u0026#34;AAAAAA\u0026#34;); } } public class B : A { public override void lalala() { Console.WriteLine(\u0026#34;BBBBBB\u0026#34;); } } public class C:A { public new void lalala() { Console.WriteLine(\u0026#34;CCCCC\u0026#34;); } } sealed 针对重写的成员，可以使用sealed关键字把它密封起来， 防止它被其他子类重写 也可以sealed类本身，就隐式的sealed所有的virtual函数了 public class Student1 : Person1 { //使用sealed的话，就无法在其他子类重写了 public sealed override string Name =\u0026gt; job; public string job { get; set; } } base关键字 base和this很像，base主要用于 从子类访问父类里被重写的函数 调用父类的构造函数 这种写法可以保证，访问的一定是asset的liability属性，无论该属性是呗重写了还是被隐藏了 构造函数和继承 子类必须声明自己的构造函数\n从子类可访问父类的构造函数，但不是自动继承的\n子类必须重新定义他想要暴露的构造函数\n调用父类的构造函数需要使用base关键字\n父类的构造函数肯定会先执行\n如果子类的构造函数里没有使用base关键字，那么父类的无参构造函数就会被隐式的调用\n如果父类没有无参构造函数，那么子类就必须在构造函数里使用base关键字\nnew Tiget( \u0026#34;lalala\u0026#34;); new Tiget(\u0026#34;lalala\u0026#34;, \u0026#34;lulullu\u0026#34;); } public class Animial { public Animial(string @class) { Console.WriteLine(@class); } } public class Tiget : Animial { public Tiget(string @class) : base(@class) { Console.WriteLine(\u0026#34;tiger\u0026#34;); } public Tiget(string @class ,string b):base(@class) { Console.WriteLine(b); } } object object是引用类型 但值类型可以转化为object，反之亦然（类型统一） 在值类型和object之间转换的时候，clr必须执行一些特殊的工作，以弥补值类型和引用类型之间语义上的一些差异，这个过程就叫做装箱和拆箱 装箱 装箱就是把值类型的实例转换为引用类型的实例的动作 目标引用类型可以是object，也可以是某个接口 拆箱 拆箱正好相反，把那个对象转换成原来的值类型\n拆箱需要显示的转换\n数组和泛型只支持引用转换，不支持装箱\n装箱和拆箱的复制 装箱会把值类型的实例复制到一个新的对象 拆箱会把这个对象的内容再赋值给一个值类型的实例 静态和运行时类型检查 C#的程序既会做静态的类型检查（编译时），也会做运行时的类型检查（CLR） 静态检查：不运行程序的情况下，让编译器保证程序的正确性 运行时的类型检查，是由CLR执行，发生在向下的引用转换或拆箱的时候 运行时检查之所以可行是因为：每个在heap上的对象内部都存储了一个类型token 。 这个token可以通过调用object的gettype（）方法来获取 tostring方法 可以在自定义的类型上重写tostring方法 如果你不重写该方法，那就会返回该类型的名称 image-20210124214053490\rstruct struct和class差不多，但是有一些不同 struct是值类型，class是引用类型 struct不支持继承（除了隐式的继承了object） class能有的成员，struct也可以有， 但是一下几个不行 无参构造函数不行 字段初始化器不行 终结器不行 virtual和protected成员不可以 struct的构建 有一个无参构造函数，但是不能对其进行重写，他会对字段进行按位归零操作 当定义struct构造函数的时候，必须显式的为每个字段赋值 不可以有字段初始化器 访问修饰符 public ，完全可访问，enum和interface的成员默认都是这个级别 internal ， 当前assembly或者朋友assembly可访问， 非嵌套类的默认访问级别 private， 本类可以访问， class 和struct 的成员的默认访问级别 protected ， 本类或其子类可以访问 protected internal ， 联合了protected 和internal 的访问级别 朋友程序集assembly 通过添加system.runtime.compilerservices.internalsvisibleto这个assembly的属性 ， 并指定朋友assembly的名字，就可以把internal的成员暴露给朋友assembly [assembyy:internalsvisibleto(\u0026ldquo;friend\u0026rdquo;)]\n如果朋友assembly 有strong name ， 那么就必须指定其完整的160字节的public key [assembyy :internalsvisibleto(\u0026ldquo;strongfriend,publickey=0024f0000448c\u0026hellip;\u0026rdquo;)]\n访问修饰符的限制 当重写父类的函数时，重写后的函数和被重写的函数的访问级别必须一致 有一个例外：当在其他的assembly重写protected internal的方法时， 重写后的方法必须是protected 接口简介 接口只为成员提供规格，没有实现 接口成员都是隐式抽象的 一个class或者struct都可以实现多个接口 接口的实现 接口的成员都是隐式public的，不可以声明访问修饰符 实现接口对她的所有成员进行public的实现 接口和对象的相互转换 接口的扩展 接口可以继承其他接口 显示的接口实现 实现多个接口的时候可能会造成各成员签名的冲突。通过显式实现接口成员可以解决这个问题 枚举 枚举时一个特殊的值类型，它可以让你指定一组命名的数值常量 每个枚举都对应一个底层的整型数值，默认是int类型 也可以指定其他的类型作为枚举的整数类型，例如byte 可以单独指定枚举成员的整数值 也可以指定其中某些成员的数值，未被赋值的成员将接着他前面的已赋值成员的值递增 image-20210124221533924\r枚举可以显式的和其底层的数值相互转换 flags enum 可以对枚举的成员进行组合 为了避免歧义，枚举成员的需要显示的赋值，典型的使用2的乘幂 按约定，如果枚举成员可以组合的话，flags属性就应该引用在枚举类型上 如果声明了这样的枚举却没有使用flags属性，你仍然可以组合枚举的成员，但是调用枚举实例的tostring（）方法时，输出的将是一个数值而不是一组名称 按约定，可以组合枚举的名称应该是复数的 var b = sex.top | sex.bottom | sex.right; Console.WriteLine(b); } [Flags] public enum sex { top = 1 , right = 2 , bottom = 4 , left = 8 } 枚举支持的操作符 = == != \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= + - ^ \u0026amp; | - += -= \u0026ndash; sizeof\n其中按位的、比较的、算术的操作符返回的都是处理底层值后得到的结果 加法操作符只允许一个枚举和一个整型数值相加，两个枚举相加是不可以的 嵌套类型的特性 可访问封闭类型的私有成员，以及任何封闭类型能访问的东西 可以使用所有的访问修饰符来声明，不仅仅是public和internal 嵌套类型的默认访问级别是private而不是internal 从封闭类型外边访问嵌套类型需要使用到封闭类型的名称 复习一下 分部类、命名空间global::、external alias、virtual、override和new的区别、abstract、继承构造函数的base关键字、 goto label 、 using static 、 string.isnullorwhitespace、getvalueordefault、is修饰符、as修饰符、本地方法、deconstructor、 属性自动初始化器、构造函数支持expression body形式、nameof修饰符、分布方法提供钩子、is修饰符提供变量、sealed、子类继承父类构造函数问题、 装箱拆箱是复制、tostring自定义类型得重写不然、deconstructor支持扩展方法 第三章 泛型部分 泛型的作用 跨类型可复用的代码：继承和泛型 继承=\u0026gt;基类 泛型=\u0026gt;带有类型占位符的模板 泛型类型 generic types 泛型会声明类型参数\u0026mdash;泛型的消费者需要提供类型参数（argument）来吧占位符类型填充上 open type \u0026amp; closed type stack open type 开放类型 stack closed type 封闭类型 在运行时，所有的泛型类型实例都是封闭的（占位符类型已经被填充了） 泛型方法 泛型方法在方法的签名内也可以声明类型参数 在泛型类型里面的方法，除非也引入了类型参数，否则是不会归为泛型方法的 只有类型和方法可以引入类型参数，属性、索引器、事件、字段、构造函数、操作符等都不可以声明类型参数、但是他们可以使用他们所在的泛型类型的参数 声明类型参数 在声明class / struct / interface / delegate 的时候可以引入类型参数(type parameters) 其他的例如属性， 就不可以引入类型参数，但是可以使用类型参数 引入就是使用形式， 使用就是直接使用T的形式 泛型类型/泛型方法的名称可以被重载，条件是参数类型的个数不同 typeof 与 未绑定的泛型类型 开方的泛型类型在编译后就变成了封闭的泛型类型 但是如果作为type对象， 那么未绑定的泛型类型在运行时是可以存在的， 只能通过typeof操作符来实现 使用default关键字来获取泛型的默认值 泛型的约束 默认情况下，泛型的类型参数(parameter)可以是任何类型的 如果只允许使用特定的类型参数(argument) ， 就可以指定约束 where T:base-class where T:class where T:interface where T:struct where U:T where T:new () //保证无参构造函数 泛型的约束可以作用于类型或方法的定义 泛型类型的子类 泛型class可以有子类， 在子类里，可以继续让父类的类型参数保持开放 在子类里，也可以使用具体的类型来关闭（封闭）父类的类型参数 子类型也可以引入新的类型参数 静态数据 针对每一个封闭类型， 静态数据都是唯一的 Console.WriteLine(Bob\u0026lt;int\u0026gt;.Count++); //0 Console.WriteLine(Bob\u0026lt;int\u0026gt;.Count++); //1 Console.WriteLine(Bob\u0026lt;object\u0026gt;.Count++); //0 class Bob\u0026lt;T\u0026gt; { public static int Count; } 参数类型和转换 使用 arg as int这样的操作符 或者使用 (int)(object) x 操作符 第四章 委托、事件、lambda表达式 delegate委托 委托是一个对象，他知道如何调用一个方法 委托类型定义了委托实例可以调用的那类方法，具体来说，委托类型定义了方法的返回类型和参数 class Program { static void Main(string[] args) { //第一种推荐 Transformer transformer1 = Square; var i = transformer1(3); //第二种，自己琢磨出来的不推荐 Transformer transformer = new Transformer(Square); var invoke = transformer.Invoke(2); Console.WriteLine(invoke); } delegate int Transformer(int x); static int Square(int x) =\u0026gt; x * x; 委托实例 委托的实例其实就是调用者的委托：调用者调用委托，然后委托调用目标方法 间接的吧调用者和目标方法解耦了 编写插件式的方法 方法是在运行时才赋值给委托变量的 var transformer = new Transformer(Square); var ints = new int[]{1,2,3}; Util.Transform(ints, transformer); foreach (var i in ints) { Console.WriteLine(i); } } public delegate int Transformer(int x); class Util { public static void Transform(int[] values, Transformer t) { for (int i = 0; i \u0026lt; values.Length; i++) { values[i] = t(values[i]); } } } static int Square(int x) =\u0026gt; x * x; } 实现解绑，是在编写程序的时候，才决定我要给这个委托实例一个可供调用的方法，这个方法可以是square平方，也可以是三次方，这取决于需求方，因此解耦之后你可以编写插件式的方法，最后让需求实现者自己来决定要实例化何种方法委托\n多播委托 所有的委托实例都具有多播的能力。一个委托实例可以引用一组目标方法。 使用+和+=操作符可以合并委托实例 delegateDemo1 delegateDemo = null; delegateDemo += Square1; delegateDemo += Cube1; delegateDemo(3); delegateDemo -= Cube1; delegateDemo(3); static void Square1(int x) =\u0026gt; Console.WriteLine(x * x); static void Cube1(int x) =\u0026gt; Console.WriteLine(x *x* x); delegate void delegateDemo1(int i); 调用d就会调用你添加进去的1和2方法，委托的调用顺序与他们定义的顺序是一致的\n用-和-=会把右边的委托从左边的委托里移除\n委托变量使用+或+=操作符时，其操作数可以是null。就相当于把一个新的值赋给了委托变量。\n对于单个目标方法的委托变量使用-=操作符时，就相当于把null值赋给了委托变量\nvar transformer = new Transformer(Square); transformer += Cube; var ints = new int[]{1,2,3}; Util.Transform(ints, transformer); foreach (var i in ints) { Console.WriteLine(i); } } public delegate int Transformer(int x); class Util { public static void Transform(int[] values, Transformer t) { for (int i = 0; i \u0026lt; values.Length; i++) { values[i] = t(values[i]); } } } static int Square(int x) =\u0026gt; x * x; static int Cube(int x) =\u0026gt; x * x * x; 委托是不可变的 使用+=或-=操作符时，实际上是创建了新的委托实例，并把它赋给当前的委托变量 如果多播委托的返回值类型不是void，那么调用者从最后一个被调用的方法来接收返回值。前面的方法仍然会被调用，但是其返回值就被弃用了。 委托 所有的委托类型都派生于system.multicastdelegate，而它又派生于system.delegate c#会把作用于委托的+、-、+=、-+操作编译成使用system.delegate的combine和remove两个静态方法 public static void HardWork(A a) { for (int i = 0; i \u0026lt; 10; i++) { a(i*10+10+\u0026#34;%\u0026#34;); } } public static void WriteFile(string b) { System.IO.File.WriteAllText(\u0026#34;progress.txt\u0026#34;,b); } public static void console(string b) { Console.WriteLine(b); } } public delegate void A(string b); A a = Class1.console; a += Class1.WriteFile; Class1.HardWork(a); 实例方法目标和静态方法目标 target 当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留着对方法的引用，还要保留着对方法所属实例的引用 system.delegate的target属性就代表着这个实例 如果引用的是静态方法，那么target属性就是null 泛型委托类型 委托类型可以包含泛型类型参数 public delegate T transformer (T arg) class Program { static void Main(string[] args) { Transformer\u0026lt;int\u0026gt; transformer = Square; int[] a = {1, 2, 3}; Transform(a,transformer); foreach (var i in a) { Console.WriteLine(i); } Transformer\u0026lt;string\u0026gt; transformer1 = Cw; string[] b = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;}; Transform(b, transformer1); foreach (var s in b) { Console.WriteLine(s); } } public delegate T Transformer\u0026lt;T\u0026gt;(T t); public static void Transform\u0026lt;T\u0026gt;(T[] values, Transformer\u0026lt;T\u0026gt; t) { for (int i = 0; i \u0026lt; values.Length; i++) { values[i]=t(values[i]); } } static int Square(int a) =\u0026gt; a * a; static string Cw(string a) =\u0026gt; (a+\u0026#34;CW\u0026#34;); } Func和Action委托 使用泛型委托，就可以写出这样一组委托类型，他们可以调用的方法可以拥有任意的返回类型和任意（合理）数量的参数 System命名空间 image-20210127163836922\rimage-20210127163930536\rFunc\u0026lt;\u0026gt;可以有多个输入参数，0个也行，一个输出参数\nclass Program { static void Main(string[] args) { // Transformer\u0026lt;int\u0026gt; transformer = Square; int[] a = {1, 2, 3}; Transform(a, Square); foreach (var i in a) { Console.WriteLine(i); } // Transformer\u0026lt;string\u0026gt; transformer1 = Cw; string[] b = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;}; Transform(b, Cw); foreach (var s in b) { Console.WriteLine(s); } } // public delegate T Transformer\u0026lt;T\u0026gt;(T t); public static void Transform\u0026lt;T\u0026gt;(T[] values, Func\u0026lt;T,T\u0026gt; t) { for (int i = 0; i \u0026lt; values.Length; i++) { values[i] = t(values[i]); } } static int Square(int a) =\u0026gt; a * a; static string Cw(string a) =\u0026gt; (a + \u0026#34;CW\u0026#34;); } 个人理解：委托就是把方法作为参数来调用，传来传去呀什么的思密达\nAction\u0026lt;\u0026gt;可以有多个输入参数，0个也行，但是没有输出参数\nclass Program { static void Main(string[] args) { int[] a = new int[] {1, 2, 3}; Transform(a, Square); string[] b = { \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34; , \u0026#34;3\u0026#34;}; Transform(b,Cw); } static void Transform\u0026lt;T\u0026gt;(T[] values, Action\u0026lt;T\u0026gt; tAction) { for (int i = 0; i \u0026lt; values.Length; i++) { tAction(values[i]); } } static void Square(int a) =\u0026gt; Console.WriteLine(a*a); static void Cw(string b) =\u0026gt; Console.WriteLine(b + \u0026#34;CW\u0026#34;); } 委托Vs接口 委托可以解决的问题，接口都可以解决 什么情况下更适合用委托而不是接口呢？当下列条件之一满足时： 接口只能定义一个方法 需要多播能力 订阅者需要多次实现接口 没想到接口居然能作为一个方法的传入参数，我震惊\nclass Util { public static void TransformAll(int[] values, Interface1 a) { for (int i = 0; i \u0026lt; values.Length; i++) { values[i] = a.Transform(values[i]); Console.WriteLine(values[i]); } } } class Cube:Interface1 { public int Transform(int x) =\u0026gt; x * x * x; } public interface Interface1 { int Transform(int x); } Util.TransformAll(new []{1,2,3},new Cube()); 委托的兼容性–委托类型 委托类型之间互不相容，即使方法签名一样 委托的兼容性–委托实例 如果委托实例拥有相同的方法目标，那么委托实例就认为是相等的 委托的兼容性–参数 当你调用一个方法时，你提供的参数argument可以比防范的参数parameter定义更具体 委托可以接受比他的方法目标更具体的参数类型，这个叫contravariance 委托的兼容性–返回类型 调用方法时，你可以得到一个比请求的类型更具体的类型的返回结果 委托的目标方法可以返回比委托描述里更具体的类型的返回结果covariance Event事件 使用委托的时候，通常会出现两个角色，一个广播者，一个订阅者 广播和订阅 使用委托的时候，通常会出现两个角色，一个广播者，一个订阅者 广播者这个类型包含一个委托字段，广播者通过调用委托来决定什么时候进行广播 订阅者是这个方法目标的接收者，订阅者可以决定何时开始或结束监听 一个订阅者不知道和不干扰其他的订阅者 Event事件 事件就是将上述模式正式化的一个语言特性 事件是一种结构，为了实现广播者/订阅者模型，他只暴露了所需的委托特性的部分子集 事件的主要目的就是防止订阅者之间相互干扰 声明事件 最简单的声明事件的方式就是在委托前面加上event关键字 标准的事件模式 为编写事件，.net定义了一个标准的模式 system.eventargs， 一个预定义的框架类，除了静态的empty属性之外，他没有其他成员 eventargs是为事件传递信息的类的基类 为事件选择或定义委托 返回类型是void 接收两个参数，第一个参数类型是object，第二个参数类型是eventagrs的子类。第一个参数表示事件的广播者，第二个参数包含需要传递的信息 名称必须以eventhandler结尾 复习 delegate int D1(int x, int y); static void Main(string[] args) { D1 x = Sum; var i = x(1, 2); Console.WriteLine(i); var operation = Operation(1, 2, Sum); Console.WriteLine(operation); var operation1 = Operation(1, 2, new Func\u0026lt;int, int, int\u0026gt;((i1, i2) =\u0026gt; i1 + i2)); Console.WriteLine(operation1); } static int Sum(int x, int y) =\u0026gt; x + y; static int Multiply(int x, int y) =\u0026gt; x * y; static int Operation(int x, int y, Func\u0026lt;int, int, int\u0026gt; aFunc) { var func = aFunc(x, y); return func; } 针对选择的委托定义事件 在多线程场景下，你需要在测试或调用前，把委托赋给一个临时变量，来避免线程安全相关的错误 var temp = pricechanged ; if(temp!=null) temp (this , e) 在c# 6.0之后，可以这样写： priceChanged?.Invoke(this,e) 非泛型的eventhandler 当事件不携带多余信息的时候，可以使用非泛型的eventhandler委托 eventargs.empty属性 class Program { public class PriceChangedEventArgs : EventArgs { public readonly decimal LastPrice; public readonly decimal NewPrice; public PriceChangedEventArgs(decimal lastPrice, decimal newPrice) { this.LastPrice = lastPrice; this.NewPrice = newPrice; } } public class Stock { private string symbol; private decimal price; public Stock(string symbol) { this.symbol = symbol; } public event EventHandler\u0026lt;PriceChangedEventArgs\u0026gt; PriceChanged; protected virtual void OnPriceChanged(PriceChangedEventArgs e) { PriceChanged?.Invoke(this,e); } public decimal Price { get =\u0026gt; price; set { if (price==value) { return; } decimal oldPrice = price; price = value; OnPriceChanged(new PriceChangedEventArgs(oldPrice , price)); } } } static void Main(string[] args) { var stock = new Stock(\u0026#34;microsoft\u0026#34;); stock.Price = 120; stock.PriceChanged += stock_PriceChanged; stock.Price = 135; } static void stock_PriceChanged(object sender, PriceChangedEventArgs e) { if ((e.NewPrice-e.LastPrice)/e.LastPrice\u0026gt;0.1M) { Console.WriteLine(\u0026#34;Alert , 10% stock price increase ! \u0026#34;); } } } lambda表达式 lambda表达式其实就是一个用来代替委托实例的未命名的方法 编译器会把lambda表达式转化为以下二者之一： 一个委托实例 一个表达式树（expression tree） ， 类型是expression，他表示了可遍历的对象模型中lambda表达式里面的代码。他允许lambda表达式延迟到运行时再被解释 class Program { static void Main(string[] args) { D1 d1 = x=\u0026gt;x*x; var i = d1(3); Console.WriteLine(i); var operation = Operation(3, Multiply); Console.WriteLine(operation); Console.ReadKey(); } static int Operation(int x, Func\u0026lt;int, int\u0026gt; func) =\u0026gt; func(x); delegate int D1(int a); static int Multiply(int x) =\u0026gt; x * x; } lambda表达式的形式 (parameters)=\u0026gt;expression -or- statement -block （参数）=\u0026gt;表达式或语句块 其中如果只有一个参数并且类型可以推断的话，那么参数的小括号可以省略 lambda表达式与委托 每个lambda表达式的参数对应委托的参数 表达式的类型对应委托的返回类型 class Program { static void Main(string[] args) { D1 d1 = x=\u0026gt;x*x; var i = d1(3); Console.WriteLine(i); var operation = Operation(3, Multiply); Console.WriteLine(operation); Func\u0026lt;int, int\u0026gt; func = (a) =\u0026gt; a * a; func(1); Func\u0026lt;string, string, int\u0026gt; function = (str1, str2) =\u0026gt; { return str1.Length + str2.Length; }; Func\u0026lt;string, string, int\u0026gt; function1 = (str1, str2) =\u0026gt; str1.Length + str2.Length; Console.WriteLine( function(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)); Console.WriteLine( function1(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)); } static int Operation(int x, Func\u0026lt;int, int\u0026gt; func) =\u0026gt; func(x); delegate int D1(int a); static int Multiply(int x) =\u0026gt; x * x; } 如果不用{}那么就不需要return关键字 ，如果用了{}那么就要使用return关键字，且内部还要加封号；\n显式指定lambda表达式的参数类型 捕获外部变量 lambda表达式可以引用本地的变量和所在方法的参数 被lambda表达式引用的外部变量叫做被捕获的变量（captured variables） 捕获了外部变量的lambda表达式叫做闭包 被捕获的变量是在委托被实际调用的时候才被计算，而不是在捕获的时候 int factor = 2; Func\u0026lt;int, int\u0026gt; func = x =\u0026gt; x * factor; factor = 10; var i = func(3); Console.WriteLine(i); 被捕获的变量的生命周期会被延长到和委托一样 lambda表达式内的本地变量 在lambda表达式内实例化的本地变量对于委托实例的每次调用来说都是唯一的 lambda表达式vs本地方法 本地方式是c#7的新特性 。 他和lambda表达式在功能上有很多重复之处，但他又三个优点： 简单明了进行递归 无需指定委托类型 性能开销略低一点 本地方法效率更高是因为它避免了委托的间接调用。本地方法也可以访问所在方法的本地变量，而且无需编译器把被捕获的变量hoist到隐藏的类 匿名方法vslambda表达式 匿名方法和lambda表达式很像，但是缺少以下三个特性 隐式类型参数 表达式语法（只能是语句块） 编译表达式树的能力，通过赋值给expression 第五章 进阶特性 try-catch-finnally catch可以设置捕获不同类型的异常，如果没有异常类型匹配的，可能就程序报错了 如果你希望有一个兜底的catch可以捕获任何类型的异常，那么你需要把待定类型的异常捕获放在靠前的位置 从c#6 开始，你可以在catch子句中添加一个when子句来指定一个异常过滤器 try { } catch (Exception e)when(e.StackTrace==\u0026#34;\u0026#34;) { Console.WriteLine(e); throw; } finally块 finally块永远都会被执行，无论是否跑出异常 唯一可以让他不执行就是无限执行，或者中断 using语句 很多类都封装了非托管资源，都实现了disposable接口，这个接口定义了一个无参的dispose方法来清理这些资源 using语句提供了一个优雅的语法来在finally块里调用实现了idisposable接口对象上的dispose方法 抛出异常 c# 7 中，throw new Exception 可以作为expression-bodied functions里的一个表达式出现 也可以出现在三元条件表达式里 重新抛出异常 如果使用rhrow ex代替throw的话，程序仍然可以运行 其他常见的情景是抛出一个更为具体的异常类型 如果把原异常的ex传入第二个异常类型作为参数，利于调试，但可能出现信息泄露 System.exception 的关键属性 stacktrace 他是一个字符串，展现了从异常发生地到catch块所有的被调用的方法 message 关于错误的描述信息 innerexception 引起外层异常的内层异常（如果存在的话）而且innerException本身还有可能含有innerexception 常见的异常类型 system.argumentexception system.argumentnullexception system.argumentoutofrangeexception system.invalidoperationexception system.notsuppostedexception system.notimplementedexception system.oubjecdisposedexception nullreferenceexception 你也可以直接throw null ，来抛出此类型异常 try xxx模式 如果解析失败 ， parse方法会抛出异常，而tryparse方法会返回false 枚举器 枚举器是一个只读的，作用于一序列值的、只能向前的游标 枚举器是一个实现了下列任意一个接口的对象： system.collections.ienumrator system.collections.generic.IEnumerator 技术上来说，任何一个含有名为movenext方法和名为current的属性的对象，都会被当做枚举器来对待 foreach语句会迭代可枚举的对象enumerable object 。可枚举的对象是一序列值的逻辑标识。它本身不是游标，它是一个可以基于本身产生的游标的对象。 可枚举对象 enumerable object 一个可枚举对象可以是（下列任意一个） 实现了ienumerable或者ienumerable的对象 有一个名为getenumerator的方法，并且该方法返回一个枚举器emunerator IEumrator和IEnumerable是定义在system.collections命名空间下的 IEnumerator和IEnumerable是定义在system.collections.generic命名空间下的 集合初始化器 要求可枚举对象实现了system.collections.ienumerable接口，并且他还有一个可接受适当参数的add方法 迭代器iterators foreach是枚举器（enumerator）的消费者，而迭代器（iterators）是枚举器的生产者 foreach (var VARIABLE in Foo()) { Console.WriteLine(VARIABLE); } static IEnumerable\u0026lt;string\u0026gt; Foo() { yield return \u0026#34;one\u0026#34;; yield return \u0026#34;two\u0026#34;; yield return \u0026#34;Three\u0026#34;; } yield break yield break 语句表示迭代器块会提前退出，不在返回更多的元素 return语句在迭代器块里面是非法的，你必须使用yield break代替 var enumerable = Foo(false); foreach (var VARIABLE in enumerable) { Console.WriteLine(VARIABLE); } static IEnumerable\u0026lt;string\u0026gt; Foo(bool breakEarly) { yield return \u0026#34;one\u0026#34;; yield return \u0026#34;two\u0026#34;; if (breakEarly) { yield break; } yield return \u0026#34;Three\u0026#34;; } 迭代器和try/catch/finally块 yield return 语句不可以出现在含有catch子句的try里面 yield return 也不能出现在catch或者finally块里面 但是yield return 可以出现在只含有finally块的try块里面 当消费者的枚举器到达序列终点或被disposed的时候，finally块里面的代码会被执行 如果你提前进行了break，那么foreach语句也会dispose掉枚举器，所以用起来很安全 var enumerator = Foo(false).GetEnumerator(); if (enumerator.MoveNext()) { var enumeratorCurrent = enumerator.Current; } while (enumerator.MoveNext()) { Console.WriteLine(enumerator.Current); } static IEnumerable\u0026lt;string\u0026gt; Foo(bool breakEarly) { yield return \u0026#34;one\u0026#34;; yield return \u0026#34;two\u0026#34;; if (breakEarly) { yield break; } yield return \u0026#34;Three\u0026#34;; } 通过movenext的true或false确定是否可以枚举到下一个，如果可以，通过拿到current，进而拿到里面的值，如果用foreach就可以忽略什么current，movenext操作，因为他是一种高阶的写法\n可空值类型 nullable 可空结构体 struct hasvalue getvalueordefault() 和 getvalueordefault(T defaultvalue) object里面定义的equal（object）和gethashcode（）这两个方法也被响应的重写了，首先会比较hasvalue属性的值，如果两个被比较对象的hasvalue属性都是true ， 那么然后就会比较value属性的相等性 可空类型的装箱和拆箱boxing and unboxing nullable values 当T？被装箱后，在堆内存上被装箱的值会包含T，而不是T？ 因为被装箱之后的值本身就是一个引用类型，而引用 类型是可以表示null值的 c#也允许对可空类型进行拆箱操作，这里就需要使用as运算符。如果拆箱转换失败，那么得到的结果就是null，不会抛出异常 null对于可空值类型的定义 null有两种含义 null引用 可空值类型hasvalue为false时的值 下面这两种写法是等价的 运算符提升 就是可以比较两个可空值类型的\u0026gt;\u0026lt;== 前提都是hasvalue为true时才开始判断，否则返回的结果要不是null就是false ？？ 在可空值类型上使用？？运算符，就相当于调用了getvalueordefault方法，并且为这个方法提供了显式的默认值作为参数。当然，有一点不同是：如果变量不是null，那么默认值那部分的表达式就不会被执行\nint? b = null; int a = b ?? 4; Console.WriteLine(a); 可空类型和as运算符 as转化不了的话返回null\n扩展方法 扩展方法允许我们使用新的方法来扩展现有的类型，而且无需修改原有的类型的定义 扩展方法是静态类的一个静态方法，在静态方法里的第一个参数使用this修饰符，第一个参数的类型就是要被扩展的类型 static class StringHelper { public static bool IsCapitalized(this string s) { if (string.IsNullOrEmpty(s)) { return false; } return char.IsUpper(s[0]); } } string stra = \u0026#34;Ok\u0026#34;; var isCapitalized = stra.IsCapitalized(); Console.WriteLine(isCapitalized); 接口也可以被扩展 扩展方法链 扩展方法和实例方法一样，也提供了一种整洁的方式来进行链式调用 前提是他们返回值类型和另一个的传入参数的类型是一致的 歧义和解析 命名空间 只有所在类处于作用范围内的扩展方法才可以被访问， 典型的做法是引入命名空间 如果这里不引入，编译时就会报错 歧义和解析 扩展方法vs实例方法 兼容的实例方法的优先级总是高于扩展方法的 这种情况下，唯一能调用扩展方法的心事就是使用静态调用的语法，也就是类名.方法 歧义和解析 扩展方法vs扩展方法 如果两个扩展方法拥有相同的签名，那么扩展方法必须像常规静态方法那样调用以避免歧义，而如果其中一个扩展方法的参数类型更具体，那么这个方法的优先级就会更高 注意：类和结构体被认为比接口更加具体 什么是匿名类型 匿名类型就是由编译器及时创建的一个class ， 它用来存储一组数据 创建匿名类型：new + object 初始化器，并指定属性及其值 static void Main(string[] args) { string name = \u0026#34;ljs\u0026#34;; int age = 23; string school = \u0026#34;hfut\u0026#34;; var foo = new {name , age , school}; Console.WriteLine(foo.name); } 使用var关键字来引用匿名类，因为匿名类型没有名字 匿名类型的名称可以通过本身就是标识符/以标识符结尾的表达式推断出来 在同一个assembly下声明的两个匿名类实例，如果他们的元素名和类型都完全一致，那么他们的基础类型underlying type 就是一样的 equals方法被重写来进行相等性比较 比较值是否相等 可以创建匿名类型数组 方法不可以返回匿名类型的对象，必须使用dynamic或者object ，调用时依赖动态绑定，并且会损失静态类型的安全性 dynamic foo1 = new[] { new {Name = \u0026#34;ljs\u0026#34; , Age = 23 } , new {Name = \u0026#34;jwt\u0026#34; , Age = 23} , }; 匿名类型主要用来写linq查询 var foo1 = new[] { new {Name = \u0026#34;ljs\u0026#34; , Age = 23 } , new {Name = \u0026#34;jwt\u0026#34; , Age = 23} , }; foreach (var VARIABLE in foo1) { Console.WriteLine(VARIABLE.Name); } Tuple的意义 tuple提供了简单的方式来存储一组数据 使用tuple的主要目的是从方法安全的返回多个值，而且无序使用out参数 c# 7 的tuple主要依赖于一组支撑他的struct 创建tuple 创建tuple字面值最简单的方式就是在小括号里列出所有的值 通过xx.item1和xx.item2来引用tuple里面的未命名元素 static void Main(string[] args) { var tuple = (\u0026#34;ljs\u0026#34;, 20); Console.WriteLine(tuple.Item1); var tuple1 = tuple; tuple1.Item1 = \u0026#34;sbjwt\u0026#34;; Console.WriteLine(tuple); Console.WriteLine(tuple1); } tuple是值类型， 其元素是可变的可读写 你可以明确的指定tuple的类型 只需要在小括号里面列出每个元素的类型即可 可以从方法里返回tuple类型 static void Main(string[] args) { var tuple = (\u0026#34;ljs\u0026#34;, 20); Console.WriteLine(tuple.Item1); var tuple1 = tuple; tuple1.Item1 = \u0026#34;sbjwt\u0026#34;; Console.WriteLine(tuple); Console.WriteLine(tuple1); (int, string) tuple2 = (23, \u0026#34;hfut\u0026#34;); CWtupleByDelegate(23,\u0026#34;hfut\u0026#34;,sum); void CWtupleByDelegate(int a , string b , Action\u0026lt;int ,string \u0026gt; func) =\u0026gt; func(a, b); CWtupleByDelegate1(new Tuple\u0026lt;int, string\u0026gt;(23,\u0026#34;htuf\u0026#34;), sumTuple); void CWtupleByDelegate1(Tuple\u0026lt;int,string\u0026gt; aTuple , Action\u0026lt;Tuple\u0026lt;int,string\u0026gt;\u0026gt; func) =\u0026gt; func(aTuple); } static void sum(int a, string b) =\u0026gt; Console.WriteLine(a + b); static void sumTuple(Tuple\u0026lt;int, string\u0026gt; tuple) =\u0026gt; Console.WriteLine(tuple.Item1+tuple.Item2); } tuple可以和泛型很好的共存\nTask\u0026lt;(string, int)\u0026gt; a; Dictionary\u0026lt;(string, int),bool\u0026gt; b; IEnumerable\u0026lt;(int id, string name)\u0026gt; c; 给tuple元素命名 在创建tuple字面值的时候，你可以给元素起一个有意义的名字 var t1 = (name: \u0026#34;ljs\u0026#34;, age: 23); Console.WriteLine(t1.name); Console.WriteLine(t1.age); (string Name, int Age) t2 = (\u0026#34;jwt\u0026#34;, 12); Console.WriteLine(t2.Name); Console.WriteLine(t2.Age); 在指定tuple类型的时候，也可以给元素起名 仍然可以通过item1，item来引用元素 如果两个tuple元素类型、顺序都一直，那么两个tuple的类型就是兼容的 valuetuple.create 可以使用valueTuple(非泛型)类型上的工厂方法来创建tuple 命名元素不可以通过这种方式创建，因为元素命名依赖于编译器的一些骚操作 var valueTuple = ValueTuple.Create(\u0026#34;Bob\u0026#34;,23); (string,int) bobTuple = ValueTuple.Create(\u0026#34;Bob\u0026#34;,23); Deconstructing Tuples tuple隐式的支持deconstructing模式，你可以很简单的将tuple deconstruct为多个变量 var valueTuple = ValueTuple.Create(\u0026#34;Bob\u0026#34;,23); (string, int) bobTuple = ValueTuple.Create(\u0026#34;Bob\u0026#34;, 23); (string name, int age) = valueTuple; (string name1, int age1) = (\u0026#34;Bob\u0026#34;, 23); Console.WriteLine(name); Console.WriteLine(age); Console.WriteLine(name1); Console.WriteLine(age1); 相等性比较 valuetuple\u0026lt;\u0026gt;也重写了equals方法，让比较更有意义 通过例子可以看出，tuple可以作为dictionary的key tuple也实现了icomparable接口，所以tuple也可以作为排序的key Attribute attribute是一种扩展机制，他可以为代码元素添加自定义的信息 assembly ，类型、成员、返回值、参数、泛型参数 一个很好的应用场景就是序列化 把任意一个对象转化为特定格式/从特定格式转化过来 Attribute Class 一个attribute是通过一个继承了system.attribute的类来定义的 好像就是注解 ，应用于代码元素 按约定，所有的attribute都应该以attribute都应该以attribute这个单词结尾，但是c#会识别这个后缀，并且允许你附加attribute的时候忽略这个后缀 命名和位置attribute参数 attrubute可以有参数 attribute的参数可以分为两类：位置的和命名的 位置参数对应attribute类型的公共构造函数的参数 命名参数对应attribute类型的公共字段或公共属性 当指定attribute的时候，必须包含与attribute相应构造函数所对应的位置参数，而命名参数是可选的 Attribute的目标 没有明确指定的情况下，attribute的目标就是紧随他的代码元素，通常是一个类型或类型的成员 也可以把attribute附加到一个assembly，这就需要显式指定attribute的目标 指定多个attribute 对一个代码元素可以指定多个attribute。每个attribute可以列在同一个中括号内（使用逗号分开） ， 也可以独占一个中括号 Caller Info Attribute 从c# 5.0开始，你可以使用下列三个caller info attributes 之一对可选参数进行标记 [callermembername] 标识调用者成员的名称 [callerfilepath] 表示调用者源代码的路径 [callerLineNumber] 表示调用者在源码文件里面的行号 class Program { static void Main(string[] args) =\u0026gt; Foo(); static void Foo( [CallerMemberName] string memberName = null , [CallerFilePath] string filePath = null , [CallerLineNumber] int lineNumber = 0 ) { Console.WriteLine(memberName); Console.WriteLine(filePath); Console.WriteLine(lineNumber); } } 动态绑定 dynamic binding 静态绑定vs动态绑定 静态绑定：通常来讲，引用在编译时就可以解析出来 动态绑定：把解析类型、成员、操作的过程从编译时延迟到运行时 通常用于：你知道某个函数、成员、操作存在，但是编译器不知道 dynamic类型 dynamic类型使用上下文关键字dynamic来声明 因为d是dynamic的，编译器就会把quack方法绑定到d的这个动作延迟到运行时 静态绑定 编译器在duck上寻找一个名叫quack的无参方法 否则就扩大搜索范围，含有可选参数的quack方法 父类上的方法 扩展方法 dynamic dynamic类型和object类型很像，但是它允许你使用在编译时还不知道的方式来操作 dynamic类型在运行时基于运行时的类型进行绑定，而不是编译时的类型 在运行时： 如果dynamic对象实现了idynamicmetaobjectprovider,那么该接口就用来执行绑定。这叫做自定义绑定 否则，绑定发生的方式和编译器已经知道dynamic对象运行时类型一样，这叫做语言绑定 动态绑定 动态绑定确实规避了静态的类型检查，但是没有规避运行时的类型检查 与反射不一样，使用动态绑定，你无法规避成员的访问规则 动态绑定也会引起心更能问题 但是重复调用同样的动态表达式是有优化的 RunTimeBinderException 如果成员无法进行绑定，那么就会抛出runtimebinderException 动态转换 dynamic类型可以隐式的从其他类型转换过来，也可以隐式的转换到其他类型 var vs dynamic var：让编译器编译时推断出类型 dynamic：让运行时推断出类型 动态表达式 字段、属性、方法、事件、构造函数、索引器、运算符和转换都可以动态的调用 使用void返回类型来消费动态表达式的结果是不可以的，这点和静态的表达式一样 区别是，这个错误会发生在运行时 涉及动态运算对象的表达式就是动态表达式，缺失类型信息是有级联效果的 无法动态调用的函数 有一些函数不可以被动态调用 扩展方法 接口的成员 被子类隐藏的基类成员 因为动态绑定需要两方面的信息 被调用函数的名字 调用函数的对象 这三种情况，都需要额外的类型，并且他只是在编译时知晓了，运行时就丢失了 运算符重载 运算符可以被重载，可以为自定义类型提供更自然的语法 使用implict explicit 关键字 隐式/显式转换 运算符函数 通过声明运算符函数，就可以对运算符进行重载 运算符函数有一下规则 函数名：使用operator关键字，后边跟着运算符的符号 必须是static和public 函数的参数代表着运算符的运算数 函数的结果代表表达式的结果 至少有一个运算数的类型必须是函数所声明的类型 class Program { static void Main(string[] args) { var B = new Note(2); var CShrap = B + 2; Console.WriteLine(CShrap.value); } public struct Note { public int value; public Note(int semitonesFormA) { value = semitonesFormA; } public static Note operator +(Note x, int semitones)=\u0026gt;new Note(x.value+semitones); } } 重载相等性和比较运算符 重载相等性和比较运算符的时候有一些规则 成对重载 equals和gethashcode 大多数情况下，如果你重载了！=和== ， 你通常需要重载equals和gethashcode这两个方法，这样才能得到比较有意义的行为 如果你不这样做，会给一个警告 icomparable和icomparable 如果你重载了\u0026lt;\u0026gt;和\u0026lt;= \u0026gt;=运算符，那么你就应该事先icomparable和icomparable这两个接口 自定义隐式和显式转换 隐式和显示转换是可重载的运算符 自定义转换会被as和is运算符忽略 class Program { static void Main(string[] args) { var B = new Note(2); var CShrap = B + 2; Console.WriteLine(CShrap.value); var cShrap = (double)CShrap; Console.WriteLine(cShrap); int a = 4; var note = (Note)a; Console.WriteLine(note.value); } public struct Note { public int value; public Note(int semitonesFormA) { value = semitonesFormA; } public static Note operator +(Note x, int semitones) =\u0026gt; new Note(x.value + semitones); public static implicit operator double(Note x) =\u0026gt; x.value; public static explicit operator Note (double x)=\u0026gt;new Note((int)x); } } 重载true和false 不安全代码\nfixed语句\n第六章 异步编程 什么是线程 thread 线程是一个可执行路径，他可以独立于其他线程执行 每个线程都在操作系统的进程process内执行，而操作系统进程提供了程序运行的独立环境 单线程应用，在进程的独立环境里只跑一个线程，所以该线程拥有独占权 多线程应用， 单个进程中会跑多个线程，它们会共享当前的执行环境（尤其是内存） 例如，一个线程在后台读取数据，另一个线程在数据到达后进行展示 这个数据就被称作共享的状态 例子\n在单核计算机中 ， 操作系统必须为每个线程分配“时间片”（在windows中通常为20ms）来模拟并发，从而导致重复的x块和y块 在多核或多处理器计算机上，这两个线程可以真正地并行执行（可能受到计算机上其他活动进程的竞争） 在本例中，由于控制台处理并发请求的机制的微妙性，仍然会得到重复的x块和y块 static void Main(string[] args) { Thread t = new Thread(WriteY); //开辟了一个新的线程 thread t.Name = \u0026#34;Y Thread ...\u0026#34;; t.Start(); //运行 writeY //同时主线程也做一些工作 for (int i = 0; i \u0026lt; 1000; i++) { Console.Write(\u0026#34;x\u0026#34;); } } static void WriteY() { for (int i = 0; i \u0026lt; 1000; i++) { Console.Write(\u0026#34;y\u0026#34;); } } } 术语：线程被抢占了 线程在这个时候就可以称之为被抢占了： 他的执行与另一个线程上代码的执行交织的那一点 线程的一些属性 一旦开始执行，isalive就是true，线程结束就是false 线程结束的条件就是：线程构造函数传入的委托结束了执行 线程一旦结束，就无法再重启了 每个线程都有个name属性，通常用于调试 线程name只能设置一次，以后更改就会抛出异常 静态的thread.currentthread属性，会返回当前执行的线程 join and sleep 调用join方法，就可以等待另一个线程结束 例子 private static Thread thread1, thread2; static void Main(string[] args) { thread1 = new Thread(ThreadProc); thread1.Name = \u0026#34;Thread1\u0026#34;; thread1.Start(); thread2 = new Thread(ThreadProc); thread2.Name = \u0026#34;Thread2\u0026#34;; thread2.Start(); } private static void ThreadProc() { Console.WriteLine(\u0026#34;\\n Current thread :{0}\u0026#34; , Thread.CurrentThread.Name); if (Thread.CurrentThread.Name==\u0026#34;Thread1\u0026#34;\u0026amp;\u0026amp;thread2.ThreadState!=ThreadState.Unstarted) { thread2.Join(); } Thread.Sleep(4000); Console.WriteLine(\u0026#34;\\n current Thread :{0}\u0026#34;, Thread.CurrentThread.Name); Console.WriteLine(\u0026#34;Thread1: {0}\u0026#34;,thread1.ThreadState); Console.WriteLine(\u0026#34;Thread2: {0}\\n\u0026#34;,thread2.ThreadState); } 添加超时 调用join的时候，可以设置一个超时，用毫秒或者timespan都可以 如果返回true就是ok了，如果false就是超时了 static TimeSpan waitTime = new TimeSpan(0,0,1); static void Main(string[] args) { var newThread = new Thread(Work); newThread.Start(); if (newThread.Join(waitTime/2)) { Console.WriteLine(\u0026#34;New Thread terminated\u0026#34;); } else { Console.WriteLine(\u0026#34;Join timed out\u0026#34;); } } static void Work() { Thread.Sleep(waitTime); } thread.sleep()方法会暂停当前的线程，并等待一段时间 注意 thread.sleep(0)这样调用会导致线程立即放弃本身当前的时间片，自动将cup移交给其他线程 thread.yield()做同样的事情，但是它只会把执行交给同一个处理器上的其他线程 当等待sleep或join的时候，线程处于阻塞状态 阻塞 如果线程的执行由于某种原因导致暂停，那么就认为该线程被阻塞了。 例如在sleep或者通过join等待其他线程结束 被阻塞的线程会立即将其处理器的时间片生成给其他线程 ，从此就不在消耗处理器时间，直到满足其阻塞线程条件为止 可以通过threadstate这个属性来判断线程是否处于被阻塞的状态 threadstate 但是它大部分的枚举值都没什么用，下面的代码将threadstate剥离成四个最有用的值之一：unstarted / running / waitsleepingjoin / stopped 解除阻塞 unblocking 当遇到下列四种情况的时候，就会解除阻塞 阻塞条件被满足 操作超时（如果设置超时的话） 通过thread.Interrupt()进行打断 通过thread.abort()进行中止 上下文切换 当线程阻塞或解除阻塞的时，操作系统将执行上下文切换。这会产生少量开销，通常为1-2微妙 i/o-bound 和 compute-bound 一个花费大部分时间等待某事发生的操作成为i/o bound i/o绑定操作通常涉及输入或输出， 但这不是硬性要求：thread.sleep()也被视为 i /o -bound 相反，一个花费大部分时间执行cpu密集型工作的操作称为compute-bound 阻塞 vs 忙等待（自旋） blocking vs spinning i/o - bound 操作的工作方式有两种 在当前线程上同步的等待 console.readline() , thread.sleep() , thread.join() 异步的操作， 在稍后操作完成时触发一个回调动作 同步等待的i/o-bound 操作将大部分时间花在阻塞线程上 本地和共享的状态 local本地独立 clr为每个线程分配自己的内存栈，以便使本地变量保持独立 new Thread(Go1).Start(); Go1(); } private static void Go1() { for (int cycle = 0; cycle \u0026lt; 5; cycle++) { Console.WriteLine(\u0026#34;?\u0026#34;); } } shared 共享\n如果多个线程都引用同一个对象的实例，那么他们就共享了数据 var threadTest = new ThreadTest(); var thread = new Thread(threadTest.Go); thread.Name = \u0026#34;new thread\u0026#34;; thread.Start(); Console.WriteLine(Thread.CurrentThread.Name); threadTest.Go(); Console.WriteLine(Thread.CurrentThread.Name); public class ThreadTest { public bool _done=false; public void Go() { if (!_done) { _done = true; Console.WriteLine(\u0026#34;Done\u0026#34;); } } } 被lambda表达式或匿名委托所捕获的本地变量， 会被编译器转化成字段field， 所以也会被共享. bool done = false; //这里是声明了方法 ThreadStart action = () =\u0026gt; { if (!done) { done = true; Console.WriteLine(\u0026#34;Done\u0026#34;); } }; new Thread(action).Start(); action(); 静态字段也会在线程间共享数据field 上述情况就可能导致线程的不安全：即可能相同的操作被执行了多次\n线程安全 thread safety 尽可能避免使用共享状态 锁定与线程安全 简介 locking \u0026amp; thread safety 在读取和写入共享数据的时候，通过使用一个互斥锁exclusive lock，就可以修复前面的问题 c# 使用lock语句来加锁 当两个线程同时竞争一个锁的时候（锁可以基于任何引用类型对象），一个线程会等待或阻塞，直到锁变成可用状态 lock不是线程安全的银弹， 很容易忘记对字段加锁，lock也会引起一些问题（死锁） class ThreadSafe { private static bool _done; static readonly object _locker = new object(); static void Main() { new Thread(Go).Start(); Go(); } static void Go() { lock (_locker) { if (!_done) { Console.WriteLine(\u0026#34;done\u0026#34;); _done = true; } } } } 向线程传递数据 如果你想往线程的启动方法里传递数据，最简单的方式是使用lambda表达式，在里面使用参数调用方法 static void Main(string[] args) { new Thread(() =\u0026gt; Print(\u0026#34;hello asyncprogramming\u0026#34;)).Start(); Print(\u0026#34;hello ljs\u0026#34;); } static void Print(string message) { Console.WriteLine(message); } 甚至可以把整个逻辑都放在lambda里 static void Main(string[] args) { // new Thread(() =\u0026gt; Print(\u0026#34;hello asyncprogramming\u0026#34;)).Start(); // // Print(\u0026#34;hello ljs\u0026#34;); new Thread(() =\u0026gt; { Console.WriteLine(\u0026#34;i am a good man\u0026#34;); var o = new object(); o = \u0026#34;i am a good man\u0026#34;; switch (o) { case string s: Console.WriteLine(\u0026#34;yoo this is a string\u0026#34;); break; case int i: Console.WriteLine(\u0026#34;yoo ! this is an int\u0026#34;); break; default: Console.WriteLine(\u0026#34;yoo i don\u0026#39;t know \u0026#34;); break; } }).Start(); Console.WriteLine(\u0026#34;this is main thread\u0026#34;); } 异常处理 创建线程时在作用范围内的try/catch/finally块，在线程开始执行后就与线程无关了 解决方案，在方法内部设置异常捕获策略 new Thread(()=\u0026gt;Go()).Start(); static void Go() { try { throw null; } catch (Exception e) { Console.WriteLine(e); throw; } } 在wpf、winform里，可以订阅全局异常处理事件 application.dispatcherunhandledException application.threadexception 在通过消息循环调用的程序的任何部分发生未处理的异常（这相当于应用程序处于活动状态时在主线程上运行的所有代码）后，将触发这些异常 但是非ui线程上的未处理异常，并不会触发它 任何线程有任何未处理的异常都会触发 appdomain.currentdomain.unhandledexception 前台线程和后台线程 foreground vs vackground threads 默认情况下，你手动创建的线程就是前台线程 只要有前台线程在运行，那么应用程序就会一直处于活动状态 但是后台线程却不行 一旦所有的前台线程停止，那么应用程序就停止了 任何的后台线程也会突然停止 注意：线程的前台、后台状态与他的优先级无关（所分配的执行时间） var thread = new Thread(() =\u0026gt; { Console.ReadLine(); }); if (args.Length\u0026gt;0) { thread.IsBackground = true; } thread.Start(); 进程以这种形式终止的时候，后台线程执行栈中的finally块就不会被执行了 如果想让她执行，可以在退出程序时使用join来等待后台线程，如果是你自己创建的线程的话，或者使用signal construct ， 如果是线程池的话 应用程序无法正常退出的一个常见原因是还有活跃的前台线程 线程优先级 线程的优先级Thread的priority属性，他决定了相对于操作系统中其他活跃线程所占的执行时间 优先级分为 enum threadpriority {lowest , belownormal , normal , abovenormal , highest} 提升线程优先级 提升线程优先级的时候需要特别注意，因为它可能“饿死”其他线程\n如果想让某线程thread的优先级比其他进程process中的线程thread高的话，那就必须提升进程process的优先级\n使用system.diagnostics下的process类\nusing(process p = process.getcurrentprocess()) p.priorityclass = processpriorityclass.high ; 这可以很好的用于只做少量工作且需要较低延迟的非ui线程\n对于需要大量计算的应用程序，尤其是有ui的应用程序，提高进程优先级可能会使其他进程饿死，从而降低整个计算机的速度\n信号 sinaling 有时候，你需要让某线程一直处于等待状态，直至接收到其他线程发来的通知。这就叫做signaling发送信号 最简单的信号结构就是manualresetevent 调用它上面的waitone方法会阻塞当前的线程，直到另一个线程通过调用set方法开启信号 我们可以调用reset方法将其再次关闭 var signal = new ManualResetEvent(false); new Thread(() =\u0026gt; { Console.WriteLine(\u0026#34;waiting for signal ...\u0026#34;); signal.WaitOne(); Console.WriteLine(\u0026#34;got sinal \u0026#34;); Thread.Sleep(1000); Console.WriteLine(\u0026#34;wo zai xie le\u0026#34;); signal.Dispose(); }).Start(); Thread.Sleep(3000); Console.WriteLine(\u0026#34;准备打开信号了哦\u0026#34;); Thread.Sleep(1000); signal.Set();//打开了信号 Thread.Sleep(500); signal.Reset(); Console.WriteLine(\u0026#34;我有准备打开了\u0026#34;); Thread.Sleep(1000); 富客户端应用程序的线程 在wpf、uwp、winform等类型的程序中，如果在主线程执行耗时的操作，就会导致整个程序无响应。因为主线程同时还要处理消息循环，而渲染和鼠标键盘事件处理等工作都是消息循环来执行的 针对这种耗时的操作，一种流行的做法是启用一个worker线程 执行完操作后，再更新到UI 富客户端应用的线程模型通常是： ui元素和控件只能从创建它们的线程来进行访问（通常是主ui线程） 当想从worker线程更新到ui的时候，你必须把请求交给ui线程 比较底层的实现是： 在wpf，在元素的dispatcher对象上调用begininvoke或invoke 在winform，调用控件的begininvoke或invoke 在uwp中， 调用dispatcher对象上的runasync或invoke 所有这些方法都接收一个委托 begininvoke或runasync通过将委托排队到ui线程的消息队列在执行工作 invoke执行相同的操作，但随后会进行阻塞，直到ui线程读取并处理消息。 因此，invoke允许您从方法中获取返回值 如果不需要返回值，begininvoke/runasync更可取，因为他们不会阻塞调用方，也不会引入死锁的可能性 private void Button_Click(object sender, RoutedEventArgs e) { Work();//这样用直接卡了5s整个界面 // new Thread(Work).Start();//这样用又会直接报错呜呜呜 } void Work() { Thread.Sleep(5000); textbox.Text = \u0026#34;The answer\u0026#34;; } demo wpf\nprivate void Button_Click(object sender, RoutedEventArgs e) { // Work();//这样用直接卡了5s整个界面 new Thread(Work).Start();//这样用又会直接报错呜呜呜 } void Work() { Thread.Sleep(5000);//实际上是为了模拟好多好多奇奇怪怪占用时间的逻辑操作 // textbox.Text = \u0026#34;The answer\u0026#34;; UpdateMessage(\u0026#34;The Answer is me...\u0026#34;); } void UpdateMessage(string message) { Action action = () =\u0026gt; { textbox.Text = message; }; Dispatcher.BeginInvoke(action); } winform demo\nimage-20210126105507084\rprivate void button1_Click(object sender, EventArgs e) { // Work(); //显然，这样做卡死界面了嗷嗷嗷呜呜呜 new Thread(Work).Start(); } void Work() { Thread.Sleep(5000); UpdateUIMessage(\u0026#34;ljs is shuaibi ...\u0026#34;); } void UpdateUIMessage(string message) { Action action = () =\u0026gt; { textBox1.Text = message; }; BeginInvoke(action); } 同步上下文 synchronization contexts 在system.componentmodel 下有一个抽象类：synchronizationcontext ，它使得thread marshaling 的得到泛化 啥意思嘞 就是将一个线程里数据的所有权交给另一个线程，就是把数据移交过去呗还能有啥意思啊\n针对移动、桌面（wpf、uwp、winforms）等富客户端应用的api，他们都定义和实例化了synchronizationcontext的子类\n可以通过静态属性synchronizationcontext.current来获得（当运行在ui线程时） 捕获该属性让你可以在稍后的时候从worker线程向ui线程发送数据 public SynchronizationContext _SynchronizationContext; private void button1_Click(object sender, EventArgs e) { //为当前ui线程捕获 synchronization context _SynchronizationContext =SynchronizationContext.Current; // Work(); //显然，这样做卡死界面了嗷嗷嗷呜呜呜 new Thread(Work).Start(); } void Work() { Thread.Sleep(5000);//模拟耗时操作 UpdateUIMessageMethod1(\u0026#34;ljs is a shuaibi \u0026#34;); // UpdateUIMessage(\u0026#34;ljs is shuaibi ...\u0026#34;); } void UpdateUIMessageMethod1(string message) { //把委托 marshal 给 ui 线程 _SynchronizationContext.Post(s =\u0026gt; textBox1.Text = message, null); //调用post 就相当于 dispatcher或 control 上的 begininvoke 方法 } 调用post方法就相当于调用dispatch或control上面的begininvoke方法 还有一个send方法，就等价于invoke方法 线程池 thread pool 当开始一个线程的时候，将花费几百微妙来组织类似以下内容 一个新的局部变量栈stack 线程池就可以节省这种开销 通过预先创建一个可循环使用线程的池来减少这一开销 线程池对于高效的并行编程和细粒度并发是必不可少的 他允许在不被线程启动的开销淹没的情况下运行短期操作 使用线程池线程需要注意一下几点 不可以设置池线程的名称name 池线程都是后台线程 阻塞池线程可使性能降级 你可以自由的更改池线程的优先级 当他释放回池的时候优先级将还原为正常状态 可以通过thread.currentthread.isthreadpoolthread属性来判断是否执行在池线程上 进入线程池 最简单的、显式的在池线程运行代码的方式就是使用task.run Task.Run(() =\u0026gt; { Thread.Sleep(1000); Console.WriteLine(\u0026#34;this is a threadpool ...\u0026#34;); }); Console.WriteLine(\u0026#34;hey boy! i am a cowboy !\u0026#34;); // Console.ReadKey(); Thread.Sleep(1000); 谁使用了线程池 wcf/remoting / asp.net / asmx web services 应用服务器 system.timers.times / system.threading .timer 并行编程结构 backgroundworkder类 (现在很多余) 异步委托(现在很多余) 线程池中的整洁 线程池提供了另一个功能，即确保临时超出 计算-bound 的工作不会导致cpu超额订阅 cpu超额订阅：活跃的线程超过cpu的核数，操作系统就需要对线程进行时间切片 超额订阅对性能的影响很大，时间切片需要昂贵的上下文切换，并且可能使cpu缓存失效，而cpu缓存对于现代处理器的性能至关重要 clr的策略 clr通过对任务排队并对其启动进行节流限制来避免线程池中的超额订阅 他首先运行尽可能多的并发任务（只要还有cpu核），然后通过爬山算法调整并发级别，并在特定方向上不断调整工作负载 如果吞吐量提高，它将继续朝同一个方向（否则将反转） 这确保他始终追随最佳性能曲线，即时面对计算机上竞争的进程活动时也是如此 如果下面两点能够满足，那么clr的策略将发挥出最佳效果 工作项大多是短时间运行的，（\u0026lt;250ms，或者理想情况下\u0026lt;100ms）因此clr有很多机会可进行测量和调整 大部分时间都被阻塞的工作项不会主宰线程池 thread的问题 线程thread是用来创建并发concurrency的一种低级别工具，他有一些限制，尤其是 虽然开始线程的时候可以方便的传入数据，但是当join的时候，很难从线程获得返回值。 可能需要设置一些共享字段 如果操作抛出异常，捕获和传播改异常都很麻烦 无法告诉线程在结束时开始做另外的工作，你必须进行join操作（在进程中阻塞当前的线程） 很难使用较小的并发concurrent来组建大型的并发 导致了对手动同步的更大依赖以及随之而来的问题 Task class task可以很好的解决上述的问题 task是一个相对高级的抽象，他代表了一个并发的操作concurrent 该操作可能有thread支持，可能不由thread支持 task是可组合的（可使用continuation把他们串成链） task可以使用线程池来减少启动延迟 使用taskcompletionsource，tasks可以利用回调的方式，在等待I/O绑定操作时完全避免线程 开始一个task task.run 开启一个task最简单的办法就是使用task.run这个静态方法 传入一个action委托即可 task默认使用线程池，也就是后台线程 当主线程结束的时候，你创建的所有的tasks都会结束 task.run返回一个task对象，可以使用他来监视其过程 在task.run之后，我们没有调用start，因为该方法创建的是热任务 hot task 可以通过task的构造函数创建冷任务 cold task ， 但是很少这么做 可以通过task的status属性来跟踪task的执行状态 Wait 等待 调用task的wait方法会进行阻塞直到操作完成\n相当于调用thread上的join方法 实际上，task.wait我觉得就是让主线程，或者前台线程等待我们创建出来的这个task后台线程继续执行，在这个过程中，阻塞了线程，直至task完成任务\nAction action = () =\u0026gt; { Thread.Sleep(3000); Console.WriteLine(\u0026#34;Foo\u0026#34;); }; var task = Task.Run(action); Console.WriteLine(task.IsCompleted); task.Wait(); Console.WriteLine(task.IsCompleted); wait也可以让你指定一个超时时间和一个取消令牌来提前结束等待 long-running tasks 长时间运行的任务 默认情况下，clr在线程池中运行task，这非常适合短时间运行的compute-bound类工作 针对长时间运行的任务或者阻塞操作，你可以不采用线程池 var startNew = Task.Factory.StartNew(() =\u0026gt; { Thread.Sleep(3000); Console.WriteLine(\u0026#34;Foo\u0026#34;); },TaskCreationOptions.LongRunning); Console.ReadKey(); Console.WriteLine(startNew.Status); 如果同时运行多个long-running tasks 尤其是其中有处于阻塞状态的，那么性能将会受到很大的影响，这时有比taskcreationoptions.longrunning更好的方法 如果任务是io-bound ，taskcompletionsource和异步函数可以让你用毁掉coninuations代替线程来实现并发 如果任务是compute-bound,生产者/消费者队列允许你对任务的并发性进行限流，避免把其他线程和进程饿死 task的返回值 task有一个泛型子类叫做task，他允许发出一个返回值\n使用func委托或兼容的lambda表达式来调用task.run就可以得到task\n随后，可以通过result属性来获得返回的结果\n如果这个task还没有完成操作，访问result属性会阻塞该线程直到该task完成操作 var task = Task.Run(() =\u0026gt; { Console.WriteLine(\u0026#34;Foo\u0026#34;); return 3; }); int result = task.Result; Console.WriteLine(result); task可以看作是一种所谓的“未来/许诺” future 、promise ，在它里面包裹着一个result ， 在稍后的时候就会变得可用\n在ctp版本，task实际上叫做future\ntask的异常 与thread不一样，task可以很方便的传播异常 如果你的task里面抛出了一个未处理的异常（故障）， 那么该异常就会重新被抛出给 调用了wait的地方 访问了task的result属性的地方 CLR将异常包裹在aggregateException里，以便在并行编程场景中发挥很好的作用 无需重新抛出异常，通过task的isfaulted和iscancled属性也可以检测出task是否发生了故障 如果两个属性都返回了false，那么就是没有错误发生 如果iscancled为true，那就说明一个operationCanceledException为该task抛出了 如果isfaulted为true，那就说明另一个类型的异常被抛出了，而Exception属性也将指明错误 异常与自治的task 自治的，设置完就不管了的task。就是指不通过调用wait（）方法、result属性或者continuation进行会合的任务 针对自治的task，需要像thread一样，显式的处理异常，避免发生“悄无声息”的故障 自治task上未处理的异常称为未观察到的异常 未观察到的异常 可以通过全局的taskscheduler.unobservedtaskexception来订阅未观察到的异常 关于什么是未观察到的异常，有一些细微的差别 Continuation 一个continuation会对task说 ： 当你结束的时候，继续再做点其他的事\ncontinuation通常是通过回调的方式实现的\n当操作一结束，就开始执行 在task上调用getawaiter会返回一个awaiter对象\n他的oncompleted方法会告诉之前的task：当你结束/发生故障的时候要执行委托 可以将continuation附加到已经结束的task上面，此时continuation将会被安排立即执行\nstatic void Main(string[] args) { Task\u0026lt;int\u0026gt; task = Task.Run(() =\u0026gt; Enumerable.Range(2, 3000000) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); var awaiter = task.GetAwaiter(); awaiter.OnCompleted(() =\u0026gt; { Console.WriteLine(awaiter.GetResult()); }); Console.ReadKey(); } 实际上，我们是否可以通过这个方式作为不阻塞主线程并最后为ui更新数据的方式呢\nawaiter 任何可以暴露下列两个方法和一个属性的对象就是awaiter oncompleted getresult iscompleted 的bool属性 没有接口或者父类来统一这些成员 其中oncompleted是inotifycompletion的一部分 private void button1_Click(object sender, EventArgs e) { Task\u0026lt;int\u0026gt; task = Task.Run(() =\u0026gt; Enumerable.Range(2, 3000000) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); var awaiter = task.GetAwaiter(); awaiter.OnCompleted(() =\u0026gt; { textBox1.Text = awaiter.GetResult().ToString(); }); 如果发生故障 如果之前的任务发生故障，那么当continuation代码调用awaiter.getresult的时候，异常就会被重新抛出 无需调用getresult，我们可以直接访问task的result属性 但调用getresult的好处是，如果task是发生故障了，那么异常会被直接抛出，而不是包裹在aggregateexception里面，这样的话catch块就简洁很多了 非泛型 task 针对非泛型的task，getresult方法有一个void返回值，他就是用来重新抛出异常的 同步上下文 如果同步上下文出现了，那么oncompleted会自动捕获它，并将continuation提交到这个上下文中。这一点在富客户端应用中非常有用，因为他会把continuation放回到ui线程中 如果编写的是一个库，则不希望出现上述行为，因为开销较大的ui线程切换应该在程序运行离开库的时候只发生一次，而不是出现在方法调用之间。所以，我们可以使用configureawait方法来避免这种行为 image-20210126170725006\r如果没有同步上下文出现，或者你使用的是configureawait(false)，那么continuation会运行在先前task的同一个线程上，从而避免不必要的开销 ContinueWith 另一种附加continuation的方式是调用task的continuewith方法 Task\u0026lt;int\u0026gt; task = Task.Run(() =\u0026gt; Enumerable.Range(2, 3000000) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); task.ContinueWith(task =\u0026gt; { int? result = task.Result; Console.WriteLine(result); }); Console.ReadKey(); continuewith本身返回一个task，他可以用他来附加更多的continuation\n但是，必须直接处理aggregateexception\n如果task发生故障，需要写额外的代码来吧continuation给封装（marshal）到ui应用上 Task\u0026lt;int\u0026gt; task = Task.Run(() =\u0026gt; Enumerable.Range(2, 3000000) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); task.ContinueWith(a =\u0026gt; { Console.WriteLine(a.Result); UpdateUIMessageMethod1(a.Result.ToString());//marshal过程 } ); 在非ui上下文中，若想让continuation和task执行在同一个线程上，必须指定taskcontinuationoptions.executesynchronously,否则他将弹回线程池 continuewith对于并行编程来说非常有用\ntaskCompletionSource task.run 创建task 另一种方式就是用taskcompletionsource来创建task taskcompletionsource让你在稍后开始和结束的任意操作中创建task 他会为你提供一个可手动执行的从属task 指示操作何时结束或发生故障 他对io-bound类工作比较理想 可以获得所有task的好处（传播值、异常、continuation） 不需要在操作时阻塞线程 使用taskcompletionsource 初始化一个实例即可 他有一个task属性可以返回一个task 该task完全由taskcompletionsource对象控制 调用任意一个方法都会给task发信号： 完成、故障、取消 这些方法只能调用一次，如果再次调用 set会抛出异常 try会返回false static void Main(string[] args) { var taskCompletionSource = new TaskCompletionSource\u0026lt;int\u0026gt;(); new Thread(() =\u0026gt; { Thread.Sleep(5000); taskCompletionSource.SetResult(42); }) { IsBackground = true }.Start(); var task = taskCompletionSource.Task; Console.WriteLine(task.Result); } Taskcompletionsource真正魔力 它创建task，但并不占用线程 task.delay 相当于异步版本的thread.sleep static void Main(string[] args) { Task.Delay(5000).GetAwaiter().OnCompleted(()=\u0026gt;Console.WriteLine(42)); Console.WriteLine(1); Task.Delay(5000).ContinueWith(task =\u0026gt; Console.WriteLine(42)); Console.ReadKey(); } 同步vs异步 同步操作会返回调用者之前完成它的工作 异步操作会返回调用者之后去做他的工作（大部分的） 异步的方法更为少见，会启用并发，因为它的工作会与调用者并行执行 异步方法通常很快就会返回到调用者，因此又叫非阻塞方法 目前见到的大部分的一部方法都是通用目的的 thread.start task.run 可以将continuation 附加到task的方法 异步编程 异步编程的原则是将长时间运行的函数写成异步的 传统的做法是将长时间运行的函数写成同步的，然后从新的线程或task进行调用，从而按需引入并发 上述异步方式的不同之处在于，它是从长时间运行函数的内部启动并发。这有两点好处： io-bound 并发可不使用线程来实现。可提高可扩展性和执行效率 富客户端在worker线程会使用更少的代码，简化了线程安全性 异步编程的两种用途 编写高效处理大量并发io的应用程序（典型的：服务端应用程序） 挑战并不是线程安全（因为共享状态通常是最小化的），而是执行效率 特别的，每个网络请求并不会消耗一个线程 调用图 call graph 在富客户端应用里简化线程安全 如果调用图中任何一个操作都是长时间运行的，那么整个call graph 必须运行在worker线程上，以保证ui的响应 得到一个横跨多个方法的单一并发操作（粗粒度） 需要为call graph 中的每个方法考虑线程安全 异步的call graph，直到需要才开启一个线程，通常较浅（io-bound操作完全不需要） 其他的方法可以在ui线程执行，线程安全得到简化 并发的粒度适中 一连串小的并发操作，操作之间会弹回到ui线程 经验之谈 为了获得上述好处，建议下列操作使用异步编写： io-bound和compute-bound操作 执行超过50ms的操作 另一方面过细的粒度会损害性能，因为异步操作也有开销 异步编程和continuation task非常适合异步编程，因为他们支持continuation（它对异步非常重要） taskcompletionsource是实现底层io-bound异步方法的一种标准方式 对于compute-bound方法，task.run会初始化绑定线程的并发 把task返回调用者，创建异步方法 异步编程的区别：目标是在调用图较低的位置来这样做 富客户端应用中，高级方法可以保留在ui线程和访问控制以及共享状态上，不会出现线程安全问题 // static void Main(string[] args) // { // // DisplayPrimeCounts();//同步写法 // Task.Run(DisplayPrimeCounts);//粗粒度异步写法 // Thread.Sleep(500); // Console.WriteLine(\u0026#34;lalala\u0026#34;); // Console.ReadKey(); // } static void Main(string[] args) { Task.Run(DisplayPrimeCountsAsync); Console.ReadKey(); } static void DisplayPrimeCounts() { for (int i = 0; i \u0026lt; 10; i++) { Console.WriteLine(GetPrimesCount(i * 1000000 + 2, 1000000) + \u0026#34;primes between \u0026#34; + (i + 1000000) + \u0026#34;and\u0026#34;+ ((i+1)*1000000-1)); } Console.WriteLine(\u0026#34;done!\u0026#34;); } static void DisplayPrimeCountsAsync() { for (int i = 0; i \u0026lt; 10; i++) { var taskAwaiter = GetPrimesCountAsync(i * 1000000 + 2, 1000000).GetAwaiter(); taskAwaiter.OnCompleted(() =\u0026gt; { Console.WriteLine(taskAwaiter.GetResult()+ \u0026#34;primes between \u0026#34; + (i + 1000000) + \u0026#34;and\u0026#34; + ((i + 1) * 1000000 - 1)); }); } Console.WriteLine(\u0026#34;done!\u0026#34;); } static int GetPrimesCount(int start, int count) { return ParallelEnumerable.Range(start, count) .Count(n =\u0026gt; Enumerable.Range(2, (int) Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0)); } static Task\u0026lt;int\u0026gt; GetPrimesCountAsync(int start, int count) { return Task.FromResult(ParallelEnumerable.Range(start, count) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); } 语言对异步的支持非常重要 需要对task的执行序列化\n例如task b 依赖于 task a 的执行结果 为此，必须在continuation内部触发下一次循环 很麻烦 因为我们决定引入 async 和await关键字\n对于不想复杂的实现异步非常重要 命令式循环结构不要和continuation混合在一起，因为他们依赖于当前本地状态\n另一个实现，函数式写法（linq查询）, 他也是响应式编程（Rx）的基础\n异步函数 async和await关键字可以让你写出和同步代码一样简洁且结构相同的异步代码 await await关键字简化了附加continuation的过程 他的作用相当于 var awaiter = expression.GetAwaiter() ; awaiter.OnCompleted(()=\u0026gt; { var result = awaiter.GetResult() ; statement(s) ; }) async修饰符 async修饰符会让编译器把await当做关键字而不是标识符（c# 5 以前可能会使用await作为标识符） async修饰符智能应用于方法（包括lambda表达式） 该方法可以返回void / task / task async修饰符对方法的签名或public元数据没有影响（和uisafe一样），他只会影响方法内部 在接口里使用async是没有意义的 使用async来重载非async方法确实合法的 使用async修饰符的方法就是异步函数 static async Task Main(string[] args) { await DisplayPrimeCountsAsync(); } static async Task DisplayPrimeCountsAsync() { for (int i = 0; i \u0026lt; 10; i++) { Console.WriteLine(await GetPrimesCountAsync(i * 1000000 + 2, 1000000) + \u0026#34;primes between \u0026#34; + (i + 1000000) + \u0026#34;and\u0026#34; + ((i + 1) * 1000000 - 1)); } Console.WriteLine(\u0026#34;Done!\u0026#34;); } static async Task\u0026lt;int\u0026gt; GetPrimesCountAsync(int start , int count) { return await Task.FromResult(ParallelEnumerable.Range(start, count) .Count(n =\u0026gt; Enumerable.Range(2, (int)Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); } 异步方法如何执行 遇到await表达式，执行（正常情况下）会返回调用者 就像iterator里面的yield return 在返回前，运行时会附加一个continuation到await的task 为保证task结束时，执行会跳回原方法，从停止的地方继续执行 如果发生故障，那么异常会被重新抛出 如果一切正常，那么他的返回值就会赋给await表达式 —实际上就是跟那个awaiter 和 awaiter.oncompleted 是一样的，执行完的得到返回值继续向下执行 可以await什么 await的表达式通常是一个task 也可以满足以下条件的任意对象 有getawaiter方法，返回一个awaiter 返回适当类型的getresult方法 一个bool类型的iscompleted属性 捕获本地状态 await表达式最牛的地方在于他几乎可以出现在任何地方 特别的，在异步方法内，await表达式可以替换任何表达式 除了lock表达式和unsafe上下文 await之后在哪个线程上执行 在await表达式之后，编译器依赖于continuation（通过awaiter模式）来继续执行 如果在富客户端应用的ui线程上，同步上下文会保证后续是在原线程上执行 否则，就会在task结束的线程上继续执行 private void button2_Click(object sender, EventArgs e) { // Go(); GoAsync(); } async void GoAsync() { button2.Enabled = false; for (int i = 1; i \u0026lt; 5; i++) { textBox2.Text += await GetPrimesCountAsync(i * 1000000, 1000000) + \u0026#34; primes between \u0026#34; + \u0026#34; and \u0026#34; + ((i + 1) * 1000000 - 1) + Environment.NewLine; } button2.Enabled = true; } Task\u0026lt;int\u0026gt; GetPrimesCountAsync(int start, int count) { return Task.Run(() =\u0026gt; ParallelEnumerable.Range(start, count) .Count(n =\u0026gt; Enumerable.Range(2, (int) Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); } UI 上的await 只有getprimescountasync是在worker线程上运行的 go中的代码会“租用”ui线程上的时间 可以说：Go是在消息循环中伪并发的执行 也就是说：它和ui线程处理的其他时间是穿插执行的 因为这种伪并发，唯一可能发生抢占的时刻就是在await期间 这其实简化了线程安全，防止重新进入即可 这种并发发生在调用栈比较浅的地方（rask.run调用的代码里） 为了从该模型中获益，真正的并发代码要避免访问共享状态或ui控件 private void button2_Click(object sender, EventArgs e) { // Go(); GoAsync(); } async void GoAsync() { button2.Enabled = false; for (int i = 1; i \u0026lt; 5; i++) { textBox2.Text += await GetPrimesCountAsync(i * 1000000, 1000000) + \u0026#34; primes between \u0026#34; + \u0026#34; and \u0026#34; + ((i + 1) * 1000000 - 1) + Environment.NewLine; } button2.Enabled = true; } Task\u0026lt;int\u0026gt; GetPrimesCountAsync(int start, int count) { return Task.Run(() =\u0026gt; ParallelEnumerable.Range(start, count) .Count(n =\u0026gt; Enumerable.Range(2, (int) Math.Sqrt(n) - 1).All(i =\u0026gt; n % i \u0026gt; 0))); } 因为在ui线程上await ， continuation将发送到同步上下文中，该同步上下文通过消息循环执行，来保证整个go方法伪并发的在ui线程上运行 和粗粒度的并发相比 整个同步调用图都在worker线程上 必须在代码中到处使用dispatcher.begininvoke 引入了race condition 循环本省在worker线程上 若实现取消或者过程报告，会使得线程安全问题更容易发生，在方法中新添加任何代码也是同样的效果 编写异步函数 对于任何异步函数，你可以使用task代替void作为返回类型，让该方法称为更有效的异步（可以进行await） static async Task Main(string[] args) { // PrintAnswerToLife(); //如果不使用异步关键字，会导致并行执行 ， 又由于是task线程池，是后台进程，前台进程执行完毕就关了，所以程序还没输出42就停了 await PrintAnswerToLife(); } static async Task PrintAnswerToLife() { await Task.Delay(5000); int answer = 21 * 2; Console.WriteLine(answer); } 并不需要在方法体中显式的返回task。编译器会生成一个task（当方法完成或者发生异常时），这使得创建异步的调用链非常方便啊 编译器会返回task的异步函数来进行扩展，使其成为当发送信号或发生故障时使用taskcompletionsource来创建task代码 因此，当返回task的异步方法结束的时候，执行就会跳回到对它进行await的地方（通过continuation） 编写异步函数在富客户端场景下 富客户端场景下，执行在此刻会跳回到ui线程（如果目前不在ui线程的话） 否则，就在continuation返回的任意线程上继续运行 这意味着，在异步调用图中向上冒泡的时候，不会发生延迟成本，除非是ui线程启动的第一次反弹 返回task 如果方法体返回tresult ， 那么异步方法就可以返回task 其原理就是给taskcompletionsource发送的信号带有值，而不是null 与同步编程很相似，是故意这样设计的 C#中如何设计异步函数 以同步的方式编写函数 使用异步调用来代替同步调用，并且进行await 除了顶层方法外（UI控件的event handler），把你的方法的返回类型升级为task或task,这样他们就可以进行await了 编译器能对异步函数生成task意味着什么 大多数情况下，你只需要在初始化io-bound并发的底层方法里显式的初始化taskcompletionsource，这种情况很少见 针对初始化compute-bound的并发方法，你可以使用task.run来创建task class Program { static async Task Main(string[] args) { await Go(); } static async Task Go() { var printAnswerToLife = PrintAnswerToLife(); await printAnswerToLife; Console.WriteLine(\u0026#34;Done!\u0026#34;); } static async Task PrintAnswerToLife() { var answerToLife = GetAnswerToLife(); var toLife = await answerToLife; Console.WriteLine(toLife); } static async Task\u0026lt;int\u0026gt; GetAnswerToLife() { var delay = Task.Delay(5000); await delay; int answer = 21 * 2; return answer; } } 异步调用图执行 整个执行与同步例子中调用图的顺序一样，因为我们对每个异步函数的调用都进行了await 在调用图中创建了一个没有并行和重叠的连续流 每个await在执行中都创建了一个间隙，在间隙后，程序可以从中断处恢复执行 private void button3_Click(object sender, EventArgs e) { Go1(); } async void Go1() { var printAnswerToLife = PrintAnswerToLife(); await printAnswerToLife; textBox3.Text = \u0026#34;Done!\u0026#34;; } async Task PrintAnswerToLife() { var answerToLife = GetAnswerToLife(); var toLife = await answerToLife; textBox3.Text = toLife.ToString(); } async Task\u0026lt;int\u0026gt; GetAnswerToLife() { var delay = Task.Delay(5000); await delay; int answer = 21 * 2; return answer; } 并行Parallelism 不适用await来调用异步函数会导致并行执行的发生 确实也能满足保持ui响应的并发要求 同样，可以并行跑两个操作 异步lambda表达式 匿名方法（包括lambda表达式），通过使用async也可以变成异步方法 static async Task Main(string[] args) { Func\u0026lt;Task\u0026gt; func = async () =\u0026gt; { await Task.Delay(1000); Console.WriteLine(\u0026#34;Foo\u0026#34;); }; await NamedMethod(); await func(); } static async Task NamedMethod() { await Task.Delay(1000); Console.WriteLine(\u0026#34;Foo1\u0026#34;); } 调用方式也是一样样的 附加 event handler 的时候也可以使用异步lambda表达式 // this.button3.Click += async (sender,args) =\u0026gt; // { // await Task.Delay(1000); // button3.Text = \u0026#34;comeon baby\u0026#34;; // }; 也可以返回task Func\u0026lt;Task\u0026lt;int\u0026gt;\u0026gt; func = async () =\u0026gt; { await Task.Delay(1000); Console.WriteLine(\u0026#34;Foo\u0026#34;); return 123; }; 发布异常 富客户端应用通常依赖于集中的异常处理事件来处理ui线程上未捕获的异常 例如wpf中的application.dispatcherunhandledexception asp.net core 中定制 exceptionfilterattribute也是差不多的效果 其内部原理就是：通过在它们自己的try/catch块来调用ui事件（在asp.net core里就是页面处理方法的管道） 顶层的异步方法会使事情更加复杂 顶层的异步方法由于已经没有方法让他进行await了，所以他会使用void 而不是task作为返回类型 在抛出异常后无法被消息循环中的catch捕获 为了缓解该问题，asyncvoidmethodbuilder会捕获未处理的异常（在返回void的异步方法里） ， 并把他们发布到同步上下文（如果出现的话），以确保全局异常处理事件能够触发 注意 编译器只会把上述逻辑应用于返回类型为void的一部方法\n如果buttonclick的返回类型是task，那么未处理的异常将导致结果task出错，然后task将无处可去（导致为观察到的异常）\n无论在await前面还是后面跑出异常，都没有区别\n如果出现同步上下文，返回值为void的异常会被发布到同步上下文中，如果没有出现，异常将会在线程池上传播，从而导致终止应用程序\noperationstarted 和 operationcompleted 如果存在同步上下文，返回void的异步函数也会进入函数时调用其operationstarted方法，在函数完成时调用其operationcompleted方法 优化同步完成 异步函数可以在await之前就返回 static async Task Main(string[] args) { Console.WriteLine(await GetWebPageAsync(\u0026#34;http://oreilly.com\u0026#34;)); } static Dictionary\u0026lt;string ,string \u0026gt; _cache = new Dictionary\u0026lt;string, string\u0026gt;(); private static async Task\u0026lt;string\u0026gt; GetWebPageAsync(string uri) { string html; if (_cache.TryGetValue(uri,out html)) { return html; } return _cache[uri] = await new WebClient().DownloadStringTaskAsync(uri); } 编译器是通过检查awaiter上的iscompleted属性来实现这个优化的，也就是说，无论何时await收到时候，都会检查\n如果是同步完成了，编译器就会释放可短路的continuation代码\n编写完全没有await的异步方法也是合法的，但是编译器会发出警告\n这类方法可以用于重载virtual/abstract方法\n另一种可以达到相同结果的方式是，使用task.fromresult，他会返回一个已经设置好信号的task\n如果从ui线程上调用，那么getwebpageasync方法是隐式线程安全的。可以连续多次调用它（从而启动多个并发下载），并且不需要lock来保护缓存\n有一种简单的方法可以实现这一点，而不必求助于lock或信令结构。我们创建一个futures （task）的缓存，而不是字符串的缓存，注意并没有async\n取消 cancellationToken 和 cancellationTokenSource 获取cancellationToken 先实例化cancellationtokensource var cancelsource = new cancellationTokensource() ; 这回暴露一个token属性，他会返回一个cancellationtoken ，所以我们可以这样调用 task foo = Foo(cancelsource.token) … … cancelsource.cancel() Delay clr里大部分异步方法都支持cancellationtoken ， 包括delay方法 其他 事实上，可以在构造cancellationtokensource时指定一个时间间隔，以便在一段时间后启动取消。它对于实现超时非常有用，无论是同步还是异步 cancellationtoken这个struct提供了一个register方法，他可以让你注册一个回调委托，这个委托会在取消时触发，它会返回一个对象，这个对象在取消注册时可以被dispose掉 进度报告 异步操作在运行当中反馈实时进度，解决办法是向异步方法中闯入一个action委托，当进度变化时触发方法调用\niprogress 和progress\nprogress的一个构造函数可以接受action类型的委托\nTask组合器 异步函数有一个让其保持一致的协议（可以一致的返回task），让其保持良好的结果，可以使用以及编写task组合器，也就是可以组合task，但是不关心task具体做什么的函数 CLR提供了两个task组合器： task.whenany task.whenall WhenAny 当一组task中任何一个task完成时，task.whenany会返回完成的task 因为task.whenany本身就返回一个task，我们对他进行await，就会返回最先完成的task 事实上，whenany很适合为不支持超时或取消的操作添加这些功能 whenall 当传给他的所有的task都完成后，task.whenall会返回一个task ","date":"2021-10-30T00:17:57+08:00","permalink":"https://jianrongma.github.io/p/%E7%9C%9F%E4%BC%9Acsharp%E5%90%97%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"真会CSharp吗学习文档"},{"content":"Mysql高级学习文档 mysql的架构介绍 mysql简介 mysqllinux版安装 mysql配置文件 mysql逻辑架构介绍 mysql存储引擎 索引优化分析 性能下降sql慢是执行时间长还是等待时间长 常见通用的join查询 索引简介 性能分析 索引优化 查询截取分析 查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志 mysql锁机制 锁的分类 主从复制 主从配置 mysql简介 高级mysql 完整的mysql优化\nmysql内核 sql优化攻城狮 mysql服务器的优化 各种参数常量设定 查询语句优化 主从复制 软硬件升级 容灾备份 sql编程 mysqllinux版的安装 image-20211012195826053\r#查看当前ubuntu版本 yourtreedad@yourtreedad:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.3 LTS Release: 20.04 Codename: focal yourtreedad@yourtreedad:~$ 准备工作\n#切换到root账户 yourtreedad@yourtreedad:~$ sudo passwd root New password: Retype new password: passwd: password updated successfully yourtreedad@yourtreedad:~$ su root Password: root@yourtreedad:/home/yourtreedad# #查看电脑里有没有mysql root@yourtreedad:/home/yourtreedad# service mysql status * MySQL is stopped. root@yourtreedad:/home/yourtreedad# mysql --version mysql Ver 8.0.26-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu)) root@yourtreedad:/home/yourtreedad# service mysql start * Starting MySQL database server mysqld su: warning: cannot change directory to /nonexistent: No such file or directory #那就彻底卸载了 root@yourtreedad:/home/yourtreedad# sudo apt-get remove mysql-* root@yourtreedad:/home/yourtreedad# sudo rm -rf /etc/mysql/ root@yourtreedad:/home/yourtreedad# dpkg -l |grep ^rc|awk \u0026#39;{print $2}\u0026#39; |sudo xargs dpkg -P dpkg: error: --purge needs at least one package name argument #如果出现这个错误 dpkg: error: --purge needs at least one package name argument，说明已经清空完毕了 #全部删除了 root@yourtreedad:/home/yourtreedad# service mysql status mysql: unrecognized service root@yourtreedad:/home/yourtreedad# mysql --version bash: /usr/bin/mysql: No such file or directory root@yourtreedad:/home/yourtreedad# #更新到最新 安装rpm root@yourtreedad:/opt# apt-get update root@yourtreedad:/home/yourtreedad# apt-get upgrade root@yourtreedad:/home/yourtreedad# apt-get install rpm #使用rpm判断当前系统是否安装过mysql root@yourtreedad:/home/yourtreedad# rpm -qa|grep -i mysql #安装mysql root@yourtreedad:/opt# sudo apt-get install mysql-server mysql-client #查看是否安装成功 root@yourtreedad:/# id yourtreedad uid=1000(yourtreedad) gid=1000(yourtreedad) groups=1000(yourtreedad),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),117(netdev) root@yourtreedad:/# cat /etc/passwd|grep mysql mysql:x:112:119:MySQL Server,,,:/var/lib/mysql/:/bin/false root@yourtreedad:/# cat /etc/group|grep mysql mysql:x:119: root@yourtreedad:/# mysqladmin --version mysqladmin Ver 8.0.26-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu)) root@yourtreedad:/# root@yourtreedad:/# service mysql start root@yourtreedad:/# ps -ef|grep mysql mysql 18675 1 0 21:03 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe mysql 18822 18675 0 21:03 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --log-error=/var/log/mysql/error.log --pid-file=yourtreedad.pid root 19055 16743 0 21:14 tty1 00:00:00 grep --color=auto mysql https://www.cnblogs.com/duolamengxiong/p/13650684.html\nmysql启停和自动运行 #查看运行时间 root@yourtreedad:/home/yourtreedad# top top - 21:17:30 up 1:21, 0 users, load average: 0.52, 0.58, 0.59 Tasks: 8 total, 1 running, 7 sleeping, 0 stopped, 0 zombie %Cpu(s): 4.0 us, 2.9 sy, 0.0 ni, 92.7 id, 0.0 wa, 0.4 hi, 0.0 si, 0.0 st MiB Mem : 32674.8 total, 21949.1 free, 10501.7 used, 224.0 buff/cache MiB Swap: 38400.2 total, 38322.8 free, 77.3 used. 22042.5 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 8944 328 288 S 0.0 0.0 0:00.18 init 16725 root 20 0 8952 232 184 S 0.0 0.0 0:00.00 init 16726 yourtre+ 20 0 18096 3588 3484 S 0.0 0.0 0:00.13 bash 18675 mysql 20 0 10656 812 780 S 0.0 0.0 0:00.10 mysqld_safe 18822 mysql 20 0 2603072 299920 20628 S 0.0 0.9 0:00.75 mysqld 19087 root 20 0 18412 2592 2568 S 0.0 0.0 0:00.03 su 19088 root 20 0 17008 2396 2304 S 0.0 0.0 0:00.07 bash 19201 root 20 0 18924 2152 1528 R 0.0 0.0 0:00.04 top #直接mysql 就进来了 root@yourtreedad:/home/yourtreedad# mysql Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 24 mysql默认没有密码,所以我们这里咩有输入密码就直接连上了\n设置登陆密码\nroot@yourtreedad:/home/yourtreedad# /usr/bin/mysqladmin -u root password 123456 mysqladmin: [Warning] Using a password on the command line interface can be insecure. Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety. image-20211012213458570\rmysql\u0026gt; create database student ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; exit Bye root@yourtreedad:/var/lib/mysql# ls -l total 193956 -rw-r----- 1 mysql mysql 196608 Oct 12 21:33 \u0026#39;#ib_16384_0.dblwr\u0026#39; -rw-r----- 1 mysql mysql 8585216 Oct 12 20:19 \u0026#39;#ib_16384_1.dblwr\u0026#39; drwxr-x--- 1 mysql mysql 512 Oct 12 21:03 \u0026#39;#innodb_temp\u0026#39; -rw-r----- 1 mysql mysql 56 Oct 12 20:19 auto.cnf -rw-r----- 1 mysql mysql 12582912 Oct 12 21:33 ibdata1 -rw-r----- 1 mysql mysql 12582912 Oct 12 21:03 ibtmp1 drwxr-x--- 1 mysql mysql 512 Oct 12 20:19 mysql -rw-r----- 1 mysql mysql 25165824 Oct 12 21:33 mysql.ibd drwxr-x--- 1 mysql mysql 512 Oct 12 21:33 student drwxr-x--- 1 mysql mysql 512 Oct 12 20:19 sys 修改配置文件位置\nimage-20211012213843009\r弄好了重启mysql\nmysql\u0026gt; insert into user values (2,\u0026#39;张三\u0026#39;); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from user ; +----+--------+ | id | name | +----+--------+ | 1 | z3 | | 2 | 张三 | +----+--------+ 2 rows in set (0.00 sec) #有时候字符集没弄好 要弄成utf-8 mysql\u0026gt; show variables like \u0026#39;%char%\u0026#39;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8mb4 | | character_set_connection | utf8mb4 | | character_set_database | utf8mb4 | | character_set_filesystem | binary | | character_set_results | utf8mb4 | | character_set_server | utf8mb4 | | character_set_system | utf8mb3 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.01 sec) 修改字符集和数据存储路径\n必须在字符集修改之后才能支持中文,之前的数据库好像不行\nmysql配置文件 二进制日志 log - bin 主从复制 错误日志 mysqlerror.error 查询日志log 默认关闭,记录查询的sql语句,如果开启会减低mysql的整体性能 数据文件 两个系统不一致 windows mysql5.0\\data目录下有很多库 linux 默认路径 /var/lib/mysql frm文件 存放表结构 myd文件 存放表数据 myi文件 存放表索引 mysql逻辑架构介绍 image-20211014205109147\r第一层:连接层 最上层是一些客户端和连接服务,包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信.主要完成一些类似于连接处理/授权认证及相关的安全方案.在该层上引入了线程池的概念,为通过认证安全接入的客户端提供线程.同样在该层上可以实现基于ssl的安全连接.服务器也会为安全接入的每个客户端验证它所具有的操作权限.\n第二层:数据库连接池 备份恢复安全集群容灾 存储过程 视图 触发器 解析器 优化器 缓存 第二层架构主要完成大多数的核心服务功能,如sql接口,并完成缓存的查询,sql的分析和优化以部分内置函数的执行.所有跨存储引擎的功能也在这一层实现,如过程/函数等.在该层,服务器会解析查询并创建相应的内部解析树,并对其完成相应的优化如确定查询表的顺序,是否利用索引等,最后生成相应的执行操作.如果是select语句,服务器还会查询内部的缓存,如果缓存空间足够大,这样在解决大量读操作的环境中能够很好的提升系统的性能.\n第三层:可插拔存储引擎 存储引擎层,存储引擎真正的负责了mysql中数据的存储和提取,服务器通过api与存储引擎进行通信.不同的存储引擎具有的功能不同,这样我们可以根据自己的实际需要进行选取.后面介绍myisam和innodb\n第四层:文件系统和文件日志 数据存储层,主要是将数据存储在运行于裸设备的文件系统上,并完成与存储引擎的交互\n和其他的数据库相比,mysql有点与众不同,它的架构可以在多种不同场景中应用并发挥良好作用.主要体现在存储引擎的架构上,插件式的存储引擎将查询处理和其他的系统任务以及数据的存储提取相分离.这种架构可以根据业务的需求和实际需要选择合适的存储引擎\nmysql存储引擎 mysql\u0026gt; show engines ; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine #查看存储引擎 mysql\u0026gt; show variables like \u0026#39;%storage_engine%\u0026#39; ; +---------------------------------+-----------+ | Variable_name | Value | +---------------------------------+-----------+ | default_storage_engine | InnoDB | | default_tmp_storage_engine | InnoDB | | disabled_storage_engines | | | internal_tmp_mem_storage_engine | TempTable | +---------------------------------+-----------+ image-20211014211207589\rimage-20211014211324759\r索引优化 优化分析 性能下降sql慢/执行时间长/等待时间长\n查询语句写的烂 索引失效 单值 复合 #创建索引 mysql\u0026gt; create index idx_beauty_name on beauty(name); Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; create index idx_beauty_name_sex on beauty(name,sex); Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #查看索引 mysql\u0026gt; show index from beauty ; +--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | beauty | 0 | PRIMARY | 1 | id | A | 13 | NULL | NULL | | BTREE | | | YES | NULL | | beauty | 1 | idx_beauty_name | 1 | name | A | 12 | NULL | NULL | | BTREE | | | YES | NULL | | beauty | 1 | idx_beauty_name_sex | 1 | name | A | 12 | NULL | NULL | | BTREE | | | YES | NULL | | beauty | 1 | idx_beauty_name_sex | 2 | sex | A | 12 | NULL | NULL | YES | BTREE | | | YES | NULL | +--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 关联查询太多join(设计缺陷或不得已的需求) 服务器调优以各个参数设置(缓冲/线程数) 常见的join查询 sql的执行顺序\n手写 select from join on where group by having order by limit 机读 from on join where group by having select dinstinct order by limit image-20211014213300494\rjoin 图\nimage-20211014213503395\rimage-20211014213909722\rmysql\u0026gt; CREATE TABLE tbl_dept ( -\u0026gt; id INT(11) NOT NULL AUTO_INCREMENT, -\u0026gt; deptName VARCHAR(30) DEFAULT NULL, -\u0026gt; locAdd VARCHAR(40) DEFAULT NULL, -\u0026gt; PRIMARY KEY (id) -\u0026gt; ) ENGINE INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; Query OK, 0 rows affected, 2 warnings (0.02 sec) mysql\u0026gt; CREATE TABLE tbl_emp ( -\u0026gt; id INT(11) NOT NULL AUTO_INCREMENT, -\u0026gt; name VARCHAR(20) DEFAULT NULL, -\u0026gt; deptld INT(11) DEFAULT NULL, -\u0026gt; PRIMARY KEY(id), -\u0026gt; KEY fk_dept_id(deptld) -\u0026gt; #CONSTRAINT fk_dept_id FOREIGNKEY(deptld) REFERENCES tbl_dept(id) -\u0026gt; )ENGINE INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; Query OK, 0 rows affected, 3 warnings (0.02 sec) mysql\u0026gt; select * from tbl_emp ; +----+------+--------+ | id | name | deptld | +----+------+--------+ | 1 | z3 | 1 | | 2 | z4 | 1 | | 3 | z5 | 1 | | 4 | w5 | 2 | | 5 | w6 | 2 | | 6 | s7 | 3 | | 7 | s8 | 4 | | 8 | s9 | 51 | +----+------+--------+ 8 rows in set (0.00 sec) mysql\u0026gt; select * from tbl_dept ; +----+----------+--------+ | id | deptName | locAdd | +----+----------+--------+ | 1 | RD | 11 | | 2 | HR | 12 | | 3 | MK | 13 | | 4 | MIS | 14 | | 5 | FD | 15 | +----+----------+--------+ 5 rows in set (0.00 sec) #内连接 就么有8员工 和 5部门 mysql\u0026gt; select e.* , d.* from tbl_emp e join tbl_dept d on e.deptld = d.id ; +----+------+--------+----+----------+--------+ | id | name | deptld | id | deptName | locAdd | +----+------+--------+----+----------+--------+ | 1 | z3 | 1 | 1 | RD | 11 | | 2 | z4 | 1 | 1 | RD | 11 | | 3 | z5 | 1 | 1 | RD | 11 | | 4 | w5 | 2 | 2 | HR | 12 | | 5 | w6 | 2 | 2 | HR | 12 | | 6 | s7 | 3 | 3 | MK | 13 | | 7 | s8 | 4 | 4 | MIS | 14 | +----+------+--------+----+----------+--------+ #左外连接 没有5部门 mysql\u0026gt; select e.* , d.* from tbl_emp e left join tbl_dept d on e.deptid = d.id ; +----+------+--------+------+----------+--------+ | id | name | deptid | id | deptName | locAdd | +----+------+--------+------+----------+--------+ | 1 | z3 | 1 | 1 | RD | 11 | | 2 | z4 | 1 | 1 | RD | 11 | | 3 | z5 | 1 | 1 | RD | 11 | | 4 | w5 | 2 | 2 | HR | 12 | | 5 | w6 | 2 | 2 | HR | 12 | | 6 | s7 | 3 | 3 | MK | 13 | | 7 | s8 | 4 | 4 | MIS | 14 | | 8 | s9 | 51 | NULL | NULL | NULL | +----+------+--------+------+----------+--------+ #右外连接 没有8员工 mysql\u0026gt; select e.* , d.* from tbl_emp e right join tbl_dept d on e.deptid = d.id ; +------+------+--------+----+----------+--------+ | id | name | deptid | id | deptName | locAdd | +------+------+--------+----+----------+--------+ | 1 | z3 | 1 | 1 | RD | 11 | | 2 | z4 | 1 | 1 | RD | 11 | | 3 | z5 | 1 | 1 | RD | 11 | | 4 | w5 | 2 | 2 | HR | 12 | | 5 | w6 | 2 | 2 | HR | 12 | | 6 | s7 | 3 | 3 | MK | 13 | | 7 | s8 | 4 | 4 | MIS | 14 | | NULL | NULL | NULL | 5 | FD | 15 | +------+------+--------+----+----------+--------+ #只有左边 只有8员工 mysql\u0026gt; select e.* , d.* from tbl_emp e left join tbl_dept d on e.deptid = d.id where d.id is null ; +----+------+--------+------+----------+--------+ | id | name | deptid | id | deptName | locAdd | +----+------+--------+------+----------+--------+ | 8 | s9 | 51 | NULL | NULL | NULL | +----+------+--------+------+----------+--------+ #只有右边 只有5部门 mysql\u0026gt; select e.* , d.* from tbl_emp e right join tbl_dept d on e.deptid = d.id where e.deptid is null ; +------+------+--------+----+----------+--------+ | id | name | deptid | id | deptName | locAdd | +------+------+--------+----+----------+--------+ | NULL | NULL | NULL | 5 | FD | 15 | +------+------+--------+----+----------+--------+ 1 row in set (0.00 sec) #全连接 都得有 mysql不支持outer join mysql\u0026gt; select e.* , d.* from tbl_emp e outer join tbl_dept d on e.deptid = d.id; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;outer join tbl_dept d on e.deptid = d.id\u0026#39; at line 1 #可以这么做 union默认去重 union all 就不会去重 mysql\u0026gt; select e.* , d.* from tbl_emp e left join tbl_dept d on e.deptid = d.id union select e.* , d.* from tbl_emp e right join tbl_dept d on e.deptid = d.id; +------+------+--------+------+----------+--------+ | id | name | deptid | id | deptName | locAdd | +------+------+--------+------+----------+--------+ | 1 | z3 | 1 | 1 | RD | 11 | | 2 | z4 | 1 | 1 | RD | 11 | | 3 | z5 | 1 | 1 | RD | 11 | | 4 | w5 | 2 | 2 | HR | 12 | | 5 | w6 | 2 | 2 | HR | 12 | | 6 | s7 | 3 | 3 | MK | 13 | | 7 | s8 | 4 | 4 | MIS | 14 | | 8 | s9 | 51 | NULL | NULL | NULL | | NULL | NULL | NULL | 5 | FD | 15 | +------+------+--------+------+----------+--------+ 9 rows in set (0.00 sec) #不要join重合的部分 要另外两半的 mysql\u0026gt; select e.* , d.* from tbl_emp e left join tbl_dept d on e.deptid = d.id where d.id is null union select e.* ,d.* from tbl_emp e right join tbl_dept d on e.deptid = d.id where e.deptid is null ; +------+------+--------+------+----------+--------+ | id | name | deptid | id | deptName | locAdd | +------+------+--------+------+----------+--------+ | 8 | s9 | 51 | NULL | NULL | NULL | | NULL | NULL | NULL | 5 | FD | 15 | +------+------+--------+------+----------+--------+ 2 rows in set (0.00 sec) 索引简介 是什么 mysql官方对索引的定义为:索引index是帮助mysql高效获取数据的数据结构.可以得到索引的本质:索引是数据结构.\n如果要查mysql这个单词,我们肯定需要定位到m字母,然后往下找到y字母,再找到剩下的sql\n如果没有索引,那么你可能需要a\u0026ndash;z,如果我想找到java开头的单词呢,或者oracle开头的单词呢\n你可以简单理解为 排好序的快速查找数据结构\n在数据之外,数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构,就是索引.下图就是一种可能的索引方式示例:\nimage-20211014224606584\r所以说索引是一种数据结构,如果要查7这本书,正常的遍历要第七次才能找到,时间复杂度为n,索引是利用平衡二叉树,或者B+树,也就是说不一定二叉可以多叉,这样至多log2n+1次就能索引到,故而提高了效率\n一般来说,索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存储在磁盘上\n索引不太适合删除和修改多的场景,因为删除数据的同时要删除索引,修改数据的同时要修改索引,索引为何会失效\n我们常说的索引,如果没有特别指明,都是指B树(多路搜索树,并不一定是二叉的)结构组织的索引.其中聚集索引,次要索引,覆盖索引,符合索引,前缀索引,唯一索引默认都是使用B+树索引,统称索引.当然,除了B+树这种类型的索引之外,还有哈希索引(hash index)等.\n优势 类似大学图书馆建书索引,提高数据检索的效率,降低数据库的IO成本 通过索引列对数据进行排序,降低数据排序的成本,降低了CPU的消耗 劣势 实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录,所以索引列也是要占用空间的 虽然索引大大提高了查询速度,同时却会降低更新表的速度,如对表进行insert/update/delete.因为更新表时,mysql不仅要保存数据,还要保存一下索引文件每次更新添加了索引列的字段,都会调整因为更新所带来的键值变化后的索引信息 索引只是提高效率的一个因素,如果你的mysql有大数据量的表,就需要花时间研究建立最优秀的索引,或优化查询 mysql索引分类 单值索引 即一个索引只包含单个列,一个表可以有多个单列索引 唯一索引 索引列的值必须唯一,但允许空值 复合索引 即一个索引包含多个列 基本语法 创建 create [unique] index indexName on tableName(columnName,\u0026hellip;) ; alter tableName add [unique] index [indexName] on (columnName(length)) ; 删除 drop index [indexName] on tableName ; 查看 show index from tableName ; 使用alter命令 alter table tbl_name add primary key (column_list) ; 该语句添加一个主键,这意味这索引值必须是唯一的,且不能为null alter table tbl_name add unique index_name (column_list) ; 这条语句创建索引的值必须是唯一的,除了null之外,null可能会出现多次 alter table tbl_name add index index_name (column_list) ; 添加普通索引,索引值可出现多次 alter table tbl_name add fulltext index_name (column_list) ; 该语句指定了索引为fulltext,用于全文索引 #主键外键唯一都是索引 我们这边讲的是那种普通索引 mysql\u0026gt; show index from tbl_emp ; +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | tbl_emp | 0 | PRIMARY | 1 | id | A | 8 | NULL | NULL | | BTREE | | | YES | NULL | | tbl_emp | 1 | fk_dept_id | 1 | deptid | A | 5 | NULL | NULL | YES | BTREE | | | YES | NULL | +---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 2 rows in set (0.02 sec) mysql索引的结构 Btree索引 索引原理 hash索引 full-text全文索引 R-Tree索引 image-20211016093656515\r初始化介绍\n一颗B+树,浅蓝色的块我们称之为一个磁盘块,可以看到每个磁盘块包含了几个数据项(深蓝色所示)和指针(黄色所示),如磁盘块1包含数据项17和35,包含指针P1P2P3\nP1表示小于17的磁盘块,P2表示在17和35之间的磁盘块,P3表示大于35的磁盘块\n真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99\n非叶子节点不存储真实的数据,只存储指引搜索方向的数据项,如17、35并不真实存在与数据表中\n查找过程\n如果要查找数据项29,那么首先会把磁盘块1由磁盘加载到内存,此时发生一次IO,在内存中用二分查找确定29在17和35之间,锁定磁盘块1的P2指针,内存时间因为非常短(相比于磁盘的IO)可以忽略不计,通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存中,发生了第二次IO,29在26和30之间,锁定磁盘块3的P2指针,通过指针加载磁盘块8到内存,发生第三次IO,同时内存中做二分查找找到29,结束查询,总计三次IO\n真实情况\n3层的b+树可以表示上百万条的数据,如果上百万的数据查找只需要三次IO,性能提高将是巨大的,如果没有索引,每个数据项都要发生一次IO,那么总共需要百万次IO,显然成本非常非常高\n哪些情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段,外键关系应该建立索引 频繁更新的字段不适合创建索引 因为每次更新不单单是更新了记录还会更新索引 where条件里用不到的字段不创建索引 单值/复合索引的选择问题 高并发下倾向创建组合索引 查询中排序的字段,排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 哪些情况不要创建索引 表记录太少 经常增删改的表 提高了查询速度,同时却会降低更新表的速度,如对表进行insert/update和delete,因为更新表时,mysql不仅要保存数据,还要保存一下索引文件 数据重复且分布均匀的表字段,因此应该只为最经常查询和最经常排序的数据列创建索引. 注意,如果某个数据列包含许多重复的内容,为它建立索引就没有太大的实际效果 image-20211016095439966\r性能分析 msyql query optimizer 查询优化器 image-20211016095805682\rmysql常见瓶颈 CPU cpu在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候 IO 磁盘IO瓶颈发生在装入数据远大于内存容量的时候 服务器硬件的性能瓶颈: top free iostat vmstat 来查看系统的性能状态 explain Explain 是什么(查看执行计划) 使用explain关键字可以模拟优化器执行sql查询语句,从而知道mysql是如何处理你的sql语句的.分析你的查询语句或是表结构的性能瓶颈 官网介绍 能干嘛 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 怎么玩 Explain + SQL语句 执行计划包含的信息 表头 id select_type table partitions type possible_keys key ken_len ref rows filtered extra 各字段解释 id select查询的序列号,包含一组数字,表示查询中执行select子句或操作表的顺序 三种情况 id相同,执行顺序由上到下\rimage-20211016101510820\rid不同,如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行\rimage-20211016101830835\rid相同不同,同时存在\rimage-20211016102234339\rselect_type 有哪些 simple primary subquery dirived union union result 查询的类型,主要是用于区别普通查询/联合查询/子查询等的复杂查询 simple 简单的select查询,查询中不包含子查询或者union primary 查询中若包含任何复杂的子部分,最外层查询则被标记为 subquery 在select或where列表中包含了子查询 derived 在from列表中包含的子查询被标记为derived(衍生) mysql会递归执行这些子查询,把结果放在临时表里 union 若第二个select出现在union之后,则被标记为union;若union包含在from子句的子查询中,外层select 将被标记为derived(很正常嘛,union之后的结果作为临时表 所以被标记为derived) union result 从union表获取结果的select table 显示这一行的数据是关于那些表的 type all index range ref eq_ref const,system null 访问类型排列 显示查询使用了何种类型,最好到最差依次是 syste\u0026gt;const\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all\rimage-20211016110536099\rsystem 表只有一行记录(等于系统表),这是const类型的特例,平时不会出现,这个也可以忽略不计 const 表示通过索引一次就找到了,const用于比较primary key 或者 unique索引,因为只匹配了一行数据,所以很快,如将主键置于where列表中,mysql就能将该查询转换为一个常量\rimage-20211016110923813\req_ref 唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配.常用语主键或唯一索引扫描\rimage-20211016112628359\rref 非唯一性索引扫描,返回匹配某个单独值的所有行.本质上也是一种索引访问,他返回所有匹配某个单独值的行,然而,她可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体.\rimage-20211016113043870\rrange 只检索给定范围的行,使用一个索引来选择行. key列显示使用了哪个索引,一般就是在你的where语句中出现了between \u0026lt; \u0026gt; in 等的查询,这种范围扫描索引扫描比全表扫描要好,因为它只需要开始于索引的某一点,而结束于另一点,不用扫描全部索引\rimage-20211016113701811\rindex (full index san) index与all的区别为index类型只遍历索引树.这通常比all快,因为索引文件比数据文件小 也就是说虽然all和index都是读全表,但index是从索引中读取的,而all是从硬盘中读取的\rimage-20211016114028963\rall (full table scan) 将遍历全表以找到匹配的行\rimage-20211016114058619\r**注意:**一般来说,得保证查询至少打到range级别,最好能够达到ref possible_keys 用来判断索引用上没,索引失效没 显示可能应用在这张表中的索引,一个或多个.查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用 key 实际使用的索引.如果为null,则没有使用索引 查询中若使用了覆盖索引,则该索引仅出现在key列表中 key_len 表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度.在不损失精确性的情况下,长度越短越好 key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的 同样的查询条件下,精度越小越好\rimage-20211016145227350\rref 显示索引的哪一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值\rimage-20211016145926736\rrows 根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数\rimage-20211016150445129\rextra 包含不适合在其他列中显示但十分重要的额外信息 extra信息 using filesort 说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取 mysql中无法利用索引完成的排序操作称为文件排序 出现这个东西不好 如果可以尽快优化\rimage-20211016151320887\rusing temporary 使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表.常见于排序order by和分组查询group by 使用临时表会损伤数据库性能 用完还要回收 这个很不好哦\rimage-20211016151757718\rusing index 表示相应的select操作中使用了覆盖索引covering index , 避免了访问了表的的数据行,效率不错! 如果同时出现using where ,表明索引被用来执行索引键值的查找 如果没有同时出现using where , 表明索引用来读取数据而非执行查找动作 覆盖索引 建了3个索引,查的也是3个 全覆盖 image-20211016152608867\rimage-20211016152333029\rusing where 表明使用了where条件 using join buffer 表明使用了连接缓存 impossible where 表明where子句的值总是false , 不能用来获取任何元组\rimage-20211016152746052\rselect tables optimized away 在没有groupby子句的情况下,基于索引优化min/max操作或者对于myisam存储引擎优化count(*)操作,不必等到执行阶段再进行计算,查询执行计划生成的阶段即完成优化. select distinct 优化distinct操作,在找到第一匹配的元组后立即停止查找同样值的操作 #使用explain关键字 进行性能分析 mysql\u0026gt; explain select * from tbl_emp ; +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ | 1 | SIMPLE | tbl_emp | NULL | ALL | NULL | NULL | NULL | NULL | 8 | 100.00 | NULL | +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; explain select * from tbl_emp a left join tbl_dept b on a.deptId = b.id union select * from tbl_emp a right join tbl_dept b on a.deptid = b.id ; +----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ | 1 | PRIMARY | a | NULL | ALL | NULL | NULL | NULL | NULL | 8 | 100.00 | NULL | | 1 | PRIMARY | b | NULL | eq_ref | PRIMARY | PRIMARY | 4 | girls.a.deptid | 1 | 100.00 | NULL | | 2 | UNION | b | NULL | ALL | NULL | NULL | NULL | NULL | 5 | 100.00 | NULL | | 2 | UNION | a | NULL | ref | fk_dept_id | fk_dept_id | 5 | girls.b.id | 1 | 100.00 | NULL | | NULL | UNION RESULT | \u0026lt;union1,2\u0026gt; | NULL | ALL | NULL | NULL | NULL | NULL | NULL | NULL | Using temporary | +----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ 5 rows in set, 1 warning (0.00 sec) 热身case image-20211016153657227\rimage-20211016153809882\r索引优化 索引分析\n单表\n两表\n三表\n索引失效(应该避免)\n一般性建议\n#建表 单表示例 mysql\u0026gt; CREATE TABLE IF NOT EXISTS `article`( -\u0026gt; `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT, -\u0026gt; `author_id` INT(10) UNSIGNED NOT NULL, -\u0026gt; `category_id` INT(10) UNSIGNED NOT NULL, -\u0026gt; `views` INT(10) UNSIGNED NOT NULL, -\u0026gt; `comments` INT(10) UNSIGNED NOT NULL, -\u0026gt; `title` VARBINARY(255) NOT NULL, -\u0026gt; `content` TEXT NOT NULL -\u0026gt; ); Query OK, 0 rows affected, 5 warnings (0.03 sec) mysql\u0026gt; mysql\u0026gt; INSERT INTO `article`(`author_id`,`category_id`,`views`,`comments`,`title`,`content`) VALUES -\u0026gt; (1,1,1,1,\u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;), -\u0026gt; (2,2,2,2,\u0026#39;2\u0026#39;,\u0026#39;2\u0026#39;), -\u0026gt; (1,1,3,3,\u0026#39;3\u0026#39;,\u0026#39;3\u0026#39;); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql\u0026gt; select * from article; +----+-----------+-------------+-------+----------+--------------+---------+ | id | author_id | category_id | views | comments | title | content | +----+-----------+-------------+-------+----------+--------------+---------+ | 1 | 1 | 1 | 1 | 1 | 0x31 | 1 | | 2 | 2 | 2 | 2 | 2 | 0x32 | 2 | | 3 | 1 | 1 | 3 | 3 | 0x33 | 3 | +----+-----------+-------------+-------+----------+--------------+---------+ 3 rows in set (0.00 sec) #性能分析 type是all 说明是全表扫描 #显然 using filesort 也是最坏的情况 发生了文件内排序 mysql\u0026gt; explain select id,author_id from article where category_id = 1 and comments \u0026gt;1 order by views desc limit 1 ; +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ | 1 | SIMPLE | article | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where; Using filesort | +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ 1 row in set, 1 warning (0.00 sec) #如果创建的索引是ccv type 变成了range extra还是filesort 好了点 mysql\u0026gt; create index idx_ccv on article(category_id,comments,views) ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; explain select id,author_id from article where category_id = 1 and comments \u0026gt;1 order by views desc limit 1 ; +----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ | 1 | SIMPLE | article | NULL | range | idx_ccv | idx_ccv | 8 | NULL | 1 | 100.00 | Using index condition; Using filesort | +----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ 1 row in set, 1 warning (0.00 sec) #删除索引 mysql\u0026gt; drop index idx_ccv on article ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 image-20211016171713970\rmysql\u0026gt; create index idx_cv on article(category_id,views) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #把范围的去掉 mysql\u0026gt; explain select id,author_id from article where category_id = 1 and comments \u0026gt;1 order by views desc limit 1 ; +----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ | 1 | SIMPLE | article | NULL | ref | idx_cv | idx_cv | 4 | const | 2 | 33.33 | Using where; Backward index scan | +----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ 1 row in set, 1 warning (0.00 sec) #两表 mysql\u0026gt; CREATE TABLE IF NOT EXISTS `class`( -\u0026gt; `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, -\u0026gt; `card` INT(10) UNSIGNED NOT NULL, -\u0026gt; PRIMARY KEY(`id`) -\u0026gt; ); Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql\u0026gt; CREATE TABLE IF NOT EXISTS `book`( -\u0026gt; `bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, -\u0026gt; `card` INT(10) UNSIGNED NOT NULL, -\u0026gt; PRIMARY KEY(`bookid`) -\u0026gt; ); Query OK, 0 rows affected, 2 warnings (0.01 sec) #分析 都是全表扫描 很几把恐怖 mysql\u0026gt; explain select * from book b right join class c on b.card = c.card ; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ | 1 | SIMPLE | c | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL | | 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (hash join) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) #优化 先给右连接的左表定索引 同理 或者给左连接的右表定索引 mysql\u0026gt; alter table book add index Y(card) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #type变成ref了 有点意思 using index 很好 mysql\u0026gt; explain select * from book b right join class c on b.card = c.card ; +----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ | 1 | SIMPLE | c | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL | | 1 | SIMPLE | b | NULL | ref | Y | Y | 4 | girls.c.card | 1 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ 2 rows in set, 1 warning (0.00 sec) #不知道给左边添加索引好还是给右边添加好 所以再试试 mysql\u0026gt; drop index Y on book ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #添加索引 mysql\u0026gt; alter table class add index Y(card) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #发现没有用 为啥呢 因为右连接 没有where的话右边是肯定是全都有的 加了索引有啥用啊 mysql\u0026gt; explain select * from book b right join class c on b.card = c.card ; +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ | 1 | SIMPLE | c | NULL | index | NULL | Y | 4 | NULL | 20 | 100.00 | Using index | | 1 | SIMPLE | b | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (hash join) | +----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) #删除索引 mysql\u0026gt; drop index Y on class ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 image-20211016174325936\r#三表 mysql\u0026gt; CREATE TABLE IF NOT EXISTS `phone`( -\u0026gt; `phoneid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, -\u0026gt; `card` INT(10) UNSIGNED NOT NULL, -\u0026gt; PRIMARY KEY(`phoneid`) -\u0026gt; )ENGINE=INNODB; Query OK, 0 rows affected, 2 warnings (0.02 sec) #都是all 很差劲 20 mysql\u0026gt; explain select * from class left join book on class.card = book.card left join phone on phone.card = book.card ; +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ | 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL | | 1 | SIMPLE | book | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (hash join) | | 1 | SIMPLE | phone | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (hash join) | +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ 3 rows in set, 1 warning (0.00 sec) mysql\u0026gt; alter table phone add index z(card); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; create index y on book(card) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; explain select * from class left join book on class.card = book.card left join phone on phone.card = book.card ; +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ | 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL | | 1 | SIMPLE | book | NULL | ref | y | y | 4 | girls.class.card | 1 | 100.00 | Using index | | 1 | SIMPLE | phone | NULL | ref | z | z | 4 | girls.book.card | 1 | 100.00 | Using index | +----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ 3 rows in set, 1 warning (0.00 sec) image-20211016193542297\r索引失效(应该避免) 全值匹配我最爱\n最佳左前缀法则\n如果索引了多列,要遵守最左前缀法则.指的是查询从索引的最左前列开始并且不跳过索引中的列\rimage-20211016195626235\r不在索引列上做任何操作(计算/函数/自动手动类型转换),会导致索引失效而转向全表扫描\n少计算\n#对索引列进行函数转换后会导致索引失效的问题 mysql\u0026gt; explain select * from staffs where left(name,4)= \u0026#39;July\u0026#39; ; +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 100.00 | Using where | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 存储引擎不能使用索引中范围条件右边的列\n范围后面的索引都失效了 between and / in / like #都用到了 三个索引 140的长度 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; and age =25 and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 140 | const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #用到了两个 因为范围后的索引失效了 78长度 说明第二个用到了 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; and age \u0026gt;25 and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | staffs | NULL | range | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 78 | NULL | 1 | 33.33 | Using index condition | +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select *\n#查找所有字段 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; and age =25 and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 140 | const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #就只查找索引 索引覆盖 extra 变成 using index 是个好兆头 mysql\u0026gt; explain select name , age , pos from staffs where name = \u0026#39;July\u0026#39; and age =25 and pos=\u0026#39;manager\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 140 | const,const,const | 1 | 100.00 | Using index | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) image-20211016201217849\rmysql在使用不等于!= 或者 \u0026lt;\u0026gt;的时候无法使用索引 , 会导致全表扫描\nimage-20211016201756985\ris null , is not null 也无法使用索引 image-20211016202018668\rlike 以通配符开头 (\u0026rsquo;%abc\u0026hellip;\u0026rsquo;) mysql索引失效会变成全表扫描的操作\n只有把%写在右边才能避免索引失效 #索引失效 mysql\u0026gt; explain select * from staffs where name like \u0026#39;%July%\u0026#39; ; +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #放在左边也失效 毕竟不全表扫怎么知道是否找全了 mysql\u0026gt; explain select * from staffs where name like \u0026#39;%July\u0026#39; ; +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #没有失效 mysql\u0026gt; explain select * from staffs where name like \u0026#39;July%\u0026#39; ; +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | staffs | NULL | range | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 74 | NULL | 1 | 100.00 | Using index condition | +----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) 问题是解决like\u0026rsquo;%字符%\u0026lsquo;时索引不失效??? mysql\u0026gt; CREATE TABLE `tbl_user`( -\u0026gt; `id` INT(11) NOT NULL AUTO_INCREMENT, -\u0026gt; `NAME` VARCHAR(20) DEFAULT NULL, -\u0026gt; `age` INT(11) DEFAULT NULL, -\u0026gt; email VARCHAR(20) DEFAULT NULL, -\u0026gt; PRIMARY KEY (`id`) -\u0026gt; ) ENGINE =INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; Query OK, 0 rows affected, 3 warnings (0.03 sec) #用覆盖索引来解决 mysql\u0026gt; create index idx_user_nameAge on tbl_user(name,age) ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #index了 说明用到了 mysql\u0026gt; explain select name , age from tbl_user where name like \u0026#39;%aa%\u0026#39; ; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select id from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select name from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select age from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select id,name from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select id,name,age from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select id,name,age from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #index了 说明用到了 mysql\u0026gt; explain select name,age from tbl_user where name like \u0026#39;%aa%\u0026#39;; +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ | 1 | SIMPLE | tbl_user | NULL | index | NULL | idx_user_nameAge | 68 | NULL | 4 | 25.00 | Using where; Using index | +----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1 row in set, 1 warning (0.00 sec) #没有覆盖到索引 ， 索引失效 mysql\u0026gt; explain select * from tbl_user where name like \u0026#39;%aa%\u0026#39; ; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_user | NULL | ALL | NULL | NULL | NULL | NULL | 4 | 25.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #没有完全覆盖 索引失效 mysql\u0026gt; explain select id,name,age,email from tbl_user where name like \u0026#39;%aa%\u0026#39; ; +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | tbl_user | NULL | ALL | NULL | NULL | NULL | NULL | 4 | 25.00 | Using where | +----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) 字符串不加单引号索引失效\nmysql\u0026gt; select * from staffs where name = \u0026#39;2000\u0026#39; ; +----+------+-----+-----+---------------------+ | id | NAME | age | pos | add_time | +----+------+-----+-----+---------------------+ | 3 | 2000 | 23 | dev | 2021-10-16 19:38:15 | +----+------+-----+-----+---------------------+ 1 row in set (0.00 sec) #会发生隐式转换 mysql\u0026gt; select * from staffs where name =2000 ; +----+------+-----+-----+---------------------+ | id | NAME | age | pos | add_time | +----+------+-----+-----+---------------------+ | 3 | 2000 | 23 | dev | 2021-10-16 19:38:15 | +----+------+-----+-----+---------------------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; explain select * from staffs where name =\u0026#39;2000\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 74 | const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #和第三个吻合 隐式自动转换 自动转换会导致索引失效 mysql\u0026gt; explain select * from staffs where name =2000 ; +----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | idx_staffs_nameAgePos | NULL | NULL | NULL | 3 | 33.33 | Using where | +----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ 1 row in set, 3 warnings (0.00 sec) 少用or , 用它来连接时会索引失效 image-20211017095517319\r#建表 mysql\u0026gt; CREATE TABLE staffs( -\u0026gt; id INT PRIMARY KEY AUTO_INCREMENT, -\u0026gt; NAME VARCHAR(24) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;姓名\u0026#39;, -\u0026gt; age INT NOT NULL DEFAULT 0 COMMENT \u0026#39;年龄\u0026#39;, -\u0026gt; pos VARCHAR(20) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;职位\u0026#39;, -\u0026gt; add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;入职时间\u0026#39; -\u0026gt; )CHARSET utf8 COMMENT \u0026#39;员工记录表\u0026#39;; Query OK, 0 rows affected, 1 warning (0.02 sec) #添加索引 mysql\u0026gt; ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #查看索引 mysql\u0026gt; show index from staffs ; +--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | staffs | 0 | PRIMARY | 1 | id | A | 2 | NULL | NULL | | BTREE | | | YES | NULL | | staffs | 1 | idx_staffs_nameAgePos | 1 | NAME | A | 3 | NULL | NULL | | BTREE | | | YES | NULL | | staffs | 1 | idx_staffs_nameAgePos | 2 | age | A | 3 | NULL | NULL | | BTREE | | | YES | NULL | | staffs | 1 | idx_staffs_nameAgePos | 3 | pos | A | 3 | NULL | NULL | | BTREE | | | YES | NULL | +--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ #挺好的哈 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 74 | const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #两个条件 key_len越来越大 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39;and age = 25; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 78 | const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #三个条件 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; and age =25 and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 140 | const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #问题来了 没有name 只用age和pos的时候变成了全表扫描 索引失效 mysql\u0026gt; explain select * from staffs where age =23 and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #没有name 只用pos变成了全表扫描 索引失效 mysql\u0026gt; explain select * from staffs where pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ | 1 | SIMPLE | staffs | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where | +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #必须要有name 带头大哥不能死 最佳左前缀法则 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 74 | const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #虽然用到索引了 但是从索引的长度可以看出 只用了name这个索引 因为中间的age丢了 mysql\u0026gt; explain select * from staffs where name = \u0026#39;July\u0026#39; and pos = \u0026#39;dev\u0026#39; ; +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ | 1 | SIMPLE | staffs | NULL | ref | idx_staffs_nameAgePos | idx_staffs_nameAgePos | 74 | const | 1 | 33.33 | Using index condition | +----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) image-20211017095823171\rimage-20211017100150557\r可能有点小问题,到时候勘误一下\n练习一下\nmysql\u0026gt; CREATE TABLE test03( -\u0026gt; id int primary key not null auto_increment, -\u0026gt; c1 char(10), -\u0026gt; c2 char(10), -\u0026gt; c3 char(10), -\u0026gt; c4 char(10), -\u0026gt; c5 char(10) -\u0026gt; ); Query OK, 0 rows affected (0.05 sec) mysql\u0026gt; select * from test03; +----+------+------+------+------+------+ | id | c1 | c2 | c3 | c4 | c5 | +----+------+------+------+------+------+ | 1 | a1 | a2 | a3 | a4 | a5 | | 2 | b1 | b2 | b3 | b4 | b5 | | 3 | c1 | c2 | c3 | c4 | c5 | | 4 | d1 | d2 | d3 | d4 | d5 | | 5 | e1 | e2 | e3 | e4 | e5 | +----+------+------+------+------+------+ mysql\u0026gt; create index idx_test03_c1234 on test03(c1,c2,c3,c4); Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #用到了 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #索引在逐渐递增 key_len mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #mysql会自我优化 优化常量的查询顺序 mysql\u0026gt; explain select * from test03 where c2=\u0026#39;a2\u0026#39; and c1=\u0026#39;a1\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #索引在逐渐递增 key_len mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c3=\u0026#39;a3\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 93 | const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c3=\u0026#39;a3\u0026#39; and c4=\u0026#39;a4\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 124 | const,const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #mysql会自我优化 优化常量的查询顺序 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c4=\u0026#39;a4\u0026#39; and c3=\u0026#39;a3\u0026#39; ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 124 | const,const,const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #范围后面全失效 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c3\u0026gt;\u0026#39;a3\u0026#39; and c4=\u0026#39;a4\u0026#39; ; +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | test03 | NULL | range | idx_test03_c1234 | idx_test03_c1234 | 93 | NULL | 1 | 20.00 | Using index condition | +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) #我觉得是4个 查询顺序会被mysql优化 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c4\u0026gt;\u0026#39;a4\u0026#39; and c3=\u0026#39;a3\u0026#39; ; +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ | 1 | SIMPLE | test03 | NULL | range | idx_test03_c1234 | idx_test03_c1234 | 124 | NULL | 1 | 100.00 | Using index condition | +----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) #c3没有统计到里面 用于排序了而不是查找 c4就失效了呗 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39;and c4=\u0026#39;a4\u0026#39; order by c3 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 20.00 | Using index condition | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) #和上面的没什么区别 c3用去排序了 所以c4就失效了呗 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; order by c3 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #用到了索引 a1 和 a2 但是抓到数据之后,由于索引设置的是a1a2a3a4默认的排序是a1a2a3a4但是你这边直接 #开始用a4开始排 你还是人吗 这样抓到数据之后还需要对数据进行文件内部的排序才能展示给大家 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; order by c4 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 100.00 | Using filesort | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) #用到了索引 a1 但是排序按照a2 a3排序 不会导致索引失效 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c5=\u0026#39;a5\u0026#39; order by c2,c3 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 20.00 | Using where | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ #用到了索引a1 但是排序按照a3 a2排序 不会导致索引失效 但是检索到数据之后,排序不是索引默认的排序规则a1 a2 a3 而是a3 a2 所以检索到后又按照文件内排序 拍了一遍 Using filesort mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c5=\u0026#39;a5\u0026#39; order by c3,c2 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 20.00 | Using where; Using filesort | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ #没有问题哈 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; order by c2,c3; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 100.00 | NULL | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1 row in set, 1 warning (0.00 sec) #也没有问题哈 索引就给了1234 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; and c5=\u0026#39;c5\u0026#39; order by c2,c3; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 20.00 | Using where | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #不是说order by 的顺序是要和索引建立的顺序保持一致吗 为啥不会出现文件内排序呢 那是因为c2=a2出现在where中,相当于你order by的排序已经没有用处了 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c2=\u0026#39;a2\u0026#39; and c5=\u0026#39;c5\u0026#39; order by c3,c2; +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 62 | const,const | 1 | 20.00 | Using where | +----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ 1 row in set, 1 warning (0.00 sec) #这个没问题哈 c3 c2 会导致文件内排序 mysql\u0026gt; explain select * from test03 where c1 =\u0026#39;a1\u0026#39; and c5=\u0026#39;c5\u0026#39; order by c3,c2; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 20.00 | Using where; Using filesort | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ 1 row in set, 1 warning (0.00 sec) #索引没有失效 但是只用到了一个 没有发生文件内排序 mysql\u0026gt; explain select * from test03 where c1=\u0026#39;a1\u0026#39; and c4= \u0026#39;a4\u0026#39; group by c2,c3 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 20.00 | Using index condition | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ 1 row in set, 1 warning (0.00 sec) #索引没问题 使用了部分索引 但是分组的时候 Using temporary 十死无生啊 分组前必排序 mysql\u0026gt; explain select * from test03 where c1=\u0026#39;a1\u0026#39; and c4= \u0026#39;a4\u0026#39; group by c3,c2 ; +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ | 1 | SIMPLE | test03 | NULL | ref | idx_test03_c1234 | idx_test03_c1234 | 31 | const | 1 | 20.00 | Using index condition; Using temporary | +----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ 1 row in set, 1 warning (0.00 sec) 总结\n定值 / 范围 还是排序 , 一般order by 是给个范围\ngroup by 基本上都需要进行排序 , 否则会有临时表产生,即temporary\n索引优化 索引分析 索引失效 一般性建议 对于单键索引,尽量选择针对当前query过滤性更好的索引 在选择组合索引的时候,当前query中过滤性最好的字段在索引字段的顺序中 ,位置越靠前越好 在选择组合索引的时候,尽量选择可以能够包含当前query中的where字句中更多字段的索引 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的 image-20211018194551515\rlike后面跟着常量的话就没什么问题能做索引也能跳板\n优化总结口诀 全值匹配我最爱,最左前缀要遵守\n带头大哥不能死,中间兄弟不能断\n索引列上少计算,范围之后全失效\nlike百分写最右, 覆盖索引不写*\n不等空值还有or,索引失效要少用\nvar引号不可丢,sql高级也不难\n查询截取分析 查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志 分析步骤 观察,至少跑一天,看看生产的慢sql情况 开启慢查询日志,设置阙值,比如超过5秒钟的就是慢sql,并将它抓取出来 explain + 慢sql分析 show profile 运维经理或dba,进行sql数据库服务器的参数调优 总结 0\n慢查询的开启并捕获 explain+慢sql分析 show profile查询sql在mysql服务器里面的执行细节和声明周期情况 sql数据库服务器的参数调优 永远小表驱动大表\n类似于嵌套循环nested loop\norderby关键字优化\ngroup by关键字优化\nimage-20211018201006527\r很好分析嘛,如果B数据少于A,那么用B驱动,B在右边那就是先查B,因为B先查,查到的是小表,这样就小表驱动大表了; 如果B数据多余A,那么用A驱动,B在右边,那就是用exists,在B的查询里套上子查询,这样先查的B的同时需要先查A(这样才知道A.id,B才能查),这样就变成小表驱动大表了\nimage-20211018201111638\rmysql\u0026gt; select * from tbl_emp where deptid in (select id from tbl_dept ) ; +----+------+--------+ | id | name | deptid | +----+------+--------+ | 1 | z3 | 1 | | 2 | z4 | 1 | | 3 | z5 | 1 | | 4 | w5 | 2 | | 5 | w6 | 2 | | 6 | s7 | 3 | | 7 | s8 | 4 | +----+------+--------+ 7 rows in set (0.00 sec) #两种最终效果是一样的 但是得考虑哪个是小表哪个是大表 需要小表驱动大表 那就考虑使用哪一种 mysql\u0026gt; select * from tbl_emp where exists (select 1 from tbl_dept where tbl_emp.deptid = tbl_dept.id); +----+------+--------+ | id | name | deptid | +----+------+--------+ | 1 | z3 | 1 | | 2 | z4 | 1 | | 3 | z5 | 1 | | 4 | w5 | 2 | | 5 | w6 | 2 | | 6 | s7 | 3 | | 7 | s8 | 4 | +----+------+--------+ 7 rows in set (0.00 sec) orderby 关键字优化 orderby子句,尽量使用index方式排序,避免使用filesort方式排序 mysql支持两种方式的排序,filesort和index,index效率高,它指ysql扫描索引本身完成排序,filesort方式效率低 order by 满足两种情况,会使用index方式排序 order by 语句使用索引最左前列 使用where子句和order by子句条件列满足索引最左前列 尽可能在索引列上完成排序操作,遵照索引建的最佳左前缀原则 如果不在索引列上,filesort有两种算法:mysql就要启动双路排序和单路排序 双路排序 4.1之前使用双路排序,扫描两次磁盘,最终得到数据,读取行指针和order by 列, 对他们进行排序,然后扫描已经排序好的列表,按照列表中的值重新从列表中读取 从磁盘取排序字段,在buffer进行排序,再从磁盘取其他字段 单路排序 取一批数据,要对磁盘进行两次扫描,众所周知,IO很耗时,在4.1之后,出现了第二种的改进算法,就是单路排序 从磁盘读取查询需要的所有列,按照orderby列在buffer对他们进行排序,然后扫描排序后的列表进行输出,它的效率更快一些,避免了第二次读取数据.并且把随机IO变成了顺序IO,但是它会使用更多的空间,因为它把每一行都保存在内存中了. image-20211018204727314\r优化策略 增大sort_buffer_size参数设置 增大max_length_for_sort_data参数的设置 why image-20211018205003059\rmysql\u0026gt; CREATE TABLE tblA( -\u0026gt; #id int primary key not null autp_increment, -\u0026gt; age int, -\u0026gt; birth timestamp not null -\u0026gt; ); Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; CREATE INDEX idx_A_ageBirth on tblA(age,birth); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 image-20211018203216016\r默认升序 打乱了就会发生filesort\nimage-20211018203523533\r总结 image-20211018205452929\rgroup by 关键字优化 group by实质是先排序后进行分组,遵照索引建的最佳左前缀 当无法使用索引列,增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置 where高于having , 能写在where限定的条件就不要去having限定了 mysql慢查询日志 image-20211018205757207\rimage-20211018205824359\r如何查看是否开启与如何开启\nmysql\u0026gt; show variables like \u0026#39;%slow_query_log%\u0026#39;; +---------------------+--------------------------+ | Variable_name | Value | +---------------------+--------------------------+ | slow_query_log | ON | | slow_query_log_file | LAPTOP-FKVMDBSI-slow.log | +---------------------+--------------------------+ 2 rows in set, 1 warning (0.01 sec) #只对当前数据库生效 mysql\u0026gt; set global slow_query_log = 1 ; Query OK, 0 rows affected (0.00 sec) image-20211018210231026\r什么样的会记录到慢查询日志里面呢?\nmysql\u0026gt; show variables like \u0026#39;%long_query_time%\u0026#39;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set, 1 warning (0.00 sec) image-20211018210404815\r设置慢查询时间阙值\nmysql\u0026gt; set global long_query_time = 3 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; show variables like \u0026#39;%long_query_time%\u0026#39;; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.000000 | +-----------------+-----------+ 1 row in set, 1 warning (0.00 sec) image-20211018210539898\rimage-20211018210653124\r去哪儿找慢sql呀?\n#超过3s了 应该会记录到某个日志里对不对 mysql\u0026gt; select sleep(4); +----------+ | sleep(4) | +----------+ | 0 | +----------+ 1 row in set (4.01 sec)\timage-20211018211230665\r查看有多少条慢查询的sql mysql\u0026gt; show global status like \u0026#39;slow_queries%\u0026#39; ; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | Slow_queries | 2 | +---------------+-------+ 1 row in set (0.00 sec) 配置版 永久生效 image-20211018212354576\r日志分析工具mysqldumpslow 查看帮助信息 s 标识按照何种方式排序 c 访问次数 l 锁定时间 r 返回记录 t 查询时间 al 平均锁定时间 ar 平均返回记录数 at 平均查询时间 t 返回前面多少条的数据 g 后边搭配一个正则匹配模式,大小写不敏感的 image-20211018212608969\rimage-20211018213827239\r批量插入数据 #准备工作 mysql\u0026gt; create database bigdata ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; use bigdata ; Database changed mysql\u0026gt; CREATE TABLE `dept` ( -\u0026gt; `id` int(10) unsigned NOT NULL AUTO_INCREMENT, -\u0026gt; `deptno` mediumint(8) unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39;, -\u0026gt; `dname` varchar(20) NOT NULL DEFAULT \u0026#39;\u0026#39;, -\u0026gt; `loc` varchar(13) NOT NULL DEFAULT \u0026#39;\u0026#39;, -\u0026gt; PRIMARY KEY (`id`) -\u0026gt; ) ENGINE=InnoDB DEFAULT CHARSET=GBK; Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql\u0026gt; mysql\u0026gt; CREATE TABLE `emp` ( -\u0026gt; `id` int(10) unsigned NOT NULL AUTO_INCREMENT, -\u0026gt; `empno` mediumint(8) unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39;,/*编号*/ -\u0026gt; `ename` varchar(20) NOT NULL DEFAULT \u0026#39;\u0026#39;,/*名字*/ -\u0026gt; `job` varchar(9) NOT NULL DEFAULT \u0026#39;\u0026#39;,/*工作*/ -\u0026gt; `mgr` mediumint(8) unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39;,/*上级编号*/ -\u0026gt; `hiredate` date NOT NULL,/*入职时间*/ -\u0026gt; `sal` decimal(7,2) NOT NULL,/*薪水*/ -\u0026gt; `comm` decimal(7,2) NOT NULL,/*红利*/ -\u0026gt; `deptno` mediumint(8) unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39;,/*部门编号*/ -\u0026gt; PRIMARY KEY (`id`) -\u0026gt; ) ENGINE=InnoDB DEFAULT CHARSET=GBK; Query OK, 0 rows affected, 4 warnings (0.02 sec) mysql\u0026gt; show variables like \u0026#39;log_bin_trust_function_creators\u0026#39; ; +---------------------------------+-------+ | Variable_name | Value | +---------------------------------+-------+ | log_bin_trust_function_creators | OFF | +---------------------------------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; set global log_bin_trust_function_creators = 1 ; Query OK, 0 rows affected (0.00 sec) #重启会失效 如果永久就修改配置文件 mysql\u0026gt; show variables like \u0026#39;log_bin_trust_function_creators\u0026#39; ; +---------------------------------+-------+ | Variable_name | Value | +---------------------------------+-------+ | log_bin_trust_function_creators | ON | +---------------------------------+-------+ 1 row in set, 1 warning (0.00 sec) #创建函数随机产生字符串和部门编号 mysql\u0026gt; delimiter $$ mysql\u0026gt; create function rand_string (n int) returns varchar (255) -\u0026gt; begin -\u0026gt; declare chars_str varchar(100) default \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ\u0026#39;; -\u0026gt; declare return_str varchar(255) default \u0026#39;\u0026#39;; -\u0026gt; declare i int default 0 ; -\u0026gt; while i\u0026lt;n do -\u0026gt; set return_str = concat (return_str,substring(chars_str,floor(1+rand()*52),1)); -\u0026gt; set i = i + 1; -\u0026gt; end while ; -\u0026gt; return return_str ; -\u0026gt; end $$ Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; create function rand_num() returns int(5) -\u0026gt; begin -\u0026gt; declare i int default 0 ; -\u0026gt; set i = floor(100+rand()*10); -\u0026gt; return i ; -\u0026gt; end $$ Query OK, 0 rows affected, 1 warning (0.01 sec) #创建存储过程 并使用函数 mysql\u0026gt; create procedure insert_emp(in start int(10),in max_num int(10)) -\u0026gt; begin -\u0026gt; declare i int default 0 ; -\u0026gt; set autocommit = 0 ; -\u0026gt; repeat -\u0026gt; set i = i + 1 ; -\u0026gt; insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values ((start+i),rand_string(6),\u0026#39;SALESMAN\u0026#39;,0001,curdate(),2000,400,rand_num()); -\u0026gt; until i = max_num -\u0026gt; end repeat ; -\u0026gt; commit ; -\u0026gt; end $$ Query OK, 0 rows affected, 2 warnings (0.01 sec) mysql\u0026gt; DELIMITER $$ mysql\u0026gt; CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10)) -\u0026gt; BEGIN -\u0026gt; DECLARE i INT DEFAULT 0; -\u0026gt; SET autocommit = 0; -\u0026gt; REPEAT -\u0026gt; SET i = i + 1; -\u0026gt; INSERT INTO dept (deptno,dname,loc) VALUES((START+i),rand_string(10), rand_string(8)); -\u0026gt; UNTIL i = max_num -\u0026gt; END REPEAT; -\u0026gt; COMMIT; -\u0026gt; END $$ Query OK, 0 rows affected, 2 warnings (0.01 sec) #调用存储过程 mysql\u0026gt; delimiter ; mysql\u0026gt; call insert_dept(100,10); Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from dept ; +----+--------+------------+----------+ | id | deptno | dname | loc | +----+--------+------------+----------+ | 1 | 101 | sqzyWknJJc | uPRPyWny | | 2 | 102 | JIzyTYkhea | MMwVrWFn | | 3 | 103 | yJHubWCauW | yDuqsQbL | | 4 | 104 | zpcqwlOlOo | amifZKyp | | 5 | 105 | dygjEsdkSJ | PXrTreuK | | 6 | 106 | sImmyFJrNO | JOaNOEFl | | 7 | 107 | sclZmoJqML | uOLngSTP | | 8 | 108 | wKlcBBdKqB | HJlkuqvf | | 9 | 109 | phTUTIJwhu | ELSeUlwz | | 10 | 110 | jvArhMohVh | WoFhVhYw | +----+--------+------------+----------+ 10 rows in set (0.00 sec) mysql\u0026gt; call insert_emp(100001,500000); Query OK, 0 rows affected (31.37 sec) image-20211018214549181\rshow Profile 是什么 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况 可以用于sql的调优测量\n默认情况下,参数处于关闭状态,并保存最近15次的运行结果\n分析步骤\n是否支持 , 看看当前的mysql版本是否支持\nmysql\u0026gt; show variables like \u0026#39;%profiling%\u0026#39;; +------------------------+-------+ | Variable_name | Value | +------------------------+-------+ | have_profiling | YES | | profiling | OFF | | profiling_history_size | 15 | +------------------------+-------+ 3 rows in set, 1 warning (0.00 sec) 开启功能,默认是关闭,使用前需要开启\nmysql\u0026gt; set profiling = on ; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt; show variables like \u0026#39;%profiling%\u0026#39;; +------------------------+-------+ | Variable_name | Value | +------------------------+-------+ | have_profiling | YES | | profiling | ON | | profiling_history_size | 15 | +------------------------+-------+ 3 rows in set, 1 warning (0.00 sec) 运行SQL\n查看结果,show profiles\nmysql\u0026gt; show profiles ; +----------+------------+------------------------------------------------------------------+ | Query_ID | Duration | Query | +----------+------------+------------------------------------------------------------------+ | 1 | 0.00142325 | show variables like \u0026#39;%profiling%\u0026#39; | | 2 | 0.00311650 | select * from tbl_emp | | 3 | 0.00040100 | select * from tbl_emp | | 4 | 0.00018025 | SELECT DATABASE() | | 5 | 0.00356750 | select * from tbl_emp | | 6 | 0.00046875 | select * from tbl_emp e inner join tbl_dept on e.deptid = d.id | | 7 | 0.00317325 | select * from tbl_emp e inner join tbl_dept d on e.deptid = d.id | | 8 | 0.00029500 | select * from tbl_emp e inner join tbl_dept d on e.deptid = d.id | | 9 | 0.00031975 | select * from tbl_emp e left join tbl_dept d on e.deptid = d.id | | 10 | 0.00016175 | SELECT DATABASE() | | 11 | 0.48647650 | select * from emp group by id%10 limit 150000 | | 12 | 0.46590675 | select * from emp group by id%20 order by 5 | +----------+------------+------------------------------------------------------------------+ 12 rows in set, 1 warning (0.00 sec) 诊断sql,show profile cpu ,block io for query 上一步前面的问题sql数字号码 ; mysql\u0026gt; show profile cpu , block io for query 7; +--------------------------------+----------+----------+------------+--------------+---------------+ | Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | +--------------------------------+----------+----------+------------+--------------+---------------+ | starting | 0.000054 | 0.000000 | 0.000000 | NULL | NULL | | Executing hook on transaction | 0.000003 | 0.000000 | 0.000000 | NULL | NULL | | starting | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | checking permissions | 0.000002 | 0.000000 | 0.000000 | NULL | NULL | | checking permissions | 0.000003 | 0.000000 | 0.000000 | NULL | NULL | | Opening tables | 0.000041 | 0.000000 | 0.000000 | NULL | NULL | | init | 0.000004 | 0.000000 | 0.000000 | NULL | NULL | | System lock | 0.000007 | 0.000000 | 0.000000 | NULL | NULL | | optimizing | 0.000012 | 0.000000 | 0.000000 | NULL | NULL | | statistics | 0.000027 | 0.000000 | 0.000000 | NULL | NULL | | preparing | 0.000017 | 0.000000 | 0.000000 | NULL | NULL | | executing | 0.002927 | 0.000000 | 0.000000 | NULL | NULL | | end | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | query end | 0.000002 | 0.000000 | 0.000000 | NULL | NULL | | waiting for handler commit | 0.000007 | 0.000000 | 0.000000 | NULL | NULL | | closing tables | 0.000006 | 0.000000 | 0.000000 | NULL | NULL | | freeing items | 0.000041 | 0.000000 | 0.000000 | NULL | NULL | | cleaning up | 0.000013 | 0.000000 | 0.000000 | NULL | NULL | +--------------------------------+----------+----------+------------+--------------+---------------+ #看看耗时多的 找结论 image-20211019231456204\r日常开发需要注意的结论 converting heap to myisam 查询结果太大 , 内存不够用了往磁盘上搬 creating temp table 创建临时表 拷贝数据到临时表 用完再删除 copying to tmp table on dist 把内存中临时表复制到磁盘,危险!! locked #使用temp临时表很消耗时间 要创建 拷贝 处理 释放 mysql\u0026gt; show profile cpu , block io for query 11; +--------------------------------+----------+----------+------------+--------------+---------------+ | Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out | +--------------------------------+----------+----------+------------+--------------+---------------+ | starting | 0.000078 | 0.000000 | 0.000000 | NULL | NULL | | Executing hook on transaction | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | starting | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | checking permissions | 0.000004 | 0.000000 | 0.000000 | NULL | NULL | | Opening tables | 0.000264 | 0.000000 | 0.000000 | NULL | NULL | | init | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | System lock | 0.000005 | 0.000000 | 0.000000 | NULL | NULL | | optimizing | 0.000003 | 0.000000 | 0.000000 | NULL | NULL | | statistics | 0.000015 | 0.000000 | 0.000000 | NULL | NULL | | preparing | 0.000011 | 0.000000 | 0.000000 | NULL | NULL | | Creating tmp table | 0.000055 | 0.000000 | 0.000000 | NULL | NULL | | executing | 0.485898 | 0.421875 | 0.046875 | NULL | NULL | | end | 0.000010 | 0.000000 | 0.000000 | NULL | NULL | | query end | 0.000003 | 0.000000 | 0.000000 | NULL | NULL | | waiting for handler commit | 0.000017 | 0.000000 | 0.000000 | NULL | NULL | | closing tables | 0.000007 | 0.000000 | 0.000000 | NULL | NULL | | freeing items | 0.000074 | 0.000000 | 0.000000 | NULL | NULL | | cleaning up | 0.000019 | 0.000000 | 0.000000 | NULL | NULL | +--------------------------------+----------+----------+------------+--------------+---------------+ 18 rows in set, 1 warning (0.00 sec) 全局查询日志 配置启用 image-20211019232353049\r编码启用 image-20211019232435273\rmysql\u0026gt; set global general_log = 1 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; set global log_output = \u0026#39;TABLE\u0026#39; ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from dept ; +----+--------+------------+----------+ | id | deptno | dname | loc | +----+--------+------------+----------+ | 1 | 101 | sqzyWknJJc | uPRPyWny | | 2 | 102 | JIzyTYkhea | MMwVrWFn | | 3 | 103 | yJHubWCauW | yDuqsQbL | | 4 | 104 | zpcqwlOlOo | amifZKyp | | 5 | 105 | dygjEsdkSJ | PXrTreuK | | 6 | 106 | sImmyFJrNO | JOaNOEFl | | 7 | 107 | sclZmoJqML | uOLngSTP | | 8 | 108 | wKlcBBdKqB | HJlkuqvf | | 9 | 109 | phTUTIJwhu | ELSeUlwz | | 10 | 110 | jvArhMohVh | WoFhVhYw | +----+--------+------------+----------+ 10 rows in set (0.01 sec) mysql\u0026gt; select * from mysql.general_log ; +----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ | event_time | user_host | thread_id | server_id | command_type | argument | +----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ | 2021-10-19 23:25:31.577792 | root[root] @ localhost [::1] | 12 | 1 | Query | 0x73656C656374202A2066726F6D2064657074 | | 2021-10-19 23:25:44.682913 | root[root] @ localhost [::1] | 12 | 1 | Query | 0x73656C656374202A2066726F6D206D7973716C2E67656E6572616C5F6C6F67 | +----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ 2 rows in set (0.00 sec) mysql\u0026gt; set global general_log = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; alter table mysql.general_log modify column argument varchar(100) not null ; Query OK, 3 rows affected (0.04 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql\u0026gt; set global general_log = 1 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from mysql.general_log ; +----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ | event_time | user_host | thread_id | server_id | command_type | argument | +----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ | 2021-10-19 23:25:31.577792 | root[root] @ localhost [::1] | 12 | 1 | Query | select * from dept | | 2021-10-19 23:25:44.682913 | root[root] @ localhost [::1] | 12 | 1 | Query | select * from mysql.general_log | | 2021-10-19 23:28:59.776726 | root[root] @ localhost [::1] | 12 | 1 | Query | set global general_log = 0 | +----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ 3 rows in set (0.01 sec) mysql锁机制 锁是计算机协调多个进程或线程并发访问某一资源的机制\n在数据库中,除传统的计算资源如CPU/RAM/IO等的争用以外,数据也是一种供许多用户共享的资源.如何保证数据并发访问的一致性,有效性是所有数据库必须解决的一个问题,锁冲突也是影响数据库并发访问性能的一个重要因素.从这个角度来说,锁对数据库而言显得尤为重要,也更加复杂.\nimage-20211019233809036\r锁的分类\n对数据操作的类型 读/写 读锁(共享锁):针对同一份数据,多个读操作可以同时进行而不会互相影响 写锁(排它锁):当前写操作没有完成前,它会阻断其他写锁和读锁 对数据操作的粒度 表锁/行锁 锁机制中的三锁\n表锁(偏读) 特点 偏向myisam存储引擎,开销小,加锁快,无死锁;锁定粒度大,发生锁冲突的概率最高,并发度最低 #建表 mysql\u0026gt; create table mylock( -\u0026gt; id int not null primary key auto_increment, -\u0026gt; name varchar(20) -\u0026gt; )engine myisam; Query OK, 0 rows affected (0.02 sec) #查看哪些上锁mysql\u0026gt; show open tables ; +--------------------+---------------------------+--------+-------------+ | Database | Table | In_use | Name_locked | +--------------------+---------------------------+--------+-------------+ | mysql | check_constraints | 0 | 0 | | mysql | column_type_elements | 0 | 0 | #加读写锁 mysql\u0026gt; lock table mylock read , emp write ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; show open tables ; +--------------------+---------------------------+--------+-------------+ | Database | Table | In_use | Name_locked | +--------------------+---------------------------+--------+-------------+ | mysql | check_constraints | 0 | 0 | | mysql | column_type_elements | 0 | 0 | | bigdata | emp | 1 | 0 | | mysql | general_log | 0 | 0 | | bigdata | mylock | 1 | 0 | +--------------------+---------------------------+--------+-------------+ #释放锁 mysql\u0026gt; unlock tables ; Query OK, 0 rows affected (0.00 sec) 加读锁\npowershell 中加锁\nmysql\u0026gt; lock table mylock read ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from mylock ; +----+------+ | id | name | +----+------+ | 1 | a | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+------+ 5 rows in set (0.00 sec) cmd中也能读\nmysql\u0026gt; use bigdata ; Database changed mysql\u0026gt; select * from mylock ; +----+------+ | id | name | +----+------+ | 1 | a | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+------+ 5 rows in set (0.01 sec) 但powershell中加了读锁,不能对该表进行写操作,也就是增删改操作,也不能对其他表进行crud操作\nmysql\u0026gt; update mylock set name = \u0026#39;a2\u0026#39; where id = 1 ; ERROR 1099 (HY000): Table \u0026#39;mylock\u0026#39; was locked with a READ lock and can\u0026#39;t be updated mysql\u0026gt; insert into mylock values(6,\u0026#39;ljs\u0026#39;); ERROR 1099 (HY000): Table \u0026#39;mylock\u0026#39; was locked with a READ lock and can\u0026#39;t be updated mysql\u0026gt; delete from mylock where id = 5 ; ERROR 1099 (HY000): Table \u0026#39;mylock\u0026#39; was locked with a READ lock and can\u0026#39;t be updated mysql\u0026gt; select * from emp ; ERROR 1100 (HY000): Table \u0026#39;emp\u0026#39; was not locked with LOCK TABLES 而cmd不能对该表进行写的操作,可以对该表进行读操作,写操作会阻塞,直到powershell中释放锁,但能对其他表进行crud操作\nmysql\u0026gt; update mylock set name = \u0026#39;a2\u0026#39; where id = 1 ; ^C -- query aborted ERROR 1317 (70100): Query execution was interrupted mysql\u0026gt; insert into mylock values(6,\u0026#39;ljs\u0026#39;); ^C -- query aborted ERROR 1317 (70100): Query execution was interrupted mysql\u0026gt; delete from mylock where id = 5 ; ^C -- query aborted ERROR 1317 (70100): Query execution was interrupted mysql\u0026gt; select * from emp ; +--------+--------+--------+----------+-----+------------+---------+--------+--------+ | id | empno | ename | job | mgr | hiredate | sal | comm | deptno | +--------+--------+--------+----------+-----+------------+---------+--------+--------+ | 1 | 100002 | lPrnpM | SALESMAN | 1 | 2021-10-18 | 2000.00 | 400.00 | 107 | | 2 | 100003 | NuIiSO | SALESMAN | 1 | 2021-10-18 | 2000.00 | 400.00 | 103 | 当powershell解锁后,cmd立刻得到执行\n#powershell端 mysql\u0026gt; unlock tables ; Query OK, 0 rows affected (0.01 sec) #cmd端 等到解锁后立刻执行 mysql\u0026gt; update mylock set name = \u0026#39;a2\u0026#39; where id = 1 ; Query OK, 1 row affected (19.80 sec) Rows matched: 1 Changed: 1 Warnings: 0 image-20211020200516110\rimage-20211020200614618\r加写锁\npowershell加写锁,其他未锁的表都访问不了\nmysql\u0026gt; lock table mylock write ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from mylock ; +----+------+ | id | name | +----+------+ | 1 | a2 | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+------+ 5 rows in set (0.01 sec) mysql\u0026gt; update mylock set name = \u0026#39;a4\u0026#39; where id =1 ; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; select * from emp ; ERROR 1100 (HY000): Table \u0026#39;emp\u0026#39; was not locked with LOCK TABLES cmd访问该表,发生阻塞,直至powershell解锁\nmysql\u0026gt; select * from mylock ; +----+------+ | id | name | +----+------+ | 1 | a4 | | 2 | b | | 3 | c | | 4 | d | | 5 | e | +----+------+ 5 rows in set (2.44 sec) image-20211020201254172\rimage-20211020201310837\rimage-20211020201455840\r表锁分析\nshow open tables ; 哪些表被锁了 通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定; show status like \u0026rsquo;table%\u0026rsquo; ; mysql\u0026gt; show status like \u0026#39;table%\u0026#39; ; +----------------------------+-------+ | Variable_name | Value | +----------------------------+-------+ | Table_locks_immediate | 104 | | Table_locks_waited | 0 | | Table_open_cache_hits | 89 | | Table_open_cache_misses | 24 | | Table_open_cache_overflows | 0 | +----------------------------+-------+ image-20211020203053434\r行锁 innodb存储引擎,开销大,加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低,并发度最高 innodb与myisam的最大不同有两点:一是支持事务transactioon;二是采用行级锁 事务\n事务及acid属性\nimage-20211020203617056\r并发事务处理带来的问题\n更新丢失 image-20211020203848386\r脏读 image-20211020204010474\r不可重复读 image-20211020204034952\r幻读 image-20211020204053892\r事务的并发隔离级别\nread uncommitted read committed repeatable read serializable image-20211020204239692\rmysql\u0026gt; show variables like \u0026#39;transaction_isolation\u0026#39; ; +-----------------------+-----------------+ | Variable_name | Value | +-----------------------+-----------------+ | transaction_isolation | REPEATABLE-READ | +-----------------------+-----------------+ 1 row in set, 1 warning (0.01 sec) 示例\nmysql\u0026gt; create table test_innodb_lock(a int(11),b varchar(16))engine=innodb; Query OK, 0 rows affected, 1 warning (0.04 sec) mysql\u0026gt; create index test_innodb_a_ind on test_innodb_lock(a); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; create index test_innodb_lock_b_ind on test_innodb_lock(b); Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 powershell中修改数据\nmysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; update test_innodb_lock set b = \u0026#39;4001\u0026#39; where a = 4 ; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 为保证数据一致性 在cmd中 拿到的肯定还是4000\nmysql\u0026gt; select * from test_innodb_lock ; +------+------+ | a | b | +------+------+ | 1 | b2 | | 3 | 3 | | 4 | 4000 | | 5 | 5000 | | 6 | 6000 | | 7 | 7000 | | 8 | 8000 | | 9 | 9000 | | 1 | b1 | +------+------+ powershell修改数据\nmysql\u0026gt; update test_innodb_lock set b = \u0026#39;4002\u0026#39; where a = 4 ; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 如果不提交 就发生了行锁 cmd中等到powershell中提交了 才会更新 否则会阻塞\nmysql\u0026gt; update test_innodb_lock set b = \u0026#39;4003\u0026#39; where a = 4 ; Query OK, 1 row affected (19.16 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.01 sec) 动不同的行是没有问题的\nimage-20211020210157165\r无索引行锁升级为表锁\npowershell中由于varchar没有加单引号‘’ 导致类型转换发生了索引失效\nmysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; update test_innodb_lock set a = 41 where b = 4000 ; Query OK, 0 rows affected (0.01 sec) Rows matched: 0 Changed: 0 Warnings: 0 理论上只是行锁，但是索引失效导致行锁升级为了表锁，操作其他行也发现表被锁住了\nmysql\u0026gt; select * from test_innodb_lock ; +------+------+ | a | b | +------+------+ | 1 | b2 | | 3 | 3 | | 4 | 4003 | | 5 | 5000 | | 6 | 6000 | | 7 | 7000 | | 8 | 8000 | | 9 | 9000 | | 1 | b1 | +------+------+ 9 rows in set (0.01 sec) mysql\u0026gt; update test_innodb_lock set b = \u0026#39;9002\u0026#39; where a =9 ; Query OK, 1 row affected (21.24 sec) Rows matched: 1 Changed: 1 Warnings: 0 间隙锁\ncmd中更新一个范围,还没提交\nmysql\u0026gt; update test_innodb_lock set b = \u0026#39;0629\u0026#39; where a\u0026gt;1 and a\u0026lt;6 ; Query OK, 3 rows affected (0.01 sec) Rows matched: 3 Changed: 3 Warnings: 0 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.01 sec) powershell中插入的话要等到cmd中commit的时候才能插入,否则会阻塞\nmysql\u0026gt; insert into test_innodb_lock values (2,\u0026#39;2000\u0026#39;); Query OK, 1 row affected (23.87 sec) 什么是间隙锁\n当我们使用范围条件而不是相等条件检索数据,并请求共享或排他锁时,innodb会给符合条件的已有数据记录的索引项加锁;对于键值再条件范围内但并不存在的记录,叫做间隙GAP\ninnodb也会对这个间隙加锁,这种锁机制就是所谓的间隙锁NETT \u0026ndash;KEY锁\n危害\n因为query执行过程中通过范围查找的话,它会锁定整个范围内所有的索引键值,即使这个键值并不存在\n间隙锁有一个比较致命的弱点,就是当锁定一个范围键值之后,即使某些不存在的键值也会被无辜的锁定,而造成锁定的时候无法插入锁定键值范围内的任何数据,在某些场景下这可能会对性能造成很大的危害\nimage-20211022212523821\r如何锁定一行\nselect xxx \u0026hellip; for update 锁定某一行后,其他的操作会被阻塞,直到锁定行的会话提交commit\ncmd使用begin \u0026hellip; for update 来锁定一行\nmysql\u0026gt; begin ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from test_innodb_lock where a = 8 for update ; +------+------+ | a | b | +------+------+ | 8 | 8000 | +------+------+ 1 row in set (0.01 sec) mysql\u0026gt; commit ; Query OK, 0 rows affected (0.01 sec) powershell不能对该行做改动,除非cmd提交了commit才会释放锁\nmysql\u0026gt; update test_innodb_lock set b = \u0026#39;xxx\u0026#39; where a = 8 ; ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction mysql\u0026gt; update test_innodb_lock set b = \u0026#39;xxx\u0026#39; where a = 8 ; Query OK, 1 row affected (2.17 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.01 sec) 案例结论 innodb存储引擎由于实现了行级锁定,虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一点,但是在整体并发处理能力方面要远远优于myisam的表级锁定的.当系统并发量较高的时候,innodb的整体性能和myisam相比就会有比较明显的优势了.\n但是,innodb的行级锁定同样也有其脆弱的一面,当我们使用不当的时候,可能会让innodb的整体性能表现不仅不能比myisam高,甚至可能会更差.\n如何分析行锁定\n通过检查innodb_row_lock变量来分析系统上的行锁的争夺情况\nmysql\u0026gt; show status like \u0026#39;innodb_row_lock%\u0026#39; ; +-------------------------------+--------+ | Variable_name | Value | +-------------------------------+--------+ | Innodb_row_lock_current_waits | 0 | | Innodb_row_lock_time | 117831 | | Innodb_row_lock_time_avg | 23566 | | Innodb_row_lock_time_max | 51419 | | Innodb_row_lock_waits | 5 | +-------------------------------+--------+ 5 rows in set (0.01 sec) image-20211022214707680\r优化建议 尽可能让所有数据检索都通过索引来完成,避免无索引行锁升级为表锁\n合理设计索引,尽量缩小锁的范围\n尽可能减少检索条件,避免使用间隙锁\n尽量控制事务大小,减少锁定资源量和时间长度\n尽可能低级别事务隔离\n页锁 开销和加锁时间介于表锁和行锁之间;会出现死锁;锁定粒度介于表锁和行锁之间,并发度一般\n主从复制 复制的基本原理 slave会从master读取binlog来进行数据同步 三步骤+原理图 复制的基本原则 每个slave只有一个master 每个slave只能有一个唯一的服务器ID 每个master可以有多个slave 复制的最大问题 延时 一主一从常见配置 mysql版本一致且后台以服务运行 主从都配置在[mysqld]节点下,都是小写 主机修改my.ini配置文件 [必须]主服务器唯一ID server-id =1 ; [必须]启用二进制日志 log-bin = 自己本地的路径/mysqlbin log-bin =C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\LAPTOP-FKVMDBSI-bin [可选]启用错误日志 log-err = 自己本地的路径/mysqlerr log-err=C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\LAPTOP-FKVMDBSI [可选]根目录 basedir=\u0026ldquo;自己本地路径\u0026rdquo; basedir=\u0026ldquo;C:/Program Files/MySQL/MySQL Server 8.0/\u0026rdquo; [可选]临时目录 好像不行再8.0版本中 tmpdir=\u0026ldquo;自己本地路径\u0026rdquo; tmpdir=\u0026ldquo;C:/Program Files/MySQL/MySQL Server 8.0/\u0026rdquo; [可选]数据目录 data=\u0026ldquo;自己本地路径/Data/\u0026rdquo; datadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data read-only = 0 主机,读写都可以 [可选]设置不要复制的数据库 binlog-ignore-db=不需要复制的主数据库名字 [可选]设置需要复制的数据库 binlog-do-db=需要复制的主数据库名字 从机修改my.cnf配置文件 [必选]从服务器唯一ID [可选]启用二进制日志 因修改过配置文件,请主机+从机都重启后台mysql服务 主机从机都关闭防火墙 windows手动关闭 关闭虚拟机linux防火墙 service iptables stop 在windows主机上建立账户并授权slave create user \u0026lsquo;zhangsan\u0026rsquo;@\u0026lsquo;192.168.202.64\u0026rsquo; identified by \u0026lsquo;123456\u0026rsquo;; grant replication slave on *.* to \u0026lsquo;zhangsan\u0026rsquo; @ \u0026lsquo;192.168.202.64\u0026rsquo; ; 8.0 不支持grant的时候用identified by flush privileges ; 刷新权限 查询master的状态 show master status ; 记录下file和position的值 在linux从机上配置需要复制的主机 change master to master_host=\u0026lsquo;ip地址\u0026rsquo; , master_user =\u0026lsquo;授权的用户\u0026rsquo; , master_password = \u0026lsquo;密码\u0026rsquo; , master_log_file=\u0026lsquo;mysqlbin.具体数字\u0026rsquo;,master_log_pos = 具体值; change master to master_host=\u0026lsquo;192.168.202.64\u0026rsquo; , master_user =\u0026lsquo;zhangsan\u0026rsquo; , master_password = \u0026lsquo;123456\u0026rsquo; , master_log_file=\u0026lsquo;LAPTOP-FKVMDBSI-bin.000105\u0026rsquo;,master_log_pos = 156; 启动从服务器复制功能 start slave ; show slave status \\G ; 下面两个参数都是yes的话,则说明主从配置成功! slave_io_running :yes slave_sql_running :yes 主机新建库/新建表/insert记录/从机复制 如何停止从服务复制功能 stop slave ; 三步骤+原理图\nimage-20211022215731804\r主从复制配置过程 主机\n设置主服务器\nimage-20211023100459506\r设置二进制日志文件\nimage-20211023095228167\r设置错误文件\nimage-20211023095304402\rimage-20211023100542517\r设置读写都可以 设置忽略和需要复制的数据库 设置数据库目录位置\nimage-20211023101034426\r这里有个坑,使用WSL,linux子系统的话不设置端口会导致端口占用,必须把windows上的mysql服务关掉,linuxmysql才能start 所以再配置文件里改一下端口号试试看\nimage-20211023113130359\r弄完重启主机从机的mysql服务\n在windows主机中授权 从000104的912行开始抄书 复制的数据库是bigdata 忽略的数据库是mysql\nmysql\u0026gt; create user \u0026#39;zhangsan\u0026#39;@\u0026#39;192.168.202.64\u0026#39; identified by \u0026#39;123456\u0026#39;; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; grant replication slave,replication client on *.* to \u0026#39;zhangsan\u0026#39;@\u0026#39;192.168.202.64\u0026#39; ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; flush privileges ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; show master status ; +----------------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +----------------------------+----------+--------------+------------------+-------------------+ | LAPTOP-FKVMDBSI-bin.000104 | 912 | bigdata | mysql | | +----------------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) binlog_do_db为空说明都要复制,我重新设置一下\nimage-20211023115552278\r重启服务,查看状态\nmysql\u0026gt; show master status ; +----------------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +----------------------------+----------+--------------+------------------+-------------------+ | LAPTOP-FKVMDBSI-bin.000105 | 156 | | mysql | | +----------------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) 接下来进入linux命令行进行操作 通过 Last_IO_Errno 和 Last_SQL_Errno 来排查问题 简单的\nmysql\u0026gt; change master to master_host=\u0026#39;192.168.202.64\u0026#39; , master_user =\u0026#39;zhangsan\u0026#39; , master_password = \u0026#39;123456\u0026#39; , master_log_file=\u0026#39;LAPTOP-FKVMDBSI-bin.000105\u0026#39;,master_log_pos = 156; Query OK, 0 rows affected, 8 warnings (0.00 sec) mysql\u0026gt; start slave ; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt; show slave status \\G ; *************************** 1. row *************************** Slave_IO_State: Waiting for source to send event Master_Host: 192.168.202.64 Master_User: zhangsan Master_Port: 3306 Connect_Retry: 60 Master_Log_File: LAPTOP-FKVMDBSI-bin.000105 Read_Master_Log_Pos: 156 Relay_Log_File: yourtreedad-relay-bin.000003 Relay_Log_Pos: 334 Relay_Master_Log_File: LAPTOP-FKVMDBSI-bin.000105 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 156 Relay_Log_Space: 549 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: 3a5f9439-a33e-11eb-85f6-002b67a4fefa Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Replica has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: Master_public_key_path: Get_master_public_key: 0 Network_Namespace: 1 row in set, 1 warning (0.00 sec) ERROR: No query specified image-20211023150356197\r起飞!!!\n完结撒花~~~\n😜😋🤣😊\n","date":"2021-10-12T19:35:55+08:00","image":"https://jianrongma.github.io/hutomo-abrianto-l2jk-uxb1BY-unsplash.jpg","permalink":"https://jianrongma.github.io/p/test-chinese/","title":"Mysql高级"},{"content":"mysql学习文档 一 为什么要学习数据库 二 数据库的相关概念 DBMS DB SQL\n三 数据库存储数据的特点 四 初始mysql mysql产品的介绍\nmysql产品的安装\nmysql服务的启动和停止\nmysql服务的登陆和退出\nmysql的常见命令和语法规范\n五DQL语言的学习 基础查询\n条件查询\n排序查询\n常见函数\n分组查询\n连接查询\n子查询\n分页查询\nunion联合查询\n六 DML语言的学习 插入语句\n修改语句\n删除语句\n七 DDL语言的学习 库和表的管理\n常见数据类型介绍\n常见约束\n保存数据的容器:\n数组 集合 内存数据 断电就没了\n文件 但是文件不好查找\n因此把文件做成方便增删改查的软件 对文件进行操作 这样的软件就叫做数据库\n数据库的好处 实现数据持久化 使用完整的管理系统统一管理,易于查询 数据库的概念 DB 数据库 database:存储数据的仓库,保存了一系列有组织的数据.\nDBMS 数据库管理系统 database management system 数据库是通过dbms创建和操作的容器\n常见的数据库管理系统 mysql oracle db2 sqlserver\nSQL 结构化查询语言 structure query language :专门用来与数据库通信的语言\nsql的优点:\n不是某个特定数据库供应商专有的语言,几乎所有DBMS都支持sql 简单易学 虽然简单,但实际上是一种强有力的语言,灵活使用其语言元素,可以进行非常复杂和高级的数据库操作 类似于管家 管理 文件柜 DBMS 管理 DB\n数据库的特点 将数据放到表中,表再放到库中 一个数据库中够可以有多个表,每个表都有一个自己的名字,用来标识自己,表名具有唯一性 表具有一些特性,这些特性定义了数据在表中如何存储,类似java中类的设计 表由列组成,我们也称为字段.所有表都是由一个或多个列组成的,每个列类似java中的属性 表中的数据是按行存储的,每一行类似于java中的对象 Mysql产品的特点 mysql数据库隶属于mysqlab公司,总部位于瑞典,后被oracle收购 优点 成本低:开放源代码,一般可以免费使用 性能高:执行很快 简单:很容易安装和使用 DBMS分为两类 基于共享文件系统的DBMS 例如 access 基于客户机\u0026mdash;服务器的DBMS 例如 mysql oracle sqlserver mysql版本 社区版 免费 企业版 收费 mysql卸载 先控制面板卸载\n然后在安装目录下删除文件夹\n然后在programdata中删除残余文件\n清理注册表\nimage-20210919154523464\rmy.ini 配置文件 image-20210919160841225\r端口号 安装位置 数据存放位置 字符集 默认存储引擎 语法模式 最大连接数\n改完服务需要重启\nmysql服务的启动和停止 image-20210919161439996\rmysql服务端的登陆和退出 使用mysql command line client 不建议 只适用于root用户 image-20210919161620401\rimage-20210919161637466\r2.命令行 p输入密码不能有空格 -h 主机名 -P 端口号 -u 用户名 -p密码\nimage-20210919161848290\r简化命令 退出exit 或者 ctrl+C\nimage-20210919161938321\r基本命令\nshow databases ; use tset ; //进入数据库 image-20210919163057930\rshow tables ; //查看数据库里的表 在当前用户进入的数据库中查看 show tables from sys ; //查看数据库里的表 可以在当前数据库中查看别的数据库中的表 select database() ; //查看当前处于什么位置 类似于linux中的 pwd create table ... //创建表 image-20210919163334648\rdesc stuInfo ; //查看表stuInfo中的字段 insert into stuInfo(id,name) value (1,\u0026#39;ljs\u0026#39;) ; delete from stuInfo where id = 1; update stuInfo set name =\u0026#39;jwt\u0026#39; where id =1; select * from stuInfo ; #增删改查 image-20210919163430191\r练习\nimage-20210919164509494\rsql select version() ; //查看版本号 sql中 cmd mysql --version mysql -V mysql的语法规范 不区分大小写,但建议关键字大写,表名 列名小写 每条命令用分号结尾 每条命令根据需要,可以进行缩进或者换行 注释 单行注释 #注释文字 \u0026ndash; 注释文字 (必须要有空格) 多行注释 /* lkdfjasldfj */ 基础查询 select 查询列表 from 表名\n查询列表可以是:表中的字段 / 常量值 / 表达式 / 函数 查询的结果可以是一个虚拟的表格 查询单个字段\n查询多个字段\n查询所有字段\nselect * 不能控制字段的显示顺序\n之所以用`` 着重号 第一为了直白,第二为了区分关键字 防止与关键字重名\n查询常量\n查询表达式\n查询函数\nimage-20210919202609756\rselect 100 ; select \u0026#39;join\u0026#39; ; select 100*98 ; select database () ; select version () ; show tables ; 起别名 方便理解 如果要查询的字段有重名的情况,使用别名可以区分开来\n方式一: 使用as\n方式二: 直接不用as\nselect last_name as 姓 ,first_name as 名 from employees ; select last_name 姓 ,first_name 名 from employees ; # 防止歧义 双引号也行 单引号也可以 select salary as `out put` from employees ; 去重\nselect database() ; show tables ; desc employees ; select distinct department_id from employees ; image-20210919203515527\r+号的作用\n姓名连接成一个字段 , 显示为姓名\n以下错误\nimage-20210919203805417\rjava中的+号:\n运算符 , 操作数为数值型 连接符, 只要有一个操作数为字符串 mysql中的+号:\n仅仅只有一个功能:运算符 select 100+90 ;\nselect \u0026lsquo;123\u0026rsquo; +90 ; 其中一方为字符型,视图将字符型数值转换为数值型, 如果转换成功,则继续做加法运算\nselect \u0026lsquo;james\u0026rsquo; + 90 ; 如果转换失败,则将字符型数值转换成0\nselect null +10 ; 只要其中一方为null , 则结果肯定为null image-20210919204251938\r所以需要使用函数 concat() ;\n#这是错误的用法 , 加上了单引号 , 无法解析 select concat (\u0026#39;last_name\u0026#39; , \u0026#39;first_name\u0026#39;) 姓名 from employees ; #这是正确的 select concat (last_name , first_name) 姓名 from employees ; 显示出表employees中的全部列,各个列之间用逗号连接,列头显示成out_put #查看某表列名 select column_name fuck_name from information_schema.columns where table_schema = \u0026#39;myemployees\u0026#39; and table_name = \u0026#39;employees\u0026#39; ; #没问题 因为不存在null select concat (employee_id ,\u0026#39;,\u0026#39;,first_name ) from employees ; #有问题 因为存在null , 导致那行都变成null 了 select concat (employee_id ,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,commission_pct ) from employees ; +----------------------------------------------------------+ | concat (employee_id ,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,commission_pct ) | +----------------------------------------------------------+ | NULL | | NULL | | NULL | | NULL | | NULL | 引入函数 IFNULL select IFNULL(a,b) select ifnull(commission_pct,0) as 奖金率, commission_pct from employees ; mysql\u0026gt; select ifnull(commission_pct,0) as 奖金率, commission_pct from employees ; +--------+----------------+ | 奖金率 | commission_pct | +--------+----------------+ | 0.00 | NULL | | 0.00 | NULL | | 0.00 | NULL | | 0.00 | NULL | | 0.00 | NULL | | 0.00 | NULL | | 0.40 | 0.40 | | 0.30 | 0.30 | | 0.30 | 0.30 | #这是正确的 select concat (employee_id ,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,ifnull(commission_pct,0) ) from employees ; +--------------------------------------------------------------------+ | concat (employee_id ,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,ifnull(commission_pct,0) ) | +--------------------------------------------------------------------+ | 142,Curtis,0.00 | | 143,Randall,0.00 | | 144,Peter,0.00 | | 161,Sarath,0.25 | | 169,Harrison,0.20 | | 170,Tayler,0.20 | | 171,William,0.15 | 条件查询 select 查询列表 from 表名 where 筛选条件 ; 先查表名有没有在,再筛选,再查询\n分类\n按条件表达式筛选 条件运算符 \u0026gt; \u0026lt; = \u0026lt;\u0026gt;(不等于) 按逻辑表达式筛选 作用用于连接条件表达式 \u0026amp;\u0026amp; || ! and or not 模糊查询 like between and in is null #条件运算符 select * from employees where salary \u0026gt;12000 ; #逻辑运算符 select first_name , department_id from employees where department_id \u0026lt;\u0026gt; 90 ; #逻辑表达式筛选 select first_name , salary , commission_pct from employees where salary \u0026gt;10000 and salary \u0026lt;20000 ; #好像三个不太一样 select * from employees where not(department_id between 90 and 120) or salary \u0026gt;15000 ; select * from employees where department_id not in(90, 120) or salary \u0026gt;15000 ; select * from employees where department_id not in(department_id between 90 and 120) or salary \u0026gt;15000 ; 模糊查询\nlike 一般和通配符使用 % 0到任意个字符 _ 任意一个字符 between and in is null | is not null #模糊查询 select * from employees where first_name like \u0026#39;%a%\u0026#39; ; select first_name , salary from employees where first_name like \u0026#39;__e_a%\u0026#39; ; #如果不想使用转义字符 , 第二个字符就是_ 而不是任意单个字符的话 mysql\u0026gt; select last_name from employees where last_name like \u0026#39;_\\_%\u0026#39; ; +-----------+ | last_name | +-----------+ | K_ing | | K_ing | +-----------+ 2 rows in set (0.00 sec) #或者使用以下这种 使用ESCAPE 来取消转义 mysql\u0026gt; select last_name from employees where last_name like \u0026#39;_$_%\u0026#39; escape \u0026#39;$\u0026#39; ; +-----------+ | last_name | +-----------+ | K_ing | | K_ing | +-----------+ 2 rows in set (0.00 sec) mysql\u0026gt; select last_name from employees where last_name like \u0026#39;_h_%\u0026#39; escape \u0026#39;h\u0026#39; ; +-----------+ | last_name | +-----------+ | K_ing | | K_ing | +-----------+ 2 rows in set (0.00 sec) between and 提高语句简洁度 左右都包含临界值 不能颠倒顺序 #左闭右闭 select * from employees where employee_id between 100 and 120 ; in 判断某字段的值是否属于in列表中的某一项 使用 in 提高语句的简洁度\nin 列表的值类型必须一致或兼容\nin 不支持通配符 毕竟不是like关键字\nselect employee_id , job_id from employees where job_id in(\u0026#39;IT_PROG\u0026#39;,\u0026#39;AD_VP\u0026#39;,\u0026#39;AD_PRES\u0026#39;) ; is null = 或 \u0026lt;\u0026gt; 不能用于判断null值 select first_name , commission_pct from employees where commission_pct is null ; is not null 安全等于 \u0026lt;=\u0026gt; #安全等于可以用来判断是不是为空 select first_name , commission_pct from employees where commission_pct \u0026lt;=\u0026gt; null ; #安全等于也可以用来判断是不是某个数值 mysql\u0026gt; select last_name , salary from employees where salary \u0026lt;=\u0026gt; 12000 ; +-----------+----------+ | last_name | salary | +-----------+----------+ | Greenberg | 12000.00 | | Errazuriz | 12000.00 | | Higgins | 12000.00 | +-----------+----------+ 3 rows in set (0.00 sec) 安全等于和is null 的区别 is null 仅仅可以判断null值 , 可读性较高 , 建议使用\n\u0026lt;=\u0026gt; 既可以判断null值,又可以判断普通的数值\n复习一下 mysql 与mysql的第一次亲密接触 数据库的好处 持久化数据到本地 结构化查询 数据库的常见概念 DB 数据库,存储数据的容器 DBMS 数据库管理系统, 又称为数据库软件或数据库产品,用于创建或管理DB SQL 结构化查询语言 ,用于和数据库通信的语言,不是某个数据库软件特有的,而是几乎所有的主流数据库软件通用的语言 数据库存储的特点 数据存放到表中,然后表再存放到库中 一个库中可以有多张表,每张表具有唯一的表名用以标识自己 表有一个或多个列,列又称为字段,相当于java中的属性 表中的每一行数据,相当于java中的对象 常见的数据库管理系统 mysq oracle db2 sqlserver\nmysql的介绍 mysql的背景 前身属于瑞典的一家公司 mysql ab , 08被sun收购 , 09年被oracle收购\nmysql的优点 开源免费成本低 性能高 , 移植性好 体积小,便于安装 mysql的安装 属于c/s架构的软件,一般来讲是安装服务端\n企业版/社区版\n环境变量配置\nmysql服务的启动和停止 net start mysql\n图形化界面里开服务\nmysql服务的登陆和退出 mysql -h localhost -P 3306 -u root -p123456\nexit或者ctrl+C\nDQL语言 基础查询 select 查询列表 from 表名\n特点\n查询列表可以是字段/常量 / 表达式/ 函数/ 也可以是多个 查询结果是一个虚拟表 示例\n查询单个字段 select 字段名 from 表名 ;\n查询多个字段 select 字段名 , 字段名 from 表名 ;\n查询所有字段 select * from 表名 ;\n查询常量 select 常量 as \u0026hellip; ;\n注意:字符型和日期型的常量值必须用单引号引起来,数值型不需要\n查询函数 select 函数名(实参列表) ;\n查询表达式 select 100%98 ;\n起别名 as 空格 去重 distinct 只能给一个参数用\n+号的作用 只能做加法运算\nselect 数值+数值 ; 直接运算\nselect 字符 +数值 ; 尝试隐式转换然后运算 , 成功就成功,不成功就是0+数值\nselect null + 数值; 返回null\nconcat函数 拼接字符\nselect concat (字符1 , 字符2 , 字符3 \u0026hellip;) ;\nifnull函数 判断某自字段或表达式是否为null , 如果为null 返回指定的值, 否则返回原本的值\nselect ifnull(commission_pct,0) from employees ; 如果是null则返回0 , 如果不是null , 则返回原值\nisnull函数 判断是不是null , 是的话返回1 , 否的话就返回0\n条件查询 select 查询列表 from 表名 where 筛选条件\n筛选条件的分类\n简单条件运算符 \u0026gt; \u0026lt; = \u0026lt;\u0026gt; \u0026lt;=\u0026gt; \u0026gt;= \u0026lt;= 逻辑运算符 || \u0026amp;\u0026amp; ! and or not 模糊查询 like in is null is not null between and\nlike :一般搭配通配符使用, 用于判断字符型数值, 在5.5版本之后 , 也可以判断int类型的 , % 和 _ 区别\nmysql\u0026gt; select * from employees where department_id like \u0026#39;1__\u0026#39; ; +-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ | 108 | Nancy | Greenberg | NGREENBE | 515.124.4569 | FI_MGR | 12000.00 | NULL | 101 | 100 | 1998-03-03 00:00:00 | | 109 | Daniel | Faviet | DFAVIET | 515.124.4169 | FI_ACCOUNT | 9000.00 | NULL | 108 | 100 | 1998-03-03 00:00:00 | | 110 | John | Chen | JCHEN | 515.124.4269 | FI_ACCOUNT | 8200.00 | NULL | 108 | 100 | 2000-09-09 00:00:00 | | 111 | Ismael | Sciarra | ISCIARRA | 515.124.4369 | FI_ACCOUNT | 7700.00 | NULL | 108 | 100 | 2000-09-09 00:00:00 | | 112 | Jose Manuel | Urman | JMURMAN | 515.124.4469 | FI_ACCOUNT | 7800.00 | NULL | 108 | 100 | 2000-09-09 00:00:00 | | 113 | Luis | Popp | LPOPP | 515.124.4567 | FI_ACCOUNT | 6900.00 | NULL | 108 | 100 | 2000-09-09 00:00:00 | | 205 | Shelley | Higgins | SHIGGINS | 515.123.8080 | AC_MGR | 12000.00 | NULL | 101 | 110 | 2016-03-03 00:00:00 | | 206 | William | Gietz | WGIETZ | 515.123.8181 | AC_ACCOUNT | 8300.00 | NULL | 205 | 110 | 2016-03-03 00:00:00 | +-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ 8 rows in set (0.00 sec) is null 和\u0026lt;=\u0026gt; 的区别 is null 只会判断null\n\u0026lt;=\u0026gt; 不仅判断null 还可以普通类型的数值\n排序查询 select 查询列表 from 表 where 筛选条件 order by 排序列表 asc|desc\n默认是asc 升序\n支持单个字段/多个字段/表达式/函数/别名\norder by 一般是放在查询语句的最后面 limit子句除外\n按表达式排序 按字段排序 按别名排序 按函数排序 按多字段排序 select * from employees order by salary desc ; select * from employees order by salary asc ; #默认升序 asc select * from employees where department_id \u0026gt;=90 order by hiredate desc ; # *必须放在前面 可以按照表达式排序 也可以按照别名排序 select * , salary*12*(1+ifnull(commission_pct,0))as 年薪 from employees order by 年薪 desc; # 按照函数排序 select last_name , salary from employees order by length(last_name) desc ; #双重排序 先按照工资升序排 , 再按照员工编号降序排 select * from employees order by salary asc , employee_id desc ; 练习\nselect last_name , department_id , salary * 12 * (1+ifnull(commission_pct,0)) as 年薪 from employees order by 年薪 desc , length(last_name) asc ; #以下用法 错误 between and 不能 按照 别名来 select last_name , salary as 工资 from employees where not(工资 between 8000 and 17000) order by 工资 ; #以下用法 正确 select last_name , salary as 工资 from employees where not(salary between 8000 and 17000) order by 工资 ; #可以这样 直接 not between and select last_name , salary as 工资 from employees where salary not between 8000 and 17000 order by 工资 select * from employees where email like \u0026#39;%e%\u0026#39; order by length(email) desc , department_id ; 常见函数 功能:类似于java中的方法,将一组逻辑语句封装在方法体中,对外暴露方法名\n好处:1.隐藏了实现细节 2.提高代码的重用性\n调用: select 函数名(实参列表) [from 表] ;\n特点:\n叫什么 函数名 干什么 函数功能 分类：\n单行函数 字符函数 length concat substr substring replace lpad rpad upper lower instr trim 数学函数 mod floor round ceil truncate 日期函数 now curdate curtime year month monthname day hour minute second date_format str_to_date 其他函数 流程控制函数 concat / length / ifnull 等 分组函数 做统计使用 又称为统计函数、聚合函数、组函数 #查看字节长度 mysql\u0026gt; select length(\u0026#39;lalala\u0026#39;) ; +------------------+ | length(\u0026#39;lalala\u0026#39;) | +------------------+ | 6 | +------------------+ 1 row in set (0.00 sec) #查看字节长度 mysql\u0026gt; select length (\u0026#39;林健树\u0026#39;) ; +-------------------+ | length (\u0026#39;林健树\u0026#39;) | +-------------------+ | 6 | +-------------------+ 1 row in set (0.00 sec) #展示字符集 mysql\u0026gt; show variables like \u0026#39;%char%\u0026#39; ; +--------------------------+---------------------------------------------------------+ | Variable_name | Value | +--------------------------+---------------------------------------------------------+ | character_set_client | gbk | | character_set_connection | gbk | | character_set_database | utf8mb4 | | character_set_filesystem | binary | | character_set_results | gbk | | character_set_server | utf8mb4 | | character_set_system | utf8mb3 | | character_sets_dir | C:\\Program Files\\MySQL\\MySQL Server 8.0\\share\\charsets\\ | +--------------------------+---------------------------------------------------------+ #拼接字符 select concat(last_name , \u0026#39;_\u0026#39; , first_name ) from employees ; # upper / lower select upper(\u0026#39;aaabbbccc\u0026#39;) ; select lower(\u0026#39;aBc\u0026#39;) ; #函数嵌套 select concat(lower(last_name),\u0026#39;_\u0026#39;,upper(first_name)) from employees ; #substr / substring #sql中索引从1开始 mysql\u0026gt; select substring(\u0026#39;李莫愁爱上了陆展元\u0026#39;,7) out_put ; +---------+ | out_put | +---------+ | 陆展元 | +---------+ 1 row in set (0.00 sec) #函数的重载 从指定索引出指定字符长度的字符 mysql\u0026gt; select SUBSTRING(\u0026#39;李莫愁爱上了陆展元\u0026#39;,1,3) ; +-------------------------------------+ | SUBSTRING(\u0026#39;李莫愁爱上了陆展元\u0026#39;,1,3) | +-------------------------------------+ | 李莫愁 | +-------------------------------------+ 1 row in set (0.00 sec) select concat(concat(upper(substring(first_name,1,1)),substr(first_name,2)),\u0026#39;_\u0026#39;,last_name) from employees ; #instr 判断是否在字符串中 #返回的是第一次出现的索引 索引仍然从1开始 , 如果找不到返回0 mysql\u0026gt; select instr(\u0026#39;杨不悔爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;) ; +--------------------------------------+ | instr(\u0026#39;杨不悔爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;) | +--------------------------------------+ | 7 | +--------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select instr(\u0026#39;杨不悔尹柳霞爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;) out_put ; +---------+ | out_put | +---------+ | 4 | +---------+ 1 row in set (0.00 sec) #trim 去空格 mysql\u0026gt; select length(\u0026#39; 张翠山 \u0026#39;) , length (trim(\u0026#39; 张翠山 \u0026#39;)) ; +------------------------+--------------------------------+ | length(\u0026#39; 张翠山 \u0026#39;) | length (trim(\u0026#39; 张翠山 \u0026#39;)) | +------------------------+--------------------------------+ | 12 | 6 | +------------------------+--------------------------------+ 1 row in set (0.00 sec) #trim 可以去掉指定的字符或者字符串 中间不会去掉的 mysql\u0026gt; select trim(\u0026#39;a\u0026#39; from \u0026#39;aabbaaccaa\u0026#39;) as out_put ; +---------+ | out_put | +---------+ | bbaacc | +---------+ 1 row in set (0.00 sec) #trim 只是按照单位去去的 mysql\u0026gt; select trim(\u0026#39;aa\u0026#39; from \u0026#39;aaabbaaccaaa\u0026#39;) as out_put ; +----------+ | out_put | +----------+ | abbaacca | +----------+ 1 row in set (0.00 sec) #lpad 用指定的字符来实现左填充指定长度 mysql\u0026gt; select lpad(\u0026#39;殷素素\u0026#39;,10,\u0026#39;*\u0026#39;) ; +-----------------------+ | lpad(\u0026#39;殷素素\u0026#39;,10,\u0026#39;*\u0026#39;) | +-----------------------+ | *******殷素素 | +-----------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select lpad(\u0026#39;97\u0026#39;,3,\u0026#39;0\u0026#39;) ; +------------------+ | lpad(\u0026#39;97\u0026#39;,3,\u0026#39;0\u0026#39;) | +------------------+ | 097 | +------------------+ 1 row in set (0.00 sec) #lpad 如果长度超过了 反而会发生截断 从左边开始向右边截断 mysql\u0026gt; select lpad(\u0026#39;101\u0026#39;,2,\u0026#39;0\u0026#39;) ; +-------------------+ | lpad(\u0026#39;101\u0026#39;,2,\u0026#39;0\u0026#39;) | +-------------------+ | 10 | +-------------------+ 1 row in set (0.00 sec) #Rpad同理 #replace替换 mysql\u0026gt; select replace(\u0026#39;张无忌爱上了周芷若\u0026#39;,\u0026#39;周芷若\u0026#39;,\u0026#39;赵敏\u0026#39;) as out_put ; +------------------+ | out_put | +------------------+ | 张无忌爱上了赵敏 | +------------------+ 1 row in set (0.00 sec) #replace 凡是有的全部替换喔 mysql\u0026gt; select replace(\u0026#39;周芷若张无忌爱上了周芷若\u0026#39;,\u0026#39;周芷若\u0026#39;,\u0026#39;赵敏\u0026#39;) as out_put ; +----------------------+ | out_put | +----------------------+ | 赵敏张无忌爱上了赵敏 | +----------------------+ 1 row in set (0.00 sec) 数学函数 round 四舍五入\n#round 四舍五入 mysql\u0026gt; select round(4.65) ; +-------------+ | round(4.65) | +-------------+ | 5 | +-------------+ 1 row in set (0.00 sec) #round 两个参数时,后面的参数是值按小数点后几位来四舍五入 mysql\u0026gt; select round(4.65,1) ; +---------------+ | round(4.65,1) | +---------------+ | 4.7 | +---------------+ mysql\u0026gt; select round(4.65,0) ; +---------------+ | round(4.65,0) | +---------------+ | 5 | +---------------+ 1 row in set (0.00 sec) #ceil 向上取整 mysql\u0026gt; select ceil(1.001) ; +-------------+ | ceil(1.001) | +-------------+ | 2 | +-------------+ 1 row in set (0.00 sec) #floor 向下取整 mysql\u0026gt; select floor(-1.01) ; +--------------+ | floor(-1.01) | +--------------+ | -2 | +--------------+ 1 row in set (0.00 sec) #truncate 截断 保留小数点后几位 mysql\u0026gt; select truncate(1.6999,2) ; +--------------------+ | truncate(1.6999,2) | +--------------------+ | 1.69 | +--------------------+ 1 row in set (0.00 sec) #mod 取余运算 a-a/b*b a/b会发生截断的可能 所以这个等式没毛病 # -10 mod -3 = -1 -10 mod 3 = -1 10 mod -3 = 1 只要被除数是- 就是- mysql\u0026gt; select mod(10,-3) ; +------------+ | mod(10,-3) | +------------+ | 1 | +------------+ 1 row in set (0.00 sec) 日期函数 # now 返回当前系统日期 包含时间 mysql\u0026gt; select now() ; +---------------------+ | now() | +---------------------+ | 2021-09-20 16:00:28 | +---------------------+ 1 row in set (0.00 sec) # curdate 返回当前日期 不包含时间 mysql\u0026gt; select curdate() ; +------------+ | curdate() | +------------+ | 2021-09-20 | +------------+ 1 row in set (0.00 sec) # curtime 返回当前时间 不包含日期 mysql\u0026gt; select curtime() ; +-----------+ | curtime() | +-----------+ | 16:01:21 | +-----------+ 1 row in set (0.00 sec) #获取指定的部分 , 年 月 日 时 分 秒 mysql\u0026gt; select year(now()) 年 , month (\u0026#39;1998-1-1\u0026#39;) 月, day(curdate())日 ; +------+------+------+ | 年 | 月 | 日 | +------+------+------+ | 2021 | 1 | 20 | +------+------+------+ 1 row in set (0.00 sec) # 获取月份的英文 mysql\u0026gt; select monthname(hiredate) 月份英文, year(hiredate) from employees ; +-----------+----------------+ | 月份英文 | year(hiredate) | +-----------+----------------+ | April | 1992 | | April | 1992 | # 日期转换函数 str_to_date() date_format() mysql\u0026gt; select str_to_date (\u0026#39;9--10--2021\u0026#39;,\u0026#39;%m--%d--%Y\u0026#39;) as out_put ; +------------+ | out_put | +------------+ | 2021-09-10 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt; select date_format(\u0026#39;2021-09-20\u0026#39;,\u0026#39;%y年%m月%d日\u0026#39;) as out_put ; +--------------+ | out_put | +--------------+ | 21年09月20日 | +--------------+ 1 row in set (0.00 sec) # 前端传进来的是字符串 而且格式不一 我们要使用函数来将字符串做处理 解析成想要的格式 然后再到数据库中查找 mysql\u0026gt; select hiredate from employees where hiredate = str_to_date(\u0026#39;4-3 1992\u0026#39;,\u0026#39;%c-%d %Y\u0026#39;) ; +---------------------+ | hiredate | +---------------------+ | 1992-04-03 00:00:00 | | 1992-04-03 00:00:00 | | 1992-04-03 00:00:00 | | 1992-04-03 00:00:00 | | 1992-04-03 00:00:00 | +---------------------+ 5 rows in set (0.00 sec) #数据库这边也需要做好相应的处理 将日期处理成对应格式字符串然后返回回去 mysql\u0026gt; select last_name ,date_format(hiredate,\u0026#39;%m月/%d日 %y年\u0026#39;) as 入职日期 from employees where commission_pct \u0026lt;=\u0026gt; null ; +-------------+----------------+ | last_name | 入职日期 | +-------------+----------------+ | K_ing | 04月/03日 92年 | | Kochhar | 04月/03日 92年 | image-20210920161042293\rimage-20210920161613677\r其他函数 mysql\u0026gt; select version() ; +-----------+ | version() | +-----------+ | 8.0.24 | +-----------+ 1 row in set (0.00 sec) mysql\u0026gt; select database() ; +-------------+ | database() | +-------------+ | myemployees | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; select user() ; +----------------+ | user() | +----------------+ | root@localhost | +----------------+ 1 row in set (0.00 sec) 流程控制函数 # IF函数 true就是第二个参数 false就是第三个参数 mysql\u0026gt; select commission_pct , if(isnull(commission_pct)=0,\u0026#39;没奖金 呵呵\u0026#39;,\u0026#39;有奖金 嘻嘻\u0026#39;) 备注 from employees ; +----------------+-------------+ | commission_pct | 备注 | +----------------+-------------+ | NULL | 有奖金 嘻嘻 | | NULL | 有奖金 嘻嘻 | # mysql中默认 0就是第三个参数 1就是第二个参数 mysql\u0026gt; select commission_pct , if(isnull(commission_pct),\u0026#39;没奖金 呵呵\u0026#39;,\u0026#39;有奖金 嘻嘻\u0026#39;) 备注 from employees ; +----------------+-------------+ | commission_pct | 备注 | +----------------+-------------+ | NULL | 没奖金 呵呵 | | NULL | 没奖金 呵呵 | mysql\u0026gt; select commission_pct , if(isnull(commission_pct),concat(\u0026#39;没奖金 呵呵 \u0026#39;,0),concat(\u0026#39;有奖金 嘻嘻 \u0026#39;,commission_pct)) 备注 from employees ; +----------------+------------------+ | commission_pct | 备注 | +----------------+------------------+ | NULL | 没奖金 呵呵 0 | | NULL | 没奖金 呵呵 0 | #case 函数 相当于 switch case的效果 /* case 要判断的字段或者表达式 when 常量1 then 要显示的值1或语句1 when 常量2 then 要显示的值2或语句2 ... else 要显示的值n或语句n end */ mysql\u0026gt; select salary 原始工资 , department_id 部门, case department_id when 30 then salary*1.1 when 40 then salary*1.2 when 50 then salary*1.3 else salary end as 新工资 from employees ; +----------+------+----------+ | 原始工资 | 部门 | 新工资 | +----------+------+----------+ | 24000.00 | 90 | 24000.00 | | 17000.00 | 90 | 17000.00 | #case 多重if类似于 /* case when 条件1 then 要显示的值1或语句1 when 条件2 then 要显示的值2或语句2 ... else 要显示的值n或语句n end */ mysql\u0026gt; select salary , case when salary \u0026gt;20000 then \u0026#39;A\u0026#39; when salary \u0026gt;15000 then \u0026#39;B\u0026#39; when salary \u0026gt;10000 then \u0026#39;C\u0026#39; else \u0026#39;D\u0026#39; end as 工资级别 from employees ; +----------+----------+ | salary | 工资级别 | +----------+----------+ | 24000.00 | A | | 17000.00 | B | | 17000.00 | B | 练习\nselect employee_id , last_name , salary , salary * 1.2 as `new salary` from employees ; mysql\u0026gt; select last_name , substr(last_name , 1,1) as szm ,length(last_name) `length` from employees order by szm ; +-------------+------+--------+ | last_name | szm | length | +-------------+------+--------+ | Austin | A | 6 | | Atkinson | A | 8 | mysql\u0026gt; select concat(last_name,\u0026#39; earns \u0026#39; ,salary ,\u0026#39; monthly but wants \u0026#39;, salary*3 ) `Dream Salary` from employees ; +-----------------------------------------------------+ | Dream Salary | +-----------------------------------------------------+ | K_ing earns 24000.00 monthly but wants 72000.00 | | Kochhar earns 17000.00 monthly but wants 51000.00 | mysql\u0026gt; select job_id as job , case job_id when \u0026#39;AD_PRES\u0026#39; then \u0026#39;A\u0026#39; when \u0026#39;ST_MAN\u0026#39; then \u0026#39;B\u0026#39; when \u0026#39;IT_PROG\u0026#39; then \u0026#39;C\u0026#39;end grade from employees ; +------------+-------+ | job | grade | +------------+-------+ | AC_ACCOUNT | NULL | | AC_MGR | NULL | 分组函数 功能:用作统计使用,又称为聚合函数或统计函数或组函数\n分类:\nsum 求和 avg平均值 max最大值 min最小值 count计算个数\nmysql\u0026gt; select sum(salary) from employees ; +-------------+ | sum(salary) | +-------------+ | 691400.00 | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; select avg(salary) from employees ; +-------------+ | avg(salary) | +-------------+ | 6461.682243 | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; select min(salary) from employees ; +-------------+ | min(salary) | +-------------+ | 2100.00 | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; select max(salary) from employees ; +-------------+ | max(salary) | +-------------+ | 24000.00 | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(salary) from employees ; +---------------+ | count(salary) | +---------------+ | 107 | +---------------+ 1 row in set (0.00 sec) mysql\u0026gt; select sum(salary) 和 , round(avg(salary),2) 平均 , min(salary) 最低 , max(salary) 最高,count(salary) 个数 from employees ; +-----------+---------+---------+----------+------+ | 和 | 平均 | 最低 | 最高 | 个数 | +-----------+---------+---------+----------+------+ | 691400.00 | 6461.68 | 2100.00 | 24000.00 | 107 | +-----------+---------+---------+----------+------+ #参数支持哪些类型 #sum avg 不支持字符型 mysql\u0026gt; select sum(last_name) , avg(last_name) from employees ; +----------------+----------------+ | sum(last_name) | avg(last_name) | +----------------+----------------+ | 0 | 0 | +----------------+----------------+ # max min 支持字符型/日期型 只要能够排序 max 和 min就能支持 mysql\u0026gt; select max(last_name) , min(last_name) from employees ; +----------------+----------------+ | max(last_name) | min(last_name) | +----------------+----------------+ | Zlotkey | Abel | +----------------+----------------+ mysql\u0026gt; select max(hiredate) , min(hiredate) from employees ; +---------------------+---------------------+ | max(hiredate) | min(hiredate) | +---------------------+---------------------+ | 2016-03-03 00:00:00 | 1992-04-03 00:00:00 | +---------------------+---------------------+ 1 row in set (0.00 sec) #count支持计数 计的是非null的数 mysql\u0026gt; select count(last_name) from employees ; +------------------+ | count(last_name) | +------------------+ | 107 | +------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(commission_pct)from employees ; +-----------------------+ | count(commission_pct) | +-----------------------+ | 35 | +-----------------------+ #判断是否忽略null来计算 这里说明sum肯定是没参与 因为如果有null null+任何都是null 不可能有值 #avg也没有参与 所以avg不将null的项加入运算 mysql\u0026gt; select sum(commission_pct)总计 , avg(commission_pct) 平均值, sum(commission_pct)/35 没参与 , sum(commission_pct)/107 参与了 from employees ; +------+----------+----------+----------+ | 总计 | 平均值 | 没参与 | 参与了 | +------+----------+----------+----------+ | 7.80 | 0.222857 | 0.222857 | 0.072897 | +------+----------+----------+----------+ 1 row in set (0.00 sec) #min 和 max 也忽略了null 否则肯定会在一头出现的 mysql\u0026gt; select max(commission_pct) max , min(commission_pct) min from employees ; +------+------+ | max | min | +------+------+ | 0.40 | 0.10 | +------+------+ 1 row in set (0.00 sec) #可以和distinct 匹配使用 mysql\u0026gt; select sum(distinct salary) 去重, sum(salary) 不去重 from employees ; +-----------+-----------+ | 去重 | 不去重 | +-----------+-----------+ | 397900.00 | 691400.00 | +-----------+-----------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(distinct(salary)) 几种工资 from employees ; +----------+ | 几种工资 | +----------+ | 57 | +----------+ 1 row in set (0.00 sec) # count 1 和 2 意思是加了一列 那么当然就等同于统计行数辣 mysql\u0026gt; select count(*) from employees ; +----------+ | count(*) | +----------+ | 107 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(1) from employees ; +----------+ | count(1) | +----------+ | 107 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(2) from employees ; +----------+ | count(2) | +----------+ | 107 | +----------+ 1 row in set (0.00 sec) 所有的分组函数 都忽略null值\n可以和distinct搭配\ncount函数的详细介绍\n效率:\nMYISAM 存储引擎下, count(*) 的效率高\nINNODB存储引擎下, count(*) 和 count(1) 的效率差不多,比count(字段) 要高一点儿\n和分组函数一同查询的字段有限制\n#已经不存在逻辑意义了 mysql\u0026gt; select avg(salary) , employee_id from employees ; +-------------+-------------+ | avg(salary) | employee_id | +-------------+-------------+ | 6461.682243 | 100 | +-------------+-------------+ 1 row in set (0.00 sec) 和分组函数一同查询的字段要求是group by 后的字段\n练习一下\nmysql\u0026gt; select datediff(max(hiredate),min(hiredate)) from employees ; +---------------------------------------+ | datediff(max(hiredate),min(hiredate)) | +---------------------------------------+ | 8735 | +---------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select datediff(now(),\u0026#39;1997-11-21\u0026#39;) 活了多久了 ; +------------+ | 活了多久了 | +------------+ | 8705 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt; select count(*) from employees where department_id = 90 ; +----------+ | count(*) | +----------+ | 3 | +----------+ 1 row in set (0.00 sec) 分组查询 select 分组函数, 列(要求出现在group by的后面) from 表 where 筛选条件 group by 分组的列表 order by 子句\n**注意:\t**查询列表必须特殊,要求是分组函数和group by 后出现的字段\ngroup by可以使用别名 oracle是不支持的 mysql支持\nhaving 可以使用别名 oracle是不支持的 mysql支持\norder by 可以使用别名 oracle是不支持的 mysql支持\nwhere 不可以使用别名\nmysql\u0026gt; select max(salary) 最高工资 , job_id 工种 from employees group by 工种 ; +----------+------------+ | 最高工资 | 工种 | +----------+------------+ | 8300.00 | AC_ACCOUNT | | 12000.00 | AC_MGR | | 4400.00 | AD_ASST | mysql\u0026gt; select count(*) 部门个数 , location_id 位置 from departments group by 位置; +----------+------+ | 部门个数 | 位置 | +----------+------+ | 1 | 1400 | | 1 | 1500 | mysql\u0026gt; select avg(salary) 平均工资,department_id 部门编号 from employees where email like \u0026#39;%a%\u0026#39; group by 部门编号 ; +--------------+----------+ | 平均工资 | 部门编号 | +--------------+----------+ | 7000.000000 | NULL | | 4400.000000 | 10 | +--------------+----------+ 11 rows in set (0.00 sec) #查询有奖金的每个领导手下员工的最高工资 很奇怪 mysql\u0026gt; select max(salary)最高工资,manager_id 领导 from employees where commission_pct \u0026lt;=\u0026gt; null group by manager_id ; +----------+------+ | 最高工资 | 领导 | +----------+------+ | 24000.00 | NULL | | 17000.00 | 100 | | 9000.00 | 102 | | 6000.00 | 103 | | 12000.00 | 101 | | 9000.00 | 108 | | 3100.00 | 114 | | 3200.00 | 120 | | 4200.00 | 121 | | 3800.00 | 122 | | 4000.00 | 123 | | 3500.00 | 124 | | 6000.00 | 201 | | 8300.00 | 205 | +----------+------+ 14 rows in set (0.00 sec) mysql\u0026gt; select max(salary)最高工资,manager_id 领导 from employees where commission_pct is not null group by manager_id ; +----------+------+ | 最高工资 | 领导 | +----------+------+ | 14000.00 | 100 | | 10000.00 | 145 | | 10000.00 | 146 | | 10500.00 | 147 | | 11500.00 | 148 | | 11000.00 | 149 | +----------+------+ 6 rows in set (0.00 sec) #查询每个部门的员工个数 其实就是having 在每个group之下的筛选 mysql\u0026gt; select department_id 部门 , count(*)员工个数 from employees group by 部门 having 员工个数\u0026gt;2 ; +------+----------+ | 部门 | 员工个数 | +------+----------+ | 30 | 6 | | 50 | 45 | | 60 | 5 | | 80 | 34 | | 90 | 3 | | 100 | 6 | +------+----------+ 6 rows in set (0.00 sec) #查询每个工种有奖金的员工的最高工资\u0026gt;12000的工种编号和最高工资 mysql\u0026gt; select max(salary) 最高工资 , job_id 工种编号 from employees where commission_pct is not null group by 工种编号 having 最高工资\u0026gt;12000 ; +----------+----------+ | 最高工资 | 工种编号 | +----------+----------+ | 14000.00 | SA_MAN | +----------+----------+ 1 row in set (0.00 sec) #查询领导编号\u0026gt;102的每个领导手下的最低工资\u0026gt;5000的领导编号是那个,以及其最低工资 mysql\u0026gt; select min(salary) 最低工资 , manager_id 领导编号 from employees where manager_id\u0026gt;102 group by 领导编号 having 最低工资\u0026gt;5000 ; +----------+----------+ | 最低工资 | 领导编号 | +----------+----------+ | 6900.00 | 108 | | 7000.00 | 145 | 特点 分组查询中的筛选条件分为两类 分组前筛选 来源于原始表 放在group by 子句的前面 使用where关键字 分组后筛选 来源于分组后的结果集 放在group by子句的后面 使用having关键字 分组函数 min max count avg 作为条件肯定是放在having子句中 能用分组前筛选的,就优先考虑放在分组前面,考虑到性能 group by 子句支持单个字段分组,多个字段分组(多个字段之间用逗号隔开,没有顺序之分),也支持表达式或函数(较少) 也可以添加排序(排序放在整个分组查询的最后) 按表达式或函数分组 #按员工姓名的长度分组,查询每一组的员工个数,筛选同学个数\u0026gt;5的有哪些 mysql\u0026gt; select length(last_name) 姓名长度 , count(*) 员工个数 from employees group by length(last_name) having 员工个数\u0026gt;5 ; +----------+----------+ | 姓名长度 | 员工个数 | +----------+----------+ | 5 | 29 | | 7 | 15 | 按多个字段分组 #查询每个部门每个工种的员工的平均工资 交换group by 的顺序不影响 mysql\u0026gt; select avg(salary) 平均工资, department_id 部门编号 , job_id 工种编号 from employees group by 部门编号 , 工种编号 ; +--------------+----------+------------+ | 平均工资 | 部门编号 | 工种编号 | +--------------+----------+------------+ | 24000.000000 | 90 | AD_PRES | | 17000.000000 | 90 | AD_VP | | 5760.000000 | 60 | IT_PROG | 分组后添加排序 mysql\u0026gt; select avg(salary) 平均工资, department_id 部门编号 , job_id 工种编号 from employees group by 部门编号 , 工种编号 order by 平均工资 asc ; +--------------+----------+------------+ | 平均工资 | 部门编号 | 工种编号 | +--------------+----------+------------+ | 2780.000000 | 30 | PU_CLERK | | 2785.000000 | 50 | ST_CLERK | 练习一下\nmysql\u0026gt; select job_id 工种, max(salary) 最大 ,min(salary) 最小 ,avg(salary) 平均 ,sum(salary) 总和 from employees group by 工种 order by 工种 asc ; +------------+----------+----------+--------------+-----------+ | 工种 | 最大 | 最小 | 平均 | 总和 | +------------+----------+----------+--------------+-----------+ | AC_ACCOUNT | 8300.00 | 8300.00 | 8300.000000 | 8300.00 | | AC_MGR | 12000.00 | 12000.00 | 12000.000000 | 12000.00 | mysql\u0026gt; select max(salary)-min(salary) DIFFERENCE from employees ; +------------+ | DIFFERENCE | +------------+ | 21900.00 | +------------+ mysql\u0026gt; select manager_id 领导编号, employee_id 员工编号, min(salary) 最低工资 from employees where salary \u0026gt;=6000 and manager_id is not null group by 领导编号 ; +----------+----------+----------+ | 领导编号 | 员工编号 | 最低工资 | +----------+----------+----------+ | 100 | 101 | 6500.00 | | 102 | 103 | 9000.00 | mysql\u0026gt; select department_id 部门编号 , count(*) 员工数量 , avg(salary) 平均工资 from employees group by 部门编号 order by 平均工资 desc ; +----------+----------+--------------+ | 部门编号 | 员工数量 | 平均工资 | +----------+----------+--------------+ | 90 | 3 | 19333.333333 | | 110 | 2 | 10150.000000 | mysql\u0026gt; select job_id 工种 , count(*)人数 from employees group by 工种 ; +------------+------+ | 工种 | 人数 | +------------+------+ | AC_ACCOUNT | 1 | | AC_MGR | 1 | 连接查询 含义:又称为多表查询,当查询的字段来自于多个表时,就会用到连接查询\n笛卡尔积现象: 表1 有m行 表2 有n行 结果有m*n行\n发生原因:没有有效的连接条件\n如何避免:添加有效的连接条件\nimage-20210921141653473\r每个都匹配了一遍 , 这不好 ,都是我的\nmysql\u0026gt; select name , boyName from beauty , boys where beauty.boyfriend_id =boys.id ; +------------+---------+ | name | boyName | +------------+---------+ | Angelababy | 黄晓明 | | 热巴 | 鹿晗 | | 周芷若 | 张无忌 | | 小昭 | 张无忌 | | 王语嫣 | 段誉 | | 赵敏 | 张无忌 | +------------+---------+ 分类:\n按照年代分类 sql92标准 仅仅支持内连接 sql99标准 [推荐] 支持内连接+外连接(左外+右外)+交叉连接 按功能分类 内连接 等值连接 非等值连接 自连接 外连接 左外连接 右外连接 全外连接 交叉连接 #以下是sql92标准的等值连接用法 mysql\u0026gt; select last_name , department_name from employees , departments where employees.department_id =departments.department_id ; +-------------+-----------------+ | last_name | department_name | +-------------+-----------------+ | K_ing | Exe | | Kochhar | Exe | #为表起别名 提高语句的简洁度 区分多个重名的字段 mysql\u0026gt; select last_name , e.job_id , job_title from employees e , jobs where e.job_id = jobs.job_id ; +-------------+------------+---------------------------------+ | last_name | job_id | job_title | +-------------+------------+---------------------------------+ | Gietz | AC_ACCOUNT | Public Accountant | | Higgins | AC_MGR | Accounting Manager | #交换表的出现顺序是可以的 #加上筛选条件 mysql\u0026gt; select last_name , commission_pct , department_name from employees e ,departments d where commission_pct is not null and e.department_id = d.department_id ; +------------+----------------+-----------------+ | last_name | commission_pct | department_name | +------------+----------------+-----------------+ | Russell | 0.40 | Sal | | Partners | 0.30 | Sal | mysql\u0026gt; select department_name , city from departments d ,locations l where d.location_id = l.location_id and city like \u0026#39;_o%\u0026#39; ; +-----------------+---------------------+ | department_name | city | +-----------------+---------------------+ | IT | Southlake | | Shi | South San Francisco | #查询每个城市的部门个数 mysql\u0026gt; select city , count(*) 部门个数 from departments d , locations l where d.location_id = l.location_id group by city ; +---------------------+----------+ | city | 部门个数 | +---------------------+----------+ | Southlake | 1 | | South San Francisco | 1 | | Seattle | 21 | mysql\u0026gt; select d.department_id , department_name , d.manager_id , min(salary) 最低工资 from employees e , departments d where e.department_id = d.department_id and commission_pct is not null group by department_id ; +---------------+-----------------+------------+----------+ | department_id | department_name | manager_id | 最低工资 | +---------------+-----------------+------------+----------+ | 80 | Sal | 145 | 6100.00 | +---------------+-----------------+------------+----------+ mysql\u0026gt; select job_title , count(*) 员工个数 from employees e , jobs j where e.job_id = j.job_id group by j.job_id order by 员工个数 desc ; +---------------------------------+----------+ | job_title | 员工个数 | +---------------------------------+----------+ | Sales Representative | 30 | | Shipping Clerk | 20 | #三表连接 mysql\u0026gt; select last_name , department_name , city from employees e , departments d , locations l where e.department_id = d.department_id and d.location_id = l.location_id ; +-------------+-----------------+---------------------+ | last_name | department_name | city | +-------------+-----------------+---------------------+ | Whalen | Adm | Seattle | | Hartstein | Mar | Toronto | 注意:如果为表起了别名,则查询的字段就不能使用原来的表名去限定了\nsql92标准 等值连接 多表等值连接的结果为多表的交集部分 n表连接,至少需要n-1个连接条件 多表的顺序没有要求 一般需要为表其别名 可以搭配前面介绍的所有子句使用,比如排序/筛选/分组 非等值连接 #非等值连接 也可以加上排序/筛选/分组 mysql\u0026gt; select salary , grade_level from employees e , job_grades g where salary between lower_sal and highest_sal ; +----------+-------------+ | salary | grade_level | +----------+-------------+ | 24000.00 | E | | 17000.00 | E | ​\t3.自连接\n# mysql\u0026gt; select a.last_name 员工名 ,b.last_name 领导名称 from employees a , employees b where a.manager_id =b.employee_id ; +-------------+-----------+ | 员工名 | 领导名称 | +-------------+-----------+ | Kochhar | K_ing | | De Haan | K_ing | 练习一下 mysql\u0026gt; select max(salary) , min(salary) from employees ; +-------------+-------------+ | max(salary) | min(salary) | +-------------+-------------+ | 24000.00 | 2100.00 | +-------------+-------------+ mysql\u0026gt; select employee_id , job_id , last_name from employees order by department_id desc , salary asc ; +-------------+------------+-------------+ | employee_id | job_id | last_name | +-------------+------------+-------------+ | 206 | AC_ACCOUNT | Gietz | | 205 | AC_MGR | Higgins | mysql\u0026gt; select job_id from employees where job_id like \u0026#39;%a%e%\u0026#39; order by job_id ; +---------+ | job_id | +---------+ | AD_PRES | | SA_REP | mysql\u0026gt; select substr(\u0026#39;aabbcc\u0026#39;,3) ; +--------------------+ | substr(\u0026#39;aabbcc\u0026#39;,3) | +--------------------+ | bbcc | +--------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select trim( \u0026#39;aa\u0026#39; from \u0026#39;aaabbbcccaaa\u0026#39;) ; +---------------------------------+ | trim( \u0026#39;aa\u0026#39; from \u0026#39;aaabbbcccaaa\u0026#39;) | +---------------------------------+ | abbbccca | +---------------------------------+ 1 row in set (0.00 sec) 复习一下 语法\nselect 查询列表 from 表 where 筛选条件 order by 排序列表 asc|desc\n特点\nasc 升序 默认 desc 降序\n排序列表 支持 单个字段 多个字段 函数 表达式 别名\norder by 位置一般放在查询语句的最后(除了limit语句之外)\n常见函数\n功能:类似于java中的方法\n好处:提高重用性和隐藏实现细节\n调用:select 函数名(实参列表) ;\n单行函数\n字符函数 length concat substr substring upper lower instr replace trim lpad rpad 数学函数 truncate round ceil mod floor rand(获取随机数 0-1) 日期函数 curdate curtime now year month monthname day hour minute second date_format str_to_date timediff datediff 其他函数 version user database ifnull isnull md5(自动将字符加密成md格式密文) 流程控制函数 if case when then else end mysql\u0026gt; select MD5(\u0026#39;lalala123\u0026#39;) ; +----------------------------------+ | MD5(\u0026#39;lalala123\u0026#39;) | +----------------------------------+ | 24500fa6ecaeb8300905727802af3081 | +----------------------------------+ 1 row in set (0.00 sec) 流程控制函数\nif(条件表达式, 表达式1 , 表达式2) 如果条件表达式成立, 返回表达式1 , 否则返回表达式2 #case 情况1 case 变量或表达式或字段 when 常量1 then 值1 when 常量2 then 值2 else 值n end #case 情况2 case when 条件1 then 值1 when 条件2 then 值2 else 值n end 分组函数 分类\nmax min avg sum count\n特点\nselect max(字段) from 表名\n支持的类型\nsum 和 avg 一般用于处理数值型\nmax min count 可以处理任何数据类型\n以上分组函数都忽略null\n都可以搭配distinct使用,实现去重的统计\nselect sum(distinct 字段) from 表 ;\ncount函数\ncount(字段) 统计该字段非空值的个数\ncount(*) 统计结果集的行数\ncount(1) 统计结果集的行数\n效率上:\nmyisam 存储引擎 count(*) 最高\ninnodb 存储引擎 count(*)和count(1) 效率\u0026gt;count(字段)\n和分组函数一同查询的字段,要求是group by后面出现的字段\n分组查询 select 分组函数, 分组后的字段 from 表 where 筛选条件 group by 分组的字段 having 分组后的筛选 order by 排序列表\n分组前筛选 where 原始表 group by的前面\n分组后筛选 having 分组后的结果 group by的后面\n连接查询 含义 当查询中涉及到了多个表的字段,需要使用多表连接\nselect 字段1 , 字段2 from 表1 , 表2\n笛卡儿乘积:当查询多个表时,没有添加有效的连接条件,导致多个表所有行实现完全连接\n如何解决:添加有效的连接条件\n分类 按年代分类 sql92 等值 非等值 自连接 也支持一部分外连接 用于oracle sqlserver , mysql不支持 sql99 [推荐使用] 内连接 等值 非等值 自连接 外连接 左外 右外 全外(mysql 不支持) 交叉连接 等值连接: select 查询列表 from 表1 别名, 表2 别名 where 表1.key = 表2.key and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n特点:\n一般为表起别名 多表顺序可以调换 n表连接至少需要n-1个连接条件 等值连接的结果是多表的交集部分 非等值连接 select 查询列表 from 表1 别名, 表2 别名 where 非等值连接条件 and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n自连接 select 查询列表 from 表 别名1, 表 别名2 where 等值连接条件 and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n练习一下\nmysql\u0026gt; select last_name , e.department_id , department_name from employees e , departments d where e.department_id = d.department_id ; +-------------+---------------+-----------------+ | last_name | department_id | department_name | +-------------+---------------+-----------------+ | Whalen | 10 | Adm | | Hartstein | 20 | Mar | mysql\u0026gt; select job_id , d.location_id from employees e , departments d where d.department_id = 90 and e.department_id = d.department_id ; +---------+-------------+ | job_id | location_id | +---------+-------------+ | AD_PRES | 1700 | | AD_VP | 1700 | mysql\u0026gt; select last_name , department_name , d.location_id , city from employees e , departments d ,locations l where e.department_id = d.department_id and d.location_id = l.location_id and commission_pct is not null ; +------------+-----------------+-------------+--------+ | last_name | department_name | location_id | city | +------------+-----------------+-------------+--------+ | Russell | Sal | 2500 | Oxford | | Partners | Sal | 2500 | Oxford | mysql\u0026gt; select last_name , job_id , d.department_id , department_name from employees e ,departments d , locations l where e.department_id = d.department_id and d.location_id = l.location_id and city =\u0026#39;Toronto\u0026#39; ; +-----------+--------+---------------+-----------------+ | last_name | job_id | department_id | department_name | +-----------+--------+---------------+-----------------+ | Hartstein | MK_MAN | 20 | Mar | | Fay | MK_REP | 20 | Mar | +-----------+--------+---------------+-----------------+\\ #查询每个工种 每个部门的部门名 工种名 和最低工资 mysql\u0026gt; select department_name , job_title ,min(salary) from employees e , departments d,jobs j where e.department_id = d.department_id and j.job_id = e.job_id group by j.job_title , d.department_name ; +-----------------+---------------------------------+-------------+ | department_name | job_title | min(salary) | +-----------------+---------------------------------+-------------+ | Acc | Public Accountant | 8300.00 | | Acc | Accounting Manager | 12000.00 | #查询每个国家下的部门个数大于2的国家编号 mysql\u0026gt; select country_id,count(*) 部门个数 from locations l , departments d where l.location_id = d.location_id group by country_id having 部门个数\u0026gt;2 ; +------------+----------+ | country_id | 部门个数 | +------------+----------+ | US | 23 | +------------+----------+ #选择指定员工的姓名 员工号 以及他的管理者的姓名和员工号 结果类似于下面的格式 mysql\u0026gt; select a.last_name employees , a.employee_id Emp , b.last_name manager , b.employee_id Mgr from employees a , employees b where a.manager_id = b.employee_id ; +-------------+-----+-----------+-----+ | employees | Emp | manager | Mgr | +-------------+-----+-----------+-----+ | Kochhar | 101 | K_ing | 100 | | De Haan | 102 | K_ing | 100 | sql99语法 语法:\nselect 查询列表 from 表1 别名 连接类型 join 表2 别名 on 连接条件 where 筛选条件 group by 分组条件 having 筛选条件 order by 排序列表\n分类:\n内连接: inner\n外连接:\n​\t左外:left outer\n​\t右外:right outer\n​\t全外:full outer\n交叉连接 :cross\n内连接 select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件 where 筛选条件 \u0026hellip;\n分类:\n等值连接 非等值连接 自连接 #调换顺序是可以的 mysql\u0026gt; select last_name , department_name from employees e inner join departments d on e.department_id = d.department_id ; +-------------+-----------------+ | last_name | department_name | +-------------+-----------------+ | Whalen | Adm | mysql\u0026gt; select last_name , job_title from employees e inner join jobs j on e.job_id = j.job_id where last_name like \u0026#39;%e%\u0026#39; ; +-------------+---------------------------------+ | last_name | job_title | +-------------+---------------------------------+ | De Haan | Administration Vice President | | Ernst | Programmer | mysql\u0026gt; select last_name , job_title from employees e inner join jobs j on e.job_id = j.job_id where e.last_name like \u0026#39;%e%\u0026#39; ; +-------------+---------------------------------+ | last_name | job_title | +-------------+---------------------------------+ | De Haan | Administration Vice President | | Ernst | Programmer | #查询部门个数\u0026gt;3的城市名和部门个数 mysql\u0026gt; select city , count(*) 部门个数 from departments d join locations l on d.location_id = l.location_id group by l.location_id having 部门个数\u0026gt;3 ; +---------+----------+ | city | 部门个数 | +---------+----------+ | Seattle | 21 | +---------+----------+ #查询哪个部门的员工个数\u0026gt;3的部门名和员工个数,并按个数降序 mysql\u0026gt; select department_name , count(*) 员工个数 from departments d inner join employees e on e.department_id = d.department_id group by e.department_id having count(*)\u0026gt;3 order by count(*) desc; +-----------------+----------+ | department_name | 员工个数 | +-----------------+----------+ | Shi | 45 | | Sal | 34 | | Pur | 6 | #多表连接 是有顺序的 第一个表和第二个表在连接的时候形成了新的表 然后新的表里的字段和第三个表里的字段再连接 所以是有顺序之分的 这个和两表连接有差别 mysql\u0026gt; select last_name , department_name , job_title from employees e join departments d on e.department_id = d.department_id join jobs j on j.job_id = e.job_id order by department_name desc ; +-------------+-----------------+---------------------------------+ | last_name | department_name | job_title | +-------------+-----------------+---------------------------------+ | Taylor | Shi | Shipping Clerk | | Fleaur | Shi | Shipping Clerk | 特点:\n添加排序/分组/筛选 inner可以省略 筛选条件放在where后面 , 连接条件放在on后面, 提高分离性, 便于阅读 inner join等值连接和sql92中的等值连接效果是一样的,都是查询多表的交集 非等值连接 #非等值连接 mysql\u0026gt; select salary , grade_level from employees e join job_grades g on e.salary between g.lower_sal and g.highest_sal ; +----------+-------------+ | salary | grade_level | +----------+-------------+ | 24000.00 | E | | 17000.00 | E | #查询工资级别的个数\u0026gt;2并且按工资级别降序 mysql\u0026gt; select count(*) 级别个数 , grade_level from employees e join job_grades g on e.salary between g.lower_sal and g.highest_sal group by g.grade_level having 级别个数\u0026gt;2 order by g.grade_level ; +----------+-------------+ | 级别个数 | grade_level | +----------+-------------+ | 24 | A | | 26 | B | | 38 | C | 自连接 #自连接 #查询员工姓名和他的领导的姓名 mysql\u0026gt; select a.last_name , b.last_name from employees a join employees b on a.manager_id = b.employee_id ; +-------------+-----------+ | last_name | last_name | +-------------+-----------+ | Kochhar | K_ing | | De Haan | K_ing | 外连接 应用场景 用于查询一个表中有,另一个表中没有的记录\n特点\n外连接的查询结果为主表中的所有记录 如果从表中有和他匹配的,则显示匹配的值 如果从表中没有和他匹配的,则显示null 外连接查询结果=内连接结果+主表中有而从表中没有的记录 左外连接,left join左边的是主表 右外连接,right join右边的是主表 交换两表的顺序和关键字,可以实现同样的结果 #查询没有男朋友的女神名 #这样的话就是内连接 内连接是取的交集 没有用查不到 mysql\u0026gt; select name,b.id from beauty g join boys b on g.boyfriend_id = b.id ; +------------+----+ | name | id | +------------+----+ | Angelababy | 3 | | 热巴 | 2 | #这样的话就是外连接 外连接全取了 要加筛选条件 mysql\u0026gt; select name,b.id from beauty g left join boys b on g.boyfriend_id = b.id ; +------------+------+ | name | id | +------------+------+ | 柳岩 | NULL | | 苍老师 | NULL | | Angelababy | 3 | #这样没错 mysql\u0026gt; select name,b.id from beauty g left join boys b on g.boyfriend_id = b.id where b.id is null ; +--------+------+ | name | id | +--------+------+ | 柳岩 | NULL | | 苍老师 | NULL | #查询那个部门没有员工 mysql\u0026gt; select d.department_id ,department_name from departments d left join employees e on d.department_id = e.department_id where e.department_id is null ; +---------------+-----------------+ | department_id | department_name | +---------------+-----------------+ | 120 | Tre | | 130 | Cor | 全外连接 好像不支持 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 交叉连接 #交叉做 笛卡尔乘积 mysql\u0026gt; select beauty.* , boys.* from beauty cross join boys ; +----+------------+------+---------------------+-------------+--------------+--------------+----+---------+--------+ | id | name | sex | borndate | phone | photo | boyfriend_id | id | boyName | userCP | +----+------------+------+---------------------+-------------+--------------+--------------+----+---------+--------+ | 1 | 柳岩 | 女 | 1988-02-03 00:00:00 | 18209876577 | NULL | 8 | 4 | 段誉 | 300 | | 1 | 柳岩 | 女 | 1988-02-03 00:00:00 | sql92和sql99的区别 功能:sql99 支持的较多\n可读性:sql99实现连接条件和筛选条件的分离,可读性较高\nimage-20210923202009215\rimage-20210923202111351\r#查询编号\u0026gt;3的女生的男朋友信息,如果有则列出,如果没有就null填充 mysql\u0026gt; select g.id 女生id,g.name ,b.* from beauty g left join boys b on g.boyfriend_id = b.id where g.id\u0026gt;3 ; +--------+--------+------+---------+--------+ | 女生id | name | id | boyName | userCP | +--------+--------+------+---------+--------+ | 4 | 热巴 | 2 | 鹿晗 | 800 | | 5 | 周冬雨 | NULL | NULL | NULL | | 6 | 周芷若 | 1 | 张无忌 | 100 | #查询哪个城市没有部门 mysql\u0026gt; select city 这个城市没有部门 from locations l left join departments d on l.location_id = d.location_id where department_id is null ; +------------------+ | 这个城市没有部门 | +------------------+ | Roma | | Venice | 子查询 含义:出现在其他语句中的eslect语句,称为子查询或内查询\n外部的查询语句,称为主查询或外查询\n分类:\n按子查询出现的位置 select后面 一般只支持标量子查询 from后面 支持表子查询 where 或者 having 后面**(重要)** 支持标量子查询/列子查询/行子查询 exists 后面 (相关子查询) 表子查询 按功能(结果集的行列书不同) 标量子查询(结果集只有一行一列) 列子查询(结果集中只有一列多行) 行子查询(结果集有一行多列) 表子查询(结果结一般为多行多列) where或having后面的子查询 支持标量子查询 / 列子查询 / 行子查询(多列多行)\n特点:\n子查询放在小括号内 一般放在条件的右侧 标量子查询,一般搭配着单行操作符使用 \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= \u0026lt;\u0026gt; 列子查询,一般搭配着多行操作符使用 in any/some all 子查询的执行顺序优先于主查询执行,主查询的条件用到了子查询的结果 标量子查询 #谁的工资比Abel高 mysql\u0026gt; select last_name , salary from employees where salary\u0026gt;(select salary from employees where last_name = \u0026#39;Abel\u0026#39;) ; +-----------+----------+ | last_name | salary | +-----------+----------+ | K_ing | 24000.00 | | Kochhar | 17000.00 | mysql\u0026gt; select last_name , job_id ,salary from employees where employee_id=141 and salary \u0026gt;(select salary from employees where employee_id =143) ; +-----------+----------+---------+ | last_name | job_id | salary | +-----------+----------+---------+ | Rajs | ST_CLERK | 3500.00 | +-----------+----------+---------+ #查询 job_id 和 141号员工的job_id相同的,salary比143号员工多的员工 mysql\u0026gt; select last_name , job_id ,salary from employees where job_id=(select job_id from employees where employee_id =141) and salary \u0026gt;(select salary from employees where employee_id =143) ; +-------------+----------+---------+ | last_name | job_id | salary | +-------------+----------+---------+ | Nayer | ST_CLERK | 3200.00 | | Mikkilineni | ST_CLERK | 2700.00 | | Bissot | ST_CLERK | 3300.00 | #查询公司工资最少的员工的last_name , job_id, 和salary mysql\u0026gt; select last_name , job_id , salary from employees where salary = (select min(salary) from employees ) ; +-----------+----------+---------+ | last_name | job_id | salary | +-----------+----------+---------+ | Olson | ST_CLERK | 2100.00 | +-----------+----------+---------+ 1 row in set (0.00 sec) #查询最低工资大于50号部门的最低工资的部门id和其最低工资 mysql\u0026gt; select department_id , min(salary) 最低工资 from employees group by department_id having min(salary) \u0026gt;(select min(salary) from employees where department_id = 50) ; +---------------+----------+ | department_id | 最低工资 | +---------------+----------+ | NULL | 7000.00 | | 10 | 4400.00 | 标量子查询可能出现的问题 子查询里查到的元素个数不止一个 子查询里压根没查到任何元素 列子查询 image-20210923211703043\rany就是大于最小值小于最大值 all就是大于最大值小于最小值\n#查询location_id是1400或1700的部门中的所有员工姓名 mysql\u0026gt; select last_name from employees e where department_id in (select distinct department_id from departments where location_id in (1400,1700)); +------------+ | last_name | +------------+ | Hunold | | Ernst | | Austin | #返回比job_id为IT_PROG部门任意工资低的员工的员工号/姓名/job_id以及salary mysql\u0026gt; select employee_id , last_name , job_id , salary from employees where salary \u0026lt; any(select salary from employees where job_id=\u0026#39;IT_PROG\u0026#39;) ; +-------------+-------------+------------+---------+ | employee_id | last_name | job_id | salary | +-------------+-------------+------------+---------+ | 104 | Ernst | IT_PROG | 6000.00 | | 105 | Austin | IT_PROG | 4800.00 | #也可以使用max或者min来代替any mysql\u0026gt; select employee_id , last_name , job_id , salary from employees where salary \u0026lt; any(select salary from employees where job_id=\u0026#39;IT_PROG\u0026#39;) order by employee_id; +-------------+-------------+------------+---------+ | employee_id | last_name | job_id | salary | +-------------+-------------+------------+---------+ | 104 | Ernst | IT_PROG | 6000.00 | | 105 | Austin | IT_PROG | 4800.00 | #all也是同样的 #in 和 =Any也是一样的 #not in 和 \u0026lt;\u0026gt;All也是一样的 行子查询 #查询员工编号最小并且工资最高的员工信息 (不一定存在) #简单粗暴的做法 mysql\u0026gt; select * from employees where employee_id = (select min(employee_id) from employees ) and salary = (select max(salary) from employees ) ; +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | 100 | Steven | K_ing | SKING | 515.123.4567 | AD_PRES | 24000.00 | NULL | NULL | 90 | 1992-04-03 00:00:00 | +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 1 row in set (0.00 sec) #行子查询 有局限性 mysql\u0026gt; select * from employees where (employee_id,salary)=(select min(employee_id),max(salary) from employees) ; +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | 100 | Steven | K_ing | SKING | 515.123.4567 | AD_PRES | 24000.00 | NULL | NULL | 90 | 1992-04-03 00:00:00 | +-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 1 row in set (0.00 sec) 放在select后面的子查询 仅仅支持标量子查询\n#查询每个部门的员工个数 #通过子查询来做 mysql\u0026gt; select d.* ,(select count(*) from employees where department_id=d.department_id) from departments d ; +---------------+-----------------+------------+-------------+----------------------------------------------------------------------+ | department_id | department_name | manager_id | location_id | (select count(*) from employees where department_id=d.department_id) | +---------------+-----------------+------------+-------------+----------------------------------------------------------------------+ | 10 | Adm | 200 | 1700 | 1 | | 20 | Mar | 201 | 1800 | 2 | #也可以通过左右连接来做 mysql\u0026gt; select d.* , count(*) from employees e right join departments d on e.department_id = d.department_id group by d.department_id ; +---------------+-----------------+------------+-------------+----------+ | department_id | department_name | manager_id | location_id | count(*) | +---------------+-----------------+------------+-------------+----------+ | 10 | Adm | 200 | 1700 | 1 | | 20 | Mar | 201 | 1800 | 2 | | 30 | Pur | 114 | 1700 | 6 | #查询员工号=102的部门名 mysql\u0026gt; select employee_id ,(select department_name from departments where department_id =e.department_id) from employees e where e.employee_id =102; +-------------+--------------------------------------------------------------------------------+ | employee_id | (select department_name from departments where department_id =e.department_id) | +-------------+--------------------------------------------------------------------------------+ | 102 | Exe | +-------------+--------------------------------------------------------------------------------+ 1 row in set (0.00 sec) from后面 特点：将子查询充当一张表 要求必须起别名\n#查询每个部门的平均工资的工资等级 #sql92语法 mysql\u0026gt; select department_id ,grade_level,av from (select department_id , avg(salary) av from employees group by department_id) a,job_grades where av between lower_sal and highest_sal ; +---------------+-------------+--------------+ | department_id | grade_level | av | +---------------+-------------+--------------+ | NULL | C | 7000.000000 | | 10 | B | 4400.000000 | #sql99语法 mysql\u0026gt; select av.department_id , grade_level from (select e.department_id , avg(salary) avs from employees e group by e.department_id) av join job_grades j on av.avs between j.lower_sal and j.highest_sal ; +---------------+-------------+ | department_id | grade_level | +---------------+-------------+ | NULL | C | | 10 | B | | 20 | C | exists后面（子查询） select exists(select employee_id from employees)\n语法:\nexists(完整的查询语句) 结果是1/0\n#回顾 mysql\u0026gt; select last_name , (select department_name from departments where department_id = e.department_id )部门 from employees e; +-------------+------+ | last_name | 部门 | +-------------+------+ | K_ing | Exe | | Kochhar | Exe | #查询有员工的部门名 mysql\u0026gt; select d.department_id , d.department_name from departments d where exists(select d.department_id from employees e where d.department_id = e.department_id); +---------------+-----------------+ | department_id | department_name | +---------------+-----------------+ | 10 | Adm | | 20 | Mar | #可以用in来代替 mysql\u0026gt; select d.department_id , d.department_name from departments d where d.department_id in (select distinct e.department_id from employees e ) ; +---------------+-----------------+ | department_id | department_name | +---------------+-----------------+ | 10 | Adm | | 20 | Mar | #查询没有女朋友的男生信息 mysql\u0026gt; select b.* from boys b where not exists(select boyfriend_id from beauty where boyfriend_id =b.id) ; +----+---------+--------+ | id | boyName | userCP | +----+---------+--------+ | 4 | 段誉 | 300 | +----+---------+--------+ 1 row in set (0.00 sec) 练习一下\nmysql\u0026gt; select last_name , salary from employees where department_id = (select department_id from employees where last_name = \u0026#39;Zlotkey\u0026#39;) ; +------------+----------+ | last_name | salary | +------------+----------+ | Russell | 14000.00 | | Partners | 13500.00 | mysql\u0026gt; select last_name , salary from employees where salary \u0026gt; (select avg(salary) from employees ) ; +------------+----------+ | last_name | salary | +------------+----------+ | K_ing | 24000.00 | | Kochhar | 17000.00 | #查询各部门中工资比本部门平均工资中搞的员工和员工号,姓名和工资 mysql\u0026gt; select e.department_id , e.employee_id , e.last_name , e.salary from employees e where salary \u0026gt;(select avg(salary) from employees where department_id = e.department_id ) ; +---------------+-------------+-----------+----------+ | department_id | employee_id | last_name | salary | +---------------+-------------+-----------+----------+ | 90 | 100 | K_ing | 24000.00 | | 60 | 103 | Hunold | 9000.00 | mysql\u0026gt; select department_id , employee_id , last_name from employees where department_id in (select department_id from employees where last_name like \u0026#39;%u%\u0026#39;) ; +---------------+-------------+-------------+ | department_id | employee_id | last_name | +---------------+-------------+-------------+ | 60 | 103 | Hunold | | 60 | 104 | Ernst | #查询部门的location_id是1700的部门工作的员工的员工号 mysql\u0026gt; select e.employee_id , e.department_id from employees e where e.department_id in (select department_id from departments where location_id =1700) ; +-------------+---------------+ | employee_id | department_id | +-------------+---------------+ | 200 | 10 | | 114 | 30 | mysql\u0026gt; select last_name , salary from employees where manager_id in (select employee_id from employees where last_name = \u0026#39;K_ing\u0026#39;) ; +-----------+----------+ | last_name | salary | +-----------+----------+ | Kochhar | 17000.00 | | De Haan | 17000.00 | #查询最高工资的员工的姓名,要求first_name和last_name显示为一列,列名为姓名 mysql\u0026gt; select concat(a.姓 , a.名)姓名 from (select first_name 姓,last_name 名 from employees where salary = (select max(salary) from employees)) a ; +-------------+ | 姓名 | +-------------+ | StevenK_ing | +-------------+ 1 row in set (0.00 sec) 分页查询 应用场景:当要显示的数据,一页显示不全,需要分页提交sql请求的时候\n语法:select 查询列表 from 表 inner join 表2 on 连接条件 group by 分组字段 having 分组后的筛选 order by 排序后的字段 limit offset,size ;\noffset要显示条目的起始索引(起始索引从0开始)\nsize要显示的条目个数\n特点:\nlimit语句放在查询语句的最后 公式 要显示的页数 page 每页的条目数size , 那么就是limit (page-1)*size,size mysql\u0026gt; select * from employees limit 0,5 ; +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | 100 | Steven | K_ing | SKING | 515.123.4567 | AD_PRES | 24000.00 | NULL | NULL | 90 | 1992-04-03 00:00:00 | | 101 | Neena | Kochhar | NKOCHHAR | 515.123.4568 | AD_VP | 17000.00 | NULL | 100 | 90 | 1992-04-03 00:00:00 | | 102 | Lex | De Haan | LDEHAAN | 515.123.4569 | AD_VP | 17000.00 | NULL | 100 | 90 | 1992-04-03 00:00:00 | | 103 | Alexander | Hunold | AHUNOLD | 590.423.4567 | IT_PROG | 9000.00 | NULL | 102 | 60 | 1992-04-03 00:00:00 | | 104 | Bruce | Ernst | BERNST | 590.423.4568 | IT_PROG | 6000.00 | NULL | 103 | 60 | 1992-04-03 00:00:00 | +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 5 rows in set (0.00 sec) #如果从第一条开始的话,那么这样可以省略前一个数字 mysql\u0026gt; select * from employees limit 5 ; +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ | 100 | Steven | K_ing | SKING | 515.123.4567 | AD_PRES | 24000.00 | NULL | NULL | 90 | 1992-04-03 00:00:00 | | 101 | Neena | Kochhar | NKOCHHAR | 515.123.4568 | AD_VP | 17000.00 | NULL | 100 | 90 | 1992-04-03 00:00:00 | | 102 | Lex | De Haan | LDEHAAN | 515.123.4569 | AD_VP | 17000.00 | NULL | 100 | 90 | 1992-04-03 00:00:00 | | 103 | Alexander | Hunold | AHUNOLD | 590.423.4567 | IT_PROG | 9000.00 | NULL | 102 | 60 | 1992-04-03 00:00:00 | | 104 | Bruce | Ernst | BERNST | 590.423.4568 | IT_PROG | 6000.00 | NULL | 103 | 60 | 1992-04-03 00:00:00 | +-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 5 rows in set (0.00 sec) #第11到第25条 mysql\u0026gt; select * from employees limit 10,15 ; mysql\u0026gt; select * from employees where commission_pct is not null order by salary*(1+commission_pct) desc limit 0,10 ; 练习一下 mysql\u0026gt; select substr(email,1,instr(email,\u0026#39;@\u0026#39;)-1) from stuinfo ; mysql\u0026gt; select count(*) 个数 , sex from stuinfo group by sex ; mysql\u0026gt; select min(age) , (select gradeName , id from grade where id = stuinfo.gradeid) from stuinfo group by gradeId ; mysql\u0026gt; select min(age) , (select gradeName , id from grade where id = stuinfo.id) from stuinfo group by gradeId having min(age)\u0026gt;20; 查询语句中涉及到的所有关键字,以及执行先后顺序. select 查询列表 ⑦\nfrom 表 ① 锁定数据源\n连接类型 join 表2 ②拼接数据源 笛卡尔儿乘积\non 连接条件 ③缩小数据源 非笛卡尔乘积\nwhere 筛选条件 ④缩小数据范围\ngroup by 分组列表 ⑤\nhaving 分组后的筛选 ⑥分组后筛选\norder by 排序列表 ⑧\nlimit 偏移,条目数; ⑨\nsql99语法 内连接 select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件 where 筛选条件 group by 分组列表 having 分组后的筛选 order by 排序列表 limit子句\n特点:\n表的顺序可以调换\n内连接的结果=多表的交集\nn表连接至少需要n-1个连接条件\n分类: 等值连接 非等值连接 自连接\n外连接 select 查询列表 from 表1 别名 left|right|full outer join 表2 别名 on 连接条件\nwhere 筛选条件 group by 分组列表 having 分组后的筛选 order by 排序列表 limit 子句;\n特点:\n查询的结果=主表中所有的行,其中从表和他匹配的将显示匹配行,如果从表没有匹配的则显示null\nleft join 左边的就是主表,right join右边的就是主表\nfull join 两边都是主表\n一般用于查询除了交集部分的剩余的不匹配的行\n交叉连接 select 查询列表 from 表1 别名 cross join 表2 别名 ;\n**特点:\t**\n类似于笛卡尔乘积\n子查询 嵌套在其他语句内部的select语句称为子查询或内查询\n外面的语句可以是insert update select delete 等等,一般select 作为外面语句较多\n外面如果为select语句,则此语句成为外查询或主查询\n**分类:\t**\n按出现的位置\nselect 后面 仅仅支持标量子查询 from 后面 表子查询 where或having后面 标量子查询 / 列子查询 / 行子查询 exists后面 标量子查询 列子查询 行子查询 表子查询 按结果集的行列\n标量子查询(单行子查询):结果集为一行一列 列子查询(多行子查询):结果集为多行一列 行子查询(结果集为多行多列) 表子查询(结果集为多行多列) 示例\n标量子查询\n查询最低工资的员工姓名和工资\nmysql\u0026gt; select last_name , salary from employees where salary=(select min(salary) from employees) ; +-----------+---------+ | last_name | salary | +-----------+---------+ | Olson | 2100.00 | +-----------+---------+ 1 row in set (0.00 sec) 列子查询\n查询所有是领导的员工姓名\nmysql\u0026gt; select last_name from employees where employee_id in (select manager_id from employees) ; +-----------+ | last_name | +-----------+ | K_ing | | De Haan | 分页查询 当要查询的条目数太多,一页显示不全\n语法\nselect 查询列表 from 表 limit offset,size\n**注意\t** offset代表的是起始的条目索引,默认是从0开始 size代表的是要显示的条目数\n公式 limit (page-1)*size , size\n练习一下 mysql\u0026gt; select last_name from employees where employee_id in (select manager_id from employees) ; +-----------+ | last_name | +-----------+ | K_ing | | De Haan | #查询平均工资最低的部门信息 直接使用order by 平均工资 asc 再limit 1 mysql\u0026gt; select d.* from departments d where d.department_id = (select department_id from employees group by department_id order by avg(salary) asc limit 1); +---------------+-----------------+------------+-------------+ | department_id | department_name | manager_id | location_id | +---------------+-----------------+------------+-------------+ | 50 | Shi | 121 | 1500 | +---------------+-----------------+------------+-------------+ #查询平均工资最低的部门信息和它的平均工资 mysql\u0026gt; select d.*,a.avgsalary from departments d join (select department_id,avg(salary) avgsalary from employees group by department_id order by avg(salary) asc limit 1) a on d.department_id = a.department_id; +---------------+-----------------+------------+-------------+-------------+ | department_id | department_name | manager_id | location_id | avgsalary | +---------------+-----------------+------------+-------------+-------------+ | 50 | Shi | 121 | 1500 | 3475.555556 | +---------------+-----------------+------------+-------------+-------------+ 1 row in set (0.00 sec) #查询平均工资最高的job信息 mysql\u0026gt; select j.* from jobs j where j.job_id =(select job_id from employees group by job_id order by avg(salary) desc limit 1); +---------+-----------+------------+------------+ | job_id | job_title | min_salary | max_salary | +---------+-----------+------------+------------+ | AD_PRES | President | 20000 | 40000 | +---------+-----------+------------+------------+ mysql\u0026gt; select avg(salary),department_id from employees group by department_id having avg(salary) \u0026gt; (select avg(salary) from employees ) ; +--------------+---------------+ | avg(salary) | department_id | +--------------+---------------+ | 7000.000000 | NULL | | 9500.000000 | 20 | | 6500.000000 | 40 | | 10000.000000 | 70 | | 8955.882353 | 80 | | 19333.333333 | 90 | | 8600.000000 | 100 | | 10150.000000 | 110 | +--------------+---------------+ mysql\u0026gt; select * from employees where employee_id in (select manager_id from employees ) ; +-------------+------------+-----------+----------+--------------------+---------+----------+----------------+------------+---------------+---------------------+ | employee_id | first_name | last_name | email | phone_number | job_id | salary | commission_pct | manager_id | department_id | hiredate | +-------------+------------+-----------+----------+--------------------+---------+----------+----------------+------------+---------------+---------------------+ | 100 | Steven | K_ing | SKING | 515.123.4567 | AD_PRES | 24000.00 | NULL | NULL | 90 | 1992-04-03 00:00:00 | | 102 | Lex | De Haan | LDEH #查询各个部门中最高工资中最低的那个部门的最低工资是多少 mysql\u0026gt; select min(salary) from employees where department_id =(select department_id from (select max(salary),department_id from employees group by department_id order by max(salary) asc limit 1) a ); +-------------+ | min(salary) | +-------------+ | 4400.00 | +-------------+ 1 row in set (0.00 sec) #查询平均工资最高的部门的manager的详细信息:last_name , department_id , email , salary mysql\u0026gt; select last_name , department_id , email , salary from employees where employee_id =(select manager_id from departments where department_id = (select department_id from employees group by department_id order by avg(salary) desc limit 1)) ; +-----------+---------------+-------+----------+ | last_name | department_id | email | salary | +-----------+---------------+-------+----------+ | K_ing | 90 | SKING | 24000.00 | +-----------+---------------+-------+----------+ 练习一下\nmysql\u0026gt; select count(*)个数 , (select majorid from major where majorid = s.majorid)专业号 from student s group by majorid ; +------+--------+ | 个数 | 专业号 | +------+--------+ | 8 | 1 | | 3 | 2 | mysql\u0026gt; select avg(score),max(score) from result group by studentno ; +--------------------+------------+ | avg(score) | max(score) | +--------------------+------------+ | 100 | 100 | | 90 | 90 | #查询姓张的每个学生的最低分大于60的学号姓名 其实可以用join 就不用那么麻烦了 mysql\u0026gt; select min(score) 最低分,r.studentno,(select s.studentname from student s where s.studentno=r.studentno and s.studentname like\u0026#39;张%\u0026#39;) a from result r group by r.studentno having 最低分\u0026gt;60 and a is not null ; +--------+-----------+--------+ | 最低分 | studentno | a | +--------+-----------+--------+ | 100 | s001 | 张三封 | | 70 | s004 | 张翠山 | +--------+-----------+--------+ #可以使用diff函数 和 join mysql\u0026gt; select s.studentname,(select majorname from major where majorid = s.majorid) 专业名称 from student s where s.borndate \u0026gt; \u0026#39;1998-1-1\u0026#39; ; +-------------+----------+ | studentname | 专业名称 | +-------------+----------+ | 张无忌 | html5 | | 赵敏 | javaee | +-------------+----------+ 2 rows in set (0.00 sec) mysql\u0026gt; select s.studentname from student s join major m on s.majorid = m.majorid where datediff(s.borndate,\u0026#39;1998-1-1\u0026#39;)\u0026gt;0 ; +-------------+ | studentname | +-------------+ | 张无忌 | | 赵敏 | +-------------+ 2 rows in set (0.00 sec) #查询每个专业的男生人数和女生人数分别是多少 在这里s.majorid=s1.majorid s1一定不能省略 mysql\u0026gt; select s1.majorid,(select count(*) from student s where s.majorid=s1.majorid and s.sex =\u0026#39;男\u0026#39;)男生,(select count(*) from student s where s.majorid=s1.majorid and s.sex=\u0026#39;女\u0026#39;) 女生 from student s1 group by s1.majorid ; +---------+------+------+ | majorid | 男生 | 女生 | +---------+------+------+ | 1 | 5 | 3 | | 2 | 2 | 1 | | 3 | 2 | 2 | +---------+------+------+ 3 rows in set (0.00 sec) #查询专业和张翠山一样的学生的最低分 mysql\u0026gt; select min(score) from result where studentno in (select s.studentno from student s where majorid =(select majorid from student where studentname =\u0026#39;张翠山\u0026#39;) and studentname \u0026lt;\u0026gt;\u0026#39;张翠山\u0026#39;) group by studentno; +------------+ | min(score) | +------------+ | 100 | | 90 | +------------+ 2 rows in set (0.00 sec) #查询大于60分的学生的姓名 密码 专业名 mysql\u0026gt; select s.studentname , s.loginpwd , (select majorname from major where majorid = s.majorid) from student s where s.studentno in (select distinct studentno from result where score \u0026gt;60) ; +-------------+----------+---------------------------------------------------------+ | studentname | loginpwd | (select majorname from major where majorid = s.majorid) | +-------------+----------+---------------------------------------------------------+ | 张三封 | 8888 | javaee | | 殷天正 | 8888 | javaee | | 周伯通 | 8888 | html5 | | 张翠山 | 8888 | javaee | | 小小张 | 8888 | android | | 张无忌 | 8888 | html5 | +-------------+----------+---------------------------------------------------------+ #按邮箱的位数分组,并查询个数 mysql\u0026gt; select count(*)个数, length(s.email) from student s group by length(s.email) ; +------+-----------------+ | 个数 | length(s.email) | +------+-----------------+ | 1 | 20 | | 2 | 19 | | 2 | 18 | | 6 | NULL | | 2 | 17 | | 2 | 15 | +------+-----------------+ #查询学生名 专业名 分数 这是错误的 如果使用join是取完全交集 mysql\u0026gt; select s.studentname ,m.majorname , r.score from student s join major m on s.majorid = m.majorid join result r on s.studentno = r.studentno ; +-------------+-----------+-------+ | studentname | majorname | score | +-------------+-----------+-------+ | 张翠山 | javaee | 70 | | 殷天正 | javaee | 90 | #查询学生名 专业名 分数 这是错误的 应该使用left join防止出现score为null的情况 mysql\u0026gt; select s.studentname ,m.majorname , r.score from student s join major m on s.majorid = m.majorid left join result r on s.studentno = r.studentno ; +-------------+-----------+-------+ | studentname | majorname | score | +-------------+-----------+-------+ | 张三封 | javaee | 100 | | 殷天正 | javaee | 90 | | 周伯通 | html5 | 80 | mysql\u0026gt; select s.studentname ,m.majorname , r.score from student s join major m on s.majorid = m.majorid left join result r on s.studentno = r.studentno ; #查询没有成绩的学生人数 mysql\u0026gt; select * from (select distinct s.studentno 学号,(select score from result where studentno =s.studentno limit 1 )a from student s) b where b.a is null ; +------+------+ | 学号 | a | +------+------+ | S007 | NULL | | S008 | NULL | | S009 | NULL | mysql\u0026gt; select count(*) from (select distinct s.studentno 学号,(select score from result where studentno =s.studentno limit 1 )a from student s) b where b.a is null ; +----------+ | count(*) | +----------+ | 9 | +----------+ 联合查询 union 联合 合并:将多条查询语句的结果合并成一个结果\n查询语句1 union 查询语句2 union 查询语句3 \u0026hellip;\n查询部门编号\u0026gt;90 或 邮箱包含a的员工信息\n应用场景\n保证两个表的列数一致 , 并不要求两个表的列名一致 ,就可以使用联合查询\n要查询的结果来源于多个表,且多个表没有直接的连接关系,但查询的信息一致时\n例如全站搜索 ,肯定不可能所有的数据都放在一个表里 , 所以这时候就需要union\n注意\nunion 会默认去重\nunion all 可以包含重复项\nmysql\u0026gt; select * from employees where department_id \u0026gt;90 or email like\u0026#39;%a%\u0026#39; ; mysql\u0026gt; select * from employees where department_id \u0026gt;90 union select * from employees where email like\u0026#39;%a%\u0026#39; ; DML语言 数据操作语言 插入 insert\n更新 update\n删除 delete\n插入语句 方式一\n语法:\ninsert into 表名(列名, \u0026hellip;) values(值, \u0026hellip;) ;\n注意\n插入的值的类型要与列的类型一直或兼容 不可以为null的列必须插入值,可以为null的列如何插入值 插入null 或者在 into beauty(少一点字段) 列的顺序可以调换 列和值的个数必须一致 可以省略列名,默认所有列名,而且列的顺序和表中列的顺序一直 #经典型 insert mysql\u0026gt; insert into beauty(id,name,sex,borndate,phone,photo,boyfriend_id) values(13,\u0026#39;唐艺昕\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;1990-4-23\u0026#39;,\u0026#39;18988888\u0026#39;,null,2); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into beauty(id,name,sex,phone) values(14,\u0026#39;金星\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;13888888\u0026#39;); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into beauty values(18,\u0026#39;张飞\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;1990-4-23\u0026#39;,\u0026#39;119\u0026#39;,null,null); Query OK, 1 row affected (0.00 sec) **方式二\t**\n语法\ninsert into 表名 set 列名 = 值 , 列名 = 值 \u0026hellip;\nmysql\u0026gt; insert into beauty set id = 19 , name = \u0026#39;文涛\u0026#39; , phone = \u0026#39;999\u0026#39; ; Query OK, 1 row affected (0.00 sec) **两种方式的区别\t**\n方式一支持多行插入,方式二不支持 方式一支持子查询,方式二不支持 #方式一 支持子查询 mysql\u0026gt; insert into beauty(id,name,phone) select 26,\u0026#39;宋西\u0026#39;,\u0026#39;11809866\u0026#39;; Query OK, 1 row affected (0.01 sec) Records: 1 Duplicates: 0 Warnings: 0 #方式一 支持多行插入 mysql\u0026gt; insert into beauty(id,name,phone) select id , boyname,\u0026#39;120\u0026#39; from boys where id\u0026lt;3; ERROR 1062 (23000): Duplicate entry \u0026#39;1\u0026#39; for key \u0026#39;beauty.PRIMARY\u0026#39; 修改语句 修改单表的记录(重要)\nupdate 表名 set 列=新值 , 列=新值 where 筛选条件 ;\nupdate beauty set phone = \u0026#39;11010011\u0026#39; where name like \u0026#39;唐%\u0026#39; ; update boys set boyname = \u0026#39;张飞\u0026#39; ,userCp = 10 where id = 2 ; 修改多表的记录(补充)\nsql92语法\nupdate 表1 别名 , 表2 别名\nset 列=值 , \u0026hellip; where 连接条件 and 筛选条件 ;\nsql99语法\nupdate 表1 别名 inner join 表2 别名 on 连接条件 set 列=值, \u0026hellip; where 筛选条件\n#修改张无忌的女朋友的手机号为114 mysql\u0026gt; update beauty b join boys on b.boyfriend_id = boys.id set phone = \u0026#39;114\u0026#39; where boys.boyname =\u0026#39;张无忌\u0026#39; ; Query OK, 3 rows affected (0.00 sec) Rows matched: 3 Changed: 3 Warnings: 0 #也可以使用修改单表 使用子查询 mysql\u0026gt; update beauty b set phone = \u0026#39;115\u0026#39; where b.boyfriend_id = (select id from boys where boyname =\u0026#39;张无忌\u0026#39;) ; Query OK, 3 rows affected (0.00 sec) Rows matched: 3 Changed: 3 Warnings: 0 #修改没有男朋友的女神的男朋友编号都为2号 #先select mysql\u0026gt; select b.name ,b.boyfriend_id,boyname from beauty b left join boys on b.boyfriend_id = boys.id where boyfriend_id is not null and boyname is null; +--------+--------------+---------+ | name | boyfriend_id | boyname | +--------+--------------+---------+ | 柳岩 | 8 | NULL | | 苍老师 | 9 | NULL | | 周冬雨 | 9 | NULL | | 岳灵珊 | 9 | NULL | | 双儿 | 9 | NULL | | 夏雪 | 9 | NULL | +--------+--------------+---------+ 6 rows in set (0.00 sec) #再update mysql\u0026gt; update beauty b left join boys on b.boyfriend_id = boys.id set b.boyfriend_id =2 where boyfriend_id is not null and boyname is null; Query OK, 6 rows affected (0.00 sec) Rows matched: 6 Changed: 6 Warnings: 0 #再查一下 mysql\u0026gt; select b.name ,b.boyfriend_id,boyname from beauty b left join boys on b.boyfriend_id = boys.id where boyfriend_id is not null and boyname is null; Empty set (0.00 sec) 删除语句 方式一 delete\n方式二 truncate\n语法:truncate table 表名 (删除的是所有的 不能加筛选条件)\n单表的删除\n语法:delete from 表名 where 筛选条件\n多表的删除\n语法:\nsql92语法\ndelete 表1的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表1的数据内容\ndelete 表2的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表2的数据内容\ndelete 表1的别名, 表2的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表1和表2的数据内容\nsql99语法\ndelete 表1的别名,表2的别名 from 表1 别名 join 表2 别名 on 连接条件 where 筛选条件\n#单表的删除 delete from beauty where phone like \u0026#39;%9\u0026#39; ; #删除张无忌的女朋友的信息 #多表删除 mysql\u0026gt; delete b from beauty b join boys boy on b.boyfriend_id = boy.id where boy.boyname = \u0026#39;张无忌\u0026#39; ; Query OK, 3 rows affected (0.01 sec) #删除黄晓明和他女朋友的信息 mysql\u0026gt; delete g , b from beauty g join boys b on g.boyfriend_id = b.id where b.boyname = \u0026#39;黄晓明\u0026#39; ; Query OK, 2 rows affected (0.00 sec) 方式二 truncate语句\n直接清空 truncate table boys ;\ndelete和truncate的区别 delete可以加where条件 , truncate不能加 truncate 删除, 效率高一丢丢 假如要删除的表中有自增长列,如果用delete删除后,再插入数据,自增长列的值依旧是从断点开始,而如果truncate删除后,再插入数据,自增长列的值从1开始 truncate删除没有返回值,delete删除有返回值 truncate删除回滚,delete删除可以回滚 练习一下 mysql\u0026gt; desc users ; +---------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------------+-------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | userid | varchar(10) | YES | | NULL | | | department_id | int | YES | | NULL | | +---------------+-------------+------+-----+---------+-------+ mysql\u0026gt; insert into my_employees(First_name,Last_name,Userid,salary) values (\u0026#39;patel\u0026#39;,\u0026#39;Ralph\u0026#39;,\u0026#39;Rpatel\u0026#39;, 895),(\u0026#39;Dance\u0026#39; , \u0026#39;Betty\u0026#39; , \u0026#39;Bdancs\u0026#39; , 860),(\u0026#39;Biri\u0026#39;,\u0026#39;Ben\u0026#39;,\u0026#39;Bbiri\u0026#39;, 1100),(\u0026#39;Newman\u0026#39;,\u0026#39;Chad\u0026#39;,\u0026#39;Cnewman\u0026#39;,750),(\u0026#39;Ropeburn\u0026#39;,\u0026#39;Audrey\u0026#39; ,\u0026#39;Aropebur\u0026#39;,1150); Query OK, 5 rows affected (0.01 sec) Records: 5 Duplicates: 0 Warnings: 0 #也可以这样 mysql\u0026gt; insert into my_employees(First_name,Last_name,Userid,salary) select \u0026#39;patel\u0026#39;,\u0026#39;Ralph\u0026#39;,\u0026#39;Rpatel\u0026#39;, 895 union select \u0026#39;Dance\u0026#39; , \u0026#39;Betty\u0026#39; , \u0026#39;Bdancs\u0026#39; , 860 union select \u0026#39;Biri\u0026#39;,\u0026#39;Ben\u0026#39;,\u0026#39;Bbiri\u0026#39;, 1100 union select \u0026#39;Newman\u0026#39;,\u0026#39;Chad\u0026#39;,\u0026#39;Cnewman\u0026#39;,750 union select \u0026#39;Ropeburn\u0026#39;,\u0026#39;Audrey\u0026#39; ,\u0026#39;Aropebur\u0026#39;,1150; mysql\u0026gt; insert into users(userid,id) values(\u0026#39;Rpatel\u0026#39;,10),(\u0026#39;Bdancs\u0026#39;,10),(\u0026#39;Bbiri\u0026#39;,20),(\u0026#39;Chewman\u0026#39;,30),(\u0026#39;Aropebur\u0026#39;,40); Query OK, 5 rows affected (0.01 sec) Records: 5 Duplicates: 0 Warnings: 0 mysql\u0026gt; update my_employees set last_name = \u0026#39;drelxer\u0026#39; where id =3 ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; update my_employees set salary = 1000 where salary \u0026lt;900 ; Query OK, 3 rows affected (0.00 sec) Rows matched: 3 Changed: 3 Warnings: 0 mysql\u0026gt; delete me , u from my_employees me join users u on me.userid = u.userid where u.userid = \u0026#39;Bbiri\u0026#39;; Query OK, 2 rows affected (0.00 sec) mysql\u0026gt; truncate table users ; DDL 数据定义语言\n库和表的管理\n库的管理 创建/修改/删除\n表的管理 创建/修改/删除\n创建:create\n修改:alter\n删除:drop\n库的管理 库的创建 语法 create database [if not exists] 库名 ;\n#如果已存在 这样执行会报错 mysql\u0026gt; create database books ; Query OK, 1 row affected (0.01 sec) #会先判断一下 mysql\u0026gt; create database if not exists books ; Query OK, 1 row affected, 1 warning (0.00 sec) 库的修改 更改库的字符集\nalter database books character set gbk ; 库的删除 drop database books ; drop database if exists books ; 表的管理 表的创建 create table 表名 ( 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], 列名 列的类型[(长度) 约束], ... ) mysql\u0026gt; select database() ; +-------------+ | database() | +-------------+ | myemployees | +-------------+ 1 row in set (0.00 sec) mysql\u0026gt; use books ; Database changed mysql\u0026gt; create table book( id int , bName varchar(20) , price double , authorId int ,publishDate datetime) ; Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; desc book ; +-------------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------------+-------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | bName | varchar(20) | YES | | NULL | | | price | double | YES | | NULL | | | authorId | int | YES | | NULL | | | publishDate | datetime | YES | | NULL | | +-------------+-------------+------+-----+---------+-------+ 5 rows in set (0.00 sec) mysql\u0026gt; create table author (id int, au_name varchar(20) , nation varchar(10)) ; Query OK, 0 rows affected (0.02 sec) 表的修改 alter table 表名 add column / drop column / change column /modify column /raname to 列名/列类型/表名\n修改列名 修改列的类型或约束 添加新列 删除列 修改表名 #修改列名 mysql\u0026gt; alter table book change column publishDate pbDate datetime; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #修改列的类型或约束 mysql\u0026gt; alter table book modify column pbdate timestamp; Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 #添加新列 mysql\u0026gt; alter table author add column annual double ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #删除列 mysql\u0026gt; alter table book drop column annual ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 #修改表名 mysql\u0026gt; alter table author rename to book_author ; Query OK, 0 rows affected (0.01 sec) 表的删除 drop table 表\ndrop table if exist 表\n通用的写法:\ndrop database if exists 旧库名 ;\ncreate database 库名 ;\ndrop table if exists 旧表名;\ncreate table 表名 (\u0026hellip;) ;\n表的复制 仅仅复制表的结构 mysql\u0026gt; create table copy like author ; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; select * from copy ; Empty set (0.00 sec) 复制表的结构和数据 #子查询 mysql\u0026gt; create table copy2 select * from author ; Query OK, 4 rows affected (0.02 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql\u0026gt; select * from copy2 ; +------+----------+--------+ | id | au_name | nation | +------+----------+--------+ | 1 | 村上春树 | 日本 | | 2 | 莫言 | 中国 | | 3 | 冯唐 | 中国 | | 4 | 金庸 | 中国 | +------+----------+--------+ 4 rows in set (0.00 sec) 只复制部分数据 #根据一张表的部分数据 建立另一张表 mysql\u0026gt; create table copy3 select id,au_name from author where nation =\u0026#39;中国\u0026#39; ; Query OK, 3 rows affected (0.02 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql\u0026gt; select * from copy3 ; +------+---------+ | id | au_name | +------+---------+ | 2 | 莫言 | | 3 | 冯唐 | | 4 | 金庸 | +------+---------+ 3 rows in set (0.00 sec) 仅仅复制某些字段 #这样就只会复制字段,并且不满足条件不携带任何一条数据过来 mysql\u0026gt; create table copy4 select id from author where 0 ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; select * from copy4 ; Empty set (0.00 sec) 练习一下 mysql\u0026gt; create database test ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; create table dept1(id int(7),name varchar(25)); Query OK, 0 rows affected, 1 warning (0.03 sec) #将departments中的数据插入新表 mysql\u0026gt; create table dept2 select * from myemployees.departments ; Query OK, 27 rows affected (0.02 sec) Records: 27 Duplicates: 0 Warnings: 0 mysql\u0026gt; create table emp5 (id int(7),first_name varchar(25),last_name varchar(25),dept_id int(7)) ; Query OK, 0 rows affected, 2 warnings (0.02 sec) #这样是修改列名和类型的 mysql\u0026gt; alter table emp5 change column last_name last_name varchar(50); Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #这样只是修改类型的 mysql\u0026gt; alter table emp5 modify column last_name varchar(50) ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #复制结构 mysql\u0026gt; create table employees2 like myemployees.employees ; Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql\u0026gt; drop table emp5 ; Query OK, 0 rows affected (0.02 sec) #修改表的名字 mysql\u0026gt; alter table employees2 rename to emp5 ; Query OK, 0 rows affected (0.02 sec) #增加列 mysql\u0026gt; alter table dept1 add column test_column int ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; alter table emp5 add column test_column int ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #删除列 mysql\u0026gt; alter table emp5 drop column department_id ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 常见的数据类型 数值型\n整形 小数 定点数 浮点数 字符型\n较短的文本 char varchar 较长的文本 text blob(较长的二进制数据) 日期型:\n整形\nimage-20210926214209015\r分类\ntinyint smallint mediumin int/interger bigint\n1 2 3 4 8\n特点\n如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字 如果插入的数值超出了类型的范围,会报out of range异常 ,但是与mysql5.0不同的是,现在不会插入数据了,mysql5.0会插入临界值 如果不设置长度,会有默认的长度 如何设置无符号和有符号\nmysql\u0026gt; desc tab_int ; +-------+------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------+------+-----+---------+-------+ | t1 | int | YES | | NULL | | +-------+------+------+-----+---------+-------+ 1 row in set (0.01 sec) #说明能够插入负数 说明默认的int是有符号的int mysql\u0026gt; insert into tab_int values(-123456) ; Query OK, 1 row affected (0.01 sec) # mysql\u0026gt; drop table if exists tab_int ; Query OK, 0 rows affected (0.02 sec) #插入无符号int类型 mysql\u0026gt; create table tab_int ( t1 int , t2 int unsigned) ; Query OK, 0 rows affected (0.02 sec) #想给无符号整数插入负数的话会报错 0行一共 但是在mysql5.5会插入 然后默认填充0 mysql\u0026gt; insert into tab_int values(-123456,-123456) ; ERROR 1264 (22003): Out of range value for column \u0026#39;t2\u0026#39; at row 1 mysql\u0026gt; select * from tab_int ; Empty set (0.00 sec) #zerofill 默认长度不够以0填充 默认是无符号数 int(7)不是2的7位,代表的是显示的最大宽度 mysql\u0026gt; create table int_zeroFill (t1 int(7) zerofill , t2 int(7) zerofill); Query OK, 0 rows affected, 4 warnings (0.02 sec) mysql\u0026gt; desc int_zeroFill ; +-------+--------------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+--------------------------+------+-----+---------+-------+ | t1 | int(7) unsigned zerofill | YES | | NULL | | | t2 | int(7) unsigned zerofill | YES | | NULL | | +-------+--------------------------+------+-----+---------+-------+ 2 rows in set (0.01 sec) mysql\u0026gt; insert into int_zerofill values (123,123); Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from int_zerofill ; +---------+---------+ | t1 | t2 | +---------+---------+ | 0000123 | 0000123 | +---------+---------+ 1 row in set (0.00 sec) 小数 image-20210929224058024\r浮点型\nfloat(M,D)\ndouble(M,D)\n定点型\ndec(M,D)\ndecimal(M,D)\n特点:\nM和D什么意思 m是小数部位+整数部位 d是小数部位 如果超过范围, 则插入临界值 m和d都可以省略 如果是decimal , 则m默认为10,d默认为0 如果是float和double,则会根据插入的数值的精度来决定精度 定点型和浮点型的区别 定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用 #小数 mysql\u0026gt; create table tab_float (f1 float(5,2) ,f2 double(5,2) ,f3 decimal(5,2)) ; Query OK, 0 rows affected, 2 warnings (0.02 sec) mysql\u0026gt; insert into tab_float values (123.45,123.45,123.45) ; Query OK, 1 row affected (0.01 sec) #会被截取 位数太长的话 mysql\u0026gt; insert into tab_float values (123.456,123.456,123.456) ; Query OK, 1 row affected, 1 warning (0.00 sec) #短了就自动填充 mysql\u0026gt; insert into tab_float values (123.4 , 123.4 , 123.4) ; Query OK, 1 row affected (0.00 sec) #(5,2) 2代表小数后几位 mysql\u0026gt; select * from tab_float ; +--------+--------+--------+ | f1 | f2 | f3 | +--------+--------+--------+ | 123.45 | 123.45 | 123.45 | | 123.46 | 123.46 | 123.46 | | 123.40 | 123.40 | 123.40 | +--------+--------+--------+ 3 rows in set (0.00 sec) #超出位数了 超出的话mysql8.0将不会插入 (5,2) 5代表一共多少位数 , 如果小数位2位,那整数位最多3位,所以整数最多999 mysql5.0会插入最大值 mysql\u0026gt; insert into tab_float values(1523.4,1523.4,1523.4); ERROR 1264 (22003): Out of range value for column \u0026#39;f1\u0026#39; at row 1 mysql\u0026gt; select * from tab_float ; +--------+--------+--------+ | f1 | f2 | f3 | +--------+--------+--------+ | 123.45 | 123.45 | 123.45 | | 123.46 | 123.46 | 123.46 | | 123.40 | 123.40 | 123.40 | +--------+--------+--------+ 3 rows in set (0.00 sec) #如果不填写 m和d decimal默认是(10,0) 小数后面是0位 mysql\u0026gt; create table tab_float_default (f1 float , f2 double , f3 decimal) ; Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; desc tab_float_default ; +-------+---------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------------+------+-----+---------+-------+ | f1 | float | YES | | NULL | | | f2 | double | YES | | NULL | | | f3 | decimal(10,0) | YES | | NULL | | +-------+---------------+------+-----+---------+-------+ 3 rows in set (0.01 sec) #如果插入了多了,会自动截断 mysql\u0026gt; insert into tab_float_default values (123.456,123.456,123.456) ; Query OK, 1 row affected, 1 warning (0.01 sec) mysql\u0026gt; select * from tab_float_default ; +---------+---------+------+ | f1 | f2 | f3 | +---------+---------+------+ | 123.456 | 123.456 | 123 | +---------+---------+------+ 1 row in set (0.00 sec) 选择类型的原则 所选择的类型越简单越好,能保存数值的类型越小越好\n字符型 较短的文本:\nchar\nvarchar\n较长的文本:\ntext\nblob(较大的二进制)\n其他:\nbinary和varbinary用于保存较短的二进制数据\nenum用于保存枚举\nset用于保存集合\nimage-20210929230011199\r特点:\nchar char(m) m代表最大的字符数,可以省略,默认为1 代表固定长度的字符 效率高一点 varchar varchar(m) m代表最大的字符数,不可以省略 可变长度的字符 比较节省 效率低一点 image-20210929230312590\r#类型为enum的字段 mysql\u0026gt; create table tab_char(c1 enum(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;)); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; desc tab_char ; +-------+-------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------------+------+-----+---------+-------+ | c1 | enum(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) | YES | | NULL | | +-------+-------------------+------+-----+---------+-------+ 1 row in set (0.01 sec) mysql\u0026gt; insert into tab_char values(\u0026#39;a\u0026#39;) ; Query OK, 1 row affected (0.01 sec) #不区分大小写 mysql\u0026gt; insert into tab_char values(\u0026#39;A\u0026#39;); Query OK, 1 row affected (0.00 sec) #没有定义的插入不进去 mysql\u0026gt; insert into tab_char values (\u0026#39;m\u0026#39;); ERROR 1265 (01000): Data truncated for column \u0026#39;c1\u0026#39; at row 1 mysql\u0026gt; select * from tab_char ; +------+ | c1 | +------+ | a | | a | +------+ 2 rows in set (0.00 sec) image-20210929230732259\r可以从在一个字段里插入多个元素辣\n#创建类型为set的字段 mysql\u0026gt; create table tab_set(s1 set(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;)); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; insert into tab_set values(\u0026#39;a\u0026#39;); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; insert into tab_set values(\u0026#39;a,B\u0026#39;); Query OK, 1 row affected (0.00 sec) #不符合的不会插入 mysql\u0026gt; insert into tab_set values (\u0026#39;a,m\u0026#39;); ERROR 1265 (01000): Data truncated for column \u0026#39;s1\u0026#39; at row 1 mysql\u0026gt; select * from tab_set ; +------+ | s1 | +------+ | a | | a,b | +------+ 2 rows in set (0.00 sec) 日期型 分类:\ndate只保存日期\ntime只保存时间\nyear只保存年\ndatetime 保存日期+时间\ntimestamp 保存日期+时间\n特点:\ndatetime 字节 8 范围 1000-9999 不受时区影响\ntimastamp 字节 4 范围 1970-2038 受时区影响\nimage-20210929233916597\rimage-20210929234007359\rmysql\u0026gt; select * from tab_date ; +---------------------+---------------------+ | t1 | t2 | +---------------------+---------------------+ | 2021-09-29 23:40:53 | 2021-09-29 23:40:53 | +---------------------+---------------------+ 1 row in set (0.00 sec) #时区 如果将时区改成其他时区 , timestamp可以更加真实地反映当前时区的真实时间 而不是不变 mysql\u0026gt; show variables like \u0026#39;time_zone\u0026#39; ; +---------------+--------+ | Variable_name | Value | +---------------+--------+ | time_zone | SYSTEM | +---------------+--------+ 1 row in set, 1 warning (0.00 sec) 复习一下 联合查询\nunion 联合 , 将多次查询结果合并为一个结果\n查询语句1 union [all] 查询语句2 \u0026hellip;\n**意义\t**\n将一条比较复杂的查询语句拆分为多条语句 适用于查询多个表的时候,查询的列基本是一致的 特点\n要求多条查询语句的查询列数必须一致 要求多条查询语句的查询的各列类型/顺序最好一致 不一致会视图隐式转换 union会默认去重 和 union all 可以包含重复项 查询的语法:\nselect * ⑦\nfrom 表1 别名 ①\njoin 表2 别名 ②\non 连接条件 ③\nwhere 筛选条件 ④\ngroup by 分组条件 ⑤\nhaving 分组后筛选条件 ⑥\norder by 排序条件 ⑧\nlimit(起始索引,条目数)选多少个 ⑨\nunion \u0026hellip;\nDML语言 插入\ninsert into 表名 (字段名 , \u0026hellip;) values (\u0026hellip;) //一一对应\n特点\n要求值的类型和字段的类型要一致或兼容 字段的个数和顺序不一定与原始表中的字段的个数和顺序一致,但必须保证值和字段一一对应 假如可以为null的字段,注意可以通过以下两种方式插入null值 字段和值都省略 字段写上,然后值也使用null插入 字段和值的个数必须一致 字段名可以省略,但是默认为所有列 插入2\ninsert into 表名 set 字段名 = 值 , 字段名 = 值 \u0026hellip;\n两种方式的区别\n方式一支持子查询\ninsert into 表名 (select * from 表名 where \u0026hellip;) 方式一支持一次插入多行,方式二不支持\ninsert into 表名 values (\u0026hellip;),(\u0026hellip;) \u0026hellip; 修改单表的记录 update 表名 set 字段=值 , 字段= 值 where 筛选条件\n修改多表的记录 update 表名 别名 join 表名 别名 on 连接条件 set 字段=值 , 字段 = 值 where 筛选语句\n删除 方式一使用delete 删除单表的记录\ndelete from 表名 where 筛选条件 [limit 条目数]\nmysql\u0026gt; select * from copy_girls ; +----+--------+------+---------------------+-------------+--------------+--------------+ | id | name | sex | borndate | phone | photo | boyfriend_id | +----+--------+------+---------------------+-------------+--------------+--------------+ | 1 | 柳岩 | 女 | 1988-02-03 00:00:00 | 18209876577 | NULL | 2 | | 2 | 苍老师 | 女 | 1987-12-30 00:00:00 | 18219876577 | NULL | 2 | | 4 | 热巴 | 女 | 1993-02-03 00:00:00 | 18209876579 | NULL | 2 | | 5 | 周冬雨 | 女 | 1992-02-03 00:00:00 | 18209179577 | NULL | 2 | mysql\u0026gt; delete from copy_girls limit 1 ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; select * from copy_girls ; +----+--------+------+---------------------+-------------+--------------+--------------+ | id | name | sex | borndate | phone | photo | boyfriend_id | +----+--------+------+---------------------+-------------+--------------+--------------+ | 2 | 苍老师 | 女 | 1987-12-30 00:00:00 | 18219876577 | NULL | 2 | | 4 | 热巴 | 女 | 1993-02-03 00:00:00 | 18209876579 | NULL | 2 | 删除多表的记录\ndelete 表1 别名1, 表2 别名2 from 表名 别名 join 表名 别名 on 连接条件 where 筛选条件\n方式二使用truncate\n两种方式的区别\ndelete不会让自增列归零,从断点开始,truncate会让自增列归零\ndelete可以加筛选条件,truncate 不能加筛选条件\ntruncate 效率较高\ntruncate 没有返回值,delete可以返回受影响的行数\ntruncate不可以回滚,delete可以回滚\nDDL语言 库的管理 创建库\ncreate database [if not exists] 库名 [character set 字符集名] ;\n修改库\nalter database 库名 character set 字符集名 ;\n修改库名很少用,不行就换个库呗何必呢,如果实在要改,就先net stop mysql80 然后到mysql8.0下的data文件夹中重命名某个数据库名,然后net start mysql80 ,刷新数据库管理工具\n删除库\ndrop database [if exists] 库名 ;\n表的管理\n创建表\ncreate table [if not exists] 表名(字段名 类型 [约束], 字段名 类型 [约束] \u0026hellip;) ;\n修改表\n添加列\nalter table 表名 add column 列名 列的类型 [first|after 字段名];\nmysql\u0026gt; create table test_add_column ( -\u0026gt; t1 int , -\u0026gt; t2 int , -\u0026gt; t3 int ); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; desc test_add_column ; +-------+------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+------+------+-----+---------+-------+ | t1 | int | YES | | NULL | | | t2 | int | YES | | NULL | | | t3 | int | YES | | NULL | | +-------+------+------+-----+---------+-------+ 3 rows in set (0.01 sec) mysql\u0026gt; alter table test_add_column add column t11 bigint first ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; desc test_add_column ; +-------+--------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+--------+------+-----+---------+-------+ | t11 | bigint | YES | | NULL | | | t1 | int | YES | | NULL | | | t2 | int | YES | | NULL | | | t3 | int | YES | | NULL | | +-------+--------+------+-----+---------+-------+ 修改列的类型或者约束\nalter table 表名 modify column 列名 新类型[新约束] ;\n修改列名\nalter table 表名 change column 旧列名 新列名 类型;\n删除列名\nalter table 表名 drop column 列名 ;\n修改表名\nalter table 表名 rename to 新表名\n删除表\ndrop table [if exists] 表名;\n复制表 可以跨库\n仅仅复制表的结构 create table 表名 like 原表 ;\n复制表的结构+数据\ncreate table 表名 select * from 原表 ;\ncreate table 表名 select 特定字段 from 原表 where 筛选条件\n数据类型 数值型\n整型 tinyint smallint mediumint int integer bigint 1 2 3 4 8 特点 都可以设置无符号和有符号 默认是有符号 ,通过 unsigned设置无符号 如果超出范围,out of range 异常,mysql5.0 和 8.0 不同 长度可以不指定,默认会有一个长度 长度代表的是显示的最大宽度,而不是只有2的长度位那个范围,但需要搭配zerofill,搭配之后将默认变为无符号整型 浮点型 定点数 decimal(m,d) 默认为(10,0) 浮点数 float(m,d) 4位字节 double(m,d) 8位字节 默认为可变的 特点 m代表整数+小数部位的个数,d代表小数部位 如果超出范围,则报out of range异常,并且插入临界值 m和d都可以省略,但对于定点数,m默认为10,d默认为0 如果精度要求较高,则有限考虑使用定点数 字符型\nchar varchar binary varbinary enum set text blob\nchar:固定长度的字符,写法为char(M) ,最大长度不能超过M ,其中M可以省略,默认为1\nvarchar:可变长度的字符 写法varchar(M),最大长度不能超过M,其中M不可以省略\n日期型\nyear 年\ndate 日期\ndatetime 日期+时间 8\ntime 时间\ntimestamp 时间戳 4 1970-2038 比较容易受到时区,语法模式,版本的影响,更能反映当前时区的真实时间\n新的一杰克 常见约束 含义 : 一种限制 , 用于限制表中的数据,为了保证表中的数据的准确和可靠性\n分类 六大约束\nNOT NULL 非空 用于保证该字段的值不能为空 比如姓名/学号等等\ndefault 默认 , 用于保证该字段有默认值\nPRIMARY KEY 主键 用于保证该字段的值具有唯一性,并且非空,如学号,工号\nUNIQUE 唯一,用于保证该字段的值具有唯一性,可以为空 如座位号/老婆\nCHECK 检查约束 [mysql 不支持] 比如性别 只能男和女 或者青年人年龄\nFOREIGN KEY 外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值 在从表添加外键约束,用于引用主表中的某列的值 例如学生表的专业编号,员工表的部门编号,员工表的工种编号\n添加约束的时机:\n创建表时 修改表时 约束的添加分类:\n列级约束 NOT NULL DEFAULT PRIMARY KEY UNIQUE CHECK FOREIGN KEY 六大约束语法上都支持,但是外键约束没有效果 表级约束 除了非空/默认,其他的都支持 create table 表( 字段名 字段类型 列级约束, 字段名\t字段类型, 表级约束 ) 创建表时添加约束\n添加列级约束\n语法:直接在字段名和类型后面追加约束类型即可\n只支持:默认/非空/主键\nmysql\u0026gt; create database students ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; use students ; Database changed #创建列级约束 mysql\u0026gt; create table stuinfo ( id int primary key , stuName varchar(20) not null , gender char(1) check(gender=\u0026#39;男\u0026#39; or gender=\u0026#39;女\u0026#39;) ,seat int unique,age int default 18,majorId int references major(id)); Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; desc stuinfo ; +---------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+-------------+------+-----+---------+-------+ | id | int | NO | PRI | NULL | | | stuName | varchar(20) | NO | | NULL | | | gender | char(1) | YES | | NULL | | | seat | int | YES | UNI | NULL | | | age | int | YES | | 18 | | | majorId | int | YES | | NULL | | +---------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) #查看索引 唯一/主键/外键都可以查看 mysql\u0026gt; show index from stuinfo ; 添加表级约束\n语法:在各个字段的最下面\n[constraint 约束名] 约束类型(字段名) \u0026hellip;\nmysql\u0026gt; create table stuinfo(id int , stuname varchar(20),gender char(1),seat int , age int ,majorid int ,constraint pk primary key(id),constraint uq unique(seat) , constraint ck check(gender in (\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)),constraint fk_stuinfo_major foreign key(majorid) references major(id)) ; Query OK, 0 rows affected (0.04 sec) mysql\u0026gt; show index from stuinfo ; image-20211001160138048\rconstraint 约束名 可以去掉\nmysql\u0026gt; create table stuinfo(id int , stuname varchar(20),gender char(1),seat int , age int ,majorid int ,primary key(id),unique(seat),check(gender in (\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)),foreign key(majorid) references major(id)) ; Query OK, 0 rows affected (0.06 sec) image-20211001160643505\r通用写法\ncrete table if not exists stuinfo( id int primary key , stuname varchar(20) not null , sex char(1) age int default 18, seat int unique , majorid int , constraint fk_stuinfo_major foreign key(majroid) references major(id) ) 主键和唯一的大对比\n保证唯一性 是否允许为空 一个表中可以有几个 是否允许组合键 主键 对 不对 一个表中至多有一个 是,但不推荐 唯一 对 对 可以有多个 是,但不推荐 primar key (id,stuname) unique (seat,majorid) 外键:\n要求在从表设置外键关系 从表的外键列的类型和主表的关联列一致或兼容,名称无所谓 主表的关联咧必须是一个key或者唯一键 插入数据时,先插入主表,再插入从表 删除数据时,先删除从表,再删除主表 修改表时添加约束\n添加列级约束 alter table 表名 mofidy column 字段名 字段类型 新约束 ; 添加表级约束 alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用] ; 添加非空约束\n添加列级约束\nmysql\u0026gt; drop table if exists stuinfo ; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; create table stuinfo(id int,stuname varchar(20),gender char(1),seat int,age int,majorid int); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; alter table stuinfo modify column stuname varchar(20) not null ; Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; desc stuinfo; +---------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+-------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | stuname | varchar(20) | NO | | NULL | | | gender | char(1) | YES | | NULL | | | seat | int | YES | | NULL | | | age | int | YES | | NULL | | | majorid | int | YES | | NULL | | +---------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) mysql\u0026gt; alter table stuinfo modify column age int defeault 18 ; mysql\u0026gt; alter table stuinfo modify column age int default 18 ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; alter table stuinfo modify column id int primary key ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 添加表级约束\nmysql\u0026gt; alter table stuinfo add unique(seat); Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 添加外键\nmysql\u0026gt; alter table stuinfo add constraint fk_studentinfo_major foreign key(majorid) references major (id) ; Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 修改表时删除约束\n#取消非空约束 mysql\u0026gt; alter table stuinfo modify column stuname varchar(20) null ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 #取消默认约束 mysql\u0026gt; alter table stuinfo modify column age int ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 #删除主键 mysql\u0026gt; alter table stuinfo drop primary key ; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 #删除唯一键 mysql\u0026gt; alter table stuinfo drop index seat ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; show index from stuinfo ; +---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | stuinfo | 1 | fk_studentinfo_major | 1 | majorid | A | 0 | NULL | NULL | YES | BTREE | | | YES | NULL | +---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 1 row in set (0.01 sec) #删除外键 mysql\u0026gt; alter table stuinfo drop foreign key fk_studentinfo_major ; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 练习一下 #添加主键约束 mysql\u0026gt; create table emp2 (id int,constraint my_emp_id_pk primary key(id)); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; use test ; Database changed #添加主键约束 mysql\u0026gt; alter table dept2 add constraint my_dept_id_pk primary key(department_id); Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 #拷贝数据和结构 mysql\u0026gt; create table emp2 select * from students.emp2 ; Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; show tables ; +-------------------+ | Tables_in_test | +-------------------+ | dept1 | | dept2 | | emp2 | | emp5 | | int_zerofill | | tab_char | | tab_date | | tab_float | | tab_float_default | | tab_int | | tab_set | | test_add_column | +-------------------+ 12 rows in set (0.00 sec) mysql\u0026gt; alter table emp2 add column dept_id int ; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 #添加外键约束 mysql\u0026gt; alter table emp2 add foreign key(dept_id) references dept2(department_id); Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0 表级约束和列级约束的区别\n​\t位置\t支持的约束类型\t是否可以起约束名\n列级约束 列的后面 支持所有语法,但是外键没有效果\t不可以起约束名\n表级约束 所有列的下面 默认和非空不支持,其他支持\t可以起约束名\n标识列 又称为自增长列\n可以不用手动的插入值，系统提供默认的序列值\n创建表时设置标识列\n特点\n标识列必须和主键搭配吗？不一定，但要求是一个key 一个表可以有多少个标识列？至多一个 标识列的类型只能是数值型 一般是int 标识列可以通过 set auto_increment =3 ;设置步长 标识列可以通过手动的方式设置起始值 mysql\u0026gt; create table tab_identity(id int primary key , name varchar(20) ) ; Query OK, 0 rows affected (0.02 sec) mysql\u0026gt; insert into tab_identity value (1,\u0026#39;john\u0026#39;) ; Query OK, 1 row affected (0.01 sec) #不是自增的话，搞不定 会主键重复的 mysql\u0026gt; insert into tab_identity value (1,\u0026#39;john\u0026#39;) ; ERROR 1062 (23000): Duplicate entry \u0026#39;1\u0026#39; for key \u0026#39;tab_identity.PRIMARY\u0026#39; mysql\u0026gt; drop table if exists tab_identity ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; create table tab_identity (id int primary key auto_increment , name varchar(20)) ; Query OK, 0 rows affected (0.02 sec) #可以给他不设置列值 mysql\u0026gt; insert into tab_identity(name) values (\u0026#39;john\u0026#39;) ; Query OK, 1 row affected (0.01 sec) #或者可以给他设置为null就好了 mysql\u0026gt; insert into tab_identity values (null , \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into tab_identity values (null , \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; insert into tab_identity values (null , \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from tab_identity ; +----+------+ | id | name | +----+------+ | 1 | john | | 2 | jwt | | 3 | jwt | | 4 | jwt | +----+------+ 4 rows in set (0.00 sec) mysql不支持设置起始的数值，但是可以通过取巧的办法手动设置\n#查看自增长变量 mysql\u0026gt; show variables like \u0026#39;%auto_increment%\u0026#39; ; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | auto_increment_increment | 1 | | auto_increment_offset | 1 | +--------------------------+-------+ 2 rows in set, 1 warning (0.00 sec) #设置自增长的步长 mysql\u0026gt; set auto_increment_increment = 3 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; show variables like \u0026#39;%auto_increment%\u0026#39; ; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | auto_increment_increment | 3 | | auto_increment_offset | 1 | +--------------------------+-------+ 2 rows in set, 1 warning (0.00 sec) mysql\u0026gt; insert into tab_identity values (null , \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from tab_identity ; +----+------+ | id | name | +----+------+ | 1 | john | | 2 | jwt | | 3 | jwt | | 4 | jwt | | 7 | jwt | +----+------+ 5 rows in set (0.00 sec) #手动设置起始值 这样就可以达到效果了 mysql\u0026gt; insert into tab_identity values (100, \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from tab_identity ; +-----+------+ | id | name | +-----+------+ | 1 | john | | 2 | jwt | | 3 | jwt | | 4 | jwt | | 7 | jwt | | 100 | jwt | +-----+------+ 6 rows in set (0.00 sec) mysql\u0026gt; insert into tab_identity values (null , \u0026#39;jwt\u0026#39;) ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from tab_identity ; +-----+------+ | id | name | +-----+------+ | 1 | john | | 2 | jwt | | 3 | jwt | | 4 | jwt | | 7 | jwt | | 100 | jwt | | 103 | jwt | +-----+------+ 7 rows in set (0.00 sec) 修改表时设置标识列\nalter table tab_identity modify column id int primary key auto_increment ; 修改表时删除标识列\nalter table tab_identity modify column id int ; TCL Transaction Control Languaue 事务控制语言\n事务 一个或者一组sql语句组成一个执行单元,这个执行单元要么全部执行,要么全部不执行\n事务的特点\nACID\n原子性 一个事务不可再分割,要么执行要么都不执行 一致性 一个事务执行会使数据从一个一致状态切换到另一个一致状态 持久性 一个事务的执行不受其他事务的干扰 隔离性 一个事务一旦提交,则会永久的改变数据库的数据 案例 转账\n事务:事务由单独单元的一个或多个语句组成,在这个单元中,每个mysql语句是相互以来的.而整个单独单元作为一个不可分割的整体,如果单元中某条sql语句一旦执行失败或产生错误,整个单元将会回滚.所有受到影响的数据将返回到事务开始以前的状态;如果单元中的所有sql语句均执行成功,则事务被顺利执行.\n存储引擎 概念:在mysql中的数据用各种不同的技术存储在文件(或内存)中 通过show engines 来查看mysql支持的存储引擎 在mysql中用的最多的存储引擎有 innodb myisam memory 等 其中innodb支持事务,而myisam/memory等不支持事务 mysql\u0026gt; show engines ; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.00 sec) 事务的ACID属性\n原子性A 事务是一个不可分割的工作单位,事务中的操作要么都发生,要么都不发生 持久性D 持久性是指一个事务一旦被提交,它对数据库中数据的改变就是永久性的,接下来的其他操作和数据库故障不应该对其有任何影响 隔离性I 事务的隔离性是指一个事务的执行不能被其他事务干扰,即一个事务内部的操作及使用的数据对并发的其他事务是隔离的,并发执行的各个事务之间不能互相干扰 一致性C 事务必须使数据库从一个一致性状态变换到另一个一致性状态 事务的创建\n隐式事务:事务没有明显的开启和结束的标记 比如insert / update / delete 语句\nmysql\u0026gt; show variables like \u0026#39;autocommit\u0026#39; ; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set, 1 warning (0.00 sec) 显式事务:事务具有明显的开启和结束标记 前提是必须先设置自动提交功能为禁用 #只是针对当前事务有效 所以每次开启显式事务的时候都要手动的关闭自动提交功能 set autocommit = 0 ; 步骤1 : 开启事务\nset autocommit = 0\nstart transaction ; 可选的\n步骤2 : 编写事务中的sql语句 select insert update delete \u0026hellip;\n语句1\n语句2\n\u0026hellip;\n步骤3 : 结束事务\ncommit ; 提交事务\nrollback ; 回滚事务\nsavepoint 节点名 ; 设置保存点\nmysql\u0026gt; create table account(id int primary key auto_increment , username varchar(20), balance double) ; Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; insert into account (username,balance) values (\u0026#39;张无忌\u0026#39;,1000) , (\u0026#39;赵敏\u0026#39;,1000) ; Query OK, 2 rows affected (0.00 sec) Records: 2 Duplicates: 0 Warnings: 0 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 张无忌 | 1000 | | 4 | 赵敏 | 1000 | +----+----------+---------+ 2 rows in set (0.00 sec) #禁用自动提交 开启事务 mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) #开启事务 mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; update account set balance =500 where username = \u0026#39;张无忌\u0026#39; ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 #在navicat里查看好像是1000 1000 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 张无忌 | 500 | | 4 | 赵敏 | 1000 | +----+----------+---------+ 2 rows in set (0.00 sec) #回滚试了试 mysql\u0026gt; rollback ; Query OK, 0 rows affected (0.00 sec) #是可以的 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 张无忌 | 1000 | | 4 | 赵敏 | 1000 | +----+----------+---------+ 2 rows in set (0.00 sec) #体验一下事务 mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; update account set balance = 500 where username = \u0026#39;张无忌\u0026#39; ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; update account set balance = 1500 where username = \u0026#39;赵敏\u0026#39; ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 #提交 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 张无忌 | 500 | | 4 | 赵敏 | 1500 | +----+----------+---------+ 2 rows in set (0.00 sec) 数据库的隔离级别 对于同时运行的多个事务,当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题\n脏读:对于两个事务T1 , T2 ,T1读取了已经被T2更新,但是还没有被提交的字段,之后,若T2回滚,T1读取的内容就是临时且无效的 不可重复读:对于两个事务T1 , T2 , T1 读取了一个字段,然后T2 更新了该字段.之后,T1再次读取同一个字段,值就不同了 幻读:对于两个事务T1 , T2 , T1从一个表中读取了一个字段,然后T2在该表中插入了一些新的行.之后,如果T1再次读取同一个条,就会多出几行. 数据库事务的隔离性:数据库系统必须具有隔离并发运行各个事务的能力,使他们不会互相影响,避免各种并发问题.\n一个事务与其他事务隔离的程度称为隔离级别.数据库规定了多种事务隔离级别,不同隔离级别对应不同的干扰程度,隔离级别越高,数据一致性就越好,但并发性就越弱\n数据库提供的4中隔离级别\nread uncommitted(读未提交数据) 允许事务读取未被其他事务提交的变更.脏读/不可重复读/幻读的问题都会出现 read commit(读已经提交的数据) 只允许事务读取已经被其他事务提交的变更,可以避免脏读,但不可重复度和幻读的问题仍然可能出现 repeatable read(可重复读) 确保事务可以多次从一个字段中读取相同的值,在这个事务持续期间,禁止其他事务对这个字段进行更新.可以避免脏读和不可重复读,但幻读的问题仍然存在. serializable(串行化) 确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表执行插入,更新和删除操作.所有并发问题都可以避免,但性能十分低下 oracle支持的2种事务隔离级别:read commited , serializable . oracle默认的事务隔离级别为:read commited\nmysql支持4种事务隔离级别 mysql默认的事务隔离级别为 repeatable read\n测试一下read uncommitted\n#重启服务可以保证恢复默认的隔离级别吧好像 PS C:\\Users\\Administrator.YOURTREEDAD\u0026gt; net stop mysql 80 此命令的语法是: NET STOP service PS C:\\Users\\Administrator.YOURTREEDAD\u0026gt; net start mysql80 请求的服务已经启动。 请键入 NET HELPMSG 2182 以获得更多的帮助。 PS C:\\Users\\Administrator.YOURTREEDAD\u0026gt; mysql -u root -p Enter password: ****** #查看隔离级别 mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set (0.00 sec) #设置隔离级别为 read uncommitted 读未提交数据 这样会导致脏读/不可重复读/幻读 mysql\u0026gt; set session transaction isolation level read uncommitted ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | READ-UNCOMMITTED | +-------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; set autocommit= 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) #看! 还没提交 mysql\u0026gt; update account set username = \u0026#39;john\u0026#39; where id = 1 ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; 在另一个界面打开设置隔离级别为 read uncommitted\n就可以看到脏读的数据\nimage-20211002112133588\r假若原来的回滚了,那就离谱了\nmysql\u0026gt; rollback ; Query OK, 0 rows affected (0.00 sec) image-20211002112511055\r所以会出现脏读幻读不可重复读都可能出现在这种隔离级别下\n测试一下 read committed\nmysql\u0026gt; set session transaction isolation level read committed ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; set autocommit =0 ; Query OK, 0 rows affected (0.00 sec) #还没提交 mysql\u0026gt; update account set username =\u0026#39;john\u0026#39; where id = 1 ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 image-20211002113519057\r这边也确实在第二个事务中没有看到还没提交的数据\n但是!!! 但是 说明这可以避免脏读,但是不可重复读和幻读 嘿嘿!不行!\nimage-20211002113728187\r**测试一下 repeatable read **\nmysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | john | 500 | | 4 | 赵敏 | 1500 | +----+----------+---------+ 2 rows in set (0.01 sec) mysql\u0026gt; show variables like \u0026#39;autocommit\u0026#39; ; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set, 1 warning (0.01 sec) mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) #更新还未提交 mysql\u0026gt; update account set username = \u0026#39;刘备\u0026#39; where id = 1 ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 image-20211002151741957\r完全没问题,避免了脏读\n#提交之后在看看 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 刘备 | 500 | | 4 | 赵敏 | 1500 | +----+----------+---------+ 2 rows in set (0.00 sec) image-20211002151946236\r下面演示一下为什么这种隔离级别会出现幻读\ncmd中开启事务,插入一条数据\nimage-20211002152534283\rpowershell中开启事务,查询数据\nmysql\u0026gt; set autocommit =0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) #暂时没查到 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 刘备 | 500 | | 4 | 赵敏 | 1500 | +----+----------+---------+ 2 rows in set (0.00 sec) cmd中commit了\nimage-20211002152659690\r#sql中也没有问题 保证数据一致性 所以么有出现不可重复读 不会多出来刚刚插入的那条数据 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 刘备 | 500 | | 4 | 赵敏 | 1500 | +----+----------+---------+ 2 rows in set (0.00 sec) #但是 ! 但是! 下面出问题了 本来希望在事务的开始的时候,表里有两条数据,我希望把两条数据的username改一下,但是这时候另一个事务中插入了一条 在更新的时候把插入的也更新了username 这样的话就裂开了 出现幻读 mysql\u0026gt; update account set username = \u0026#39;mmm\u0026#39;; Query OK, 3 rows affected (0.00 sec) Rows matched: 3 Changed: 3 Warnings: 0 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | mmm | 500 | | 4 | mmm | 1500 | | 5 | mmm | 1000 | +----+----------+---------+ 3 rows in set (0.00 sec) image-20211002153254274\r测试一下 serializable powershell中尝试开启事务 并且更新数据\nmysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; set session transaction isolation level serializable ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | SERIALIZABLE | +-------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | mmm | 500 | | 4 | mmm | 1500 | | 5 | mmm | 1000 | +----+----------+---------+ 3 rows in set (0.00 sec) mysql\u0026gt; update account set username =\u0026#39;www\u0026#39; ; 这时还没有更新,cmd中开启了一个事务尝试往这张表中插入数据\nimage-20211002154329103\r这就会将表锁住,因为上一个事务在使用这张表,为了防止数据库出现幻读的操作,该隔离级别将表锁住了,这样子完全插入不了,做更新的时候就可以保证更新的数据条目和查出来的数据条目是一致的了.\nimage-20211002154520024\r在mysql中设置隔离级别 每启动一个mysql程序,就会获得一个单独的数据库连接.每个数据库连接都有一个全局变量@@tx_isolation,表示当前的事务隔离级别 查看当前的隔离级别: select @@tx_isolation ; 设置当前mysql连接的隔离级别: set transaction isolation level read committed ; 设置数据库系统的全局的隔离级别: set global transaction isolation level read committed ; 事务的隔离级别 脏读 不可重复读 幻读 read uncommitted 会 会 会 read committed 不会 会 会 repeated read 不会 不会 会 serializable 不会 不会 不会 mysql中默认的是repeated read ;\noracle中默认的是read committed\n查看 select @@transaction_isolation ;\n设置 set session/global transaction isolation level serilizable\u0026hellip;\ndelete和truncate的区别 mysql\u0026gt; show variables like \u0026#39;autocommit\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | OFF | +---------------+-------+ 1 row in set, 1 warning (0.00 sec) mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) #删除数据 mysql\u0026gt; delete from account ; Query OK, 3 rows affected (0.00 sec) #回滚 mysql\u0026gt; rollback ; Query OK, 0 rows affected (0.01 sec) #数据还在 mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | mmm | 500 | | 4 | mmm | 1500 | | 5 | mmm | 1000 | +----+----------+---------+ 3 rows in set (0.00 sec) mysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) #删除数据 mysql\u0026gt; truncate account ; Query OK, 0 rows affected (0.03 sec) #回滚 mysql\u0026gt; rollback ; Query OK, 0 rows affected (0.00 sec) #无法恢复 mysql\u0026gt; select * from account ; Empty set (0.01 sec) savepoint的使用\nmysql\u0026gt; set autocommit = 0 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; start transaction ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; delete from account where id =1 ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; delete from account where id = 2; Query OK, 1 row affected (0.00 sec) #设置保存点 mysql\u0026gt; savepoint a ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; delete from account where id =3 ; Query OK, 1 row affected (0.00 sec) #回到保存点 mysql\u0026gt; rollback to a ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 3 | 关羽 | 3000 | +----+----------+---------+ 1 row in set (0.00 sec) #还可以再回滚 mysql\u0026gt; rollback ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select * from account ; +----+----------+---------+ | id | username | balance | +----+----------+---------+ | 1 | 刘备 | 1000 | | 2 | 张飞 | 2000 | | 3 | 关羽 | 3000 | +----+----------+---------+ 3 rows in set (0.00 sec) 视图 虚拟表,和普通表一样使用,通过普通表动态生成的数据\nmysql5.1开始提供视图功能.一种虚拟存在的表,行和列的数据来自定义视图的查询中使用的表,并且是在使用视图时动态生成的,只保存了sql逻辑,不保存查询结果\n应用场景 多个地方用到了同样的查询结果 该查询结果使用的sql语句较为复杂 创建视图\n语法 create view 视图名 as 查询语句\nmysql\u0026gt; create view info as select e.last_name,d.department_name,j.* from employees e join departments d on e.department_id = d.department_id join jobs j on j.job_id = e.job_id ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from info where last_name like \u0026#39;%a%\u0026#39;; +------------+-----------------+------------+---------------------------------+------------+------------+ | last_name | department_name | job_id | job_title | min_salary | max_salary | +------------+-----------------+------------+---------------------------------+------------+------------+ | Kochhar | Exe | AD_VP | Administration Vice President | 15000 | 30000 | | De Haan | Exe | AD_VP | Administration Vice President | 15000 | 30000 | #查询各部门的平均工资级别 mysql\u0026gt; select a.department_id , g.grade_level , a.平均工资 from (select e.department_id , avg(salary) 平均工资 from employees e group by department_id )a join job_grades g on a.平均工资 between lower_sal and highest_sal ; +---------------+-------------+--------------+ | department_id | grade_level | 平均工资 | +---------------+-------------+--------------+ | NULL | C | 7000.000000 | | 10 | B | 4400.000000 | | 20 | C | 9500.000000 | #如果用视图来做简化一点点 mysql\u0026gt; create view myv2 as select e.department_id , avg(salary) 平均工资 from employees e group by e.department_id ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select m.*,j.grade_level from myv2 m join job_grades j on m.平均工资 between j.lower_sal and j.highest_sal ; +---------------+--------------+-------------+ | department_id | 平均工资 | grade_level | +---------------+--------------+-------------+ | NULL | 7000.000000 | C | | 10 | 4400.000000 | B | #查询平均工资最低的部门信息 mysql\u0026gt; select * from departments d where d.department_id = (select department_id from employees e group by e.department_id order by avg(salary) asc limit 1); +---------------+-----------------+------------+-------------+ | department_id | department_name | manager_id | location_id | +---------------+-----------------+------------+-------------+ | 50 | Shi | 121 | 1500 | +---------------+-----------------+------------+-------------+ #使用视图 mysql\u0026gt; select * from departments where department_id = (select department_id from myv2 order by 平均工资 limit 1); +---------------+-----------------+------------+-------------+ | department_id | department_name | manager_id | location_id | +---------------+-----------------+------------+-------------+ | 50 | Shi | 121 | 1500 | +---------------+-----------------+------------+-------------+ #可以使用视图套视图 视图的优点\n重用sql语句 简化复杂的sql操作,不知道他的查询细节 保护数据,提高安全性 视图的修改\n方式一 create or replace view 视图名 as 查询语句 ;\n方式二 alter view 视图名 as 查询语句;\n视图的删除\ndrop view 视图名,视图名,\u0026hellip;\nmysql\u0026gt; drop view emp_v1,emp_v2,info,myv2 ; Query OK, 0 rows affected (0.01 sec) 查看视图\ndesc 视图名 ;\n查看具体的过程 show create view 视图名 ;\n练习一下 mysql\u0026gt; create or replace view emp_v1 as select last_name , salary , email from employees where phone_number like \u0026#39;011%\u0026#39; ; Query OK, 0 rows affected (0.01 sec) #创建视图要求查询部门的最高工资高于12000的部门信息 mysql\u0026gt; create or replace view emp_v2 as select d.* from departments d join employees e on e.department_id = d.department_id group by e.department_id having max(salary) \u0026gt;12000 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from emp_v2 ; +---------------+-----------------+------------+-------------+ | department_id | department_name | manager_id | location_id | +---------------+-----------------+------------+-------------+ | 90 | Exe | 100 | 1700 | | 80 | Sal | 145 | 2500 | | 20 | Mar | 201 | 1800 | +---------------+-----------------+------------+-------------+ 视图的更新\n视图的插入\nmysql\u0026gt; create or replace view myv1 as select last_name , email from employees; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from myv1 ; +-------------+----------+ | last_name | email | +-------------+----------+ | K_ing | SKING | | Kochhar | NKOCHHAR | #原始表也插入了张飞这条数据了 mysql\u0026gt; insert into myv1 values(\u0026#39;张飞\u0026#39;, \u0026#39;101@qq.com\u0026#39;); Query OK, 1 row affected (0.01 sec) 视图的更新\nmysql\u0026gt; update myv1 set last_name = \u0026#39;张无忌\u0026#39; where last_name = \u0026#39;张飞\u0026#39; ; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 #都会修改原始表 视图的删除\nmysql\u0026gt; delete from myv1 where last_name = \u0026#39;张无忌\u0026#39; ; Query OK, 1 row affected (0.01 sec) #都会修改原始表 通常情况下不会对视图进行增删改的操作的\n备注: 视图的可更新性和视图中查询的定义有关系,以下类型的视图是不能更新的\n包含以下关键字的sql语句:分组函数/distinct/group by/having/union/union all 常量视图 select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表 #关键字的sql语句的视图不可以被更新 mysql\u0026gt; create or replace view myv2 as select max(salary) m ,department_id from employees group by department_id ; Query OK, 0 rows affected (0.01 sec) #想想也是,怎么能简单的更新一下max(salary)呢,聚合函数的值是算出来的 mysql\u0026gt; update myv2 set m =9000 where department_id = 10 ; ERROR 1288 (HY000): The target table myv2 of the UPDATE is not updatable #常量视图不能修改 mysql\u0026gt; create or replace view myv3 as select \u0026#39;john\u0026#39; name ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from myv3 ; +------+ | name | +------+ | john | +------+ 1 row in set (0.00 sec) mysql\u0026gt; update myv3 set name = \u0026#39;lucy\u0026#39; ; ERROR 1288 (HY000): The target table myv3 of the UPDATE is not updatable #select中包含子查询的不能修改视图 mysql\u0026gt; create or replace view myv4 as select (select max(salary) from employees) 最高工资 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from myv4 ; +----------+ | 最高工资 | +----------+ | 24000.00 | +----------+ 1 row in set (0.01 sec) mysql\u0026gt; update myv4 set 最高工资 = 10000 ; ERROR 1288 (HY000): The target table myv4 of the UPDATE is not updatable #join中不能更新视图 mysql\u0026gt; create or replace view myv5 as select last_name ,department_name from employees e join departments d on e.department_id = d.department_id ; Query OK, 0 rows affected (0.01 sec) #可以更新 mysql\u0026gt; update myv5 set last_name = \u0026#39;张飞\u0026#39; where last_name= \u0026#39;Whalen\u0026#39; ; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 #不能插入 , 可能是因为两个视图中有一个是department_id是主键叭 mysql\u0026gt; insert into myv5 values (\u0026#39;陈真\u0026#39;,\u0026#39;xxxx\u0026#39;) ; ERROR 1394 (HY000): Can not insert into join view \u0026#39;myemployees.myv5\u0026#39; without fields list #由一个不可更新的视图构成的视图不可更新 mysql\u0026gt; create or replace view myv6 as select * from myv4 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from myv6 ; +----------+ | 最高工资 | +----------+ | 24000.00 | +----------+ 1 row in set (0.01 sec) mysql\u0026gt; update myv6 set 最高工资 = 20000 ; ERROR 1288 (HY000): The target table myv6 of the UPDATE is not updatable #where子句的子查询引用了from子句中的表 相当于自连接 mysql\u0026gt; create or replace view myv7 as select last_name , email , salary from employees where employee_id in(select manager_id from employees where manager_id is not null) ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select * from myv7 ; +-----------+----------+----------+ | last_name | email | salary | +-----------+----------+----------+ | K_ing | SKING | 24000.00 | | De Haan | LDEHAAN | 17000.00 | | Hunold | AHUNOLD | 9000.00 | | Kochhar | NKOCHHAR | 17000.00 | | Greenberg | NGREENBE | 12000.00 | | Raphaely | DRAPHEAL | 11000.00 | | Weiss | MWEISS | 8000.00 | | Fripp | AFRIPP | 8200.00 | | Kaufling | PKAUFLIN | 7900.00 | | Vollman | SVOLLMAN | 6500.00 | | Mourgos | KMOURGOS | 5800.00 | | Russell | JRUSSEL | 14000.00 | | Partners | KPARTNER | 13500.00 | | Errazuriz | AERRAZUR | 12000.00 | | Cambrault | GCAMBRAU | 11000.00 | | Zlotkey | EZLOTKEY | 10500.00 | | Hartstein | MHARTSTE | 13000.00 | | Higgins | SHIGGINS | 12000.00 | +-----------+----------+----------+ 18 rows in set (0.00 sec) mysql\u0026gt; update myv7 set salary =10000 where last_name = \u0026#39;K_ing\u0026#39; ; ERROR 1288 (HY000): The target table myv7 of the UPDATE is not updatable 视图和表的对比 创建语法的关键字 是否实际占用物理空间 使用 视图 create view 只是保存了sql逻辑 增删改查,只是一般不能增删改 表 create table 保存了数据 增删改查 delete和truncate在事务使用时的区别 delete可以回滚 truncate不能回滚 练习一下 #添加约束 创建表 但是这样 列级约束中外键是不起作用的 mysql\u0026gt; create table Book ( bid int primary key , bname varchar(200) not null unique , price float default(10),btypeId int references booktype(id)); Query OK, 0 rows affected (0.03 sec) #这里发现索引只有 主键和唯一键 mysql\u0026gt; show index from book ; +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | book | 0 | PRIMARY | 1 | bid | A | 0 | NULL | NULL | | BTREE | | | YES | NULL | | book | 0 | bname | 1 | bname | A | 0 | NULL | NULL | | BTREE | | | YES | NULL | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 2 rows in set (0.01 sec) #所以要改成这样 mysql\u0026gt; create table Book ( bid int primary key , bname varchar(200) not null unique , price float default(10),btypeId int , foreign key(btypeId) references bookType(id)); Query OK, 0 rows affected (0.03 sec) mysql\u0026gt; show index from book ; +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ | book | 0 | PRIMARY | 1 | bid | A | 0 | NULL | NULL | | BTREE | | | YES | NULL | | book | 0 | bname | 1 | bname | A | 0 | NULL | NULL | | BTREE | | | YES | NULL | | book | 1 | btypeId | 1 | btypeId | A | 0 | NULL | NULL | YES | BTREE | | | YES | NULL | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 3 rows in set (0.01 sec) mysql\u0026gt; create or replace view myvbook as select bname , name from book b join booktype t on b.btypeid = t.id where price \u0026gt;100 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; create or replace view myvbook1 as select bname , price from book where price between 90 and 120 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; drop view myvbook , myvbook1 ; Query OK, 0 rows affected (0.01 sec) 复习前一天内容 DDL语言\n常见的约束\nNOT NULL 非空,该字段的值必填\nDEFAULT 默认,该字段的值不用手动插入有默认值\nCHECK 检查 mysql不支持\nPRIMARY KEY 主键 该字段的值不可重复并且非空 unique+not null\nFOREIGN KEY 外键 该字段的值引用了另外的表的字段\nUNIQUE 唯一 该字段的值不可重复\n主键和唯一的区别\n一个表至多有一个主键 , 但可以有多个唯一键 主键不允许为空 , 唯一可以为空 都具有唯一性,都支持组合键 , 但不推荐 外键\n用于限制两个表的关系,从表的字段引用了主表的某字段值 要求外键列和主表的被引用列要求类型一致,意义一样,名称无要求 主表的被引用列要求是一个key(一般就是主键) 插入数据,先插入主表 删除数据,先删除从表 级联删除\n实际上就是在删除主表里的数据的时候,把从表里相关的带有该数据的行也一并删除\n#级联删除 alter table stuinfo add constraint fk_stu_major foreign key(majorid) references major(id) on delete cascade ; 级联置空\n实际上就是在删除主表里的数据的时候,把从表里相关的带有该数据的行的对应字段置为空\n#级联置空 alter table stuinfo add constraint fk_stu_major foreign key(majorid) references major(id) on delete set null ; 创建表时添加约束\ncreate table 表名( 字段名 字段类型 not null , 字段名 字段类型 primary key , 字段名 字段类型 unique , 字段名 字段类型 default , constraint 约束名 foreign key(字段名) references 主表(被引用列) ) **注意:\t**\n支持类型 可以起约束名字 列级约束 除了外键 不可以 表级约束 除了默认,非空 可以,但是对主键无效 列级约束可以在一个字段上追加多个,中间用空格隔开,没有顺序要求\n修改表时添加或删除约束\n非空\nalter table 表名 modify column 字段名 字段类型 not null ;\n删除非空\nalter table 表名 modify column 字段名 字段类型 ;\n默认\nalter table 表名 modify column 字段名 字段类型 default 值 ;\n删除默认\nalter table 表名 modify column 字段名 字段类型;\n主键\nalter table 表名 add primary key (字段名) ;\n删除主键\nalter table 表名 drop primary key ;\n唯一\nalter table 表名 add unique (字段名) ;\n删除\nalter table 表名 drop index 索引名 ;\n外键\nalter table 表名 add foreign key (字段名) references 主表 (被引用列) ;\n删除外键\nalter table 表名 drop foreign key 约束名 ;\n自增长列\n特点\n不用手动插入值 , 可以自动提供序列值,默认从1开始,步长为1 auto_increament_increment 如果要更改起始值:手动插入值 如果要更改步长:更改系统变量 set auto_increment_increment = 值 ; 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key 创建表时设置自增长列\ncreate table 表\n修改表时设置自增长列\ncreate table 表 modify column 字段名 字段类型 约束 auto_increment ;\n删除自增长列\nalter table 表 modify column 字段名 字段类型 约束\nTCL语言\n事务:一条或多条sql语句组成一个执行单位,一组sql句要么都执行要么都不执行\n特点(ACID)\n原子性 一个事务是不可再分割的整体,要么都执行要么都不执行 一致性 一个事务可以使数据从一个一致状态切换到另一个一致的状态 隔离性 一个事务不受其他事务的干扰,多个事务互相隔离的 持久性 一个事务一旦提交了,则永久的持久化到本地 事务的使用步骤\n了解:\n隐式事务(自动事务) 没有明显的开始和结束,本事就是一条事务可以自动提交,比如insert update delete 显式事务 具有明显的开启和结束 使用显式事务\n开启事务 set autocommit = 0 start transacton ; 可以省略 编写逻辑sql语句 一条或者多条 注意 不包含create alter drop 只支持insert update delete select 设置回滚点 savepoint 回滚点名 ; 结束事务 提交 commit 回滚 rollback 回滚点 rollback to 回滚点名; 并发事务 事务的并发问题是如何发生的 多个事务同时操作同一个数据库的相同数据时\n并发问题有哪些 脏读 一个事务读取了其他事务还没有提交的数据 读到的是其他事务\u0026quot;更新\u0026quot;的数据 不可重复读 一个事务多次读取结果不一样 重复读取可能造成数据不一致的现象 幻读 一个事务读取了其他事务还没有提交的数据 只是读到的是 其他事务\u0026quot;插入\u0026quot;的数据 如何解决并发问题 通过设置隔离级别来解决 隔离级别 脏读 不可重复读 幻读 read uncommitted 读未提交 会 会 会 read committed 读已提交 不会 会 会 (oracle默认) repeatted read 可重复读 不会 不会 会 (msyql默认) serializable 串行化 不会 不会 不会 视图 含义 mysql5.1版本出现的新特性 , 本身是一个虚拟表,是通过表数据动态生成的,查看时动态生成\n好处\n简化sql语句 封装重用 保护了基表的数据,提高了安全性 创建\ncreate or replace view 视图名 as select \u0026hellip;\u0026hellip;\n修改\ncreate or replace view 视图名 as select \u0026hellip;..\nalter view 视图名 as select \u0026hellip;.\n删除\ndrop view 视图名,视图名\u0026hellip;\n查看\ndesc 视图名\nshow create view 视图名\n使用\ninsert delete update select\n**注意:\t**视图一般用于查询的,而不是更新的,所以具备以下的视图都不允许更新\n带有 group by 分组函数 union having where后的子查询用到了from中的表 常量视图 从不可更新的视图中生成的视图 join 视图和表的区别\nview 和 table 视图占用较少物理空间 表占用实际数据 视图一般用于查询 表用于增删改查 变量 系统变量 全局变量 会话变量 自定义变量 用户变量 局部变量 系统变量 说明:变量由系统提供,不是用户定义,属于服务器层面\n使用的语法:\n查看所有的系统变量 show golbal/session variables ; session是默认的 查看满足条件的部分系统变量 show global/session variables like \u0026lsquo;%char%\u0026rsquo; ; 查看指定的某个系统变量的值 select @@global/session.系统变量名字 ; session是默认的 为某个系统变量赋值 方式一 set global/session 系统变量名 = 值 ; 方式二 set @@global/session.系统变量名 = 值; show global variables ; mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set (0.00 sec) 注意\n如果是全局级别,则需要加global , 如果是会话级别,则需要加session , 如果不写, 则默认\n全局变量\n作用域:服务器每次启动将为所有的全局变量赋初始值,针对所有的会话连接有效,但不能跨重启\nshow gloabl variables ;\n查看部分的全局变量\nshow global variables ; show variables like \u0026lsquo;%char%\u0026rsquo; ;\n查看指定的全局变量的值\nselect @@global.autocommit ;\n为某个指定的全局变量赋值\nmysql\u0026gt; set @@global.autocommit = 0 ; Query OK, 0 rows affected (0.00 sec)\n会话变量\n作用域:仅仅针对于当前会话(连接)有效\n查看所有的会话变量\nshow session variables ;\nshow variables ;\n查看部分的会话变量\nshow variables like \u0026lsquo;%char%\u0026rsquo; ;\nshow session variables like \u0026lsquo;%char%\u0026rsquo; ;\n查看指定的某个会话变量\nselect @@transaction_isolation ;\nselect @@session.transaction_isolation ;\n为某个会话变量赋值\n方式一\nmysql\u0026gt; set @@session.transaction_isolation = \u0026lsquo;read-committed\u0026rsquo; ; Query OK, 0 rows affected (0.00 sec)\n方式二\nmysql\u0026gt; set session transaction isolation level read uncommitted ; Query OK, 0 rows affected (0.00 sec)\n方式三\nset session transaction_isolation = \u0026lsquo;serializable\u0026rsquo; ;\nmysql\u0026gt; show variables like \u0026#39;%char%\u0026#39; ; +--------------------------+---------------------------------------------------------+ | Variable_name | Value | +--------------------------+---------------------------------------------------------+ | character_set_client | gbk | | character_set_connection | gbk | | character_set_database | utf8mb4 | | character_set_filesystem | binary | | character_set_results | gbk | | character_set_server | utf8mb4 | | character_set_system | utf8mb3 | | character_sets_dir | C:\\Program Files\\MySQL\\MySQL Server 8.0\\share\\charsets\\ | +--------------------------+---------------------------------------------------------+ 8 rows in set, 1 warning (0.00 sec) mysql\u0026gt; show session variables like \u0026#39;%char%\u0026#39; ; +--------------------------+---------------------------------------------------------+ | Variable_name | Value | +--------------------------+---------------------------------------------------------+ | character_set_client | gbk | | character_set_connection | gbk | | character_set_database | utf8mb4 | | character_set_filesystem | binary | | character_set_results | gbk | | character_set_server | utf8mb4 | | character_set_system | utf8mb3 | | character_sets_dir | C:\\Program Files\\MySQL\\MySQL Server 8.0\\share\\charsets\\ | +--------------------------+---------------------------------------------------------+ 8 rows in set, 1 warning (0.00 sec) mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select @@session.transaction_isolation ; +---------------------------------+ | @@session.transaction_isolation | +---------------------------------+ | REPEATABLE-READ | +---------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; set session transaction isolation level read uncommitted ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; set @@session.transaction_isolation = \u0026#39;read-committed\u0026#39; ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select @@transaction_isolation ; +-------------------------+ | @@transaction_isolation | +-------------------------+ | READ-COMMITTED | +-------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; set session transaction_isolation = \u0026#39;serializable\u0026#39; ; Query OK, 0 rows affected (0.00 sec) 自定义变量 说明:变量是用户自定义的,不是由系统生成的\n使用步骤:声明=\u0026gt;赋值=\u0026gt;使用(查看/比较/运算等)\n用户变量\n作用域:针对当前会话(连接)有效,同于会话变量的作用域 , 应用在任何地方,也就是begin end里面或者begin end 外面\n赋值操作符 =或者 :=\n声明并初始化 set @用户变量名 = 值 | set@用户变量名 :=值 | select @用户变量名:=值\n赋值\n方式一 set @用户变量名 = 值 | set@用户变量名 :=值 | select @用户变量名:=值 方式二 通过 select into select 字段 into 变量名 from 表 使用\nselect @用户变量名\nmysql\u0026gt; set @name := \u0026#39;ljs\u0026#39; ; Query OK, 0 rows affected (0.00 sec) #弱类型 mysql\u0026gt; set @name = 1997 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; set @count = 1 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; use myemployees ; Database changed #方式二 mysql\u0026gt; select count(*) into @count from employees ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select @name ; +-------+ | @name | +-------+ | 1997 | +-------+ 1 row in set (0.00 sec) mysql\u0026gt; select @count ; +--------+ | @count | +--------+ | 107 | +--------+ 1 row in set (0.00 sec) 局部变量 作用域:仅仅在定义它的begin end中有效\n应用在begin end 中的第一句话!!!\n声明\ndeclare 变量名 类型 ;\ndeclare 变量名 类型 default 值;\n赋值\n方式一\nset 局部变量名 = 值;\n方式二\nset 局部变量名 := 值 ;\n方式三\nselect @局部变量名 := 值 ;\n方式四\nselect 值 into @局部变量名 from 表 ;\n使用\nselect 局部变量名 ;\n对比用户变量和局部变量\n作用域 定义和使用的位置 语法 用户变量 当前会话 会话中的任何地方 需要加上@符号,不用限定类型 局部变量 begin end 中 只能在begin end中,且为第一句话 一般不用加上@符号,除非select,需要限定类型 #使用用户变量 mysql\u0026gt; set @a := 1 ; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select b1 into @b from (select 1 b1)b ; Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select @b+@a ; +-------+ | @b+@a | +-------+ | 2 | +-------+ #只能在begin end中才行 mysql\u0026gt; declare m int default 1 ; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;declare m int default 1\u0026#39; at line 1 存储过程和函数 存储过程和函数:类似与java中的方法\n好处:\n提高代码的重用性 简化操作 存储过程\n含义:一组预先编译豪的sql语句的集合,理解成批处理语句\n好处:\n提高了代码的重用性 简化操作 减少了编译次数并减少了和数据库服务器的连接次数,提高了效率 创建语法\ncreate procedure 存储过程名(参数列表)\nbegin\n​\t存储过程体(一组合法的sql语句)\nend\n注意:\n参数列表包含三部分 参数模式 参数名 参数类型\nIN stuname varchar(20) 参数模式 IN 该参数可以作为输入,也就是该参数需要调用方传入值 OUT 该参数可以作为输出,也就是该参数可以作为返回值 INOUT 该参数既可以作为输入又可以作为输出,也就是该参数既需要传入值,又可以返回值 如果存储过程体仅仅只有一句话 , begin end 可以省略\n存储过程体中的每条sql语句的结尾要求必须加分号;\n存储过程的结尾可以使用 DELIMITER重新设置\n语法:\nDELIMITER 结束标记\nDELIMITER $\n调用语法\nCALL 存储过程名 (实参列表) 结束标记;\n空参列表 #实现批量插入数据 mysql\u0026gt; show procedure status like \u0026#39;myp1\u0026#39;; +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ | Db | Name | Type | Definer | Modified | Created | Security_type | Comment | character_set_client | collation_connection | Database Collation | +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ | girls | myp1 | PROCEDURE | root@localhost | 2021-10-10 10:19:11 | 2021-10-10 10:19:11 | DEFINER | | gbk | gbk_chinese_ci | utf8_general_ci | +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ 1 row in set (0.01 sec) mysql\u0026gt; use girls ; Database changed #写错了 就把存储过程删了重来 mysql\u0026gt; drop procedure myp1 ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; show procedure status like \u0026#39;myp1\u0026#39; ; Empty set (0.01 sec) mysql\u0026gt; delimiter $ mysql\u0026gt; create procedure myp1() -\u0026gt; begin -\u0026gt; insert into admin(username ,password) -\u0026gt; values (\u0026#39;ljs\u0026#39;,\u0026#39;11\u0026#39;),(\u0026#39;jwt\u0026#39;,\u0026#39;22\u0026#39;),(\u0026#39;lje\u0026#39;,\u0026#39;33\u0026#39;),(\u0026#39;fyz\u0026#39;,\u0026#39;44\u0026#39;),(\u0026#39;wzr\u0026#39;,\u0026#39;55\u0026#39;) ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; show procedure status like \u0026#39;myp1\u0026#39; $; +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ | Db | Name | Type | Definer | Modified | Created | Security_type | Comment | character_set_client | collation_connection | Database Collation | +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ | girls | myp1 | PROCEDURE | root@localhost | 2021-10-10 11:33:35 | 2021-10-10 11:33:35 | DEFINER | | gbk | gbk_chinese_ci | utf8_general_ci | +-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ 1 row in set (0.01 sec) #执行存储过程 mysql\u0026gt; CALL myp1() $ ; Query OK, 5 rows affected (0.00 sec) mysql\u0026gt; select * from admin $ ; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | john | 8888 | | 2 | lyt | 6666 | | 3 | ljs | 11 | | 4 | jwt | 22 | | 5 | lje | 33 | | 6 | fyz | 44 | | 7 | wzr | 55 | +----+----------+----------+ 7 rows in set (0.00 sec) 创建带IN模式参数的存储过程 #查看女神的男朋友 mysql\u0026gt; DELIMITER $ ; mysql\u0026gt; create procedure myp2 (IN girlName varchar(20)) -\u0026gt; begin -\u0026gt; select bo.* from boys bo right join beauty b on bo.id = b.boyfriend_id -\u0026gt; where b.name = girlName ; -\u0026gt; end $ ; Query OK, 0 rows affected (0.01 sec) -\u0026gt; $ ERROR 1065 (42000): Query was empty mysql\u0026gt; CALL myp2(\u0026#39;柳岩\u0026#39;); -\u0026gt; $ +------+---------+--------+ | id | boyName | userCP | +------+---------+--------+ | 2 | 张飞 | 10 | +------+---------+--------+ 1 row in set (0.01 sec) Query OK, 0 rows affected, 1 warning (0.01 sec) #传入多个参数,判断用户是否登陆成功 方式一 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp3(IN username varchar(20),IN password varchar(20)) -\u0026gt; begin -\u0026gt; select case when count(*) \u0026gt; 0 then \u0026#39;登陆成功\u0026#39; else \u0026#39;未登陆\u0026#39; end 登陆状态 from admin where admin.username =username and admin.password = password ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call myp3(\u0026#39;john\u0026#39;,\u0026#39;8888\u0026#39;)$; +----------+ | 登陆状态 | +----------+ | 登陆成功 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt; call myp3(\u0026#39;john\u0026#39;,\u0026#39;8887\u0026#39;)$; +----------+ | 登陆状态 | +----------+ | 未登陆 | +----------+ 1 row in set (0.00 sec) #方式二 使用局部变量 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp4(in username varchar(20) , in password varchar(20)) -\u0026gt; begin -\u0026gt; declare result varchar(20) default \u0026#39;\u0026#39;; -\u0026gt; select count(*) into result from admin where admin.username = username and admin.password = password ; -\u0026gt; select if(result =\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;); -\u0026gt; end $ ; Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myp4(\u0026#39;john\u0026#39;,\u0026#39;8888\u0026#39;)$; +-------------------------------------+ | if(result =\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;) | +-------------------------------------+ | 登陆成功 | +-------------------------------------+ 1 row in set (0.00 sec) Query OK, 0 rows affected, 2 warnings (0.00 sec) mysql\u0026gt; CALL myp4(\u0026#39;john\u0026#39;,\u0026#39;88887\u0026#39;)$; +-------------------------------------+ | if(result =\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;) | +-------------------------------------+ | 未登陆 | +-------------------------------------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.01 sec) 创建带out模式的存储过程 #根据女神名,返回对应男神名 mysql\u0026gt; DELIMITER $ mysql\u0026gt; CREATE procedure myp5(in beautyname varchar(20),out boyname varchar(20)) -\u0026gt; begin -\u0026gt; select bo.boyname into boyname from boys bo where bo.id in (select boyfriend_id from beauty where name = beautyname) ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) #不用初始化也是可以的 mysql\u0026gt; set @boyname := \u0026#39;\u0026#39;; -\u0026gt; call myp5(\u0026#39;柳岩\u0026#39;,@boyname)$; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select @boyname ; -\u0026gt; $ +----------+ | @boyname | +----------+ | 张飞 | +----------+ 1 row in set (0.00 sec) #多个out返回值 , 返回男朋友的名字和魅力值 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp6(in girlname char(20) , out boyname char(20) , out soulIndex int) -\u0026gt; begin -\u0026gt; select bo.boyname , bo.usercp into boyname , soulIndex from boys bo join beauty b on b.boyfriend_id = bo.id where b.name = girlname ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call myp6(\u0026#39;柳岩\u0026#39;,@boyname,@soulIndex)$; Query OK, 1 row affected, 2 warnings (0.00 sec) mysql\u0026gt; select @boyname $ +----------+ | @boyname | +----------+ | 张飞 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt; select @soulIndex $ +------------+ | @soulIndex | +------------+ | 10 | +------------+ 1 row in set (0.00 sec) 创建带INOUT模式参数的存储过程 mysql\u0026gt; DELIMITER $ mysql\u0026gt; CREATE procedure myp7 (inout a int , inout b int ) -\u0026gt; begin -\u0026gt; set a = a*2 ; -\u0026gt; set b = b*2 ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; set @a:=1 ; -\u0026gt; set @b:=2 ; -\u0026gt; CALL myp7(@a,@b)$; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; select @a,@b; -\u0026gt; $ +------+------+ | @a | @b | +------+------+ | 2 | 4 | +------+------+ 1 row in set (0.00 sec) 练习一下\n#传入用户名密码,插入admin表 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp8(in username varchar(20),in password varchar(20)) -\u0026gt; begin -\u0026gt; insert into admin(admin.username , admin.password ) values (username,password); -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myp8(\u0026#39;wlz\u0026#39;,\u0026#39;hellouu\u0026#39;)$ Query OK, 1 row affected, 2 warnings (0.00 sec) #查询传入女神编号 , 返回女神名称和女神电话 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp9(in id int , out girlname varchar(20) , out phone varchar(11)) -\u0026gt; begin -\u0026gt; select b.name , b.phone into girlname , phone from beauty b where b.id = id ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myp9(1,@girlname , @phone)$ Query OK, 1 row affected, 2 warnings (0.00 sec) mysql\u0026gt; select @girlname , @phone $ +-----------+-------------+ | @girlname | @phone | +-----------+-------------+ | 柳岩 | 18209876577 | +-----------+-------------+ 1 row in set (0.00 sec) #比较两个日期大小 并返回大小关系 mysql\u0026gt; DELIMITER $ mysql\u0026gt; create procedure myp10(in birth1 datetime , in birth2 datetime , out result int ) -\u0026gt; begin -\u0026gt; select if(datediff(birth1,birth2)\u0026gt;0,1,if(datediff(birth1,birth2)\u0026lt;0,-1,0)) into result ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myp10(\u0026#39;1997-11-21\u0026#39;,\u0026#39;1998-11-21\u0026#39;,@result)$ Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select @result $ +---------+ | @result | +---------+ | -1 | +---------+ 1 row in set (0.00 sec) 删除存储过程\ndrop procedure 存储过程名 一次只能删除一次\n查看存储过程的信息\nshow create proceduce 存储过程名\n修改存储过程\n比较麻烦,通常不这么做\n练习一下\n#传入日期,转换成xx年xx月xx日并返回 mysql\u0026gt; create procedure myptest1(in mydate datetime , out strDate varchar(50)) -\u0026gt; begin -\u0026gt; select date_format(mydate,\u0026#39;%y年%m月%d日\u0026#39;) into strDate ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myptest1(\u0026#39;1997-11-21\u0026#39;,@strDate); -\u0026gt; select @strDate $ Query OK, 1 row affected, 1 warning (0.00 sec) +--------------+ | @strDate | +--------------+ | 97年11月21日 | +--------------+ 1 row in set (0.00 sec) #传入女神名字 输出 女神名字 and 男生名字 最好使用右连接 另外concat和null拼接永远都是null 所以要用ifnull的函数防止出问题 mysql\u0026gt; delimiter $ mysql\u0026gt; create procedure myptest2(inout girlName varchar(50)) -\u0026gt; select concat(b.name ,\u0026#39; AND \u0026#39;,bo.boyName) into girlName from beauty b join boys bo on b.boyfriend_id = bo.id where b.name = girlName ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; set @name :=\u0026#39;柳岩\u0026#39; ; -\u0026gt; CALL MYPTEST2(@name); -\u0026gt; select @name $ Query OK, 0 rows affected (0.00 sec) Query OK, 1 row affected (0.00 sec) +---------------+ | @name | +---------------+ | 柳岩 AND 张飞 | +---------------+ 1 row in set (0.00 sec) #传入条目数和起始索引,查询beauty表的记录 limit offset,size 是从offset的下一条开始的 mysql\u0026gt; delimiter $ mysql\u0026gt; create procedure myptest3(in size int , in startIndex int) -\u0026gt; begin -\u0026gt; select * from beauty limit startIndex,size ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; CALL myptest3(5,3) $ +----+--------+------+---------------------+-------------+--------------+--------------+ | id | name | sex | borndate | phone | photo | boyfriend_id | +----+--------+------+---------------------+-------------+--------------+--------------+ | 5 | 周冬雨 | 女 | 1992-02-03 00:00:00 | 18209179577 | NULL | 2 | | 7 | 岳灵珊 | 女 | 1987-12-30 00:00:00 | 18219876577 | NULL | 2 | | 9 | 双儿 | 女 | 1993-02-03 00:00:00 | 18209876579 | NULL | 2 | | 11 | 夏雪 | 女 | 1993-02-03 00:00:00 | 18209876579 | NULL | 2 | | 13 | 唐艺昕 | 女 | 1990-04-23 00:00:00 | 18988888 | NULL | 2 | +----+--------+------+---------------------+-------------+--------------+--------------+ 5 rows in set (0.00 sec) Query OK, 0 rows affected (0.02 sec) 函数 含义:一组预先编译豪的sql语句的集合,理解成批处理语句\n好处:\n提高了代码的重用性 简化操作 减少了编译次数并减少了和数据库服务器的连接次数,提高了效率 区别:\n存储过程:可以有0个返回,也可以有多个返回,适合做批量插入/批量更新\n函数:有且仅有1个返回,适合做处理数据后返回一个结果\n创建语法\ncreate function 函数名 (参数列表) return 返回类型\nbegin\n​\t函数体\nend\n注意:\n参数列表 包含两部分\n参数名 参数类型\n函数体:肯定会有return语句,如果没有会报错\n如果return语句没有放在函数体的最后也不报错,但不建议\nreturn 值;\n函数体中仅有一句话,则可以省略begin end\n使用delimeter语句作为设置结束标记\n调用语法\nselect 函数名(参数列表)\n无参有返回\n#返回公司的员工个数 #和存储过程不一样 这里要声明局部变量 最后一句需要return一下 #mysql中要改一下全局变量 这是我们开启了bin-log, 我们就必须指定我们的函数是否是 mysql\u0026gt; set global log_bin_trust_function_creators=1; -\u0026gt; $ Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; delimiter $ mysql\u0026gt; create function myf1() returns int -\u0026gt; begin -\u0026gt; declare count int default 0 ; -\u0026gt; select count(*) into count from employees ; -\u0026gt; return count ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) #使用的时候用select关键字 mysql\u0026gt; select myf1()$ +--------+ | myf1() | +--------+ | 107 | +--------+ 1 row in set (0.00 sec) 有参有返回\n#根据员工名,返回他的工资 mysql\u0026gt; delimiter $ mysql\u0026gt; create function myf3(departmentname varchar(20)) returns double(10,2) -\u0026gt; begin -\u0026gt; set @avgsalary := 0 ; -\u0026gt; select avg(salary) into @avgsalary from employees group by department_id having department_id in (select department_id from departments where department_name = departmentname ); -\u0026gt; return @avgsalary ; -\u0026gt; end $ Query OK, 0 rows affected, 1 warning (0.01 sec) mysql\u0026gt; select myf3(\u0026#39;Adm\u0026#39;); -\u0026gt; $ +-------------+ | myf3(\u0026#39;Adm\u0026#39;) | +-------------+ | 4400.00 | +-------------+ 1 row in set (0.00 sec) 查看函数 show create function myf3;\n删除函数\ndrop function myf3 ;\n存储过程和函数都在information_schema中的routines表中\nimage-20211010170437148\r练习一下\n#传入两个float的值 返回一个和 mysql\u0026gt; delimiter $ mysql\u0026gt; create function test_func1(a float , b float) returns float -\u0026gt; begin -\u0026gt; declare sum float default 0 ; -\u0026gt; set sum = a+b ; -\u0026gt; return sum ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; select test_func1(1,2) $ +-----------------+ | test_func1(1,2) | +-----------------+ | 3 | +-----------------+ 1 row in set (0.00 sec) mysql\u0026gt; select test_func1(1.1,-1.1) $ +----------------------+ | test_func1(1.1,-1.1) | +----------------------+ | 0 | +----------------------+ 1 row in set (0.00 sec) 流程控制结构 顺序结构:程序从上往下依次执行\n分支结构:程序从两条或多条路径中选择一条去执行\n循环结构:程序在满足一定条件的基础上,重复执行一段代码\n分支结构 if函数 功能:实现简单的双分支\n语法:\nif(表达式1,表达式2,表达式3)\n如果表达式1成立,则if函数返回表达式2的值,否则返回表达式3的值\n应用:任何地方\ncase结构 情况1:类似于java中的switch语句,一般用于实现等值判断\ncase 表达式|字段|变量\nwhen 要判断的值 then \u0026hellip; 或语句1 ;\nwhen 要判断的值 then \u0026hellip; 或语句2 ;\nelse \u0026hellip; 或语句n ;\nend case ;\n情况2:类似于java中的多重if语句,一般用于实现区间判断\ncase\nwhen 要判断的条件1 then \u0026hellip; 或语句1 ;\nwhen 要判断的表达式2 then \u0026hellip; 或语句2 ;\nelse \u0026hellip; 或语句n ;\nend case ;\n特点:\n可以作为表达式,嵌套在其他语句中使用,可以放在任何地方,begin end 中或者begin end 的外面 可以作为独立的语句去使用,只能放在begin end 中 如果when中的值或条件成立,则执行对应的then后面的语句,并且结束case 如果都不满足,则执行else中的语句或值 else可以省略,如果else省略了,并且所有when条件都不满足,则返回null image-20211010203810756\rimage-20211010203829794\r案例\n#90-100 显示A 80-90 显示B 60-80显示C 其余显示D mysql\u0026gt; create procedure test_case(in score int) -\u0026gt; begin -\u0026gt; case when score \u0026gt;=90 and score \u0026lt;=100 -\u0026gt; then select \u0026#39;A\u0026#39; ; -\u0026gt; when score \u0026gt;=80 and score \u0026lt;90 -\u0026gt; then select \u0026#39;B\u0026#39; ; -\u0026gt; when score \u0026gt;=60 and score \u0026lt;80 -\u0026gt; then select \u0026#39;C\u0026#39; ; -\u0026gt; else select \u0026#39;D\u0026#39; ; -\u0026gt; end case ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call test_case (95) $ +---+ | A | +---+ | A | +---+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) if结构 功能:实现多重分支\n语法:\nif 条件1 then 语句1 ;\nelse if 条件2 then 语句2 ;\n\u0026hellip;\nelse 语句n ;\nend if ;\n应用在begin end 中\n案例\n#90-100 返回A 80-90 返回B 60-80返回C 其余返回D #方式一 可以这样直接return mysql\u0026gt; create function test_if(score int) returns varchar(20) -\u0026gt; begin -\u0026gt; if score \u0026gt;=90 and score \u0026lt;=100 -\u0026gt; then return \u0026#39;A\u0026#39; ; -\u0026gt; elseif score \u0026gt;80 -\u0026gt; then return \u0026#39;B\u0026#39; ; -\u0026gt; elseif score \u0026gt;60 -\u0026gt; then return \u0026#39;C\u0026#39; ; -\u0026gt; else -\u0026gt; return \u0026#39;D\u0026#39; ; -\u0026gt; end if ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) #或者用原始的这样 这里注意 end if 一定要有封号!!!! mysql\u0026gt; create function test_id1(score int) returns varchar(20) -\u0026gt; begin -\u0026gt; set @grade :=\u0026#39;\u0026#39; ; -\u0026gt; if score \u0026gt;=90 and score \u0026lt;100 -\u0026gt; then set @grade = \u0026#39;A\u0026#39; ; -\u0026gt; elseif score \u0026gt;80 -\u0026gt; then set @grade = \u0026#39;B\u0026#39; ; -\u0026gt; elseif score \u0026gt;60 -\u0026gt; then set @grade = \u0026#39;C\u0026#39; ; -\u0026gt; else -\u0026gt; set @grade = \u0026#39;D\u0026#39; ; -\u0026gt; end if ; -\u0026gt; return @grade ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) 循环结构 分类:\nwhile loop repeat 循环控制:\niterate类似于continue ,结束本次循环,继续下一次\nleave 类似于 break , 跳出,结束当前所在的循环\nwhile [标签:] while 循环条件 do\n​\t循环体\nend while [标签]\nloop [标签:] loop\n​\t循环体\nend loop [标签]\n可以用来模拟简单的死循环\nrepeat [标签:] repeat\n​\t循环体\nuntil 结束循环的条件\nend repeat [标签]\n案例\n#批量插入 根据次数插入到admin中多条记录 mysql\u0026gt; create procedure pro_while1(in insertcount int ) -\u0026gt; begin -\u0026gt; declare i int default 0; -\u0026gt; while i\u0026lt;insertcount do -\u0026gt; insert into admin(id,username,password) values (null,concat(\u0026#39;rose\u0026#39;,i),666); -\u0026gt; set i = i+1 ; -\u0026gt; end while ; -\u0026gt; end $ Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call pro_while1(3) $ Query OK, 1 row affected (0.00 sec) mysql\u0026gt; select * from admin ; -\u0026gt; $ +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | john | 8888 | | 2 | lyt | 6666 | | 9 | rose0 | 666 | | 10 | rose1 | 666 | | 11 | rose2 | 666 | +----+----------+----------+ 11 rows in set (0.00 sec) #添加leave语句 #批量插入 , 根据次数插入到admin表中多条记录 , 如果次数\u0026gt;20 就停止 注意安全 if语句没写好 一直在循环插入了300w条数据 mysql\u0026gt; create procedure test_whileleave(in insertcount int ) -\u0026gt; begin -\u0026gt; declare i int default 0 ; -\u0026gt; a:while i \u0026lt; insertcount do -\u0026gt; if i=20 then leave a ; -\u0026gt; end if ; -\u0026gt; insert into admin(username,password) values (concat(\u0026#39;xiaohua\u0026#39;,i),\u0026#39;0000\u0026#39;) ; -\u0026gt; set i = i + 1 ; -\u0026gt; end while a ; -\u0026gt; end # Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call test_whileleave(30) # Query OK, 1 row affected (0.03 sec) #添加iterate ##批量插入 , 根据次数插入到admin表中多条记录 , 并且插入奇数 mysql\u0026gt; create procedure test_iterate(in insertcount int) -\u0026gt; begin -\u0026gt; declare i int default 1 ; -\u0026gt; a:while i \u0026lt;= insertcount do -\u0026gt; if mod(i,2) !=1 then set i = i+ 1 ; iterate a ; -\u0026gt; else -\u0026gt; insert into admin (username, password) values (concat(\u0026#39;jishu\u0026#39;,i),\u0026#39;1111\u0026#39;); -\u0026gt; set i = i + 1; -\u0026gt; end if ; -\u0026gt; end while a ; -\u0026gt; end # Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call test_iterate(20) # Query OK, 1 row affected (0.02 sec) image-20211010222825964\r练习一下 #新建表 然后像该表插入指定个数的 , 随机字符串 mysql\u0026gt; create table if not exists stringcontent (id int primary key auto_increment , content varchar(20)); Query OK, 0 rows affected, 1 warning (0.01 sec) mysql\u0026gt; create procedure test_randstr_insert(in insertcount int) -\u0026gt; begin -\u0026gt; declare i int default 0 ; -\u0026gt; declare str varchar(26) default \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;; -\u0026gt; declare startIndex int default 1 ; -\u0026gt; declare len int default 1 ; -\u0026gt; while i\u0026lt;insertcount do -\u0026gt; set startIndex = floor(rand()*26+1) ; -\u0026gt; set len = floor(rand()*(20-startindex+1)+1) ; -\u0026gt; insert into stringcontent(content) values (substr(str,startIndex,len)); -\u0026gt; set i = i + 1; -\u0026gt; end while ; -\u0026gt; end # Query OK, 0 rows affected (0.01 sec) mysql\u0026gt; call test_randstr_insert(10)# Query OK, 1 row affected (0.02 sec) mysql\u0026gt; select * from stringcontent # +----+--------------+ | id | content | +----+--------------+ | 1 | klm | | 2 | hijklmn | | 3 | pqr | | 4 | no | | 5 | rs | | 6 | abcde | | 7 | bcdefghijklm | | 8 | | | 9 | f | | 10 | lmn | +----+--------------+ 10 rows in set (0.00 sec) 复习一下 分类:\n系统变量\n说明:变量由系统提供的,不用自定义\n语法:\n查看系统变量 show global|session variables ;如果没有显式声明,那默认是session 查看指定的系统变量的值 select @@global|session.变量名 ; 为系统变量赋值 set gloabl|session 变量名 = 值 ; set @@global.变量名 = 值 ; set @@变量名 = 值; 全局变量 服务器层面上的,必须拥有super权限才能为系统变量赋值,作用域为整个服务器,也就是针对于所有连接(会话)有效,服务器重启后失效(除非修改配置) 会话变量 服务器为每一个连接的客户端都提供了系统变量,作用域为当前的连接(会话) 自定义变量\n说明:\n用户变量\n作用域：针对于当前连接(会话)生效\n位置:begin end 里面, 也可以放在外面\n使用\n声明并赋值\nset @变量名 = 值; set @变量名:= 值; select @变量名:=值 ; 更新值\nset @变量名 = 值; set @变量名:= 值; select @变量名:=值 ; select xx into @变量名 from 表 ; 使用\nselect @变量名 ; 局部变量\n作用域:仅仅在定义它的begin end 中有效 位置:只能放在begin end 中， 而且只能放在第一句 create procedure pro1() begin declare i int default 1 ; \u0026hellip; end 声明 declare 变量名 类型 default 值; 赋值或更新 set 变量名=值; set 变量名:= 值; select @变量名 := 值; select xx into 变量名 from 表 ; 使用 select 变量名 ; 存储过程和函数\n说明:都类似于java中的方法,将一组完成特定功能的逻辑语句包装起来,对外暴露名字\n好处:\n提高重用性 sql语句简单 减少了和数据库服务器连接的次数,提高了效率 创建\ncreate procedure 存储过程名 (参数模式 参数名 参数类型)\nbegin\n存储过程体\nend\n注意:参数模式 in out inout 其中IN可以省略 存储过程体中的每一条sql语句都需要分号结尾 调用\nCALL 存储过程名(实参列表)\n调用in模式的参数 call sp1(\u0026lsquo;值\u0026rsquo;) ;\n调用out模式的参数 set @name :=\u0026quot;\u0026quot; ; call sp1(@name) ;\n调用inout模式的参数 set @name = 值 ; call sp1(@name) ; select @name ;\n查看存储过程\nshow create procedure 存储过程名 ;\n删除存储过程\ndrop procedure 存储过程名 ;\n函数\n创建\ncreate function 函数名 (参数名 参数类型) returns 返回值类型\nbegin\ndeclare a int default 0 ;\n\u0026hellip;\nreturn a ;\nend\n**注意:\t**函数体中肯定需要有return语句\n调用\nselect 函数名 (实参列表) ;\n查看 show create function 函数名 ;\n删除\ndrop functioon 函数名 ;\n流程控制结构\n顺序结构 :程序从上往下依次执行 ;\n分支结构:: 程序按条件进行选择执行, 从两条或多条路径中选择一条执行 ;\n循环结构: 程序满足一定条件下,重复执行一组语句\n分支结构\nif函数 功能:简单实现双分支 if(条件, 值1 , 值2 ) 位置:任何位置 case 结构 功能:实现多分支 case 表达式字段 when 值1 then \u0026hellip; when 值2 then \u0026hellip; else \u0026hellip; end [case]; 位置:可以放在任何位置, 如果放在begin end 外面,作为表达式结合着其他语句使用 , 如果放在begin end 里面, 一般作为独立的语句使用 if结构 功能:实现多分支 if 条件1 then \u0026hellip;; elseif 条件2 then \u0026hellip;; else then \u0026hellip; ; end if ; 位置: 只能放在begin end中 循环结构\n注意:只能放在begin end 中\n特点:都能实现循环结构\n对比:\n这三种循环都可以省略名称,但如果循环中添加了循环控制语句(leave或iterate)则必须添加名称 loop 一般用于实现简单的死循环 while先判断后执行 repeat 先执行后判断,无条件至少执行一次 while\n[标签:] while 循环条件 do\n循环体\nend while [标签] ;\nloop\n[标签:] loop\n循环体\nend loop [标签]\nrepeat\n[标签:] repeat\n循环体\nuntil 结束条件\nend repeat [名称]\n循环控制语句\nleave:类似于 break , 用于跳出所在的循环\niterate:类似于continue , 用于结束本次循环, 继续下一次\n完结撒花😋😜💕🤣\n","date":"2021-10-10T23:44:44+08:00","permalink":"https://jianrongma.github.io/p/mysql%E5%9F%BA%E7%A1%80/","title":"Mysql基础"},{"content":"windows服务开发备忘 先开个窗体来调试试试看\n再新增一个service服务进来\n修改默认服务名\n添加安装程序 修改为本地\nimage-20210928105412125\r记得引入日志 并将config文件复制到输出目录\n有时候install.bat命令不行可能是系统没有权限\n跑服务的时候记得再program里改成服务,别泡成窗体应用了\n服务的onstart里需要写的是异步方法或者新开一个线程,否则会出现无法服务进程无法连接到服务控制器上的错误\nimage-20210928105853916\rimage-20210928105911601\r接口服务嘛,最好尝试ping一下服务器,服务器畅通才能工作\n另外最好对间隔时间做到可配置\n","date":"1999-10-01T09:17:59+08:00","permalink":"https://jianrongma.github.io/p/windows%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98/","title":"windows服务开发备忘"}]