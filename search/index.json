[{"content":"维保\n 优化内存占用 提高sql执行效率 索引 性能分析 慢查询日志 多线程上传数据  ","date":"2021-10-28T10:24:40+08:00","permalink":"https://linjianshu.github.io/p/%E6%B4%BB%E8%BF%9E%E4%B8%8A%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"活连上线学习文档"},{"content":"Mysql高级学习文档 mysql的架构介绍 mysql简介 mysqllinux版安装 mysql配置文件 mysql逻辑架构介绍 mysql存储引擎 索引优化分析 性能下降sql慢是执行时间长还是等待时间长 常见通用的join查询 索引简介 性能分析 索引优化 查询截取分析 查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志 mysql锁机制 锁的分类 主从复制 主从配置 mysql简介 高级mysql 完整的mysql优化\n mysql内核 sql优化攻城狮 mysql服务器的优化 各种参数常量设定 查询语句优化 主从复制 软硬件升级 容灾备份 sql编程  mysqllinux版的安装 \rimage-20211012195826053\r\n#查看当前ubuntu版本 yourtreedad@yourtreedad:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.3 LTS Release: 20.04 Codename: focal yourtreedad@yourtreedad:~$ 准备工作\n#切换到root账户 yourtreedad@yourtreedad:~$ sudo passwd root New password: Retype new password: passwd: password updated successfully yourtreedad@yourtreedad:~$ su root Password: root@yourtreedad:/home/yourtreedad# #查看电脑里有没有mysql root@yourtreedad:/home/yourtreedad# service mysql status * MySQL is stopped. root@yourtreedad:/home/yourtreedad# mysql --version mysql Ver 8.0.26-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu)) root@yourtreedad:/home/yourtreedad# service mysql start * Starting MySQL database server mysqld su: warning: cannot change directory to /nonexistent: No such file or directory #那就彻底卸载了 root@yourtreedad:/home/yourtreedad# sudo apt-get remove mysql-* root@yourtreedad:/home/yourtreedad# sudo rm -rf /etc/mysql/ root@yourtreedad:/home/yourtreedad# dpkg -l |grep ^rc|awk \u0026#39;{print $2}\u0026#39; |sudo xargs dpkg -P dpkg: error: --purge needs at least one package name argument #如果出现这个错误 dpkg: error: --purge needs at least one package name argument，说明已经清空完毕了 #全部删除了 root@yourtreedad:/home/yourtreedad# service mysql status mysql: unrecognized service root@yourtreedad:/home/yourtreedad# mysql --version bash: /usr/bin/mysql: No such file or directory root@yourtreedad:/home/yourtreedad# #更新到最新 安装rpm root@yourtreedad:/opt# apt-get update root@yourtreedad:/home/yourtreedad# apt-get upgrade root@yourtreedad:/home/yourtreedad# apt-get install rpm #使用rpm判断当前系统是否安装过mysql root@yourtreedad:/home/yourtreedad# rpm -qa|grep -i mysql #安装mysql root@yourtreedad:/opt# sudo apt-get install mysql-server mysql-client #查看是否安装成功 root@yourtreedad:/# id yourtreedad uid=1000(yourtreedad) gid=1000(yourtreedad) groups=1000(yourtreedad),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),117(netdev) root@yourtreedad:/# cat /etc/passwd|grep mysql mysql:x:112:119:MySQL Server,,,:/var/lib/mysql/:/bin/false root@yourtreedad:/# cat /etc/group|grep mysql mysql:x:119: root@yourtreedad:/# mysqladmin --version mysqladmin Ver 8.0.26-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu)) root@yourtreedad:/# root@yourtreedad:/# service mysql start root@yourtreedad:/# ps -ef|grep mysql mysql 18675 1 0 21:03 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe mysql 18822 18675 0 21:03 ? 00:00:00 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --log-error=/var/log/mysql/error.log --pid-file=yourtreedad.pid root 19055 16743 0 21:14 tty1 00:00:00 grep --color=auto mysql https://www.cnblogs.com/duolamengxiong/p/13650684.html\nmysql启停和自动运行 #查看运行时间 root@yourtreedad:/home/yourtreedad# top top - 21:17:30 up 1:21, 0 users, load average: 0.52, 0.58, 0.59 Tasks: 8 total, 1 running, 7 sleeping, 0 stopped, 0 zombie %Cpu(s): 4.0 us, 2.9 sy, 0.0 ni, 92.7 id, 0.0 wa, 0.4 hi, 0.0 si, 0.0 st MiB Mem : 32674.8 total, 21949.1 free, 10501.7 used, 224.0 buff/cache MiB Swap: 38400.2 total, 38322.8 free, 77.3 used. 22042.5 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 8944 328 288 S 0.0 0.0 0:00.18 init 16725 root 20 0 8952 232 184 S 0.0 0.0 0:00.00 init 16726 yourtre+ 20 0 18096 3588 3484 S 0.0 0.0 0:00.13 bash 18675 mysql 20 0 10656 812 780 S 0.0 0.0 0:00.10 mysqld_safe 18822 mysql 20 0 2603072 299920 20628 S 0.0 0.9 0:00.75 mysqld 19087 root 20 0 18412 2592 2568 S 0.0 0.0 0:00.03 su 19088 root 20 0 17008 2396 2304 S 0.0 0.0 0:00.07 bash 19201 root 20 0 18924 2152 1528 R 0.0 0.0 0:00.04 top #直接mysql 就进来了 root@yourtreedad:/home/yourtreedad# mysql Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 24 mysql默认没有密码,所以我们这里咩有输入密码就直接连上了\n设置登陆密码\nroot@yourtreedad:/home/yourtreedad# /usr/bin/mysqladmin -u root password 123456 mysqladmin: [Warning] Using a password on the command line interface can be insecure. Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety. \rimage-20211012213458570\r\nmysql\u0026gt; create database student ; Query OK, 1 row affected (0.01 sec) mysql\u0026gt; exit Bye root@yourtreedad:/var/lib/mysql# ls -l total 193956 -rw-r----- 1 mysql mysql 196608 Oct 12 21:33 \u0026#39;#ib_16384_0.dblwr\u0026#39; -rw-r----- 1 mysql mysql 8585216 Oct 12 20:19 \u0026#39;#ib_16384_1.dblwr\u0026#39; drwxr-x--- 1 mysql mysql 512 Oct 12 21:03 \u0026#39;#innodb_temp\u0026#39; -rw-r----- 1 mysql mysql 56 Oct 12 20:19 auto.cnf -rw-r----- 1 mysql mysql 12582912 Oct 12 21:33 ibdata1 -rw-r----- 1 mysql mysql 12582912 Oct 12 21:03 ibtmp1 drwxr-x--- 1 mysql mysql 512 Oct 12 20:19 mysql -rw-r----- 1 mysql mysql 25165824 Oct 12 21:33 mysql.ibd drwxr-x--- 1 mysql mysql 512 Oct 12 21:33 student drwxr-x--- 1 mysql mysql 512 Oct 12 20:19 sys 修改配置文件位置\n\rimage-20211012213843009\r\n弄好了重启mysql\nmysql\u0026gt;insertintouservalues(2,\u0026#39;张三\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromuser;+----+--------+ |id|name|+----+--------+ |1|z3||2|张三|+----+--------+ 2rowsinset(0.00sec)#有时候字符集没弄好要弄成utf-8mysql\u0026gt;showvariableslike\u0026#39;%char%\u0026#39;;+--------------------------+----------------------------+ |Variable_name|Value|+--------------------------+----------------------------+ |character_set_client|utf8mb4||character_set_connection|utf8mb4||character_set_database|utf8mb4||character_set_filesystem|binary||character_set_results|utf8mb4||character_set_server|utf8mb4||character_set_system|utf8mb3||character_sets_dir|/usr/share/mysql/charsets/|+--------------------------+----------------------------+ 8rowsinset(0.01sec)修改字符集和数据存储路径\n必须在字符集修改之后才能支持中文,之前的数据库好像不行\nmysql配置文件  二进制日志 log - bin  主从复制   错误日志  mysqlerror.error   查询日志log  默认关闭,记录查询的sql语句,如果开启会减低mysql的整体性能   数据文件  两个系统不一致  windows mysql5.0\\data目录下有很多库 linux 默认路径 /var/lib/mysql   frm文件 存放表结构 myd文件 存放表数据 myi文件 存放表索引    mysql逻辑架构介绍 \rimage-20211014205109147\r\n 第一层:连接层  最上层是一些客户端和连接服务,包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信.主要完成一些类似于连接处理/授权认证及相关的安全方案.在该层上引入了线程池的概念,为通过认证安全接入的客户端提供线程.同样在该层上可以实现基于ssl的安全连接.服务器也会为安全接入的每个客户端验证它所具有的操作权限.\n 第二层:数据库连接池 备份恢复安全集群容灾 存储过程 视图 触发器 解析器 优化器 缓存  第二层架构主要完成大多数的核心服务功能,如sql接口,并完成缓存的查询,sql的分析和优化以部分内置函数的执行.所有跨存储引擎的功能也在这一层实现,如过程/函数等.在该层,服务器会解析查询并创建相应的内部解析树,并对其完成相应的优化如确定查询表的顺序,是否利用索引等,最后生成相应的执行操作.如果是select语句,服务器还会查询内部的缓存,如果缓存空间足够大,这样在解决大量读操作的环境中能够很好的提升系统的性能.\n 第三层:可插拔存储引擎  存储引擎层,存储引擎真正的负责了mysql中数据的存储和提取,服务器通过api与存储引擎进行通信.不同的存储引擎具有的功能不同,这样我们可以根据自己的实际需要进行选取.后面介绍myisam和innodb\n 第四层:文件系统和文件日志  数据存储层,主要是将数据存储在运行于裸设备的文件系统上,并完成与存储引擎的交互\n和其他的数据库相比,mysql有点与众不同,它的架构可以在多种不同场景中应用并发挥良好作用.主要体现在存储引擎的架构上,插件式的存储引擎将查询处理和其他的系统任务以及数据的存储提取相分离.这种架构可以根据业务的需求和实际需要选择合适的存储引擎\nmysql存储引擎 mysql\u0026gt;showengines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ |Engine|Support|Comment|Transactions|XA|Savepoints|+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ |MEMORY|YES|Hashbased,storedinmemory,usefulfortemporarytables|NO|NO|NO||MRG_MYISAM|YES|CollectionofidenticalMyISAMtables|NO|NO|NO||CSV|YES|CSVstorageengine|NO|NO|NO||FEDERATED|NO|FederatedMySQLstorageengine|NULL|NULL|NULL||PERFORMANCE_SCHEMA|YES|PerformanceSchema|NO|NO|NO||MyISAM|YES|MyISAMstorageengine#查看存储引擎mysql\u0026gt;showvariableslike\u0026#39;%storage_engine%\u0026#39;;+---------------------------------+-----------+ |Variable_name|Value|+---------------------------------+-----------+ |default_storage_engine|InnoDB||default_tmp_storage_engine|InnoDB||disabled_storage_engines|||internal_tmp_mem_storage_engine|TempTable|+---------------------------------+-----------+ \rimage-20211014211207589\r\n\rimage-20211014211324759\r\n索引优化 优化分析 性能下降sql慢/执行时间长/等待时间长\n 查询语句写的烂 索引失效  单值 复合    #创建索引mysql\u0026gt;createindexidx_beauty_nameonbeauty(name);QueryOK,0rowsaffected(0.03sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;createindexidx_beauty_name_sexonbeauty(name,sex);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#查看索引mysql\u0026gt;showindexfrombeauty;+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |beauty|0|PRIMARY|1|id|A|13|NULL|NULL||BTREE|||YES|NULL||beauty|1|idx_beauty_name|1|name|A|12|NULL|NULL||BTREE|||YES|NULL||beauty|1|idx_beauty_name_sex|1|name|A|12|NULL|NULL||BTREE|||YES|NULL||beauty|1|idx_beauty_name_sex|2|sex|A|12|NULL|NULL|YES|BTREE|||YES|NULL|+--------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+  关联查询太多join(设计缺陷或不得已的需求) 服务器调优以各个参数设置(缓冲/线程数)  常见的join查询   sql的执行顺序\n 手写 select from join on where group by having order by limit 机读 from on join where group by having select dinstinct order by limit  \rimage-20211014213300494\r\n  join 图\n  \rimage-20211014213503395\r\n\rimage-20211014213909722\r\nmysql\u0026gt;CREATETABLEtbl_dept(-\u0026gt;idINT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;deptNameVARCHAR(30)DEFAULTNULL,-\u0026gt;locAddVARCHAR(40)DEFAULTNULL,-\u0026gt;PRIMARYKEY(id)-\u0026gt;)ENGINEINNODBAUTO_INCREMENT=1DEFAULTCHARSET=utf8;QueryOK,0rowsaffected,2warnings(0.02sec)mysql\u0026gt;CREATETABLEtbl_emp(-\u0026gt;idINT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;nameVARCHAR(20)DEFAULTNULL,-\u0026gt;deptldINT(11)DEFAULTNULL,-\u0026gt;PRIMARYKEY(id),-\u0026gt;KEYfk_dept_id(deptld)-\u0026gt;#CONSTRAINTfk_dept_idFOREIGNKEY(deptld)REFERENCEStbl_dept(id)-\u0026gt;)ENGINEINNODBAUTO_INCREMENT=1DEFAULTCHARSET=utf8;QueryOK,0rowsaffected,3warnings(0.02sec)mysql\u0026gt;select*fromtbl_emp;+----+------+--------+ |id|name|deptld|+----+------+--------+ |1|z3|1||2|z4|1||3|z5|1||4|w5|2||5|w6|2||6|s7|3||7|s8|4||8|s9|51|+----+------+--------+ 8rowsinset(0.00sec)mysql\u0026gt;select*fromtbl_dept;+----+----------+--------+ |id|deptName|locAdd|+----+----------+--------+ |1|RD|11||2|HR|12||3|MK|13||4|MIS|14||5|FD|15|+----+----------+--------+ 5rowsinset(0.00sec)#内连接就么有8员工和5部门mysql\u0026gt;selecte.*,d.*fromtbl_empejointbl_deptdone.deptld=d.id;+----+------+--------+----+----------+--------+ |id|name|deptld|id|deptName|locAdd|+----+------+--------+----+----------+--------+ |1|z3|1|1|RD|11||2|z4|1|1|RD|11||3|z5|1|1|RD|11||4|w5|2|2|HR|12||5|w6|2|2|HR|12||6|s7|3|3|MK|13||7|s8|4|4|MIS|14|+----+------+--------+----+----------+--------+ #左外连接没有5部门mysql\u0026gt;selecte.*,d.*fromtbl_empeleftjointbl_deptdone.deptid=d.id;+----+------+--------+------+----------+--------+ |id|name|deptid|id|deptName|locAdd|+----+------+--------+------+----------+--------+ |1|z3|1|1|RD|11||2|z4|1|1|RD|11||3|z5|1|1|RD|11||4|w5|2|2|HR|12||5|w6|2|2|HR|12||6|s7|3|3|MK|13||7|s8|4|4|MIS|14||8|s9|51|NULL|NULL|NULL|+----+------+--------+------+----------+--------+ #右外连接没有8员工mysql\u0026gt;selecte.*,d.*fromtbl_emperightjointbl_deptdone.deptid=d.id;+------+------+--------+----+----------+--------+ |id|name|deptid|id|deptName|locAdd|+------+------+--------+----+----------+--------+ |1|z3|1|1|RD|11||2|z4|1|1|RD|11||3|z5|1|1|RD|11||4|w5|2|2|HR|12||5|w6|2|2|HR|12||6|s7|3|3|MK|13||7|s8|4|4|MIS|14||NULL|NULL|NULL|5|FD|15|+------+------+--------+----+----------+--------+ #只有左边只有8员工mysql\u0026gt;selecte.*,d.*fromtbl_empeleftjointbl_deptdone.deptid=d.idwhered.idisnull;+----+------+--------+------+----------+--------+ |id|name|deptid|id|deptName|locAdd|+----+------+--------+------+----------+--------+ |8|s9|51|NULL|NULL|NULL|+----+------+--------+------+----------+--------+ #只有右边只有5部门mysql\u0026gt;selecte.*,d.*fromtbl_emperightjointbl_deptdone.deptid=d.idwheree.deptidisnull;+------+------+--------+----+----------+--------+ |id|name|deptid|id|deptName|locAdd|+------+------+--------+----+----------+--------+ |NULL|NULL|NULL|5|FD|15|+------+------+--------+----+----------+--------+ 1rowinset(0.00sec)#全连接都得有mysql不支持outerjoinmysql\u0026gt;selecte.*,d.*fromtbl_empeouterjointbl_deptdone.deptid=d.id;ERROR1064(42000):YouhaveanerrorinyourSQLsyntax;checkthemanualthatcorrespondstoyourMySQLserverversionfortherightsyntaxtousenear\u0026#39;outer join tbl_dept d on e.deptid = d.id\u0026#39;atline1#可以这么做union默认去重unionall就不会去重mysql\u0026gt;selecte.*,d.*fromtbl_empeleftjointbl_deptdone.deptid=d.idunionselecte.*,d.*fromtbl_emperightjointbl_deptdone.deptid=d.id;+------+------+--------+------+----------+--------+ |id|name|deptid|id|deptName|locAdd|+------+------+--------+------+----------+--------+ |1|z3|1|1|RD|11||2|z4|1|1|RD|11||3|z5|1|1|RD|11||4|w5|2|2|HR|12||5|w6|2|2|HR|12||6|s7|3|3|MK|13||7|s8|4|4|MIS|14||8|s9|51|NULL|NULL|NULL||NULL|NULL|NULL|5|FD|15|+------+------+--------+------+----------+--------+ 9rowsinset(0.00sec)#不要join重合的部分要另外两半的mysql\u0026gt;selecte.*,d.*fromtbl_empeleftjointbl_deptdone.deptid=d.idwhered.idisnullunionselecte.*,d.*fromtbl_emperightjointbl_deptdone.deptid=d.idwheree.deptidisnull;+------+------+--------+------+----------+--------+ |id|name|deptid|id|deptName|locAdd|+------+------+--------+------+----------+--------+ |8|s9|51|NULL|NULL|NULL||NULL|NULL|NULL|5|FD|15|+------+------+--------+------+----------+--------+ 2rowsinset(0.00sec)索引简介  是什么  mysql官方对索引的定义为:索引index是帮助mysql高效获取数据的数据结构.可以得到索引的本质:索引是数据结构.\n如果要查mysql这个单词,我们肯定需要定位到m字母,然后往下找到y字母,再找到剩下的sql\n如果没有索引,那么你可能需要a\u0026ndash;z,如果我想找到java开头的单词呢,或者oracle开头的单词呢\n你可以简单理解为 排好序的快速查找数据结构\n在数据之外,数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构,就是索引.下图就是一种可能的索引方式示例:\n\rimage-20211014224606584\r\n所以说索引是一种数据结构,如果要查7这本书,正常的遍历要第七次才能找到,时间复杂度为n,索引是利用平衡二叉树,或者B+树,也就是说不一定二叉可以多叉,这样至多log2n+1次就能索引到,故而提高了效率\n一般来说,索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存储在磁盘上\n索引不太适合删除和修改多的场景,因为删除数据的同时要删除索引,修改数据的同时要修改索引,索引为何会失效\n我们常说的索引,如果没有特别指明,都是指B树(多路搜索树,并不一定是二叉的)结构组织的索引.其中聚集索引,次要索引,覆盖索引,符合索引,前缀索引,唯一索引默认都是使用B+树索引,统称索引.当然,除了B+树这种类型的索引之外,还有哈希索引(hash index)等.\n 优势  类似大学图书馆建书索引,提高数据检索的效率,降低数据库的IO成本 通过索引列对数据进行排序,降低数据排序的成本,降低了CPU的消耗   劣势  实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录,所以索引列也是要占用空间的 虽然索引大大提高了查询速度,同时却会降低更新表的速度,如对表进行insert/update/delete.因为更新表时,mysql不仅要保存数据,还要保存一下索引文件每次更新添加了索引列的字段,都会调整因为更新所带来的键值变化后的索引信息 索引只是提高效率的一个因素,如果你的mysql有大数据量的表,就需要花时间研究建立最优秀的索引,或优化查询    mysql索引分类  单值索引  即一个索引只包含单个列,一个表可以有多个单列索引   唯一索引  索引列的值必须唯一,但允许空值   复合索引  即一个索引包含多个列   基本语法  创建  create [unique] index indexName on tableName(columnName,\u0026hellip;) ; alter tableName add [unique] index [indexName] on (columnName(length)) ;   删除  drop index [indexName] on tableName ;   查看  show index from tableName ;   使用alter命令  alter table tbl_name add primary key (column_list) ; 该语句添加一个主键,这意味这索引值必须是唯一的,且不能为null alter table tbl_name add unique index_name (column_list) ; 这条语句创建索引的值必须是唯一的,除了null之外,null可能会出现多次 alter table tbl_name add index index_name (column_list) ; 添加普通索引,索引值可出现多次 alter table tbl_name add fulltext index_name (column_list) ; 该语句指定了索引为fulltext,用于全文索引      #主键外键唯一都是索引我们这边讲的是那种普通索引mysql\u0026gt;showindexfromtbl_emp;+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |tbl_emp|0|PRIMARY|1|id|A|8|NULL|NULL||BTREE|||YES|NULL||tbl_emp|1|fk_dept_id|1|deptid|A|5|NULL|NULL|YES|BTREE|||YES|NULL|+---------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 2rowsinset(0.02sec)mysql索引的结构  Btree索引  索引原理   hash索引 full-text全文索引 R-Tree索引  \rimage-20211016093656515\r\n初始化介绍\n一颗B+树,浅蓝色的块我们称之为一个磁盘块,可以看到每个磁盘块包含了几个数据项(深蓝色所示)和指针(黄色所示),如磁盘块1包含数据项17和35,包含指针P1P2P3\nP1表示小于17的磁盘块,P2表示在17和35之间的磁盘块,P3表示大于35的磁盘块\n真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99\n非叶子节点不存储真实的数据,只存储指引搜索方向的数据项,如17、35并不真实存在与数据表中\n查找过程\n如果要查找数据项29,那么首先会把磁盘块1由磁盘加载到内存,此时发生一次IO,在内存中用二分查找确定29在17和35之间,锁定磁盘块1的P2指针,内存时间因为非常短(相比于磁盘的IO)可以忽略不计,通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存中,发生了第二次IO,29在26和30之间,锁定磁盘块3的P2指针,通过指针加载磁盘块8到内存,发生第三次IO,同时内存中做二分查找找到29,结束查询,总计三次IO\n真实情况\n3层的b+树可以表示上百万条的数据,如果上百万的数据查找只需要三次IO,性能提高将是巨大的,如果没有索引,每个数据项都要发生一次IO,那么总共需要百万次IO,显然成本非常非常高\n哪些情况需要创建索引  主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段,外键关系应该建立索引 频繁更新的字段不适合创建索引  因为每次更新不单单是更新了记录还会更新索引   where条件里用不到的字段不创建索引 单值/复合索引的选择问题  高并发下倾向创建组合索引   查询中排序的字段,排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段  哪些情况不要创建索引  表记录太少 经常增删改的表  提高了查询速度,同时却会降低更新表的速度,如对表进行insert/update和delete,因为更新表时,mysql不仅要保存数据,还要保存一下索引文件   数据重复且分布均匀的表字段,因此应该只为最经常查询和最经常排序的数据列创建索引.  注意,如果某个数据列包含许多重复的内容,为它建立索引就没有太大的实际效果    \rimage-20211016095439966\r\n性能分析 msyql query optimizer 查询优化器 \rimage-20211016095805682\r\nmysql常见瓶颈  CPU cpu在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候 IO 磁盘IO瓶颈发生在装入数据远大于内存容量的时候 服务器硬件的性能瓶颈: top free iostat vmstat 来查看系统的性能状态 explain  Explain  是什么(查看执行计划)  使用explain关键字可以模拟优化器执行sql查询语句,从而知道mysql是如何处理你的sql语句的.分析你的查询语句或是表结构的性能瓶颈 官网介绍   能干嘛  表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询   怎么玩  Explain + SQL语句 执行计划包含的信息  表头 id select_type table partitions type possible_keys key ken_len ref rows filtered extra      各字段解释  id  select查询的序列号,包含一组数字,表示查询中执行select子句或操作表的顺序 三种情况  id相同,执行顺序由上到下\rimage-20211016101510820\r id不同,如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行\rimage-20211016101830835\r id相同不同,同时存在\rimage-20211016102234339\r     select_type  有哪些 simple primary subquery dirived union union result 查询的类型,主要是用于区别普通查询/联合查询/子查询等的复杂查询  simple 简单的select查询,查询中不包含子查询或者union primary 查询中若包含任何复杂的子部分,最外层查询则被标记为 subquery 在select或where列表中包含了子查询 derived 在from列表中包含的子查询被标记为derived(衍生) mysql会递归执行这些子查询,把结果放在临时表里 union 若第二个select出现在union之后,则被标记为union;若union包含在from子句的子查询中,外层select 将被标记为derived(很正常嘛,union之后的结果作为临时表 所以被标记为derived) union result 从union表获取结果的select     table 显示这一行的数据是关于那些表的 type  all index range ref eq_ref const,system null 访问类型排列 显示查询使用了何种类型,最好到最差依次是 syste\u0026gt;const\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all\rimage-20211016110536099\r  system 表只有一行记录(等于系统表),这是const类型的特例,平时不会出现,这个也可以忽略不计 const 表示通过索引一次就找到了,const用于比较primary key 或者 unique索引,因为只匹配了一行数据,所以很快,如将主键置于where列表中,mysql就能将该查询转换为一个常量\rimage-20211016110923813\r eq_ref 唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配.常用语主键或唯一索引扫描\rimage-20211016112628359\r ref 非唯一性索引扫描,返回匹配某个单独值的所有行.本质上也是一种索引访问,他返回所有匹配某个单独值的行,然而,她可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体.\rimage-20211016113043870\r range 只检索给定范围的行,使用一个索引来选择行. key列显示使用了哪个索引,一般就是在你的where语句中出现了between \u0026lt; \u0026gt; in 等的查询,这种范围扫描索引扫描比全表扫描要好,因为它只需要开始于索引的某一点,而结束于另一点,不用扫描全部索引\rimage-20211016113701811\r index (full index san) index与all的区别为index类型只遍历索引树.这通常比all快,因为索引文件比数据文件小 也就是说虽然all和index都是读全表,但index是从索引中读取的,而all是从硬盘中读取的\rimage-20211016114028963\r all (full table scan) 将遍历全表以找到匹配的行\rimage-20211016114058619\r **注意:**一般来说,得保证查询至少打到range级别,最好能够达到ref     possible_keys  用来判断索引用上没,索引失效没 显示可能应用在这张表中的索引,一个或多个.查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用   key  实际使用的索引.如果为null,则没有使用索引 查询中若使用了覆盖索引,则该索引仅出现在key列表中   key_len  表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度.在不损失精确性的情况下,长度越短越好 key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的 同样的查询条件下,精度越小越好\rimage-20211016145227350\r   ref 显示索引的哪一列被使用了,如果可能的话,是一个常数.那些列或常量被用于查找索引列上的值\rimage-20211016145926736\r rows 根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数\rimage-20211016150445129\r extra 包含不适合在其他列中显示但十分重要的额外信息    extra信息  using filesort 说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取 mysql中无法利用索引完成的排序操作称为文件排序 出现这个东西不好 如果可以尽快优化\rimage-20211016151320887\r using temporary 使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表.常见于排序order by和分组查询group by 使用临时表会损伤数据库性能 用完还要回收 这个很不好哦\rimage-20211016151757718\r using index  表示相应的select操作中使用了覆盖索引covering index , 避免了访问了表的的数据行,效率不错! 如果同时出现using where ,表明索引被用来执行索引键值的查找 如果没有同时出现using where , 表明索引用来读取数据而非执行查找动作 覆盖索引 建了3个索引,查的也是3个 全覆盖 \rimage-20211016152608867\r\rimage-20211016152333029\r   using where 表明使用了where条件 using join buffer 表明使用了连接缓存 impossible where 表明where子句的值总是false , 不能用来获取任何元组\rimage-20211016152746052\r select tables optimized away  在没有groupby子句的情况下,基于索引优化min/max操作或者对于myisam存储引擎优化count(*)操作,不必等到执行阶段再进行计算,查询执行计划生成的阶段即完成优化.   select distinct 优化distinct操作,在找到第一匹配的元组后立即停止查找同样值的操作  #使用explain关键字进行性能分析mysql\u0026gt;explainselect*fromtbl_emp;+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ |1|SIMPLE|tbl_emp|NULL|ALL|NULL|NULL|NULL|NULL|8|100.00|NULL|+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+ 1rowinset,1warning(0.01sec)mysql\u0026gt;explainselect*fromtbl_empaleftjointbl_deptbona.deptId=b.idunionselect*fromtbl_emparightjointbl_deptbona.deptid=b.id;+----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ |1|PRIMARY|a|NULL|ALL|NULL|NULL|NULL|NULL|8|100.00|NULL||1|PRIMARY|b|NULL|eq_ref|PRIMARY|PRIMARY|4|girls.a.deptid|1|100.00|NULL||2|UNION|b|NULL|ALL|NULL|NULL|NULL|NULL|5|100.00|NULL||2|UNION|a|NULL|ref|fk_dept_id|fk_dept_id|5|girls.b.id|1|100.00|NULL||NULL|UNIONRESULT|\u0026lt;union1,2\u0026gt;|NULL|ALL|NULL|NULL|NULL|NULL|NULL|NULL|Usingtemporary|+----+--------------+------------+------------+--------+---------------+------------+---------+----------------+------+----------+-----------------+ 5rowsinset,1warning(0.00sec)热身case \rimage-20211016153657227\r\n\rimage-20211016153809882\r\n索引优化   索引分析\n  单表\n  两表\n  三表\n    索引失效(应该避免)\n  一般性建议\n  #建表单表示例mysql\u0026gt;CREATETABLEIFNOTEXISTS`article`(-\u0026gt;`id`INT(10)UNSIGNEDNOTNULLPRIMARYKEYAUTO_INCREMENT,-\u0026gt;`author_id`INT(10)UNSIGNEDNOTNULL,-\u0026gt;`category_id`INT(10)UNSIGNEDNOTNULL,-\u0026gt;`views`INT(10)UNSIGNEDNOTNULL,-\u0026gt;`comments`INT(10)UNSIGNEDNOTNULL,-\u0026gt;`title`VARBINARY(255)NOTNULL,-\u0026gt;`content`TEXTNOTNULL-\u0026gt;);QueryOK,0rowsaffected,5warnings(0.03sec)mysql\u0026gt;mysql\u0026gt;INSERTINTO`article`(`author_id`,`category_id`,`views`,`comments`,`title`,`content`)VALUES-\u0026gt;(1,1,1,1,\u0026#39;1\u0026#39;,\u0026#39;1\u0026#39;),-\u0026gt;(2,2,2,2,\u0026#39;2\u0026#39;,\u0026#39;2\u0026#39;),-\u0026gt;(1,1,3,3,\u0026#39;3\u0026#39;,\u0026#39;3\u0026#39;);QueryOK,3rowsaffected(0.01sec)Records:3Duplicates:0Warnings:0mysql\u0026gt;select*fromarticle;+----+-----------+-------------+-------+----------+--------------+---------+ |id|author_id|category_id|views|comments|title|content|+----+-----------+-------------+-------+----------+--------------+---------+ |1|1|1|1|1|0x31|1||2|2|2|2|2|0x32|2||3|1|1|3|3|0x33|3|+----+-----------+-------------+-------+----------+--------------+---------+ 3rowsinset(0.00sec)#性能分析type是all说明是全表扫描#显然usingfilesort也是最坏的情况发生了文件内排序mysql\u0026gt;explainselectid,author_idfromarticlewherecategory_id=1andcomments\u0026gt;1orderbyviewsdesclimit1;+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ |1|SIMPLE|article|NULL|ALL|NULL|NULL|NULL|NULL|3|33.33|Usingwhere;Usingfilesort|+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+ 1rowinset,1warning(0.00sec)#如果创建的索引是ccvtype变成了rangeextra还是filesort好了点mysql\u0026gt;createindexidx_ccvonarticle(category_id,comments,views);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;explainselectid,author_idfromarticlewherecategory_id=1andcomments\u0026gt;1orderbyviewsdesclimit1;+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ |1|SIMPLE|article|NULL|range|idx_ccv|idx_ccv|8|NULL|1|100.00|Usingindexcondition;Usingfilesort|+----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+---------------------------------------+ 1rowinset,1warning(0.00sec)#删除索引mysql\u0026gt;dropindexidx_ccvonarticle;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0\rimage-20211016171713970\r\nmysql\u0026gt;createindexidx_cvonarticle(category_id,views);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#把范围的去掉mysql\u0026gt;explainselectid,author_idfromarticlewherecategory_id=1andcomments\u0026gt;1orderbyviewsdesclimit1;+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ |1|SIMPLE|article|NULL|ref|idx_cv|idx_cv|4|const|2|33.33|Usingwhere;Backwardindexscan|+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+----------------------------------+ 1rowinset,1warning(0.00sec)#两表mysql\u0026gt;CREATETABLEIFNOTEXISTS`class`(-\u0026gt;`id`INT(10)UNSIGNEDNOTNULLAUTO_INCREMENT,-\u0026gt;`card`INT(10)UNSIGNEDNOTNULL,-\u0026gt;PRIMARYKEY(`id`)-\u0026gt;);QueryOK,0rowsaffected,2warnings(0.03sec)mysql\u0026gt;CREATETABLEIFNOTEXISTS`book`(-\u0026gt;`bookid`INT(10)UNSIGNEDNOTNULLAUTO_INCREMENT,-\u0026gt;`card`INT(10)UNSIGNEDNOTNULL,-\u0026gt;PRIMARYKEY(`bookid`)-\u0026gt;);QueryOK,0rowsaffected,2warnings(0.01sec)#分析都是全表扫描很几把恐怖mysql\u0026gt;explainselect*frombookbrightjoinclassconb.card=c.card;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ |1|SIMPLE|c|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|NULL||1|SIMPLE|b|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|Usingwhere;Usingjoinbuffer(hashjoin)|+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ 2rowsinset,1warning(0.00sec)#优化先给右连接的左表定索引同理或者给左连接的右表定索引mysql\u0026gt;altertablebookaddindexY(card);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#type变成ref了有点意思usingindex很好mysql\u0026gt;explainselect*frombookbrightjoinclassconb.card=c.card;+----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ |1|SIMPLE|c|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|NULL||1|SIMPLE|b|NULL|ref|Y|Y|4|girls.c.card|1|100.00|Usingindex|+----+-------------+-------+------------+------+---------------+------+---------+--------------+------+----------+-------------+ 2rowsinset,1warning(0.00sec)#不知道给左边添加索引好还是给右边添加好所以再试试mysql\u0026gt;dropindexYonbook;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#添加索引mysql\u0026gt;altertableclassaddindexY(card);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#发现没有用为啥呢因为右连接没有where的话右边是肯定是全都有的加了索引有啥用啊mysql\u0026gt;explainselect*frombookbrightjoinclassconb.card=c.card;+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ |1|SIMPLE|c|NULL|index|NULL|Y|4|NULL|20|100.00|Usingindex||1|SIMPLE|b|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|Usingwhere;Usingjoinbuffer(hashjoin)|+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------------------------+ 2rowsinset,1warning(0.00sec)#删除索引mysql\u0026gt;dropindexYonclass;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0\rimage-20211016174325936\r\n#三表mysql\u0026gt;CREATETABLEIFNOTEXISTS`phone`(-\u0026gt;`phoneid`INT(10)UNSIGNEDNOTNULLAUTO_INCREMENT,-\u0026gt;`card`INT(10)UNSIGNEDNOTNULL,-\u0026gt;PRIMARYKEY(`phoneid`)-\u0026gt;)ENGINE=INNODB;QueryOK,0rowsaffected,2warnings(0.02sec)#都是all很差劲20mysql\u0026gt;explainselect*fromclassleftjoinbookonclass.card=book.cardleftjoinphoneonphone.card=book.card;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ |1|SIMPLE|class|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|NULL||1|SIMPLE|book|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|Usingwhere;Usingjoinbuffer(hashjoin)||1|SIMPLE|phone|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|Usingwhere;Usingjoinbuffer(hashjoin)|+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+ 3rowsinset,1warning(0.00sec)mysql\u0026gt;altertablephoneaddindexz(card);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;createindexyonbook(card);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;explainselect*fromclassleftjoinbookonclass.card=book.cardleftjoinphoneonphone.card=book.card;+----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ |1|SIMPLE|class|NULL|ALL|NULL|NULL|NULL|NULL|20|100.00|NULL||1|SIMPLE|book|NULL|ref|y|y|4|girls.class.card|1|100.00|Usingindex||1|SIMPLE|phone|NULL|ref|z|z|4|girls.book.card|1|100.00|Usingindex|+----+-------------+-------+------------+------+---------------+------+---------+------------------+------+----------+-------------+ 3rowsinset,1warning(0.00sec)\rimage-20211016193542297\r\n索引失效(应该避免)   全值匹配我最爱\n  最佳左前缀法则\n 如果索引了多列,要遵守最左前缀法则.指的是查询从索引的最左前列开始并且不跳过索引中的列\rimage-20211016195626235\r    不在索引列上做任何操作(计算/函数/自动手动类型转换),会导致索引失效而转向全表扫描\n  少计算\n#对索引列进行函数转换后会导致索引失效的问题mysql\u0026gt;explainselect*fromstaffswhereleft(name,4)=\u0026#39;July\u0026#39;;+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|NULL|NULL|NULL|NULL|3|100.00|Usingwhere|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)    存储引擎不能使用索引中范围条件右边的列\n 范围后面的索引都失效了 between and / in / like  #都用到了三个索引140的长度mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andage=25andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|140|const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#用到了两个因为范围后的索引失效了78长度说明第二个用到了mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andage\u0026gt;25andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ |1|SIMPLE|staffs|NULL|range|idx_staffs_nameAgePos|idx_staffs_nameAgePos|78|NULL|1|33.33|Usingindexcondition|+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)  尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select *\n#查找所有字段mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andage=25andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|140|const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#就只查找索引索引覆盖extra变成usingindex是个好兆头mysql\u0026gt;explainselectname,age,posfromstaffswherename=\u0026#39;July\u0026#39;andage=25andpos=\u0026#39;manager\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|140|const,const,const|1|100.00|Usingindex|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------------+ 1rowinset,1warning(0.00sec)\rimage-20211016201217849\r\n  mysql在使用不等于!= 或者 \u0026lt;\u0026gt;的时候无法使用索引 , 会导致全表扫描\n  \rimage-20211016201756985\r\n is null , is not null 也无法使用索引  \rimage-20211016202018668\r\n  like 以通配符开头 ('%abc\u0026hellip;') mysql索引失效会变成全表扫描的操作\n 只有把%写在右边才能避免索引失效  #索引失效mysql\u0026gt;explainselect*fromstaffswherenamelike\u0026#39;%July%\u0026#39;;+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|NULL|NULL|NULL|NULL|3|33.33|Usingwhere|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#放在左边也失效毕竟不全表扫怎么知道是否找全了mysql\u0026gt;explainselect*fromstaffswherenamelike\u0026#39;%July\u0026#39;;+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|NULL|NULL|NULL|NULL|3|33.33|Usingwhere|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#没有失效mysql\u0026gt;explainselect*fromstaffswherenamelike\u0026#39;July%\u0026#39;;+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ |1|SIMPLE|staffs|NULL|range|idx_staffs_nameAgePos|idx_staffs_nameAgePos|74|NULL|1|100.00|Usingindexcondition|+----+-------------+--------+------------+-------+-----------------------+-----------------------+---------+------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec) 问题是解决like'%字符%\u0026lsquo;时索引不失效???  mysql\u0026gt;CREATETABLE`tbl_user`(-\u0026gt;`id`INT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;`NAME`VARCHAR(20)DEFAULTNULL,-\u0026gt;`age`INT(11)DEFAULTNULL,-\u0026gt;emailVARCHAR(20)DEFAULTNULL,-\u0026gt;PRIMARYKEY(`id`)-\u0026gt;)ENGINE=INNODBAUTO_INCREMENT=1DEFAULTCHARSET=utf8;QueryOK,0rowsaffected,3warnings(0.03sec)#用覆盖索引来解决mysql\u0026gt;createindexidx_user_nameAgeontbl_user(name,age);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#index了说明用到了mysql\u0026gt;explainselectname,agefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectidfromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectnamefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectagefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectid,namefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectid,name,agefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectid,name,agefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#index了说明用到了mysql\u0026gt;explainselectname,agefromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ |1|SIMPLE|tbl_user|NULL|index|NULL|idx_user_nameAge|68|NULL|4|25.00|Usingwhere;Usingindex|+----+-------------+----------+------------+-------+---------------+------------------+---------+------+------+----------+--------------------------+ 1rowinset,1warning(0.00sec)#没有覆盖到索引，索引失效mysql\u0026gt;explainselect*fromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|tbl_user|NULL|ALL|NULL|NULL|NULL|NULL|4|25.00|Usingwhere|+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#没有完全覆盖索引失效mysql\u0026gt;explainselectid,name,age,emailfromtbl_userwherenamelike\u0026#39;%aa%\u0026#39;;+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|tbl_user|NULL|ALL|NULL|NULL|NULL|NULL|4|25.00|Usingwhere|+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)  字符串不加单引号索引失效\n  mysql\u0026gt;select*fromstaffswherename=\u0026#39;2000\u0026#39;;+----+------+-----+-----+---------------------+ |id|NAME|age|pos|add_time|+----+------+-----+-----+---------------------+ |3|2000|23|dev|2021-10-1619:38:15|+----+------+-----+-----+---------------------+ 1rowinset(0.00sec)#会发生隐式转换mysql\u0026gt;select*fromstaffswherename=2000;+----+------+-----+-----+---------------------+ |id|NAME|age|pos|add_time|+----+------+-----+-----+---------------------+ |3|2000|23|dev|2021-10-1619:38:15|+----+------+-----+-----+---------------------+ 1rowinset,1warning(0.00sec)mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;2000\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|74|const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1rowinset,1warning(0.00sec)#和第三个吻合隐式自动转换自动转换会导致索引失效mysql\u0026gt;explainselect*fromstaffswherename=2000;+----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|idx_staffs_nameAgePos|NULL|NULL|NULL|3|33.33|Usingwhere|+----+-------------+--------+------------+------+-----------------------+------+---------+------+------+----------+-------------+ 1rowinset,3warnings(0.00sec) 少用or , 用它来连接时会索引失效  \rimage-20211017095517319\r\n#建表mysql\u0026gt;CREATETABLEstaffs(-\u0026gt;idINTPRIMARYKEYAUTO_INCREMENT,-\u0026gt;NAMEVARCHAR(24)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;姓名\u0026#39;,-\u0026gt;ageINTNOTNULLDEFAULT0COMMENT\u0026#39;年龄\u0026#39;,-\u0026gt;posVARCHAR(20)NOTNULLDEFAULT\u0026#39;\u0026#39;COMMENT\u0026#39;职位\u0026#39;,-\u0026gt;add_timeTIMESTAMPNOTNULLDEFAULTCURRENT_TIMESTAMPCOMMENT\u0026#39;入职时间\u0026#39;-\u0026gt;)CHARSETutf8COMMENT\u0026#39;员工记录表\u0026#39;;QueryOK,0rowsaffected,1warning(0.02sec)#添加索引mysql\u0026gt;ALTERTABLEstaffsADDINDEXidx_staffs_nameAgePos(name,age,pos);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#查看索引mysql\u0026gt;showindexfromstaffs;+--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |staffs|0|PRIMARY|1|id|A|2|NULL|NULL||BTREE|||YES|NULL||staffs|1|idx_staffs_nameAgePos|1|NAME|A|3|NULL|NULL||BTREE|||YES|NULL||staffs|1|idx_staffs_nameAgePos|2|age|A|3|NULL|NULL||BTREE|||YES|NULL||staffs|1|idx_staffs_nameAgePos|3|pos|A|3|NULL|NULL||BTREE|||YES|NULL|+--------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ #挺好的哈mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|74|const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1rowinset,1warning(0.00sec)#两个条件key_len越来越大mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andage=25;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|78|const,const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#三个条件mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andage=25andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|140|const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#问题来了没有name只用age和pos的时候变成了全表扫描索引失效mysql\u0026gt;explainselect*fromstaffswhereage=23andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|NULL|NULL|NULL|NULL|3|33.33|Usingwhere|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#没有name只用pos变成了全表扫描索引失效mysql\u0026gt;explainselect*fromstaffswherepos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ |1|SIMPLE|staffs|NULL|ALL|NULL|NULL|NULL|NULL|3|33.33|Usingwhere|+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#必须要有name带头大哥不能死最佳左前缀法则mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|74|const|1|100.00|NULL|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-------+ 1rowinset,1warning(0.00sec)#虽然用到索引了但是从索引的长度可以看出只用了name这个索引因为中间的age丢了mysql\u0026gt;explainselect*fromstaffswherename=\u0026#39;July\u0026#39;andpos=\u0026#39;dev\u0026#39;;+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ |1|SIMPLE|staffs|NULL|ref|idx_staffs_nameAgePos|idx_staffs_nameAgePos|74|const|1|33.33|Usingindexcondition|+----+-------------+--------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)\rimage-20211017095823171\r\n\rimage-20211017100150557\r\n可能有点小问题,到时候勘误一下\n练习一下\nmysql\u0026gt;CREATETABLEtest03(-\u0026gt;idintprimarykeynotnullauto_increment,-\u0026gt;c1char(10),-\u0026gt;c2char(10),-\u0026gt;c3char(10),-\u0026gt;c4char(10),-\u0026gt;c5char(10)-\u0026gt;);QueryOK,0rowsaffected(0.05sec)mysql\u0026gt;select*fromtest03;+----+------+------+------+------+------+ |id|c1|c2|c3|c4|c5|+----+------+------+------+------+------+ |1|a1|a2|a3|a4|a5||2|b1|b2|b3|b4|b5||3|c1|c2|c3|c4|c5||4|d1|d2|d3|d4|d5||5|e1|e2|e3|e4|e5|+----+------+------+------+------+------+ mysql\u0026gt;createindexidx_test03_c1234ontest03(c1,c2,c3,c4);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#用到了mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------+ 1rowinset,1warning(0.00sec)#索引在逐渐递增key_lenmysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#mysql会自我优化优化常量的查询顺序mysql\u0026gt;explainselect*fromtest03wherec2=\u0026#39;a2\u0026#39;andc1=\u0026#39;a1\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#索引在逐渐递增key_lenmysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc3=\u0026#39;a3\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|93|const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc3=\u0026#39;a3\u0026#39;andc4=\u0026#39;a4\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|124|const,const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#mysql会自我优化优化常量的查询顺序mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc4=\u0026#39;a4\u0026#39;andc3=\u0026#39;a3\u0026#39;;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|124|const,const,const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#范围后面全失效mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc3\u0026gt;\u0026#39;a3\u0026#39;andc4=\u0026#39;a4\u0026#39;;+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ |1|SIMPLE|test03|NULL|range|idx_test03_c1234|idx_test03_c1234|93|NULL|1|20.00|Usingindexcondition|+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)#我觉得是4个查询顺序会被mysql优化mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc4\u0026gt;\u0026#39;a4\u0026#39;andc3=\u0026#39;a3\u0026#39;;+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ |1|SIMPLE|test03|NULL|range|idx_test03_c1234|idx_test03_c1234|124|NULL|1|100.00|Usingindexcondition|+----+-------------+--------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)#c3没有统计到里面用于排序了而不是查找c4就失效了呗mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc4=\u0026#39;a4\u0026#39;orderbyc3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|20.00|Usingindexcondition|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)#和上面的没什么区别c3用去排序了所以c4就失效了呗mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;orderbyc3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#用到了索引a1和a2但是抓到数据之后,由于索引设置的是a1a2a3a4默认的排序是a1a2a3a4但是你这边直接#开始用a4开始排你还是人吗这样抓到数据之后还需要对数据进行文件内部的排序才能展示给大家mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;orderbyc4;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|100.00|Usingfilesort|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+----------------+ 1rowinset,1warning(0.00sec)#用到了索引a1但是排序按照a2a3排序不会导致索引失效mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc5=\u0026#39;a5\u0026#39;orderbyc2,c3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|20.00|Usingwhere|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-------------+ #用到了索引a1但是排序按照a3a2排序不会导致索引失效但是检索到数据之后,排序不是索引默认的排序规则a1a2a3而是a3a2所以检索到后又按照文件内排序拍了一遍Usingfilesortmysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc5=\u0026#39;a5\u0026#39;orderbyc3,c2;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|20.00|Usingwhere;Usingfilesort|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ #没有问题哈mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;orderbyc2,c3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|100.00|NULL|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------+ 1rowinset,1warning(0.00sec)#也没有问题哈索引就给了1234mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc5=\u0026#39;c5\u0026#39;orderbyc2,c3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|20.00|Usingwhere|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#不是说orderby的顺序是要和索引建立的顺序保持一致吗为啥不会出现文件内排序呢那是因为c2=a2出现在where中,相当于你orderby的排序已经没有用处了mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc2=\u0026#39;a2\u0026#39;andc5=\u0026#39;c5\u0026#39;orderbyc3,c2;+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|62|const,const|1|20.00|Usingwhere|+----+-------------+--------+------------+------+------------------+------------------+---------+-------------+------+----------+-------------+ 1rowinset,1warning(0.00sec)#这个没问题哈c3c2会导致文件内排序mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc5=\u0026#39;c5\u0026#39;orderbyc3,c2;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|20.00|Usingwhere;Usingfilesort|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------------+ 1rowinset,1warning(0.00sec)#索引没有失效但是只用到了一个没有发生文件内排序mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc4=\u0026#39;a4\u0026#39;groupbyc2,c3;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|20.00|Usingindexcondition|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+-----------------------+ 1rowinset,1warning(0.00sec)#索引没问题使用了部分索引但是分组的时候Usingtemporary十死无生啊分组前必排序mysql\u0026gt;explainselect*fromtest03wherec1=\u0026#39;a1\u0026#39;andc4=\u0026#39;a4\u0026#39;groupbyc3,c2;+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ |id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ |1|SIMPLE|test03|NULL|ref|idx_test03_c1234|idx_test03_c1234|31|const|1|20.00|Usingindexcondition;Usingtemporary|+----+-------------+--------+------------+------+------------------+------------------+---------+-------+------+----------+----------------------------------------+ 1rowinset,1warning(0.00sec)总结\n定值 / 范围 还是排序 , 一般order by 是给个范围\ngroup by 基本上都需要进行排序 , 否则会有临时表产生,即temporary\n索引优化  索引分析 索引失效 一般性建议  对于单键索引,尽量选择针对当前query过滤性更好的索引 在选择组合索引的时候,当前query中过滤性最好的字段在索引字段的顺序中 ,位置越靠前越好 在选择组合索引的时候,尽量选择可以能够包含当前query中的where字句中更多字段的索引 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的    \rimage-20211018194551515\r\nlike后面跟着常量的话就没什么问题能做索引也能跳板\n优化总结口诀 全值匹配我最爱,最左前缀要遵守\n带头大哥不能死,中间兄弟不能断\n索引列上少计算,范围之后全失效\nlike百分写最右, 覆盖索引不写*\n不等空值还有or,索引失效要少用\nvar引号不可丢,sql高级也不难\n查询截取分析  查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志  分析步骤  观察,至少跑一天,看看生产的慢sql情况 开启慢查询日志,设置阙值,比如超过5秒钟的就是慢sql,并将它抓取出来 explain + 慢sql分析 show profile 运维经理或dba,进行sql数据库服务器的参数调优  总结 0\n 慢查询的开启并捕获 explain+慢sql分析 show profile查询sql在mysql服务器里面的执行细节和声明周期情况 sql数据库服务器的参数调优  永远小表驱动大表\n类似于嵌套循环nested loop\norderby关键字优化\ngroup by关键字优化\n\rimage-20211018201006527\r\n很好分析嘛,如果B数据少于A,那么用B驱动,B在右边那就是先查B,因为B先查,查到的是小表,这样就小表驱动大表了; 如果B数据多余A,那么用A驱动,B在右边,那就是用exists,在B的查询里套上子查询,这样先查的B的同时需要先查A(这样才知道A.id,B才能查),这样就变成小表驱动大表了\n\rimage-20211018201111638\r\nmysql\u0026gt;select*fromtbl_empwheredeptidin(selectidfromtbl_dept);+----+------+--------+ |id|name|deptid|+----+------+--------+ |1|z3|1||2|z4|1||3|z5|1||4|w5|2||5|w6|2||6|s7|3||7|s8|4|+----+------+--------+ 7rowsinset(0.00sec)#两种最终效果是一样的但是得考虑哪个是小表哪个是大表需要小表驱动大表那就考虑使用哪一种mysql\u0026gt;select*fromtbl_empwhereexists(select1fromtbl_deptwheretbl_emp.deptid=tbl_dept.id);+----+------+--------+ |id|name|deptid|+----+------+--------+ |1|z3|1||2|z4|1||3|z5|1||4|w5|2||5|w6|2||6|s7|3||7|s8|4|+----+------+--------+ 7rowsinset(0.00sec)orderby 关键字优化  orderby子句,尽量使用index方式排序,避免使用filesort方式排序  mysql支持两种方式的排序,filesort和index,index效率高,它指ysql扫描索引本身完成排序,filesort方式效率低   order by 满足两种情况,会使用index方式排序  order by 语句使用索引最左前列 使用where子句和order by子句条件列满足索引最左前列   尽可能在索引列上完成排序操作,遵照索引建的最佳左前缀原则 如果不在索引列上,filesort有两种算法:mysql就要启动双路排序和单路排序  双路排序  4.1之前使用双路排序,扫描两次磁盘,最终得到数据,读取行指针和order by 列, 对他们进行排序,然后扫描已经排序好的列表,按照列表中的值重新从列表中读取 从磁盘取排序字段,在buffer进行排序,再从磁盘取其他字段   单路排序  取一批数据,要对磁盘进行两次扫描,众所周知,IO很耗时,在4.1之后,出现了第二种的改进算法,就是单路排序 从磁盘读取查询需要的所有列,按照orderby列在buffer对他们进行排序,然后扫描排序后的列表进行输出,它的效率更快一些,避免了第二次读取数据.并且把随机IO变成了顺序IO,但是它会使用更多的空间,因为它把每一行都保存在内存中了. \rimage-20211018204727314\r     优化策略  增大sort_buffer_size参数设置 增大max_length_for_sort_data参数的设置 why \rimage-20211018205003059\r    mysql\u0026gt;CREATETABLEtblA(-\u0026gt;#idintprimarykeynotnullautp_increment,-\u0026gt;ageint,-\u0026gt;birthtimestampnotnull-\u0026gt;);QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;CREATEINDEXidx_A_ageBirthontblA(age,birth);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0\rimage-20211018203216016\r\n默认升序 打乱了就会发生filesort\n\rimage-20211018203523533\r\n总结 \rimage-20211018205452929\r\ngroup by 关键字优化  group by实质是先排序后进行分组,遵照索引建的最佳左前缀 当无法使用索引列,增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置 where高于having , 能写在where限定的条件就不要去having限定了  mysql慢查询日志 \rimage-20211018205757207\r\n\rimage-20211018205824359\r\n  如何查看是否开启与如何开启\nmysql\u0026gt;showvariableslike\u0026#39;%slow_query_log%\u0026#39;;+---------------------+--------------------------+ |Variable_name|Value|+---------------------+--------------------------+ |slow_query_log|ON||slow_query_log_file|LAPTOP-FKVMDBSI-slow.log|+---------------------+--------------------------+ 2rowsinset,1warning(0.01sec)#只对当前数据库生效mysql\u0026gt;setglobalslow_query_log=1;QueryOK,0rowsaffected(0.00sec)\rimage-20211018210231026\r\n  什么样的会记录到慢查询日志里面呢?\n  mysql\u0026gt;showvariableslike\u0026#39;%long_query_time%\u0026#39;;+-----------------+-----------+ |Variable_name|Value|+-----------------+-----------+ |long_query_time|10.000000|+-----------------+-----------+ 1rowinset,1warning(0.00sec)\rimage-20211018210404815\r\n  设置慢查询时间阙值\nmysql\u0026gt;setgloballong_query_time=3;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;showvariableslike\u0026#39;%long_query_time%\u0026#39;;+-----------------+-----------+ |Variable_name|Value|+-----------------+-----------+ |long_query_time|10.000000|+-----------------+-----------+ 1rowinset,1warning(0.00sec)\rimage-20211018210539898\r\n\rimage-20211018210653124\r\n  去哪儿找慢sql呀?\n  #超过3s了应该会记录到某个日志里对不对mysql\u0026gt;selectsleep(4);+----------+ |sleep(4)|+----------+ |0|+----------+ 1rowinset(4.01sec)\rimage-20211018211230665\r\n 查看有多少条慢查询的sql  mysql\u0026gt;showglobalstatuslike\u0026#39;slow_queries%\u0026#39;;+---------------+-------+ |Variable_name|Value|+---------------+-------+ |Slow_queries|2|+---------------+-------+ 1rowinset(0.00sec) 配置版 永久生效  \rimage-20211018212354576\r\n 日志分析工具mysqldumpslow  查看帮助信息  s 标识按照何种方式排序 c 访问次数 l 锁定时间 r 返回记录 t 查询时间 al 平均锁定时间 ar 平均返回记录数 at 平均查询时间 t 返回前面多少条的数据 g 后边搭配一个正则匹配模式,大小写不敏感的      \rimage-20211018212608969\r\n\rimage-20211018213827239\r\n批量插入数据 #准备工作mysql\u0026gt;createdatabasebigdata;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;usebigdata;Databasechangedmysql\u0026gt;CREATETABLE`dept`(-\u0026gt;`id`int(10)unsignedNOTNULLAUTO_INCREMENT,-\u0026gt;`deptno`mediumint(8)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,-\u0026gt;`dname`varchar(20)NOTNULLDEFAULT\u0026#39;\u0026#39;,-\u0026gt;`loc`varchar(13)NOTNULLDEFAULT\u0026#39;\u0026#39;,-\u0026gt;PRIMARYKEY(`id`)-\u0026gt;)ENGINE=InnoDBDEFAULTCHARSET=GBK;QueryOK,0rowsaffected,2warnings(0.03sec)mysql\u0026gt;mysql\u0026gt;CREATETABLE`emp`(-\u0026gt;`id`int(10)unsignedNOTNULLAUTO_INCREMENT,-\u0026gt;`empno`mediumint(8)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,/*编号*/-\u0026gt;`ename`varchar(20)NOTNULLDEFAULT\u0026#39;\u0026#39;,/*名字*/-\u0026gt;`job`varchar(9)NOTNULLDEFAULT\u0026#39;\u0026#39;,/*工作*/-\u0026gt;`mgr`mediumint(8)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,/*上级编号*/-\u0026gt;`hiredate`dateNOTNULL,/*入职时间*/-\u0026gt;`sal`decimal(7,2)NOTNULL,/*薪水*/-\u0026gt;`comm`decimal(7,2)NOTNULL,/*红利*/-\u0026gt;`deptno`mediumint(8)unsignedNOTNULLDEFAULT\u0026#39;0\u0026#39;,/*部门编号*/-\u0026gt;PRIMARYKEY(`id`)-\u0026gt;)ENGINE=InnoDBDEFAULTCHARSET=GBK;QueryOK,0rowsaffected,4warnings(0.02sec)mysql\u0026gt;showvariableslike\u0026#39;log_bin_trust_function_creators\u0026#39;;+---------------------------------+-------+ |Variable_name|Value|+---------------------------------+-------+ |log_bin_trust_function_creators|OFF|+---------------------------------+-------+ 1rowinset,1warning(0.00sec)mysql\u0026gt;setgloballog_bin_trust_function_creators=1;QueryOK,0rowsaffected(0.00sec)#重启会失效如果永久就修改配置文件mysql\u0026gt;showvariableslike\u0026#39;log_bin_trust_function_creators\u0026#39;;+---------------------------------+-------+ |Variable_name|Value|+---------------------------------+-------+ |log_bin_trust_function_creators|ON|+---------------------------------+-------+ 1rowinset,1warning(0.00sec)#创建函数随机产生字符串和部门编号mysql\u0026gt;delimiter$$mysql\u0026gt;createfunctionrand_string(nint)returnsvarchar(255)-\u0026gt;begin-\u0026gt;declarechars_strvarchar(100)default\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ\u0026#39;;-\u0026gt;declarereturn_strvarchar(255)default\u0026#39;\u0026#39;;-\u0026gt;declareiintdefault0;-\u0026gt;whilei\u0026lt;ndo-\u0026gt;setreturn_str=concat(return_str,substring(chars_str,floor(1+rand()*52),1));-\u0026gt;seti=i+1;-\u0026gt;endwhile;-\u0026gt;returnreturn_str;-\u0026gt;end$$QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;createfunctionrand_num()returnsint(5)-\u0026gt;begin-\u0026gt;declareiintdefault0;-\u0026gt;seti=floor(100+rand()*10);-\u0026gt;returni;-\u0026gt;end$$QueryOK,0rowsaffected,1warning(0.01sec)#创建存储过程并使用函数mysql\u0026gt;createprocedureinsert_emp(instartint(10),inmax_numint(10))-\u0026gt;begin-\u0026gt;declareiintdefault0;-\u0026gt;setautocommit=0;-\u0026gt;repeat-\u0026gt;seti=i+1;-\u0026gt;insertintoemp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values((start+i),rand_string(6),\u0026#39;SALESMAN\u0026#39;,0001,curdate(),2000,400,rand_num());-\u0026gt;untili=max_num-\u0026gt;endrepeat;-\u0026gt;commit;-\u0026gt;end$$QueryOK,0rowsaffected,2warnings(0.01sec)mysql\u0026gt;DELIMITER$$mysql\u0026gt;CREATEPROCEDUREinsert_dept(INSTARTINT(10),INmax_numINT(10))-\u0026gt;BEGIN-\u0026gt;DECLAREiINTDEFAULT0;-\u0026gt;SETautocommit=0;-\u0026gt;REPEAT-\u0026gt;SETi=i+1;-\u0026gt;INSERTINTOdept(deptno,dname,loc)VALUES((START+i),rand_string(10),rand_string(8));-\u0026gt;UNTILi=max_num-\u0026gt;ENDREPEAT;-\u0026gt;COMMIT;-\u0026gt;END$$QueryOK,0rowsaffected,2warnings(0.01sec)#调用存储过程mysql\u0026gt;delimiter;mysql\u0026gt;callinsert_dept(100,10);QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*fromdept;+----+--------+------------+----------+ |id|deptno|dname|loc|+----+--------+------------+----------+ |1|101|sqzyWknJJc|uPRPyWny||2|102|JIzyTYkhea|MMwVrWFn||3|103|yJHubWCauW|yDuqsQbL||4|104|zpcqwlOlOo|amifZKyp||5|105|dygjEsdkSJ|PXrTreuK||6|106|sImmyFJrNO|JOaNOEFl||7|107|sclZmoJqML|uOLngSTP||8|108|wKlcBBdKqB|HJlkuqvf||9|109|phTUTIJwhu|ELSeUlwz||10|110|jvArhMohVh|WoFhVhYw|+----+--------+------------+----------+ 10rowsinset(0.00sec)mysql\u0026gt;callinsert_emp(100001,500000);QueryOK,0rowsaffected(31.37sec)\rimage-20211018214549181\r\nshow Profile   是什么 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况 可以用于sql的调优测量\n  默认情况下,参数处于关闭状态,并保存最近15次的运行结果\n  分析步骤\n  是否支持 , 看看当前的mysql版本是否支持\nmysql\u0026gt;showvariableslike\u0026#39;%profiling%\u0026#39;;+------------------------+-------+ |Variable_name|Value|+------------------------+-------+ |have_profiling|YES||profiling|OFF||profiling_history_size|15|+------------------------+-------+ 3rowsinset,1warning(0.00sec)  开启功能,默认是关闭,使用前需要开启\nmysql\u0026gt;setprofiling=on;QueryOK,0rowsaffected,1warning(0.00sec)mysql\u0026gt;showvariableslike\u0026#39;%profiling%\u0026#39;;+------------------------+-------+ |Variable_name|Value|+------------------------+-------+ |have_profiling|YES||profiling|ON||profiling_history_size|15|+------------------------+-------+ 3rowsinset,1warning(0.00sec)  运行SQL\n  查看结果,show profiles\n  mysql\u0026gt;showprofiles;+----------+------------+------------------------------------------------------------------+ |Query_ID|Duration|Query|+----------+------------+------------------------------------------------------------------+ |1|0.00142325|showvariableslike\u0026#39;%profiling%\u0026#39;||2|0.00311650|select*fromtbl_emp||3|0.00040100|select*fromtbl_emp||4|0.00018025|SELECTDATABASE()||5|0.00356750|select*fromtbl_emp||6|0.00046875|select*fromtbl_empeinnerjointbl_deptone.deptid=d.id||7|0.00317325|select*fromtbl_empeinnerjointbl_deptdone.deptid=d.id||8|0.00029500|select*fromtbl_empeinnerjointbl_deptdone.deptid=d.id||9|0.00031975|select*fromtbl_empeleftjointbl_deptdone.deptid=d.id||10|0.00016175|SELECTDATABASE()||11|0.48647650|select*fromempgroupbyid%10limit150000||12|0.46590675|select*fromempgroupbyid%20orderby5|+----------+------------+------------------------------------------------------------------+ 12rowsinset,1warning(0.00sec) 诊断sql,show profile cpu ,block io for query 上一步前面的问题sql数字号码 ;  mysql\u0026gt;showprofilecpu,blockioforquery7;+--------------------------------+----------+----------+------------+--------------+---------------+ |Status|Duration|CPU_user|CPU_system|Block_ops_in|Block_ops_out|+--------------------------------+----------+----------+------------+--------------+---------------+ |starting|0.000054|0.000000|0.000000|NULL|NULL||Executinghookontransaction|0.000003|0.000000|0.000000|NULL|NULL||starting|0.000005|0.000000|0.000000|NULL|NULL||checkingpermissions|0.000002|0.000000|0.000000|NULL|NULL||checkingpermissions|0.000003|0.000000|0.000000|NULL|NULL||Openingtables|0.000041|0.000000|0.000000|NULL|NULL||init|0.000004|0.000000|0.000000|NULL|NULL||Systemlock|0.000007|0.000000|0.000000|NULL|NULL||optimizing|0.000012|0.000000|0.000000|NULL|NULL||statistics|0.000027|0.000000|0.000000|NULL|NULL||preparing|0.000017|0.000000|0.000000|NULL|NULL||executing|0.002927|0.000000|0.000000|NULL|NULL||end|0.000005|0.000000|0.000000|NULL|NULL||queryend|0.000002|0.000000|0.000000|NULL|NULL||waitingforhandlercommit|0.000007|0.000000|0.000000|NULL|NULL||closingtables|0.000006|0.000000|0.000000|NULL|NULL||freeingitems|0.000041|0.000000|0.000000|NULL|NULL||cleaningup|0.000013|0.000000|0.000000|NULL|NULL|+--------------------------------+----------+----------+------------+--------------+---------------+ #看看耗时多的找结论\rimage-20211019231456204\r\n 日常开发需要注意的结论  converting heap to myisam 查询结果太大 , 内存不够用了往磁盘上搬 creating temp table 创建临时表  拷贝数据到临时表 用完再删除   copying to tmp table on dist 把内存中临时表复制到磁盘,危险!! locked      #使用temp临时表很消耗时间要创建拷贝处理释放mysql\u0026gt;showprofilecpu,blockioforquery11;+--------------------------------+----------+----------+------------+--------------+---------------+ |Status|Duration|CPU_user|CPU_system|Block_ops_in|Block_ops_out|+--------------------------------+----------+----------+------------+--------------+---------------+ |starting|0.000078|0.000000|0.000000|NULL|NULL||Executinghookontransaction|0.000005|0.000000|0.000000|NULL|NULL||starting|0.000005|0.000000|0.000000|NULL|NULL||checkingpermissions|0.000004|0.000000|0.000000|NULL|NULL||Openingtables|0.000264|0.000000|0.000000|NULL|NULL||init|0.000005|0.000000|0.000000|NULL|NULL||Systemlock|0.000005|0.000000|0.000000|NULL|NULL||optimizing|0.000003|0.000000|0.000000|NULL|NULL||statistics|0.000015|0.000000|0.000000|NULL|NULL||preparing|0.000011|0.000000|0.000000|NULL|NULL||Creatingtmptable|0.000055|0.000000|0.000000|NULL|NULL||executing|0.485898|0.421875|0.046875|NULL|NULL||end|0.000010|0.000000|0.000000|NULL|NULL||queryend|0.000003|0.000000|0.000000|NULL|NULL||waitingforhandlercommit|0.000017|0.000000|0.000000|NULL|NULL||closingtables|0.000007|0.000000|0.000000|NULL|NULL||freeingitems|0.000074|0.000000|0.000000|NULL|NULL||cleaningup|0.000019|0.000000|0.000000|NULL|NULL|+--------------------------------+----------+----------+------------+--------------+---------------+ 18rowsinset,1warning(0.00sec)全局查询日志  配置启用  \rimage-20211019232353049\r\n 编码启用  \rimage-20211019232435273\r\nmysql\u0026gt;setglobalgeneral_log=1;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;setgloballog_output=\u0026#39;TABLE\u0026#39;;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromdept;+----+--------+------------+----------+ |id|deptno|dname|loc|+----+--------+------------+----------+ |1|101|sqzyWknJJc|uPRPyWny||2|102|JIzyTYkhea|MMwVrWFn||3|103|yJHubWCauW|yDuqsQbL||4|104|zpcqwlOlOo|amifZKyp||5|105|dygjEsdkSJ|PXrTreuK||6|106|sImmyFJrNO|JOaNOEFl||7|107|sclZmoJqML|uOLngSTP||8|108|wKlcBBdKqB|HJlkuqvf||9|109|phTUTIJwhu|ELSeUlwz||10|110|jvArhMohVh|WoFhVhYw|+----+--------+------------+----------+ 10rowsinset(0.01sec)mysql\u0026gt;select*frommysql.general_log;+----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ |event_time|user_host|thread_id|server_id|command_type|argument|+----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ |2021-10-1923:25:31.577792|root[root]@localhost[::1]|12|1|Query|0x73656C656374202A2066726F6D2064657074||2021-10-1923:25:44.682913|root[root]@localhost[::1]|12|1|Query|0x73656C656374202A2066726F6D206D7973716C2E67656E6572616C5F6C6F67|+----------------------------+------------------------------+-----------+-----------+--------------+------------------------------------------------------------------+ 2rowsinset(0.00sec)mysql\u0026gt;setglobalgeneral_log=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;altertablemysql.general_logmodifycolumnargumentvarchar(100)notnull;QueryOK,3rowsaffected(0.04sec)Records:3Duplicates:0Warnings:0mysql\u0026gt;setglobalgeneral_log=1;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*frommysql.general_log;+----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ |event_time|user_host|thread_id|server_id|command_type|argument|+----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ |2021-10-1923:25:31.577792|root[root]@localhost[::1]|12|1|Query|select*fromdept||2021-10-1923:25:44.682913|root[root]@localhost[::1]|12|1|Query|select*frommysql.general_log||2021-10-1923:28:59.776726|root[root]@localhost[::1]|12|1|Query|setglobalgeneral_log=0|+----------------------------+------------------------------+-----------+-----------+--------------+---------------------------------+ 3rowsinset(0.01sec)mysql锁机制 锁是计算机协调多个进程或线程并发访问某一资源的机制\n在数据库中,除传统的计算资源如CPU/RAM/IO等的争用以外,数据也是一种供许多用户共享的资源.如何保证数据并发访问的一致性,有效性是所有数据库必须解决的一个问题,锁冲突也是影响数据库并发访问性能的一个重要因素.从这个角度来说,锁对数据库而言显得尤为重要,也更加复杂.\n\rimage-20211019233809036\r\n  锁的分类\n 对数据操作的类型 读/写  读锁(共享锁):针对同一份数据,多个读操作可以同时进行而不会互相影响 写锁(排它锁):当前写操作没有完成前,它会阻断其他写锁和读锁   对数据操作的粒度 表锁/行锁    锁机制中的三锁\n 表锁(偏读)  特点 偏向myisam存储引擎,开销小,加锁快,无死锁;锁定粒度大,发生锁冲突的概率最高,并发度最低    #建表mysql\u0026gt;createtablemylock(-\u0026gt;idintnotnullprimarykeyauto_increment,-\u0026gt;namevarchar(20)-\u0026gt;)enginemyisam;QueryOK,0rowsaffected(0.02sec)#查看哪些上锁mysql\u0026gt;showopentables;+--------------------+---------------------------+--------+-------------+ |Database|Table|In_use|Name_locked|+--------------------+---------------------------+--------+-------------+ |mysql|check_constraints|0|0||mysql|column_type_elements|0|0|#加读写锁mysql\u0026gt;locktablemylockread,empwrite;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;showopentables;+--------------------+---------------------------+--------+-------------+ |Database|Table|In_use|Name_locked|+--------------------+---------------------------+--------+-------------+ |mysql|check_constraints|0|0||mysql|column_type_elements|0|0||bigdata|emp|1|0||mysql|general_log|0|0||bigdata|mylock|1|0|+--------------------+---------------------------+--------+-------------+ #释放锁mysql\u0026gt;unlocktables;QueryOK,0rowsaffected(0.00sec)加读锁\npowershell 中加锁\nmysql\u0026gt;locktablemylockread;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommylock;+----+------+ |id|name|+----+------+ |1|a||2|b||3|c||4|d||5|e|+----+------+ 5rowsinset(0.00sec)cmd中也能读\nmysql\u0026gt;usebigdata;Databasechangedmysql\u0026gt;select*frommylock;+----+------+ |id|name|+----+------+ |1|a||2|b||3|c||4|d||5|e|+----+------+ 5rowsinset(0.01sec)但powershell中加了读锁,不能对该表进行写操作,也就是增删改操作,也不能对其他表进行crud操作\nmysql\u0026gt;updatemylocksetname=\u0026#39;a2\u0026#39;whereid=1;ERROR1099(HY000):Table\u0026#39;mylock\u0026#39;waslockedwithaREADlockandcan\u0026#39;t be updated mysql\u0026gt; insert into mylock values(6,\u0026#39;ljs\u0026#39;); ERROR 1099 (HY000): Table \u0026#39;mylock\u0026#39; was locked with a READ lock and can\u0026#39;tbeupdatedmysql\u0026gt;deletefrommylockwhereid=5;ERROR1099(HY000):Table\u0026#39;mylock\u0026#39;waslockedwithaREADlockandcan\u0026#39;t be updated mysql\u0026gt; select * from emp ; ERROR 1100 (HY000): Table \u0026#39;emp\u0026#39; was not locked with LOCK TABLES 而cmd不能对该表进行写的操作,可以对该表进行读操作,写操作会阻塞,直到powershell中释放锁,但能对其他表进行crud操作\nmysql\u0026gt;updatemylocksetname=\u0026#39;a2\u0026#39;whereid=1;^C-- query aborted ERROR1317(70100):Queryexecutionwasinterruptedmysql\u0026gt;insertintomylockvalues(6,\u0026#39;ljs\u0026#39;);^C-- query aborted ERROR1317(70100):Queryexecutionwasinterruptedmysql\u0026gt;deletefrommylockwhereid=5;^C-- query aborted ERROR1317(70100):Queryexecutionwasinterruptedmysql\u0026gt;select*fromemp;+--------+--------+--------+----------+-----+------------+---------+--------+--------+ |id|empno|ename|job|mgr|hiredate|sal|comm|deptno|+--------+--------+--------+----------+-----+------------+---------+--------+--------+ |1|100002|lPrnpM|SALESMAN|1|2021-10-18|2000.00|400.00|107||2|100003|NuIiSO|SALESMAN|1|2021-10-18|2000.00|400.00|103|当powershell解锁后,cmd立刻得到执行\n#powershell端mysql\u0026gt;unlocktables;QueryOK,0rowsaffected(0.01sec)#cmd端等到解锁后立刻执行mysql\u0026gt;updatemylocksetname=\u0026#39;a2\u0026#39;whereid=1;QueryOK,1rowaffected(19.80sec)Rowsmatched:1Changed:1Warnings:0\rimage-20211020200516110\r\n\rimage-20211020200614618\r\n加写锁\npowershell加写锁,其他未锁的表都访问不了\nmysql\u0026gt;locktablemylockwrite;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommylock;+----+------+ |id|name|+----+------+ |1|a2||2|b||3|c||4|d||5|e|+----+------+ 5rowsinset(0.01sec)mysql\u0026gt;updatemylocksetname=\u0026#39;a4\u0026#39;whereid=1;QueryOK,1rowaffected(0.01sec)Rowsmatched:1Changed:1Warnings:0mysql\u0026gt;select*fromemp;ERROR1100(HY000):Table\u0026#39;emp\u0026#39;wasnotlockedwithLOCKTABLEScmd访问该表,发生阻塞,直至powershell解锁\nmysql\u0026gt;select*frommylock;+----+------+ |id|name|+----+------+ |1|a4||2|b||3|c||4|d||5|e|+----+------+ 5rowsinset(2.44sec)\rimage-20211020201254172\r\n\rimage-20211020201310837\r\n\rimage-20211020201455840\r\n表锁分析\n show open tables ; 哪些表被锁了 通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定; show status like \u0026lsquo;table%\u0026rsquo; ;  mysql\u0026gt;showstatuslike\u0026#39;table%\u0026#39;;+----------------------------+-------+ |Variable_name|Value|+----------------------------+-------+ |Table_locks_immediate|104||Table_locks_waited|0||Table_open_cache_hits|89||Table_open_cache_misses|24||Table_open_cache_overflows|0|+----------------------------+-------+ \rimage-20211020203053434\r\n 行锁  innodb存储引擎,开销大,加锁慢;会出现死锁;锁定粒度最小,发生锁冲突的概率最低,并发度最高 innodb与myisam的最大不同有两点:一是支持事务transactioon;二是采用行级锁    事务\n事务及acid属性\n\rimage-20211020203617056\r\n并发事务处理带来的问题\n 更新丢失  \rimage-20211020203848386\r\n 脏读  \rimage-20211020204010474\r\n 不可重复读  \rimage-20211020204034952\r\n 幻读  \rimage-20211020204053892\r\n事务的并发隔离级别\n read uncommitted read committed repeatable read serializable  \rimage-20211020204239692\r\nmysql\u0026gt;showvariableslike\u0026#39;transaction_isolation\u0026#39;;+-----------------------+-----------------+ |Variable_name|Value|+-----------------------+-----------------+ |transaction_isolation|REPEATABLE-READ|+-----------------------+-----------------+ 1rowinset,1warning(0.01sec)示例\nmysql\u0026gt;createtabletest_innodb_lock(aint(11),bvarchar(16))engine=innodb;QueryOK,0rowsaffected,1warning(0.04sec)mysql\u0026gt;createindextest_innodb_a_indontest_innodb_lock(a);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;createindextest_innodb_lock_b_indontest_innodb_lock(b);QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0powershell中修改数据\nmysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;4001\u0026#39;wherea=4;QueryOK,1rowaffected(0.01sec)Rowsmatched:1Changed:1Warnings:0为保证数据一致性 在cmd中 拿到的肯定还是4000\nmysql\u0026gt; select * from test_innodb_lock ; +------+------+ | a | b | +------+------+ | 1 | b2 | | 3 | 3 | | 4 | 4000 | | 5 | 5000 | | 6 | 6000 | | 7 | 7000 | | 8 | 8000 | | 9 | 9000 | | 1 | b1 | +------+------+ powershell修改数据\nmysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;4002\u0026#39;wherea=4;QueryOK,1rowaffected(0.01sec)Rowsmatched:1Changed:1Warnings:0如果不提交 就发生了行锁 cmd中等到powershell中提交了 才会更新 否则会阻塞\nmysql\u0026gt; update test_innodb_lock set b = \u0026#39;4003\u0026#39; where a = 4 ; Query OK, 1 row affected (19.16 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; commit ; Query OK, 0 rows affected (0.01 sec) 动不同的行是没有问题的\n\rimage-20211020210157165\r\n无索引行锁升级为表锁\npowershell中由于varchar没有加单引号‘’ 导致类型转换发生了索引失效\nmysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;updatetest_innodb_lockseta=41whereb=4000;QueryOK,0rowsaffected(0.01sec)Rowsmatched:0Changed:0Warnings:0理论上只是行锁，但是索引失效导致行锁升级为了表锁，操作其他行也发现表被锁住了\nmysql\u0026gt;select*fromtest_innodb_lock;+------+------+ |a|b|+------+------+ |1|b2||3|3||4|4003||5|5000||6|6000||7|7000||8|8000||9|9000||1|b1|+------+------+ 9rowsinset(0.01sec)mysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;9002\u0026#39;wherea=9;QueryOK,1rowaffected(21.24sec)Rowsmatched:1Changed:1Warnings:0间隙锁\ncmd中更新一个范围,还没提交\nmysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;0629\u0026#39;wherea\u0026gt;1anda\u0026lt;6;QueryOK,3rowsaffected(0.01sec)Rowsmatched:3Changed:3Warnings:0mysql\u0026gt;commit;QueryOK,0rowsaffected(0.01sec)powershell中插入的话要等到cmd中commit的时候才能插入,否则会阻塞\nmysql\u0026gt;insertintotest_innodb_lockvalues(2,\u0026#39;2000\u0026#39;);QueryOK,1rowaffected(23.87sec)什么是间隙锁\n当我们使用范围条件而不是相等条件检索数据,并请求共享或排他锁时,innodb会给符合条件的已有数据记录的索引项加锁;对于键值再条件范围内但并不存在的记录,叫做间隙GAP\ninnodb也会对这个间隙加锁,这种锁机制就是所谓的间隙锁NETT \u0026ndash;KEY锁\n危害\n因为query执行过程中通过范围查找的话,它会锁定整个范围内所有的索引键值,即使这个键值并不存在\n间隙锁有一个比较致命的弱点,就是当锁定一个范围键值之后,即使某些不存在的键值也会被无辜的锁定,而造成锁定的时候无法插入锁定键值范围内的任何数据,在某些场景下这可能会对性能造成很大的危害\n\rimage-20211022212523821\r\n如何锁定一行\nselect xxx \u0026hellip; for update 锁定某一行后,其他的操作会被阻塞,直到锁定行的会话提交commit\ncmd使用begin \u0026hellip; for update 来锁定一行\nmysql\u0026gt;begin;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*fromtest_innodb_lockwherea=8forupdate;+------+------+ |a|b|+------+------+ |8|8000|+------+------+ 1rowinset(0.01sec)mysql\u0026gt;commit;QueryOK,0rowsaffected(0.01sec)powershell不能对该行做改动,除非cmd提交了commit才会释放锁\nmysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;xxx\u0026#39;wherea=8;ERROR1205(HY000):Lockwaittimeoutexceeded;tryrestartingtransactionmysql\u0026gt;updatetest_innodb_locksetb=\u0026#39;xxx\u0026#39;wherea=8;QueryOK,1rowaffected(2.17sec)Rowsmatched:1Changed:1Warnings:0mysql\u0026gt;commit;QueryOK,0rowsaffected(0.01sec)案例结论 innodb存储引擎由于实现了行级锁定,虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一点,但是在整体并发处理能力方面要远远优于myisam的表级锁定的.当系统并发量较高的时候,innodb的整体性能和myisam相比就会有比较明显的优势了.\n但是,innodb的行级锁定同样也有其脆弱的一面,当我们使用不当的时候,可能会让innodb的整体性能表现不仅不能比myisam高,甚至可能会更差.\n如何分析行锁定\n通过检查innodb_row_lock变量来分析系统上的行锁的争夺情况\nmysql\u0026gt;showstatuslike\u0026#39;innodb_row_lock%\u0026#39;;+-------------------------------+--------+ |Variable_name|Value|+-------------------------------+--------+ |Innodb_row_lock_current_waits|0||Innodb_row_lock_time|117831||Innodb_row_lock_time_avg|23566||Innodb_row_lock_time_max|51419||Innodb_row_lock_waits|5|+-------------------------------+--------+ 5rowsinset(0.01sec)\rimage-20211022214707680\r\n优化建议   尽可能让所有数据检索都通过索引来完成,避免无索引行锁升级为表锁\n  合理设计索引,尽量缩小锁的范围\n  尽可能减少检索条件,避免使用间隙锁\n  尽量控制事务大小,减少锁定资源量和时间长度\n  尽可能低级别事务隔离\n页锁 开销和加锁时间介于表锁和行锁之间;会出现死锁;锁定粒度介于表锁和行锁之间,并发度一般\n    主从复制  复制的基本原理  slave会从master读取binlog来进行数据同步 三步骤+原理图   复制的基本原则  每个slave只有一个master 每个slave只能有一个唯一的服务器ID 每个master可以有多个slave   复制的最大问题  延时   一主一从常见配置  mysql版本一致且后台以服务运行 主从都配置在[mysqld]节点下,都是小写 主机修改my.ini配置文件  [必须]主服务器唯一ID  server-id =1 ;   [必须]启用二进制日志  log-bin = 自己本地的路径/mysqlbin log-bin =C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\LAPTOP-FKVMDBSI-bin   [可选]启用错误日志  log-err = 自己本地的路径/mysqlerr log-err=C:\\ProgramData\\MySQL\\MySQL Server 8.0\\Data\\LAPTOP-FKVMDBSI   [可选]根目录  basedir=\u0026ldquo;自己本地路径\u0026rdquo; basedir=\u0026ldquo;C:/Program Files/MySQL/MySQL Server 8.0/\u0026rdquo;   [可选]临时目录 好像不行再8.0版本中  tmpdir=\u0026ldquo;自己本地路径\u0026rdquo; tmpdir=\u0026ldquo;C:/Program Files/MySQL/MySQL Server 8.0/\u0026rdquo;   [可选]数据目录  data=\u0026ldquo;自己本地路径/Data/\u0026rdquo; datadir=C:/ProgramData/MySQL/MySQL Server 8.0\\Data   read-only = 0  主机,读写都可以   [可选]设置不要复制的数据库  binlog-ignore-db=不需要复制的主数据库名字   [可选]设置需要复制的数据库  binlog-do-db=需要复制的主数据库名字     从机修改my.cnf配置文件  [必选]从服务器唯一ID [可选]启用二进制日志   因修改过配置文件,请主机+从机都重启后台mysql服务 主机从机都关闭防火墙  windows手动关闭 关闭虚拟机linux防火墙 service iptables stop   在windows主机上建立账户并授权slave  create user \u0026lsquo;zhangsan\u0026rsquo;@\u0026lsquo;192.168.202.64\u0026rsquo; identified by \u0026lsquo;123456\u0026rsquo;; grant replication slave on *.* to \u0026lsquo;zhangsan\u0026rsquo; @ \u0026lsquo;192.168.202.64\u0026rsquo; ; 8.0 不支持grant的时候用identified by flush privileges ; 刷新权限 查询master的状态  show master status ; 记录下file和position的值     在linux从机上配置需要复制的主机  change master to master_host=\u0026lsquo;ip地址\u0026rsquo; , master_user =\u0026lsquo;授权的用户\u0026rsquo; , master_password = \u0026lsquo;密码\u0026rsquo; , master_log_file=\u0026lsquo;mysqlbin.具体数字\u0026rsquo;,master_log_pos = 具体值; change master to master_host=\u0026lsquo;192.168.202.64\u0026rsquo; , master_user =\u0026lsquo;zhangsan\u0026rsquo; , master_password = \u0026lsquo;123456\u0026rsquo; , master_log_file=\u0026lsquo;LAPTOP-FKVMDBSI-bin.000105\u0026rsquo;,master_log_pos = 156; 启动从服务器复制功能  start slave ;   show slave status \\G ;  下面两个参数都是yes的话,则说明主从配置成功! slave_io_running :yes slave_sql_running :yes     主机新建库/新建表/insert记录/从机复制 如何停止从服务复制功能  stop slave ;      三步骤+原理图\n\rimage-20211022215731804\r\n主从复制配置过程 主机\n设置主服务器\n\rimage-20211023100459506\r\n设置二进制日志文件\n\rimage-20211023095228167\r\n设置错误文件\n\rimage-20211023095304402\r\n\rimage-20211023100542517\r\n设置读写都可以 设置忽略和需要复制的数据库 设置数据库目录位置\n\rimage-20211023101034426\r\n这里有个坑,使用WSL,linux子系统的话不设置端口会导致端口占用,必须把windows上的mysql服务关掉,linuxmysql才能start 所以再配置文件里改一下端口号试试看\n\rimage-20211023113130359\r\n弄完重启主机从机的mysql服务\n在windows主机中授权 从000104的912行开始抄书 复制的数据库是bigdata 忽略的数据库是mysql\nmysql\u0026gt;createuser\u0026#39;zhangsan\u0026#39;@\u0026#39;192.168.202.64\u0026#39;identifiedby\u0026#39;123456\u0026#39;;QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;grantreplicationslave,replicationclienton*.*to\u0026#39;zhangsan\u0026#39;@\u0026#39;192.168.202.64\u0026#39;;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;flushprivileges;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;showmasterstatus;+----------------------------+----------+--------------+------------------+-------------------+ |File|Position|Binlog_Do_DB|Binlog_Ignore_DB|Executed_Gtid_Set|+----------------------------+----------+--------------+------------------+-------------------+ |LAPTOP-FKVMDBSI-bin.000104|912|bigdata|mysql||+----------------------------+----------+--------------+------------------+-------------------+ 1rowinset(0.00sec)binlog_do_db为空说明都要复制,我重新设置一下\n\rimage-20211023115552278\r\n重启服务,查看状态\nmysql\u0026gt;showmasterstatus;+----------------------------+----------+--------------+------------------+-------------------+ |File|Position|Binlog_Do_DB|Binlog_Ignore_DB|Executed_Gtid_Set|+----------------------------+----------+--------------+------------------+-------------------+ |LAPTOP-FKVMDBSI-bin.000105|156||mysql||+----------------------------+----------+--------------+------------------+-------------------+ 1rowinset(0.00sec)接下来进入linux命令行进行操作 通过 Last_IO_Errno 和 Last_SQL_Errno 来排查问题 简单的\nmysql\u0026gt;changemastertomaster_host=\u0026#39;192.168.202.64\u0026#39;,master_user=\u0026#39;zhangsan\u0026#39;,master_password=\u0026#39;123456\u0026#39;,master_log_file=\u0026#39;LAPTOP-FKVMDBSI-bin.000105\u0026#39;,master_log_pos=156;QueryOK,0rowsaffected,8warnings(0.00sec)mysql\u0026gt;startslave;QueryOK,0rowsaffected,1warning(0.00sec)mysql\u0026gt;showslavestatus\\G;***************************1.row***************************Slave_IO_State:WaitingforsourcetosendeventMaster_Host:192.168.202.64Master_User:zhangsanMaster_Port:3306Connect_Retry:60Master_Log_File:LAPTOP-FKVMDBSI-bin.000105Read_Master_Log_Pos:156Relay_Log_File:yourtreedad-relay-bin.000003Relay_Log_Pos:334Relay_Master_Log_File:LAPTOP-FKVMDBSI-bin.000105Slave_IO_Running:YesSlave_SQL_Running:YesReplicate_Do_DB:Replicate_Ignore_DB:Replicate_Do_Table:Replicate_Ignore_Table:Replicate_Wild_Do_Table:Replicate_Wild_Ignore_Table:Last_Errno:0Last_Error:Skip_Counter:0Exec_Master_Log_Pos:156Relay_Log_Space:549Until_Condition:NoneUntil_Log_File:Until_Log_Pos:0Master_SSL_Allowed:NoMaster_SSL_CA_File:Master_SSL_CA_Path:Master_SSL_Cert:Master_SSL_Cipher:Master_SSL_Key:Seconds_Behind_Master:0Master_SSL_Verify_Server_Cert:NoLast_IO_Errno:0Last_IO_Error:Last_SQL_Errno:0Last_SQL_Error:Replicate_Ignore_Server_Ids:Master_Server_Id:1Master_UUID:3a5f9439-a33e-11eb-85f6-002b67a4fefaMaster_Info_File:mysql.slave_master_infoSQL_Delay:0SQL_Remaining_Delay:NULLSlave_SQL_Running_State:Replicahasreadallrelaylog;waitingformoreupdatesMaster_Retry_Count:86400Master_Bind:Last_IO_Error_Timestamp:Last_SQL_Error_Timestamp:Master_SSL_Crl:Master_SSL_Crlpath:Retrieved_Gtid_Set:Executed_Gtid_Set:Auto_Position:0Replicate_Rewrite_DB:Channel_Name:Master_TLS_Version:Master_public_key_path:Get_master_public_key:0Network_Namespace:1rowinset,1warning(0.00sec)ERROR:Noqueryspecified\rimage-20211023150356197\r\n起飞!!!\n完结撒花~~~\n😜😋🤣😊\n","date":"2021-10-12T19:35:55+08:00","image":"https://linjianshu.github.io/hutomo-abrianto-l2jk-uxb1BY-unsplash.jpg","permalink":"https://linjianshu.github.io/p/test-chinese/","title":"Mysql高级"},{"content":"Go趣学指南 ","date":"2021-10-11T09:17:59+08:00","permalink":"https://linjianshu.github.io/p/go%E8%B6%A3%E5%AD%A6%E6%8C%87%E5%8D%97/","title":"Go趣学指南"},{"content":"mysql学习文档 一 为什么要学习数据库 二 数据库的相关概念 DBMS DB SQL\n三 数据库存储数据的特点 四 初始mysql mysql产品的介绍\nmysql产品的安装\nmysql服务的启动和停止\nmysql服务的登陆和退出\nmysql的常见命令和语法规范\n五DQL语言的学习 基础查询\n条件查询\n排序查询\n常见函数\n分组查询\n连接查询\n子查询\n分页查询\nunion联合查询\n六 DML语言的学习 插入语句\n修改语句\n删除语句\n七 DDL语言的学习 库和表的管理\n常见数据类型介绍\n常见约束\n保存数据的容器:\n数组 集合 内存数据 断电就没了\n文件 但是文件不好查找\n因此把文件做成方便增删改查的软件 对文件进行操作 这样的软件就叫做数据库\n数据库的好处  实现数据持久化 使用完整的管理系统统一管理,易于查询  数据库的概念 DB 数据库 database:存储数据的仓库,保存了一系列有组织的数据.\nDBMS 数据库管理系统 database management system 数据库是通过dbms创建和操作的容器\n常见的数据库管理系统 mysql oracle db2 sqlserver\nSQL 结构化查询语言 structure query language :专门用来与数据库通信的语言\nsql的优点:\n 不是某个特定数据库供应商专有的语言,几乎所有DBMS都支持sql 简单易学 虽然简单,但实际上是一种强有力的语言,灵活使用其语言元素,可以进行非常复杂和高级的数据库操作  类似于管家 管理 文件柜 DBMS 管理 DB\n数据库的特点  将数据放到表中,表再放到库中 一个数据库中够可以有多个表,每个表都有一个自己的名字,用来标识自己,表名具有唯一性 表具有一些特性,这些特性定义了数据在表中如何存储,类似java中类的设计 表由列组成,我们也称为字段.所有表都是由一个或多个列组成的,每个列类似java中的属性 表中的数据是按行存储的,每一行类似于java中的对象  Mysql产品的特点  mysql数据库隶属于mysqlab公司,总部位于瑞典,后被oracle收购 优点  成本低:开放源代码,一般可以免费使用 性能高:执行很快 简单:很容易安装和使用    DBMS分为两类  基于共享文件系统的DBMS 例如 access 基于客户机\u0026mdash;服务器的DBMS 例如 mysql oracle sqlserver  mysql版本  社区版 免费 企业版 收费  mysql卸载 先控制面板卸载\n然后在安装目录下删除文件夹\n然后在programdata中删除残余文件\n清理注册表\n\rimage-20210919154523464\r\nmy.ini 配置文件 \rimage-20210919160841225\r\n端口号 安装位置 数据存放位置 字符集 默认存储引擎 语法模式 最大连接数\n改完服务需要重启\nmysql服务的启动和停止 \rimage-20210919161439996\r\nmysql服务端的登陆和退出  使用mysql command line client 不建议 只适用于root用户  \rimage-20210919161620401\r\n\rimage-20210919161637466\r\n2.命令行 p输入密码不能有空格 -h 主机名 -P 端口号 -u 用户名 -p密码\n\rimage-20210919161848290\r\n简化命令 退出exit 或者 ctrl+C\n\rimage-20210919161938321\r\n基本命令\nshowdatabases;usetset;//进入数据库\rimage-20210919163057930\r\nshowtables;//查看数据库里的表在当前用户进入的数据库中查看showtablesfromsys;//查看数据库里的表可以在当前数据库中查看别的数据库中的表selectdatabase();//查看当前处于什么位置类似于linux中的pwdcreatetable...//创建表\rimage-20210919163334648\r\ndescstuInfo;//查看表stuInfo中的字段insertintostuInfo(id,name)value(1,\u0026#39;ljs\u0026#39;);deletefromstuInfowhereid=1;updatestuInfosetname=\u0026#39;jwt\u0026#39;whereid=1;select*fromstuInfo;#增删改查\rimage-20210919163430191\r\n练习\n\rimage-20210919164509494\r\nsqlselectversion();//查看版本号sql中cmdmysql--version mysql-Vmysql的语法规范  不区分大小写,但建议关键字大写,表名 列名小写 每条命令用分号结尾 每条命令根据需要,可以进行缩进或者换行 注释  单行注释 #注释文字 \u0026ndash; 注释文字 (必须要有空格) 多行注释 /* lkdfjasldfj */    基础查询 select 查询列表 from 表名\n 查询列表可以是:表中的字段 / 常量值 / 表达式 / 函数 查询的结果可以是一个虚拟的表格  查询单个字段\n查询多个字段\n查询所有字段\nselect * 不能控制字段的显示顺序\n之所以用`` 着重号 第一为了直白,第二为了区分关键字 防止与关键字重名\n查询常量\n查询表达式\n查询函数\n\rimage-20210919202609756\r\nselect100;select\u0026#39;join\u0026#39;;select100*98;selectdatabase();selectversion();showtables;起别名 方便理解 如果要查询的字段有重名的情况,使用别名可以区分开来\n方式一: 使用as\n方式二: 直接不用as\nselectlast_nameas姓,first_nameas名fromemployees;selectlast_name姓,first_name名fromemployees;#防止歧义双引号也行单引号也可以selectsalaryas`output`fromemployees;去重\nselectdatabase();showtables;descemployees;selectdistinctdepartment_idfromemployees;\rimage-20210919203515527\r\n+号的作用\n姓名连接成一个字段 , 显示为姓名\n以下错误\n\rimage-20210919203805417\r\njava中的+号:\n 运算符 , 操作数为数值型 连接符, 只要有一个操作数为字符串  mysql中的+号:\n 仅仅只有一个功能:运算符  select 100+90 ;\nselect \u0026lsquo;123\u0026rsquo; +90 ; 其中一方为字符型,视图将字符型数值转换为数值型, 如果转换成功,则继续做加法运算\nselect \u0026lsquo;james\u0026rsquo; + 90 ; 如果转换失败,则将字符型数值转换成0\nselect null +10 ; 只要其中一方为null , 则结果肯定为null \rimage-20210919204251938\r\n所以需要使用函数 concat() ;\n#这是错误的用法,加上了单引号,无法解析selectconcat(\u0026#39;last_name\u0026#39;,\u0026#39;first_name\u0026#39;)姓名fromemployees;#这是正确的selectconcat(last_name,first_name)姓名fromemployees;显示出表employees中的全部列,各个列之间用逗号连接,列头显示成out_put #查看某表列名selectcolumn_namefuck_namefrominformation_schema.columnswheretable_schema=\u0026#39;myemployees\u0026#39;andtable_name=\u0026#39;employees\u0026#39;;#没问题因为不存在nullselectconcat(employee_id,\u0026#39;,\u0026#39;,first_name)fromemployees;#有问题因为存在null,导致那行都变成null了selectconcat(employee_id,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,commission_pct)fromemployees;+----------------------------------------------------------+ |concat(employee_id,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,commission_pct)|+----------------------------------------------------------+ |NULL||NULL||NULL||NULL||NULL|引入函数 IFNULL selectIFNULL(a,b)selectifnull(commission_pct,0)as奖金率,commission_pctfromemployees;mysql\u0026gt;selectifnull(commission_pct,0)as奖金率,commission_pctfromemployees;+--------+----------------+ |奖金率|commission_pct|+--------+----------------+ |0.00|NULL||0.00|NULL||0.00|NULL||0.00|NULL||0.00|NULL||0.00|NULL||0.40|0.40||0.30|0.30||0.30|0.30|#这是正确的selectconcat(employee_id,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,ifnull(commission_pct,0))fromemployees;+--------------------------------------------------------------------+ |concat(employee_id,\u0026#39;,\u0026#39;,first_name,\u0026#39;,\u0026#39;,ifnull(commission_pct,0))|+--------------------------------------------------------------------+ |142,Curtis,0.00||143,Randall,0.00||144,Peter,0.00||161,Sarath,0.25||169,Harrison,0.20||170,Tayler,0.20||171,William,0.15|条件查询 select 查询列表 from 表名 where 筛选条件 ; 先查表名有没有在,再筛选,再查询\n分类\n 按条件表达式筛选  条件运算符 \u0026gt; \u0026lt; = \u0026lt;\u0026gt;(不等于)   按逻辑表达式筛选 作用用于连接条件表达式  \u0026amp;\u0026amp; || ! and or not   模糊查询  like between and in is null    #条件运算符select*fromemployeeswheresalary\u0026gt;12000;#逻辑运算符selectfirst_name,department_idfromemployeeswheredepartment_id\u0026lt;\u0026gt;90;#逻辑表达式筛选selectfirst_name,salary,commission_pctfromemployeeswheresalary\u0026gt;10000andsalary\u0026lt;20000;#好像三个不太一样select*fromemployeeswherenot(department_idbetween90and120)orsalary\u0026gt;15000;select*fromemployeeswheredepartment_idnotin(90,120)orsalary\u0026gt;15000;select*fromemployeeswheredepartment_idnotin(department_idbetween90and120)orsalary\u0026gt;15000;模糊查询\n like 一般和通配符使用  % 0到任意个字符 _ 任意一个字符   between and in is null | is not null  #模糊查询select*fromemployeeswherefirst_namelike\u0026#39;%a%\u0026#39;;selectfirst_name,salaryfromemployeeswherefirst_namelike\u0026#39;__e_a%\u0026#39;;#如果不想使用转义字符,第二个字符就是_而不是任意单个字符的话mysql\u0026gt;selectlast_namefromemployeeswherelast_namelike\u0026#39;_\\_%\u0026#39;;+-----------+ |last_name|+-----------+ |K_ing||K_ing|+-----------+ 2rowsinset(0.00sec)#或者使用以下这种使用ESCAPE来取消转义mysql\u0026gt;selectlast_namefromemployeeswherelast_namelike\u0026#39;_$_%\u0026#39;escape\u0026#39;$\u0026#39;;+-----------+ |last_name|+-----------+ |K_ing||K_ing|+-----------+ 2rowsinset(0.00sec)mysql\u0026gt;selectlast_namefromemployeeswherelast_namelike\u0026#39;_h_%\u0026#39;escape\u0026#39;h\u0026#39;;+-----------+ |last_name|+-----------+ |K_ing||K_ing|+-----------+ 2rowsinset(0.00sec)between and  提高语句简洁度 左右都包含临界值 不能颠倒顺序  #左闭右闭select*fromemployeeswhereemployee_idbetween100and120;in 判断某字段的值是否属于in列表中的某一项   使用 in 提高语句的简洁度\n  in 列表的值类型必须一致或兼容\n  in 不支持通配符 毕竟不是like关键字\n  selectemployee_id,job_idfromemployeeswherejob_idin(\u0026#39;IT_PROG\u0026#39;,\u0026#39;AD_VP\u0026#39;,\u0026#39;AD_PRES\u0026#39;);is null  = 或 \u0026lt;\u0026gt; 不能用于判断null值  selectfirst_name,commission_pctfromemployeeswherecommission_pctisnull;is not null 安全等于 \u0026lt;=\u0026gt; #安全等于可以用来判断是不是为空selectfirst_name,commission_pctfromemployeeswherecommission_pct\u0026lt;=\u0026gt;null;#安全等于也可以用来判断是不是某个数值mysql\u0026gt;selectlast_name,salaryfromemployeeswheresalary\u0026lt;=\u0026gt;12000;+-----------+----------+ |last_name|salary|+-----------+----------+ |Greenberg|12000.00||Errazuriz|12000.00||Higgins|12000.00|+-----------+----------+ 3rowsinset(0.00sec)安全等于和is null 的区别 is null 仅仅可以判断null值 , 可读性较高 , 建议使用\n\u0026lt;=\u0026gt; 既可以判断null值,又可以判断普通的数值\n复习一下 mysql 与mysql的第一次亲密接触 数据库的好处  持久化数据到本地 结构化查询  数据库的常见概念  DB 数据库,存储数据的容器 DBMS 数据库管理系统, 又称为数据库软件或数据库产品,用于创建或管理DB SQL 结构化查询语言 ,用于和数据库通信的语言,不是某个数据库软件特有的,而是几乎所有的主流数据库软件通用的语言  数据库存储的特点  数据存放到表中,然后表再存放到库中 一个库中可以有多张表,每张表具有唯一的表名用以标识自己 表有一个或多个列,列又称为字段,相当于java中的属性 表中的每一行数据,相当于java中的对象  常见的数据库管理系统 mysq oracle db2 sqlserver\nmysql的介绍 mysql的背景 前身属于瑞典的一家公司 mysql ab , 08被sun收购 , 09年被oracle收购\nmysql的优点  开源免费成本低 性能高 , 移植性好 体积小,便于安装  mysql的安装 属于c/s架构的软件,一般来讲是安装服务端\n企业版/社区版\n环境变量配置\nmysql服务的启动和停止 net start mysql\n图形化界面里开服务\nmysql服务的登陆和退出 mysql -h localhost -P 3306 -u root -p123456\nexit或者ctrl+C\nDQL语言 基础查询 select 查询列表 from 表名\n特点\n 查询列表可以是字段/常量 / 表达式/ 函数/ 也可以是多个 查询结果是一个虚拟表  示例\n查询单个字段 select 字段名 from 表名 ;\n查询多个字段 select 字段名 , 字段名 from 表名 ;\n查询所有字段 select * from 表名 ;\n查询常量 select 常量 as \u0026hellip; ;\n注意:字符型和日期型的常量值必须用单引号引起来,数值型不需要\n查询函数 select 函数名(实参列表) ;\n查询表达式 select 100%98 ;\n起别名  as 空格  去重 distinct 只能给一个参数用\n+号的作用 只能做加法运算\nselect 数值+数值 ; 直接运算\nselect 字符 +数值 ; 尝试隐式转换然后运算 , 成功就成功,不成功就是0+数值\nselect null + 数值; 返回null\nconcat函数 拼接字符\nselect concat (字符1 , 字符2 , 字符3 \u0026hellip;) ;\nifnull函数 判断某自字段或表达式是否为null , 如果为null 返回指定的值, 否则返回原本的值\nselect ifnull(commission_pct,0) from employees ; 如果是null则返回0 , 如果不是null , 则返回原值\nisnull函数 判断是不是null , 是的话返回1 , 否的话就返回0\n条件查询 select 查询列表 from 表名 where 筛选条件\n筛选条件的分类\n 简单条件运算符 \u0026gt; \u0026lt; = \u0026lt;\u0026gt; \u0026lt;=\u0026gt; \u0026gt;= \u0026lt;= 逻辑运算符 || \u0026amp;\u0026amp; ! and or not 模糊查询  like in is null is not null between and\nlike :一般搭配通配符使用, 用于判断字符型数值, 在5.5版本之后 , 也可以判断int类型的 , % 和 _ 区别\nmysql\u0026gt;select*fromemployeeswheredepartment_idlike\u0026#39;1__\u0026#39;;+-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ |108|Nancy|Greenberg|NGREENBE|515.124.4569|FI_MGR|12000.00|NULL|101|100|1998-03-0300:00:00||109|Daniel|Faviet|DFAVIET|515.124.4169|FI_ACCOUNT|9000.00|NULL|108|100|1998-03-0300:00:00||110|John|Chen|JCHEN|515.124.4269|FI_ACCOUNT|8200.00|NULL|108|100|2000-09-0900:00:00||111|Ismael|Sciarra|ISCIARRA|515.124.4369|FI_ACCOUNT|7700.00|NULL|108|100|2000-09-0900:00:00||112|JoseManuel|Urman|JMURMAN|515.124.4469|FI_ACCOUNT|7800.00|NULL|108|100|2000-09-0900:00:00||113|Luis|Popp|LPOPP|515.124.4567|FI_ACCOUNT|6900.00|NULL|108|100|2000-09-0900:00:00||205|Shelley|Higgins|SHIGGINS|515.123.8080|AC_MGR|12000.00|NULL|101|110|2016-03-0300:00:00||206|William|Gietz|WGIETZ|515.123.8181|AC_ACCOUNT|8300.00|NULL|205|110|2016-03-0300:00:00|+-------------+-------------+-----------+----------+--------------+------------+----------+----------------+------------+---------------+---------------------+ 8rowsinset(0.00sec)is null 和\u0026lt;=\u0026gt; 的区别 is null 只会判断null\n\u0026lt;=\u0026gt; 不仅判断null 还可以普通类型的数值\n排序查询 select 查询列表 from 表 where 筛选条件 order by 排序列表 asc|desc\n默认是asc 升序\n支持单个字段/多个字段/表达式/函数/别名\norder by 一般是放在查询语句的最后面 limit子句除外\n 按表达式排序 按字段排序 按别名排序 按函数排序 按多字段排序  select*fromemployeesorderbysalarydesc;select*fromemployeesorderbysalaryasc;#默认升序ascselect*fromemployeeswheredepartment_id\u0026gt;=90orderbyhiredatedesc;#*必须放在前面可以按照表达式排序也可以按照别名排序select*,salary*12*(1+ifnull(commission_pct,0))as年薪fromemployeesorderby年薪desc;#按照函数排序selectlast_name,salaryfromemployeesorderbylength(last_name)desc;#双重排序先按照工资升序排,再按照员工编号降序排select*fromemployeesorderbysalaryasc,employee_iddesc;练习\nselectlast_name,department_id,salary*12*(1+ifnull(commission_pct,0))as年薪fromemployeesorderby年薪desc,length(last_name)asc;#以下用法错误betweenand不能按照别名来selectlast_name,salaryas工资fromemployeeswherenot(工资between8000and17000)orderby工资;#以下用法正确selectlast_name,salaryas工资fromemployeeswherenot(salarybetween8000and17000)orderby工资;#可以这样直接notbetweenandselectlast_name,salaryas工资fromemployeeswheresalarynotbetween8000and17000orderby工资select*fromemployeeswhereemaillike\u0026#39;%e%\u0026#39;orderbylength(email)desc,department_id;常见函数 功能:类似于java中的方法,将一组逻辑语句封装在方法体中,对外暴露方法名\n好处:1.隐藏了实现细节 2.提高代码的重用性\n调用: select 函数名(实参列表) [from 表] ;\n特点:\n 叫什么 函数名 干什么 函数功能  分类：\n 单行函数  字符函数 length concat substr substring replace lpad rpad upper lower instr trim 数学函数 mod floor round ceil truncate 日期函数 now curdate curtime year month monthname day hour minute second date_format str_to_date 其他函数 流程控制函数 concat / length / ifnull 等   分组函数  做统计使用 又称为统计函数、聚合函数、组函数    #查看字节长度mysql\u0026gt;selectlength(\u0026#39;lalala\u0026#39;);+------------------+ |length(\u0026#39;lalala\u0026#39;)|+------------------+ |6|+------------------+ 1rowinset(0.00sec)#查看字节长度mysql\u0026gt;selectlength(\u0026#39;林健树\u0026#39;);+-------------------+ |length(\u0026#39;林健树\u0026#39;)|+-------------------+ |6|+-------------------+ 1rowinset(0.00sec)#展示字符集mysql\u0026gt;showvariableslike\u0026#39;%char%\u0026#39;;+--------------------------+---------------------------------------------------------+ |Variable_name|Value|+--------------------------+---------------------------------------------------------+ |character_set_client|gbk||character_set_connection|gbk||character_set_database|utf8mb4||character_set_filesystem|binary||character_set_results|gbk||character_set_server|utf8mb4||character_set_system|utf8mb3||character_sets_dir|C:\\ProgramFiles\\MySQL\\MySQLServer8.0\\share\\charsets\\|+--------------------------+---------------------------------------------------------+ #拼接字符selectconcat(last_name,\u0026#39;_\u0026#39;,first_name)fromemployees;#upper/lowerselectupper(\u0026#39;aaabbbccc\u0026#39;);selectlower(\u0026#39;aBc\u0026#39;);#函数嵌套selectconcat(lower(last_name),\u0026#39;_\u0026#39;,upper(first_name))fromemployees;#substr/substring#sql中索引从1开始mysql\u0026gt;selectsubstring(\u0026#39;李莫愁爱上了陆展元\u0026#39;,7)out_put;+---------+ |out_put|+---------+ |陆展元|+---------+ 1rowinset(0.00sec)#函数的重载从指定索引出指定字符长度的字符mysql\u0026gt;selectSUBSTRING(\u0026#39;李莫愁爱上了陆展元\u0026#39;,1,3);+-------------------------------------+ |SUBSTRING(\u0026#39;李莫愁爱上了陆展元\u0026#39;,1,3)|+-------------------------------------+ |李莫愁|+-------------------------------------+ 1rowinset(0.00sec)selectconcat(concat(upper(substring(first_name,1,1)),substr(first_name,2)),\u0026#39;_\u0026#39;,last_name)fromemployees;#instr判断是否在字符串中#返回的是第一次出现的索引索引仍然从1开始,如果找不到返回0mysql\u0026gt;selectinstr(\u0026#39;杨不悔爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;);+--------------------------------------+ |instr(\u0026#39;杨不悔爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;)|+--------------------------------------+ |7|+--------------------------------------+ 1rowinset(0.00sec)mysql\u0026gt;selectinstr(\u0026#39;杨不悔尹柳霞爱上了尹柳霞\u0026#39;,\u0026#39;尹柳霞\u0026#39;)out_put;+---------+ |out_put|+---------+ |4|+---------+ 1rowinset(0.00sec)#trim去空格mysql\u0026gt;selectlength(\u0026#39; 张翠山 \u0026#39;),length(trim(\u0026#39; 张翠山 \u0026#39;));+------------------------+--------------------------------+ |length(\u0026#39; 张翠山 \u0026#39;)|length(trim(\u0026#39; 张翠山 \u0026#39;))|+------------------------+--------------------------------+ |12|6|+------------------------+--------------------------------+ 1rowinset(0.00sec)#trim可以去掉指定的字符或者字符串中间不会去掉的mysql\u0026gt;selecttrim(\u0026#39;a\u0026#39;from\u0026#39;aabbaaccaa\u0026#39;)asout_put;+---------+ |out_put|+---------+ |bbaacc|+---------+ 1rowinset(0.00sec)#trim只是按照单位去去的mysql\u0026gt;selecttrim(\u0026#39;aa\u0026#39;from\u0026#39;aaabbaaccaaa\u0026#39;)asout_put;+----------+ |out_put|+----------+ |abbaacca|+----------+ 1rowinset(0.00sec)#lpad用指定的字符来实现左填充指定长度mysql\u0026gt;selectlpad(\u0026#39;殷素素\u0026#39;,10,\u0026#39;*\u0026#39;);+-----------------------+ |lpad(\u0026#39;殷素素\u0026#39;,10,\u0026#39;*\u0026#39;)|+-----------------------+ |*******殷素素|+-----------------------+ 1rowinset(0.00sec)mysql\u0026gt;selectlpad(\u0026#39;97\u0026#39;,3,\u0026#39;0\u0026#39;);+------------------+ |lpad(\u0026#39;97\u0026#39;,3,\u0026#39;0\u0026#39;)|+------------------+ |097|+------------------+ 1rowinset(0.00sec)#lpad如果长度超过了反而会发生截断从左边开始向右边截断mysql\u0026gt;selectlpad(\u0026#39;101\u0026#39;,2,\u0026#39;0\u0026#39;);+-------------------+ |lpad(\u0026#39;101\u0026#39;,2,\u0026#39;0\u0026#39;)|+-------------------+ |10|+-------------------+ 1rowinset(0.00sec)#Rpad同理#replace替换mysql\u0026gt;selectreplace(\u0026#39;张无忌爱上了周芷若\u0026#39;,\u0026#39;周芷若\u0026#39;,\u0026#39;赵敏\u0026#39;)asout_put;+------------------+ |out_put|+------------------+ |张无忌爱上了赵敏|+------------------+ 1rowinset(0.00sec)#replace凡是有的全部替换喔mysql\u0026gt;selectreplace(\u0026#39;周芷若张无忌爱上了周芷若\u0026#39;,\u0026#39;周芷若\u0026#39;,\u0026#39;赵敏\u0026#39;)asout_put;+----------------------+ |out_put|+----------------------+ |赵敏张无忌爱上了赵敏|+----------------------+ 1rowinset(0.00sec)数学函数 round 四舍五入\n#round四舍五入mysql\u0026gt;selectround(4.65);+-------------+ |round(4.65)|+-------------+ |5|+-------------+ 1rowinset(0.00sec)#round两个参数时,后面的参数是值按小数点后几位来四舍五入mysql\u0026gt;selectround(4.65,1);+---------------+ |round(4.65,1)|+---------------+ |4.7|+---------------+ mysql\u0026gt;selectround(4.65,0);+---------------+ |round(4.65,0)|+---------------+ |5|+---------------+ 1rowinset(0.00sec)#ceil向上取整mysql\u0026gt;selectceil(1.001);+-------------+ |ceil(1.001)|+-------------+ |2|+-------------+ 1rowinset(0.00sec)#floor向下取整mysql\u0026gt;selectfloor(-1.01);+--------------+ |floor(-1.01)|+--------------+ |-2|+--------------+ 1rowinset(0.00sec)#truncate截断保留小数点后几位mysql\u0026gt;selecttruncate(1.6999,2);+--------------------+ |truncate(1.6999,2)|+--------------------+ |1.69|+--------------------+ 1rowinset(0.00sec)#mod取余运算a-a/b*ba/b会发生截断的可能所以这个等式没毛病#-10mod-3=-1-10mod3=-110mod-3=1只要被除数是-就是-mysql\u0026gt;selectmod(10,-3);+------------+ |mod(10,-3)|+------------+ |1|+------------+ 1rowinset(0.00sec)日期函数 #now返回当前系统日期包含时间mysql\u0026gt;selectnow();+---------------------+ |now()|+---------------------+ |2021-09-2016:00:28|+---------------------+ 1rowinset(0.00sec)#curdate返回当前日期不包含时间mysql\u0026gt;selectcurdate();+------------+ |curdate()|+------------+ |2021-09-20|+------------+ 1rowinset(0.00sec)#curtime返回当前时间不包含日期mysql\u0026gt;selectcurtime();+-----------+ |curtime()|+-----------+ |16:01:21|+-----------+ 1rowinset(0.00sec)#获取指定的部分,年月日时分秒mysql\u0026gt;selectyear(now())年,month(\u0026#39;1998-1-1\u0026#39;)月,day(curdate())日;+------+------+------+ |年|月|日|+------+------+------+ |2021|1|20|+------+------+------+ 1rowinset(0.00sec)#获取月份的英文mysql\u0026gt;selectmonthname(hiredate)月份英文,year(hiredate)fromemployees;+-----------+----------------+ |月份英文|year(hiredate)|+-----------+----------------+ |April|1992||April|1992|#日期转换函数str_to_date()date_format()mysql\u0026gt;selectstr_to_date(\u0026#39;9--10--2021\u0026#39;,\u0026#39;%m--%d--%Y\u0026#39;)asout_put;+------------+ |out_put|+------------+ |2021-09-10|+------------+ 1rowinset(0.00sec)mysql\u0026gt;selectdate_format(\u0026#39;2021-09-20\u0026#39;,\u0026#39;%y年%m月%d日\u0026#39;)asout_put;+--------------+ |out_put|+--------------+ |21年09月20日|+--------------+ 1rowinset(0.00sec)#前端传进来的是字符串而且格式不一我们要使用函数来将字符串做处理解析成想要的格式然后再到数据库中查找mysql\u0026gt;selecthiredatefromemployeeswherehiredate=str_to_date(\u0026#39;4-3 1992\u0026#39;,\u0026#39;%c-%d %Y\u0026#39;);+---------------------+ |hiredate|+---------------------+ |1992-04-0300:00:00||1992-04-0300:00:00||1992-04-0300:00:00||1992-04-0300:00:00||1992-04-0300:00:00|+---------------------+ 5rowsinset(0.00sec)#数据库这边也需要做好相应的处理将日期处理成对应格式字符串然后返回回去mysql\u0026gt;selectlast_name,date_format(hiredate,\u0026#39;%m月/%d日 %y年\u0026#39;)as入职日期fromemployeeswherecommission_pct\u0026lt;=\u0026gt;null;+-------------+----------------+ |last_name|入职日期|+-------------+----------------+ |K_ing|04月/03日92年||Kochhar|04月/03日92年|\rimage-20210920161042293\r\n\rimage-20210920161613677\r\n其他函数 mysql\u0026gt;selectversion();+-----------+ |version()|+-----------+ |8.0.24|+-----------+ 1rowinset(0.00sec)mysql\u0026gt;selectdatabase();+-------------+ |database()|+-------------+ |myemployees|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;selectuser();+----------------+ |user()|+----------------+ |root@localhost|+----------------+ 1rowinset(0.00sec)流程控制函数 #IF函数true就是第二个参数false就是第三个参数mysql\u0026gt;selectcommission_pct,if(isnull(commission_pct)=0,\u0026#39;没奖金 呵呵\u0026#39;,\u0026#39;有奖金 嘻嘻\u0026#39;)备注fromemployees;+----------------+-------------+ |commission_pct|备注|+----------------+-------------+ |NULL|有奖金嘻嘻||NULL|有奖金嘻嘻|#mysql中默认0就是第三个参数1就是第二个参数mysql\u0026gt;selectcommission_pct,if(isnull(commission_pct),\u0026#39;没奖金 呵呵\u0026#39;,\u0026#39;有奖金 嘻嘻\u0026#39;)备注fromemployees;+----------------+-------------+ |commission_pct|备注|+----------------+-------------+ |NULL|没奖金呵呵||NULL|没奖金呵呵|mysql\u0026gt;selectcommission_pct,if(isnull(commission_pct),concat(\u0026#39;没奖金 呵呵 \u0026#39;,0),concat(\u0026#39;有奖金 嘻嘻 \u0026#39;,commission_pct))备注fromemployees;+----------------+------------------+ |commission_pct|备注|+----------------+------------------+ |NULL|没奖金呵呵0||NULL|没奖金呵呵0|#case函数相当于switchcase的效果/* case 要判断的字段或者表达式 when 常量1 then 要显示的值1或语句1 when 常量2 then 要显示的值2或语句2 ... else 要显示的值n或语句n end */mysql\u0026gt;selectsalary原始工资,department_id部门,casedepartment_idwhen30thensalary*1.1when40thensalary*1.2when50thensalary*1.3elsesalaryendas新工资fromemployees;+----------+------+----------+ |原始工资|部门|新工资|+----------+------+----------+ |24000.00|90|24000.00||17000.00|90|17000.00|#case多重if类似于/* case when 条件1 then 要显示的值1或语句1 when 条件2 then 要显示的值2或语句2 ... else 要显示的值n或语句n end */mysql\u0026gt;selectsalary,casewhensalary\u0026gt;20000then\u0026#39;A\u0026#39;whensalary\u0026gt;15000then\u0026#39;B\u0026#39;whensalary\u0026gt;10000then\u0026#39;C\u0026#39;else\u0026#39;D\u0026#39;endas工资级别fromemployees;+----------+----------+ |salary|工资级别|+----------+----------+ |24000.00|A||17000.00|B||17000.00|B|练习\nselectemployee_id,last_name,salary,salary*1.2as`newsalary`fromemployees;mysql\u0026gt;selectlast_name,substr(last_name,1,1)asszm,length(last_name)`length`fromemployeesorderbyszm;+-------------+------+--------+ |last_name|szm|length|+-------------+------+--------+ |Austin|A|6||Atkinson|A|8|mysql\u0026gt;selectconcat(last_name,\u0026#39; earns \u0026#39;,salary,\u0026#39; monthly but wants \u0026#39;,salary*3)`DreamSalary`fromemployees;+-----------------------------------------------------+ |DreamSalary|+-----------------------------------------------------+ |K_ingearns24000.00monthlybutwants72000.00||Kochharearns17000.00monthlybutwants51000.00|mysql\u0026gt;selectjob_idasjob,casejob_idwhen\u0026#39;AD_PRES\u0026#39;then\u0026#39;A\u0026#39;when\u0026#39;ST_MAN\u0026#39;then\u0026#39;B\u0026#39;when\u0026#39;IT_PROG\u0026#39;then\u0026#39;C\u0026#39;endgradefromemployees;+------------+-------+ |job|grade|+------------+-------+ |AC_ACCOUNT|NULL||AC_MGR|NULL|分组函数 功能:用作统计使用,又称为聚合函数或统计函数或组函数\n分类:\nsum 求和 avg平均值 max最大值 min最小值 count计算个数\nmysql\u0026gt;selectsum(salary)fromemployees;+-------------+ |sum(salary)|+-------------+ |691400.00|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;selectavg(salary)fromemployees;+-------------+ |avg(salary)|+-------------+ |6461.682243|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;selectmin(salary)fromemployees;+-------------+ |min(salary)|+-------------+ |2100.00|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;selectmax(salary)fromemployees;+-------------+ |max(salary)|+-------------+ |24000.00|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(salary)fromemployees;+---------------+ |count(salary)|+---------------+ |107|+---------------+ 1rowinset(0.00sec)mysql\u0026gt;selectsum(salary)和,round(avg(salary),2)平均,min(salary)最低,max(salary)最高,count(salary)个数fromemployees;+-----------+---------+---------+----------+------+ |和|平均|最低|最高|个数|+-----------+---------+---------+----------+------+ |691400.00|6461.68|2100.00|24000.00|107|+-----------+---------+---------+----------+------+ #参数支持哪些类型#sumavg不支持字符型mysql\u0026gt;selectsum(last_name),avg(last_name)fromemployees;+----------------+----------------+ |sum(last_name)|avg(last_name)|+----------------+----------------+ |0|0|+----------------+----------------+ #maxmin支持字符型/日期型只要能够排序max和min就能支持mysql\u0026gt;selectmax(last_name),min(last_name)fromemployees;+----------------+----------------+ |max(last_name)|min(last_name)|+----------------+----------------+ |Zlotkey|Abel|+----------------+----------------+ mysql\u0026gt;selectmax(hiredate),min(hiredate)fromemployees;+---------------------+---------------------+ |max(hiredate)|min(hiredate)|+---------------------+---------------------+ |2016-03-0300:00:00|1992-04-0300:00:00|+---------------------+---------------------+ 1rowinset(0.00sec)#count支持计数计的是非null的数mysql\u0026gt;selectcount(last_name)fromemployees;+------------------+ |count(last_name)|+------------------+ |107|+------------------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(commission_pct)fromemployees;+-----------------------+ |count(commission_pct)|+-----------------------+ |35|+-----------------------+ #判断是否忽略null来计算这里说明sum肯定是没参与因为如果有nullnull+任何都是null不可能有值#avg也没有参与所以avg不将null的项加入运算mysql\u0026gt;selectsum(commission_pct)总计,avg(commission_pct)平均值,sum(commission_pct)/35没参与,sum(commission_pct)/107参与了fromemployees;+------+----------+----------+----------+ |总计|平均值|没参与|参与了|+------+----------+----------+----------+ |7.80|0.222857|0.222857|0.072897|+------+----------+----------+----------+ 1rowinset(0.00sec)#min和max也忽略了null否则肯定会在一头出现的mysql\u0026gt;selectmax(commission_pct)max,min(commission_pct)minfromemployees;+------+------+ |max|min|+------+------+ |0.40|0.10|+------+------+ 1rowinset(0.00sec)#可以和distinct匹配使用mysql\u0026gt;selectsum(distinctsalary)去重,sum(salary)不去重fromemployees;+-----------+-----------+ |去重|不去重|+-----------+-----------+ |397900.00|691400.00|+-----------+-----------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(distinct(salary))几种工资fromemployees;+----------+ |几种工资|+----------+ |57|+----------+ 1rowinset(0.00sec)#count1和2意思是加了一列那么当然就等同于统计行数辣mysql\u0026gt;selectcount(*)fromemployees;+----------+ |count(*)|+----------+ |107|+----------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(1)fromemployees;+----------+ |count(1)|+----------+ |107|+----------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(2)fromemployees;+----------+ |count(2)|+----------+ |107|+----------+ 1rowinset(0.00sec)所有的分组函数 都忽略null值\n可以和distinct搭配\ncount函数的详细介绍\n效率:\nMYISAM 存储引擎下, count(*) 的效率高\nINNODB存储引擎下, count(*) 和 count(1) 的效率差不多,比count(字段) 要高一点儿\n和分组函数一同查询的字段有限制\n#已经不存在逻辑意义了mysql\u0026gt;selectavg(salary),employee_idfromemployees;+-------------+-------------+ |avg(salary)|employee_id|+-------------+-------------+ |6461.682243|100|+-------------+-------------+ 1rowinset(0.00sec)和分组函数一同查询的字段要求是group by 后的字段\n练习一下\nmysql\u0026gt;selectdatediff(max(hiredate),min(hiredate))fromemployees;+---------------------------------------+ |datediff(max(hiredate),min(hiredate))|+---------------------------------------+ |8735|+---------------------------------------+ 1rowinset(0.00sec)mysql\u0026gt;selectdatediff(now(),\u0026#39;1997-11-21\u0026#39;)活了多久了;+------------+ |活了多久了|+------------+ |8705|+------------+ 1rowinset(0.00sec)mysql\u0026gt;selectcount(*)fromemployeeswheredepartment_id=90;+----------+ |count(*)|+----------+ |3|+----------+ 1rowinset(0.00sec)分组查询 select 分组函数, 列(要求出现在group by的后面) from 表 where 筛选条件 group by 分组的列表 order by 子句\n**注意:\t**查询列表必须特殊,要求是分组函数和group by 后出现的字段\ngroup by可以使用别名 oracle是不支持的 mysql支持\nhaving 可以使用别名 oracle是不支持的 mysql支持\norder by 可以使用别名 oracle是不支持的 mysql支持\nwhere 不可以使用别名\nmysql\u0026gt;selectmax(salary)最高工资,job_id工种fromemployeesgroupby工种;+----------+------------+ |最高工资|工种|+----------+------------+ |8300.00|AC_ACCOUNT||12000.00|AC_MGR||4400.00|AD_ASST|mysql\u0026gt;selectcount(*)部门个数,location_id位置fromdepartmentsgroupby位置;+----------+------+ |部门个数|位置|+----------+------+ |1|1400||1|1500|mysql\u0026gt;selectavg(salary)平均工资,department_id部门编号fromemployeeswhereemaillike\u0026#39;%a%\u0026#39;groupby部门编号;+--------------+----------+ |平均工资|部门编号|+--------------+----------+ |7000.000000|NULL||4400.000000|10|+--------------+----------+ 11rowsinset(0.00sec)#查询有奖金的每个领导手下员工的最高工资很奇怪mysql\u0026gt;selectmax(salary)最高工资,manager_id领导fromemployeeswherecommission_pct\u0026lt;=\u0026gt;nullgroupbymanager_id;+----------+------+ |最高工资|领导|+----------+------+ |24000.00|NULL||17000.00|100||9000.00|102||6000.00|103||12000.00|101||9000.00|108||3100.00|114||3200.00|120||4200.00|121||3800.00|122||4000.00|123||3500.00|124||6000.00|201||8300.00|205|+----------+------+ 14rowsinset(0.00sec)mysql\u0026gt;selectmax(salary)最高工资,manager_id领导fromemployeeswherecommission_pctisnotnullgroupbymanager_id;+----------+------+ |最高工资|领导|+----------+------+ |14000.00|100||10000.00|145||10000.00|146||10500.00|147||11500.00|148||11000.00|149|+----------+------+ 6rowsinset(0.00sec)#查询每个部门的员工个数其实就是having在每个group之下的筛选mysql\u0026gt;selectdepartment_id部门,count(*)员工个数fromemployeesgroupby部门having员工个数\u0026gt;2;+------+----------+ |部门|员工个数|+------+----------+ |30|6||50|45||60|5||80|34||90|3||100|6|+------+----------+ 6rowsinset(0.00sec)#查询每个工种有奖金的员工的最高工资\u0026gt;12000的工种编号和最高工资mysql\u0026gt;selectmax(salary)最高工资,job_id工种编号fromemployeeswherecommission_pctisnotnullgroupby工种编号having最高工资\u0026gt;12000;+----------+----------+ |最高工资|工种编号|+----------+----------+ |14000.00|SA_MAN|+----------+----------+ 1rowinset(0.00sec)#查询领导编号\u0026gt;102的每个领导手下的最低工资\u0026gt;5000的领导编号是那个,以及其最低工资mysql\u0026gt;selectmin(salary)最低工资,manager_id领导编号fromemployeeswheremanager_id\u0026gt;102groupby领导编号having最低工资\u0026gt;5000;+----------+----------+ |最低工资|领导编号|+----------+----------+ |6900.00|108||7000.00|145|特点  分组查询中的筛选条件分为两类  分组前筛选 来源于原始表 放在group by 子句的前面 使用where关键字 分组后筛选 来源于分组后的结果集 放在group by子句的后面 使用having关键字 分组函数 min max count avg 作为条件肯定是放在having子句中 能用分组前筛选的,就优先考虑放在分组前面,考虑到性能   group by 子句支持单个字段分组,多个字段分组(多个字段之间用逗号隔开,没有顺序之分),也支持表达式或函数(较少) 也可以添加排序(排序放在整个分组查询的最后)  按表达式或函数分组 #按员工姓名的长度分组,查询每一组的员工个数,筛选同学个数\u0026gt;5的有哪些mysql\u0026gt;selectlength(last_name)姓名长度,count(*)员工个数fromemployeesgroupbylength(last_name)having员工个数\u0026gt;5;+----------+----------+ |姓名长度|员工个数|+----------+----------+ |5|29||7|15|按多个字段分组 #查询每个部门每个工种的员工的平均工资交换groupby的顺序不影响mysql\u0026gt;selectavg(salary)平均工资,department_id部门编号,job_id工种编号fromemployeesgroupby部门编号,工种编号;+--------------+----------+------------+ |平均工资|部门编号|工种编号|+--------------+----------+------------+ |24000.000000|90|AD_PRES||17000.000000|90|AD_VP||5760.000000|60|IT_PROG|分组后添加排序 mysql\u0026gt;selectavg(salary)平均工资,department_id部门编号,job_id工种编号fromemployeesgroupby部门编号,工种编号orderby平均工资asc;+--------------+----------+------------+ |平均工资|部门编号|工种编号|+--------------+----------+------------+ |2780.000000|30|PU_CLERK||2785.000000|50|ST_CLERK|练习一下\nmysql\u0026gt;selectjob_id工种,max(salary)最大,min(salary)最小,avg(salary)平均,sum(salary)总和fromemployeesgroupby工种orderby工种asc;+------------+----------+----------+--------------+-----------+ |工种|最大|最小|平均|总和|+------------+----------+----------+--------------+-----------+ |AC_ACCOUNT|8300.00|8300.00|8300.000000|8300.00||AC_MGR|12000.00|12000.00|12000.000000|12000.00|mysql\u0026gt;selectmax(salary)-min(salary)DIFFERENCEfromemployees;+------------+ |DIFFERENCE|+------------+ |21900.00|+------------+ mysql\u0026gt;selectmanager_id领导编号,employee_id员工编号,min(salary)最低工资fromemployeeswheresalary\u0026gt;=6000andmanager_idisnotnullgroupby领导编号;+----------+----------+----------+ |领导编号|员工编号|最低工资|+----------+----------+----------+ |100|101|6500.00||102|103|9000.00|mysql\u0026gt;selectdepartment_id部门编号,count(*)员工数量,avg(salary)平均工资fromemployeesgroupby部门编号orderby平均工资desc;+----------+----------+--------------+ |部门编号|员工数量|平均工资|+----------+----------+--------------+ |90|3|19333.333333||110|2|10150.000000|mysql\u0026gt;selectjob_id工种,count(*)人数fromemployeesgroupby工种;+------------+------+ |工种|人数|+------------+------+ |AC_ACCOUNT|1||AC_MGR|1|连接查询 含义:又称为多表查询,当查询的字段来自于多个表时,就会用到连接查询\n笛卡尔积现象: 表1 有m行 表2 有n行 结果有m*n行\n发生原因:没有有效的连接条件\n如何避免:添加有效的连接条件\n\rimage-20210921141653473\r\n每个都匹配了一遍 , 这不好 ,都是我的\nmysql\u0026gt;selectname,boyNamefrombeauty,boyswherebeauty.boyfriend_id=boys.id;+------------+---------+ |name|boyName|+------------+---------+ |Angelababy|黄晓明||热巴|鹿晗||周芷若|张无忌||小昭|张无忌||王语嫣|段誉||赵敏|张无忌|+------------+---------+ 分类:\n 按照年代分类  sql92标准 仅仅支持内连接 sql99标准 [推荐] 支持内连接+外连接(左外+右外)+交叉连接   按功能分类  内连接  等值连接 非等值连接 自连接   外连接  左外连接 右外连接 全外连接   交叉连接    #以下是sql92标准的等值连接用法mysql\u0026gt;selectlast_name,department_namefromemployees,departmentswhereemployees.department_id=departments.department_id;+-------------+-----------------+ |last_name|department_name|+-------------+-----------------+ |K_ing|Exe||Kochhar|Exe|#为表起别名提高语句的简洁度区分多个重名的字段mysql\u0026gt;selectlast_name,e.job_id,job_titlefromemployeese,jobswheree.job_id=jobs.job_id;+-------------+------------+---------------------------------+ |last_name|job_id|job_title|+-------------+------------+---------------------------------+ |Gietz|AC_ACCOUNT|PublicAccountant||Higgins|AC_MGR|AccountingManager|#交换表的出现顺序是可以的#加上筛选条件mysql\u0026gt;selectlast_name,commission_pct,department_namefromemployeese,departmentsdwherecommission_pctisnotnullande.department_id=d.department_id;+------------+----------------+-----------------+ |last_name|commission_pct|department_name|+------------+----------------+-----------------+ |Russell|0.40|Sal||Partners|0.30|Sal|mysql\u0026gt;selectdepartment_name,cityfromdepartmentsd,locationslwhered.location_id=l.location_idandcitylike\u0026#39;_o%\u0026#39;;+-----------------+---------------------+ |department_name|city|+-----------------+---------------------+ |IT|Southlake||Shi|SouthSanFrancisco|#查询每个城市的部门个数mysql\u0026gt;selectcity,count(*)部门个数fromdepartmentsd,locationslwhered.location_id=l.location_idgroupbycity;+---------------------+----------+ |city|部门个数|+---------------------+----------+ |Southlake|1||SouthSanFrancisco|1||Seattle|21|mysql\u0026gt;selectd.department_id,department_name,d.manager_id,min(salary)最低工资fromemployeese,departmentsdwheree.department_id=d.department_idandcommission_pctisnotnullgroupbydepartment_id;+---------------+-----------------+------------+----------+ |department_id|department_name|manager_id|最低工资|+---------------+-----------------+------------+----------+ |80|Sal|145|6100.00|+---------------+-----------------+------------+----------+ mysql\u0026gt;selectjob_title,count(*)员工个数fromemployeese,jobsjwheree.job_id=j.job_idgroupbyj.job_idorderby员工个数desc;+---------------------------------+----------+ |job_title|员工个数|+---------------------------------+----------+ |SalesRepresentative|30||ShippingClerk|20|#三表连接mysql\u0026gt;selectlast_name,department_name,cityfromemployeese,departmentsd,locationslwheree.department_id=d.department_idandd.location_id=l.location_id;+-------------+-----------------+---------------------+ |last_name|department_name|city|+-------------+-----------------+---------------------+ |Whalen|Adm|Seattle||Hartstein|Mar|Toronto|注意:如果为表起了别名,则查询的字段就不能使用原来的表名去限定了\nsql92标准  等值连接  多表等值连接的结果为多表的交集部分 n表连接,至少需要n-1个连接条件 多表的顺序没有要求 一般需要为表其别名 可以搭配前面介绍的所有子句使用,比如排序/筛选/分组   非等值连接  #非等值连接也可以加上排序/筛选/分组mysql\u0026gt;selectsalary,grade_levelfromemployeese,job_gradesgwheresalarybetweenlower_salandhighest_sal;+----------+-------------+ |salary|grade_level|+----------+-------------+ |24000.00|E||17000.00|E|​\t3.自连接\n#mysql\u0026gt;selecta.last_name员工名,b.last_name领导名称fromemployeesa,employeesbwherea.manager_id=b.employee_id;+-------------+-----------+ |员工名|领导名称|+-------------+-----------+ |Kochhar|K_ing||DeHaan|K_ing|练习一下 mysql\u0026gt;selectmax(salary),min(salary)fromemployees;+-------------+-------------+ |max(salary)|min(salary)|+-------------+-------------+ |24000.00|2100.00|+-------------+-------------+ mysql\u0026gt;selectemployee_id,job_id,last_namefromemployeesorderbydepartment_iddesc,salaryasc;+-------------+------------+-------------+ |employee_id|job_id|last_name|+-------------+------------+-------------+ |206|AC_ACCOUNT|Gietz||205|AC_MGR|Higgins|mysql\u0026gt;selectjob_idfromemployeeswherejob_idlike\u0026#39;%a%e%\u0026#39;orderbyjob_id;+---------+ |job_id|+---------+ |AD_PRES||SA_REP|mysql\u0026gt;selectsubstr(\u0026#39;aabbcc\u0026#39;,3);+--------------------+ |substr(\u0026#39;aabbcc\u0026#39;,3)|+--------------------+ |bbcc|+--------------------+ 1rowinset(0.00sec)mysql\u0026gt;selecttrim(\u0026#39;aa\u0026#39;from\u0026#39;aaabbbcccaaa\u0026#39;);+---------------------------------+ |trim(\u0026#39;aa\u0026#39;from\u0026#39;aaabbbcccaaa\u0026#39;)|+---------------------------------+ |abbbccca|+---------------------------------+ 1rowinset(0.00sec)复习一下 语法\nselect 查询列表 from 表 where 筛选条件 order by 排序列表 asc|desc\n特点\nasc 升序 默认 desc 降序\n排序列表 支持 单个字段 多个字段 函数 表达式 别名\norder by 位置一般放在查询语句的最后(除了limit语句之外)\n常见函数\n功能:类似于java中的方法\n好处:提高重用性和隐藏实现细节\n调用:select 函数名(实参列表) ;\n单行函数\n 字符函数 length concat substr substring upper lower instr replace trim lpad rpad 数学函数 truncate round ceil mod floor rand(获取随机数 0-1) 日期函数 curdate curtime now year month monthname day hour minute second date_format str_to_date timediff datediff 其他函数 version user database ifnull isnull md5(自动将字符加密成md格式密文) 流程控制函数 if case when then else end  mysql\u0026gt;selectMD5(\u0026#39;lalala123\u0026#39;);+----------------------------------+ |MD5(\u0026#39;lalala123\u0026#39;)|+----------------------------------+ |24500fa6ecaeb8300905727802af3081|+----------------------------------+ 1rowinset(0.00sec)流程控制函数\nif(条件表达式,表达式1,表达式2)如果条件表达式成立,返回表达式1,否则返回表达式2#case情况1case变量或表达式或字段when常量1then值1when常量2then值2else值nend#case情况2casewhen条件1then值1when条件2then值2else值nend分组函数 分类\nmax min avg sum count\n特点\nselect max(字段) from 表名\n支持的类型\nsum 和 avg 一般用于处理数值型\nmax min count 可以处理任何数据类型\n以上分组函数都忽略null\n都可以搭配distinct使用,实现去重的统计\nselect sum(distinct 字段) from 表 ;\ncount函数\ncount(字段) 统计该字段非空值的个数\ncount(*) 统计结果集的行数\ncount(1) 统计结果集的行数\n效率上:\nmyisam 存储引擎 count(*) 最高\ninnodb 存储引擎 count(*)和count(1) 效率\u0026gt;count(字段)\n和分组函数一同查询的字段,要求是group by后面出现的字段\n分组查询 select 分组函数, 分组后的字段 from 表 where 筛选条件 group by 分组的字段 having 分组后的筛选 order by 排序列表\n分组前筛选 where 原始表 group by的前面\n分组后筛选 having 分组后的结果 group by的后面\n连接查询 含义 当查询中涉及到了多个表的字段,需要使用多表连接\nselect 字段1 , 字段2 from 表1 , 表2\n笛卡儿乘积:当查询多个表时,没有添加有效的连接条件,导致多个表所有行实现完全连接\n如何解决:添加有效的连接条件\n分类  按年代分类  sql92  等值 非等值 自连接 也支持一部分外连接 用于oracle sqlserver , mysql不支持   sql99 [推荐使用]  内连接  等值 非等值 自连接   外连接  左外 右外 全外(mysql 不支持)   交叉连接      等值连接: select 查询列表 from 表1 别名, 表2 别名 where 表1.key = 表2.key and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n特点:\n 一般为表起别名 多表顺序可以调换 n表连接至少需要n-1个连接条件 等值连接的结果是多表的交集部分  非等值连接 select 查询列表 from 表1 别名, 表2 别名 where 非等值连接条件 and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n自连接 select 查询列表 from 表 别名1, 表 别名2 where 等值连接条件 and 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序字段\n练习一下\nmysql\u0026gt;selectlast_name,e.department_id,department_namefromemployeese,departmentsdwheree.department_id=d.department_id;+-------------+---------------+-----------------+ |last_name|department_id|department_name|+-------------+---------------+-----------------+ |Whalen|10|Adm||Hartstein|20|Mar|mysql\u0026gt;selectjob_id,d.location_idfromemployeese,departmentsdwhered.department_id=90ande.department_id=d.department_id;+---------+-------------+ |job_id|location_id|+---------+-------------+ |AD_PRES|1700||AD_VP|1700|mysql\u0026gt;selectlast_name,department_name,d.location_id,cityfromemployeese,departmentsd,locationslwheree.department_id=d.department_idandd.location_id=l.location_idandcommission_pctisnotnull;+------------+-----------------+-------------+--------+ |last_name|department_name|location_id|city|+------------+-----------------+-------------+--------+ |Russell|Sal|2500|Oxford||Partners|Sal|2500|Oxford|mysql\u0026gt;selectlast_name,job_id,d.department_id,department_namefromemployeese,departmentsd,locationslwheree.department_id=d.department_idandd.location_id=l.location_idandcity=\u0026#39;Toronto\u0026#39;;+-----------+--------+---------------+-----------------+ |last_name|job_id|department_id|department_name|+-----------+--------+---------------+-----------------+ |Hartstein|MK_MAN|20|Mar||Fay|MK_REP|20|Mar|+-----------+--------+---------------+-----------------+\\ #查询每个工种每个部门的部门名工种名和最低工资mysql\u0026gt;selectdepartment_name,job_title,min(salary)fromemployeese,departmentsd,jobsjwheree.department_id=d.department_idandj.job_id=e.job_idgroupbyj.job_title,d.department_name;+-----------------+---------------------------------+-------------+ |department_name|job_title|min(salary)|+-----------------+---------------------------------+-------------+ |Acc|PublicAccountant|8300.00||Acc|AccountingManager|12000.00|#查询每个国家下的部门个数大于2的国家编号mysql\u0026gt;selectcountry_id,count(*)部门个数fromlocationsl,departmentsdwherel.location_id=d.location_idgroupbycountry_idhaving部门个数\u0026gt;2;+------------+----------+ |country_id|部门个数|+------------+----------+ |US|23|+------------+----------+ #选择指定员工的姓名员工号以及他的管理者的姓名和员工号结果类似于下面的格式mysql\u0026gt;selecta.last_nameemployees,a.employee_idEmp,b.last_namemanager,b.employee_idMgrfromemployeesa,employeesbwherea.manager_id=b.employee_id;+-------------+-----+-----------+-----+ |employees|Emp|manager|Mgr|+-------------+-----+-----------+-----+ |Kochhar|101|K_ing|100||DeHaan|102|K_ing|100|sql99语法 语法:\nselect 查询列表 from 表1 别名 连接类型 join 表2 别名 on 连接条件 where 筛选条件 group by 分组条件 having 筛选条件 order by 排序列表\n分类:\n内连接: inner\n外连接:\n​\t左外:left outer\n​\t右外:right outer\n​\t全外:full outer\n交叉连接 :cross\n内连接 select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件 where 筛选条件 \u0026hellip;\n分类:\n 等值连接 非等值连接 自连接  #调换顺序是可以的mysql\u0026gt;selectlast_name,department_namefromemployeeseinnerjoindepartmentsdone.department_id=d.department_id;+-------------+-----------------+ |last_name|department_name|+-------------+-----------------+ |Whalen|Adm|mysql\u0026gt;selectlast_name,job_titlefromemployeeseinnerjoinjobsjone.job_id=j.job_idwherelast_namelike\u0026#39;%e%\u0026#39;;+-------------+---------------------------------+ |last_name|job_title|+-------------+---------------------------------+ |DeHaan|AdministrationVicePresident||Ernst|Programmer|mysql\u0026gt;selectlast_name,job_titlefromemployeeseinnerjoinjobsjone.job_id=j.job_idwheree.last_namelike\u0026#39;%e%\u0026#39;;+-------------+---------------------------------+ |last_name|job_title|+-------------+---------------------------------+ |DeHaan|AdministrationVicePresident||Ernst|Programmer|#查询部门个数\u0026gt;3的城市名和部门个数mysql\u0026gt;selectcity,count(*)部门个数fromdepartmentsdjoinlocationslond.location_id=l.location_idgroupbyl.location_idhaving部门个数\u0026gt;3;+---------+----------+ |city|部门个数|+---------+----------+ |Seattle|21|+---------+----------+ #查询哪个部门的员工个数\u0026gt;3的部门名和员工个数,并按个数降序mysql\u0026gt;selectdepartment_name,count(*)员工个数fromdepartmentsdinnerjoinemployeeseone.department_id=d.department_idgroupbye.department_idhavingcount(*)\u0026gt;3orderbycount(*)desc;+-----------------+----------+ |department_name|员工个数|+-----------------+----------+ |Shi|45||Sal|34||Pur|6|#多表连接是有顺序的第一个表和第二个表在连接的时候形成了新的表然后新的表里的字段和第三个表里的字段再连接所以是有顺序之分的这个和两表连接有差别mysql\u0026gt;selectlast_name,department_name,job_titlefromemployeesejoindepartmentsdone.department_id=d.department_idjoinjobsjonj.job_id=e.job_idorderbydepartment_namedesc;+-------------+-----------------+---------------------------------+ |last_name|department_name|job_title|+-------------+-----------------+---------------------------------+ |Taylor|Shi|ShippingClerk||Fleaur|Shi|ShippingClerk|特点:\n 添加排序/分组/筛选 inner可以省略 筛选条件放在where后面 , 连接条件放在on后面, 提高分离性, 便于阅读 inner join等值连接和sql92中的等值连接效果是一样的,都是查询多表的交集  非等值连接 #非等值连接mysql\u0026gt;selectsalary,grade_levelfromemployeesejoinjob_gradesgone.salarybetweeng.lower_salandg.highest_sal;+----------+-------------+ |salary|grade_level|+----------+-------------+ |24000.00|E||17000.00|E|#查询工资级别的个数\u0026gt;2并且按工资级别降序mysql\u0026gt;selectcount(*)级别个数,grade_levelfromemployeesejoinjob_gradesgone.salarybetweeng.lower_salandg.highest_salgroupbyg.grade_levelhaving级别个数\u0026gt;2orderbyg.grade_level;+----------+-------------+ |级别个数|grade_level|+----------+-------------+ |24|A||26|B||38|C|自连接 #自连接#查询员工姓名和他的领导的姓名mysql\u0026gt;selecta.last_name,b.last_namefromemployeesajoinemployeesbona.manager_id=b.employee_id;+-------------+-----------+ |last_name|last_name|+-------------+-----------+ |Kochhar|K_ing||DeHaan|K_ing|外连接 应用场景 用于查询一个表中有,另一个表中没有的记录\n特点\n 外连接的查询结果为主表中的所有记录  如果从表中有和他匹配的,则显示匹配的值 如果从表中没有和他匹配的,则显示null 外连接查询结果=内连接结果+主表中有而从表中没有的记录   左外连接,left join左边的是主表 右外连接,right join右边的是主表 交换两表的顺序和关键字,可以实现同样的结果  #查询没有男朋友的女神名#这样的话就是内连接内连接是取的交集没有用查不到mysql\u0026gt;selectname,b.idfrombeautygjoinboysbong.boyfriend_id=b.id;+------------+----+ |name|id|+------------+----+ |Angelababy|3||热巴|2|#这样的话就是外连接外连接全取了要加筛选条件mysql\u0026gt;selectname,b.idfrombeautygleftjoinboysbong.boyfriend_id=b.id;+------------+------+ |name|id|+------------+------+ |柳岩|NULL||苍老师|NULL||Angelababy|3|#这样没错mysql\u0026gt;selectname,b.idfrombeautygleftjoinboysbong.boyfriend_id=b.idwhereb.idisnull;+--------+------+ |name|id|+--------+------+ |柳岩|NULL||苍老师|NULL|#查询那个部门没有员工mysql\u0026gt;selectd.department_id,department_namefromdepartmentsdleftjoinemployeeseond.department_id=e.department_idwheree.department_idisnull;+---------------+-----------------+ |department_id|department_name|+---------------+-----------------+ |120|Tre||130|Cor|全外连接 好像不支持 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 交叉连接 #交叉做笛卡尔乘积mysql\u0026gt;selectbeauty.*,boys.*frombeautycrossjoinboys;+----+------------+------+---------------------+-------------+--------------+--------------+----+---------+--------+ |id|name|sex|borndate|phone|photo|boyfriend_id|id|boyName|userCP|+----+------------+------+---------------------+-------------+--------------+--------------+----+---------+--------+ |1|柳岩|女|1988-02-0300:00:00|18209876577|NULL|8|4|段誉|300||1|柳岩|女|1988-02-0300:00:00|sql92和sql99的区别 功能:sql99 支持的较多\n可读性:sql99实现连接条件和筛选条件的分离,可读性较高\n\rimage-20210923202009215\r\n\rimage-20210923202111351\r\n#查询编号\u0026gt;3的女生的男朋友信息,如果有则列出,如果没有就null填充mysql\u0026gt;selectg.id女生id,g.name,b.*frombeautygleftjoinboysbong.boyfriend_id=b.idwhereg.id\u0026gt;3;+--------+--------+------+---------+--------+ |女生id|name|id|boyName|userCP|+--------+--------+------+---------+--------+ |4|热巴|2|鹿晗|800||5|周冬雨|NULL|NULL|NULL||6|周芷若|1|张无忌|100|#查询哪个城市没有部门mysql\u0026gt;selectcity这个城市没有部门fromlocationslleftjoindepartmentsdonl.location_id=d.location_idwheredepartment_idisnull;+------------------+ |这个城市没有部门|+------------------+ |Roma||Venice|子查询 含义:出现在其他语句中的eslect语句,称为子查询或内查询\n外部的查询语句,称为主查询或外查询\n分类:\n 按子查询出现的位置  select后面  一般只支持标量子查询   from后面  支持表子查询   where 或者 having 后面**(重要)**  支持标量子查询/列子查询/行子查询   exists 后面 (相关子查询)  表子查询     按功能(结果集的行列书不同)  标量子查询(结果集只有一行一列) 列子查询(结果集中只有一列多行) 行子查询(结果集有一行多列) 表子查询(结果结一般为多行多列)    where或having后面的子查询 支持标量子查询 / 列子查询 / 行子查询(多列多行)\n特点:\n 子查询放在小括号内 一般放在条件的右侧 标量子查询,一般搭配着单行操作符使用 \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= \u0026lt;\u0026gt; 列子查询,一般搭配着多行操作符使用 in any/some all 子查询的执行顺序优先于主查询执行,主查询的条件用到了子查询的结果  标量子查询 #谁的工资比Abel高mysql\u0026gt;selectlast_name,salaryfromemployeeswheresalary\u0026gt;(selectsalaryfromemployeeswherelast_name=\u0026#39;Abel\u0026#39;);+-----------+----------+ |last_name|salary|+-----------+----------+ |K_ing|24000.00||Kochhar|17000.00|mysql\u0026gt;selectlast_name,job_id,salaryfromemployeeswhereemployee_id=141andsalary\u0026gt;(selectsalaryfromemployeeswhereemployee_id=143);+-----------+----------+---------+ |last_name|job_id|salary|+-----------+----------+---------+ |Rajs|ST_CLERK|3500.00|+-----------+----------+---------+ #查询job_id和141号员工的job_id相同的,salary比143号员工多的员工mysql\u0026gt;selectlast_name,job_id,salaryfromemployeeswherejob_id=(selectjob_idfromemployeeswhereemployee_id=141)andsalary\u0026gt;(selectsalaryfromemployeeswhereemployee_id=143);+-------------+----------+---------+ |last_name|job_id|salary|+-------------+----------+---------+ |Nayer|ST_CLERK|3200.00||Mikkilineni|ST_CLERK|2700.00||Bissot|ST_CLERK|3300.00|#查询公司工资最少的员工的last_name,job_id,和salarymysql\u0026gt;selectlast_name,job_id,salaryfromemployeeswheresalary=(selectmin(salary)fromemployees);+-----------+----------+---------+ |last_name|job_id|salary|+-----------+----------+---------+ |Olson|ST_CLERK|2100.00|+-----------+----------+---------+ 1rowinset(0.00sec)#查询最低工资大于50号部门的最低工资的部门id和其最低工资mysql\u0026gt;selectdepartment_id,min(salary)最低工资fromemployeesgroupbydepartment_idhavingmin(salary)\u0026gt;(selectmin(salary)fromemployeeswheredepartment_id=50);+---------------+----------+ |department_id|最低工资|+---------------+----------+ |NULL|7000.00||10|4400.00|标量子查询可能出现的问题  子查询里查到的元素个数不止一个 子查询里压根没查到任何元素  列子查询 \rimage-20210923211703043\r\nany就是大于最小值小于最大值 all就是大于最大值小于最小值\n#查询location_id是1400或1700的部门中的所有员工姓名mysql\u0026gt;selectlast_namefromemployeesewheredepartment_idin(selectdistinctdepartment_idfromdepartmentswherelocation_idin(1400,1700));+------------+ |last_name|+------------+ |Hunold||Ernst||Austin|#返回比job_id为IT_PROG部门任意工资低的员工的员工号/姓名/job_id以及salarymysql\u0026gt;selectemployee_id,last_name,job_id,salaryfromemployeeswheresalary\u0026lt;any(selectsalaryfromemployeeswherejob_id=\u0026#39;IT_PROG\u0026#39;);+-------------+-------------+------------+---------+ |employee_id|last_name|job_id|salary|+-------------+-------------+------------+---------+ |104|Ernst|IT_PROG|6000.00||105|Austin|IT_PROG|4800.00|#也可以使用max或者min来代替anymysql\u0026gt;selectemployee_id,last_name,job_id,salaryfromemployeeswheresalary\u0026lt;any(selectsalaryfromemployeeswherejob_id=\u0026#39;IT_PROG\u0026#39;)orderbyemployee_id;+-------------+-------------+------------+---------+ |employee_id|last_name|job_id|salary|+-------------+-------------+------------+---------+ |104|Ernst|IT_PROG|6000.00||105|Austin|IT_PROG|4800.00|#all也是同样的#in和=Any也是一样的#notin和\u0026lt;\u0026gt;All也是一样的行子查询 #查询员工编号最小并且工资最高的员工信息(不一定存在)#简单粗暴的做法mysql\u0026gt;select*fromemployeeswhereemployee_id=(selectmin(employee_id)fromemployees)andsalary=(selectmax(salary)fromemployees);+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |100|Steven|K_ing|SKING|515.123.4567|AD_PRES|24000.00|NULL|NULL|90|1992-04-0300:00:00|+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 1rowinset(0.00sec)#行子查询有局限性mysql\u0026gt;select*fromemployeeswhere(employee_id,salary)=(selectmin(employee_id),max(salary)fromemployees);+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |100|Steven|K_ing|SKING|515.123.4567|AD_PRES|24000.00|NULL|NULL|90|1992-04-0300:00:00|+-------------+------------+-----------+-------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 1rowinset(0.00sec)放在select后面的子查询 仅仅支持标量子查询\n#查询每个部门的员工个数#通过子查询来做mysql\u0026gt;selectd.*,(selectcount(*)fromemployeeswheredepartment_id=d.department_id)fromdepartmentsd;+---------------+-----------------+------------+-------------+----------------------------------------------------------------------+ |department_id|department_name|manager_id|location_id|(selectcount(*)fromemployeeswheredepartment_id=d.department_id)|+---------------+-----------------+------------+-------------+----------------------------------------------------------------------+ |10|Adm|200|1700|1||20|Mar|201|1800|2|#也可以通过左右连接来做mysql\u0026gt;selectd.*,count(*)fromemployeeserightjoindepartmentsdone.department_id=d.department_idgroupbyd.department_id;+---------------+-----------------+------------+-------------+----------+ |department_id|department_name|manager_id|location_id|count(*)|+---------------+-----------------+------------+-------------+----------+ |10|Adm|200|1700|1||20|Mar|201|1800|2||30|Pur|114|1700|6|#查询员工号=102的部门名mysql\u0026gt;selectemployee_id,(selectdepartment_namefromdepartmentswheredepartment_id=e.department_id)fromemployeesewheree.employee_id=102;+-------------+--------------------------------------------------------------------------------+ |employee_id|(selectdepartment_namefromdepartmentswheredepartment_id=e.department_id)|+-------------+--------------------------------------------------------------------------------+ |102|Exe|+-------------+--------------------------------------------------------------------------------+ 1rowinset(0.00sec)from后面 特点：将子查询充当一张表 要求必须起别名\n#查询每个部门的平均工资的工资等级#sql92语法mysql\u0026gt;selectdepartment_id,grade_level,avfrom(selectdepartment_id,avg(salary)avfromemployeesgroupbydepartment_id)a,job_gradeswhereavbetweenlower_salandhighest_sal;+---------------+-------------+--------------+ |department_id|grade_level|av|+---------------+-------------+--------------+ |NULL|C|7000.000000||10|B|4400.000000|#sql99语法mysql\u0026gt;selectav.department_id,grade_levelfrom(selecte.department_id,avg(salary)avsfromemployeesegroupbye.department_id)avjoinjob_gradesjonav.avsbetweenj.lower_salandj.highest_sal;+---------------+-------------+ |department_id|grade_level|+---------------+-------------+ |NULL|C||10|B||20|C|exists后面（子查询） select exists(select employee_id from employees)\n语法:\nexists(完整的查询语句) 结果是1/0\n#回顾mysql\u0026gt;selectlast_name,(selectdepartment_namefromdepartmentswheredepartment_id=e.department_id)部门fromemployeese;+-------------+------+ |last_name|部门|+-------------+------+ |K_ing|Exe||Kochhar|Exe|#查询有员工的部门名mysql\u0026gt;selectd.department_id,d.department_namefromdepartmentsdwhereexists(selectd.department_idfromemployeesewhered.department_id=e.department_id);+---------------+-----------------+ |department_id|department_name|+---------------+-----------------+ |10|Adm||20|Mar|#可以用in来代替mysql\u0026gt;selectd.department_id,d.department_namefromdepartmentsdwhered.department_idin(selectdistincte.department_idfromemployeese);+---------------+-----------------+ |department_id|department_name|+---------------+-----------------+ |10|Adm||20|Mar|#查询没有女朋友的男生信息mysql\u0026gt;selectb.*fromboysbwherenotexists(selectboyfriend_idfrombeautywhereboyfriend_id=b.id);+----+---------+--------+ |id|boyName|userCP|+----+---------+--------+ |4|段誉|300|+----+---------+--------+ 1rowinset(0.00sec)练习一下\nmysql\u0026gt;selectlast_name,salaryfromemployeeswheredepartment_id=(selectdepartment_idfromemployeeswherelast_name=\u0026#39;Zlotkey\u0026#39;);+------------+----------+ |last_name|salary|+------------+----------+ |Russell|14000.00||Partners|13500.00|mysql\u0026gt;selectlast_name,salaryfromemployeeswheresalary\u0026gt;(selectavg(salary)fromemployees);+------------+----------+ |last_name|salary|+------------+----------+ |K_ing|24000.00||Kochhar|17000.00|#查询各部门中工资比本部门平均工资中搞的员工和员工号,姓名和工资mysql\u0026gt;selecte.department_id,e.employee_id,e.last_name,e.salaryfromemployeesewheresalary\u0026gt;(selectavg(salary)fromemployeeswheredepartment_id=e.department_id);+---------------+-------------+-----------+----------+ |department_id|employee_id|last_name|salary|+---------------+-------------+-----------+----------+ |90|100|K_ing|24000.00||60|103|Hunold|9000.00|mysql\u0026gt;selectdepartment_id,employee_id,last_namefromemployeeswheredepartment_idin(selectdepartment_idfromemployeeswherelast_namelike\u0026#39;%u%\u0026#39;);+---------------+-------------+-------------+ |department_id|employee_id|last_name|+---------------+-------------+-------------+ |60|103|Hunold||60|104|Ernst|#查询部门的location_id是1700的部门工作的员工的员工号mysql\u0026gt;selecte.employee_id,e.department_idfromemployeesewheree.department_idin(selectdepartment_idfromdepartmentswherelocation_id=1700);+-------------+---------------+ |employee_id|department_id|+-------------+---------------+ |200|10||114|30|mysql\u0026gt;selectlast_name,salaryfromemployeeswheremanager_idin(selectemployee_idfromemployeeswherelast_name=\u0026#39;K_ing\u0026#39;);+-----------+----------+ |last_name|salary|+-----------+----------+ |Kochhar|17000.00||DeHaan|17000.00|#查询最高工资的员工的姓名,要求first_name和last_name显示为一列,列名为姓名mysql\u0026gt;selectconcat(a.姓,a.名)姓名from(selectfirst_name姓,last_name名fromemployeeswheresalary=(selectmax(salary)fromemployees))a;+-------------+ |姓名|+-------------+ |StevenK_ing|+-------------+ 1rowinset(0.00sec)分页查询 应用场景:当要显示的数据,一页显示不全,需要分页提交sql请求的时候\n语法:select 查询列表 from 表 inner join 表2 on 连接条件 group by 分组字段 having 分组后的筛选 order by 排序后的字段 limit offset,size ;\noffset要显示条目的起始索引(起始索引从0开始)\nsize要显示的条目个数\n特点:\n limit语句放在查询语句的最后 公式 要显示的页数 page 每页的条目数size , 那么就是limit (page-1)*size,size  mysql\u0026gt;select*fromemployeeslimit0,5;+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |100|Steven|K_ing|SKING|515.123.4567|AD_PRES|24000.00|NULL|NULL|90|1992-04-0300:00:00||101|Neena|Kochhar|NKOCHHAR|515.123.4568|AD_VP|17000.00|NULL|100|90|1992-04-0300:00:00||102|Lex|DeHaan|LDEHAAN|515.123.4569|AD_VP|17000.00|NULL|100|90|1992-04-0300:00:00||103|Alexander|Hunold|AHUNOLD|590.423.4567|IT_PROG|9000.00|NULL|102|60|1992-04-0300:00:00||104|Bruce|Ernst|BERNST|590.423.4568|IT_PROG|6000.00|NULL|103|60|1992-04-0300:00:00|+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 5rowsinset(0.00sec)#如果从第一条开始的话,那么这样可以省略前一个数字mysql\u0026gt;select*fromemployeeslimit5;+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ |100|Steven|K_ing|SKING|515.123.4567|AD_PRES|24000.00|NULL|NULL|90|1992-04-0300:00:00||101|Neena|Kochhar|NKOCHHAR|515.123.4568|AD_VP|17000.00|NULL|100|90|1992-04-0300:00:00||102|Lex|DeHaan|LDEHAAN|515.123.4569|AD_VP|17000.00|NULL|100|90|1992-04-0300:00:00||103|Alexander|Hunold|AHUNOLD|590.423.4567|IT_PROG|9000.00|NULL|102|60|1992-04-0300:00:00||104|Bruce|Ernst|BERNST|590.423.4568|IT_PROG|6000.00|NULL|103|60|1992-04-0300:00:00|+-------------+------------+-----------+----------+--------------+---------+----------+----------------+------------+---------------+---------------------+ 5rowsinset(0.00sec)#第11到第25条mysql\u0026gt;select*fromemployeeslimit10,15;mysql\u0026gt;select*fromemployeeswherecommission_pctisnotnullorderbysalary*(1+commission_pct)desclimit0,10;练习一下 mysql\u0026gt;selectsubstr(email,1,instr(email,\u0026#39;@\u0026#39;)-1)fromstuinfo;mysql\u0026gt;selectcount(*)个数,sexfromstuinfogroupbysex;mysql\u0026gt;selectmin(age),(selectgradeName,idfromgradewhereid=stuinfo.gradeid)fromstuinfogroupbygradeId;mysql\u0026gt;selectmin(age),(selectgradeName,idfromgradewhereid=stuinfo.id)fromstuinfogroupbygradeIdhavingmin(age)\u0026gt;20;查询语句中涉及到的所有关键字,以及执行先后顺序. select 查询列表 ⑦\nfrom 表 ① 锁定数据源\n连接类型 join 表2 ②拼接数据源 笛卡尔儿乘积\non 连接条件 ③缩小数据源 非笛卡尔乘积\nwhere 筛选条件 ④缩小数据范围\ngroup by 分组列表 ⑤\nhaving 分组后的筛选 ⑥分组后筛选\norder by 排序列表 ⑧\nlimit 偏移,条目数; ⑨\nsql99语法 内连接 select 查询列表 from 表1 别名 inner join 表2 别名 on 连接条件 where 筛选条件 group by 分组列表 having 分组后的筛选 order by 排序列表 limit子句\n特点:\n表的顺序可以调换\n内连接的结果=多表的交集\nn表连接至少需要n-1个连接条件\n分类: 等值连接 非等值连接 自连接\n外连接 select 查询列表 from 表1 别名 left|right|full outer join 表2 别名 on 连接条件\nwhere 筛选条件 group by 分组列表 having 分组后的筛选 order by 排序列表 limit 子句;\n特点:\n查询的结果=主表中所有的行,其中从表和他匹配的将显示匹配行,如果从表没有匹配的则显示null\nleft join 左边的就是主表,right join右边的就是主表\nfull join 两边都是主表\n一般用于查询除了交集部分的剩余的不匹配的行\n交叉连接 select 查询列表 from 表1 别名 cross join 表2 别名 ;\n**特点:\t**\n类似于笛卡尔乘积\n子查询 嵌套在其他语句内部的select语句称为子查询或内查询\n外面的语句可以是insert update select delete 等等,一般select 作为外面语句较多\n外面如果为select语句,则此语句成为外查询或主查询\n**分类:\t**\n  按出现的位置\n select 后面 仅仅支持标量子查询 from 后面 表子查询 where或having后面 标量子查询 / 列子查询 / 行子查询 exists后面 标量子查询 列子查询 行子查询 表子查询    按结果集的行列\n 标量子查询(单行子查询):结果集为一行一列 列子查询(多行子查询):结果集为多行一列 行子查询(结果集为多行多列) 表子查询(结果集为多行多列)    示例\n标量子查询\n查询最低工资的员工姓名和工资\nmysql\u0026gt;selectlast_name,salaryfromemployeeswheresalary=(selectmin(salary)fromemployees);+-----------+---------+ |last_name|salary|+-----------+---------+ |Olson|2100.00|+-----------+---------+ 1rowinset(0.00sec)列子查询\n查询所有是领导的员工姓名\nmysql\u0026gt;selectlast_namefromemployeeswhereemployee_idin(selectmanager_idfromemployees);+-----------+ |last_name|+-----------+ |K_ing||DeHaan|  分页查询 当要查询的条目数太多,一页显示不全\n语法\nselect 查询列表 from 表 limit offset,size\n**注意\t** offset代表的是起始的条目索引,默认是从0开始 size代表的是要显示的条目数\n公式 limit (page-1)*size , size\n练习一下 mysql\u0026gt;selectlast_namefromemployeeswhereemployee_idin(selectmanager_idfromemployees);+-----------+ |last_name|+-----------+ |K_ing||DeHaan|#查询平均工资最低的部门信息直接使用orderby平均工资asc再limit1mysql\u0026gt;selectd.*fromdepartmentsdwhered.department_id=(selectdepartment_idfromemployeesgroupbydepartment_idorderbyavg(salary)asclimit1);+---------------+-----------------+------------+-------------+ |department_id|department_name|manager_id|location_id|+---------------+-----------------+------------+-------------+ |50|Shi|121|1500|+---------------+-----------------+------------+-------------+ #查询平均工资最低的部门信息和它的平均工资mysql\u0026gt;selectd.*,a.avgsalaryfromdepartmentsdjoin(selectdepartment_id,avg(salary)avgsalaryfromemployeesgroupbydepartment_idorderbyavg(salary)asclimit1)aond.department_id=a.department_id;+---------------+-----------------+------------+-------------+-------------+ |department_id|department_name|manager_id|location_id|avgsalary|+---------------+-----------------+------------+-------------+-------------+ |50|Shi|121|1500|3475.555556|+---------------+-----------------+------------+-------------+-------------+ 1rowinset(0.00sec)#查询平均工资最高的job信息mysql\u0026gt;selectj.*fromjobsjwherej.job_id=(selectjob_idfromemployeesgroupbyjob_idorderbyavg(salary)desclimit1);+---------+-----------+------------+------------+ |job_id|job_title|min_salary|max_salary|+---------+-----------+------------+------------+ |AD_PRES|President|20000|40000|+---------+-----------+------------+------------+ mysql\u0026gt;selectavg(salary),department_idfromemployeesgroupbydepartment_idhavingavg(salary)\u0026gt;(selectavg(salary)fromemployees);+--------------+---------------+ |avg(salary)|department_id|+--------------+---------------+ |7000.000000|NULL||9500.000000|20||6500.000000|40||10000.000000|70||8955.882353|80||19333.333333|90||8600.000000|100||10150.000000|110|+--------------+---------------+ mysql\u0026gt;select*fromemployeeswhereemployee_idin(selectmanager_idfromemployees);+-------------+------------+-----------+----------+--------------------+---------+----------+----------------+------------+---------------+---------------------+ |employee_id|first_name|last_name|email|phone_number|job_id|salary|commission_pct|manager_id|department_id|hiredate|+-------------+------------+-----------+----------+--------------------+---------+----------+----------------+------------+---------------+---------------------+ |100|Steven|K_ing|SKING|515.123.4567|AD_PRES|24000.00|NULL|NULL|90|1992-04-0300:00:00||102|Lex|DeHaan|LDEH#查询各个部门中最高工资中最低的那个部门的最低工资是多少mysql\u0026gt;selectmin(salary)fromemployeeswheredepartment_id=(selectdepartment_idfrom(selectmax(salary),department_idfromemployeesgroupbydepartment_idorderbymax(salary)asclimit1)a);+-------------+ |min(salary)|+-------------+ |4400.00|+-------------+ 1rowinset(0.00sec)#查询平均工资最高的部门的manager的详细信息:last_name,department_id,email,salarymysql\u0026gt;selectlast_name,department_id,email,salaryfromemployeeswhereemployee_id=(selectmanager_idfromdepartmentswheredepartment_id=(selectdepartment_idfromemployeesgroupbydepartment_idorderbyavg(salary)desclimit1));+-----------+---------------+-------+----------+ |last_name|department_id|email|salary|+-----------+---------------+-------+----------+ |K_ing|90|SKING|24000.00|+-----------+---------------+-------+----------+ 练习一下\nmysql\u0026gt;selectcount(*)个数,(selectmajoridfrommajorwheremajorid=s.majorid)专业号fromstudentsgroupbymajorid;+------+--------+ |个数|专业号|+------+--------+ |8|1||3|2|mysql\u0026gt;selectavg(score),max(score)fromresultgroupbystudentno;+--------------------+------------+ |avg(score)|max(score)|+--------------------+------------+ |100|100||90|90|#查询姓张的每个学生的最低分大于60的学号姓名其实可以用join就不用那么麻烦了mysql\u0026gt;selectmin(score)最低分,r.studentno,(selects.studentnamefromstudentswheres.studentno=r.studentnoands.studentnamelike\u0026#39;张%\u0026#39;)afromresultrgroupbyr.studentnohaving最低分\u0026gt;60andaisnotnull;+--------+-----------+--------+ |最低分|studentno|a|+--------+-----------+--------+ |100|s001|张三封||70|s004|张翠山|+--------+-----------+--------+ #可以使用diff函数和joinmysql\u0026gt;selects.studentname,(selectmajornamefrommajorwheremajorid=s.majorid)专业名称fromstudentswheres.borndate\u0026gt;\u0026#39;1998-1-1\u0026#39;;+-------------+----------+ |studentname|专业名称|+-------------+----------+ |张无忌|html5||赵敏|javaee|+-------------+----------+ 2rowsinset(0.00sec)mysql\u0026gt;selects.studentnamefromstudentsjoinmajormons.majorid=m.majoridwheredatediff(s.borndate,\u0026#39;1998-1-1\u0026#39;)\u0026gt;0;+-------------+ |studentname|+-------------+ |张无忌||赵敏|+-------------+ 2rowsinset(0.00sec)#查询每个专业的男生人数和女生人数分别是多少在这里s.majorid=s1.majorids1一定不能省略mysql\u0026gt;selects1.majorid,(selectcount(*)fromstudentswheres.majorid=s1.majoridands.sex=\u0026#39;男\u0026#39;)男生,(selectcount(*)fromstudentswheres.majorid=s1.majoridands.sex=\u0026#39;女\u0026#39;)女生fromstudents1groupbys1.majorid;+---------+------+------+ |majorid|男生|女生|+---------+------+------+ |1|5|3||2|2|1||3|2|2|+---------+------+------+ 3rowsinset(0.00sec)#查询专业和张翠山一样的学生的最低分mysql\u0026gt;selectmin(score)fromresultwherestudentnoin(selects.studentnofromstudentswheremajorid=(selectmajoridfromstudentwherestudentname=\u0026#39;张翠山\u0026#39;)andstudentname\u0026lt;\u0026gt;\u0026#39;张翠山\u0026#39;)groupbystudentno;+------------+ |min(score)|+------------+ |100||90|+------------+ 2rowsinset(0.00sec)#查询大于60分的学生的姓名密码专业名mysql\u0026gt;selects.studentname,s.loginpwd,(selectmajornamefrommajorwheremajorid=s.majorid)fromstudentswheres.studentnoin(selectdistinctstudentnofromresultwherescore\u0026gt;60);+-------------+----------+---------------------------------------------------------+ |studentname|loginpwd|(selectmajornamefrommajorwheremajorid=s.majorid)|+-------------+----------+---------------------------------------------------------+ |张三封|8888|javaee||殷天正|8888|javaee||周伯通|8888|html5||张翠山|8888|javaee||小小张|8888|android||张无忌|8888|html5|+-------------+----------+---------------------------------------------------------+ #按邮箱的位数分组,并查询个数mysql\u0026gt;selectcount(*)个数,length(s.email)fromstudentsgroupbylength(s.email);+------+-----------------+ |个数|length(s.email)|+------+-----------------+ |1|20||2|19||2|18||6|NULL||2|17||2|15|+------+-----------------+ #查询学生名专业名分数这是错误的如果使用join是取完全交集mysql\u0026gt;selects.studentname,m.majorname,r.scorefromstudentsjoinmajormons.majorid=m.majoridjoinresultrons.studentno=r.studentno;+-------------+-----------+-------+ |studentname|majorname|score|+-------------+-----------+-------+ |张翠山|javaee|70||殷天正|javaee|90|#查询学生名专业名分数这是错误的应该使用leftjoin防止出现score为null的情况mysql\u0026gt;selects.studentname,m.majorname,r.scorefromstudentsjoinmajormons.majorid=m.majoridleftjoinresultrons.studentno=r.studentno;+-------------+-----------+-------+ |studentname|majorname|score|+-------------+-----------+-------+ |张三封|javaee|100||殷天正|javaee|90||周伯通|html5|80|mysql\u0026gt;selects.studentname,m.majorname,r.scorefromstudentsjoinmajormons.majorid=m.majoridleftjoinresultrons.studentno=r.studentno;#查询没有成绩的学生人数mysql\u0026gt;select*from(selectdistincts.studentno学号,(selectscorefromresultwherestudentno=s.studentnolimit1)afromstudents)bwhereb.aisnull;+------+------+ |学号|a|+------+------+ |S007|NULL||S008|NULL||S009|NULL|mysql\u0026gt;selectcount(*)from(selectdistincts.studentno学号,(selectscorefromresultwherestudentno=s.studentnolimit1)afromstudents)bwhereb.aisnull;+----------+ |count(*)|+----------+ |9|+----------+ 联合查询 union 联合 合并:将多条查询语句的结果合并成一个结果\n查询语句1 union 查询语句2 union 查询语句3 \u0026hellip;\n查询部门编号\u0026gt;90 或 邮箱包含a的员工信息\n应用场景\n保证两个表的列数一致 , 并不要求两个表的列名一致 ,就可以使用联合查询\n要查询的结果来源于多个表,且多个表没有直接的连接关系,但查询的信息一致时\n例如全站搜索 ,肯定不可能所有的数据都放在一个表里 , 所以这时候就需要union\n注意\nunion 会默认去重\nunion all 可以包含重复项\nmysql\u0026gt;select*fromemployeeswheredepartment_id\u0026gt;90oremaillike\u0026#39;%a%\u0026#39;;mysql\u0026gt;select*fromemployeeswheredepartment_id\u0026gt;90unionselect*fromemployeeswhereemaillike\u0026#39;%a%\u0026#39;;DML语言 数据操作语言 插入 insert\n更新 update\n删除 delete\n插入语句 方式一\n语法:\ninsert into 表名(列名, \u0026hellip;) values(值, \u0026hellip;) ;\n注意\n 插入的值的类型要与列的类型一直或兼容 不可以为null的列必须插入值,可以为null的列如何插入值  插入null 或者在 into beauty(少一点字段)   列的顺序可以调换 列和值的个数必须一致 可以省略列名,默认所有列名,而且列的顺序和表中列的顺序一直  #经典型insertmysql\u0026gt;insertintobeauty(id,name,sex,borndate,phone,photo,boyfriend_id)values(13,\u0026#39;唐艺昕\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;1990-4-23\u0026#39;,\u0026#39;18988888\u0026#39;,null,2);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintobeauty(id,name,sex,phone)values(14,\u0026#39;金星\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;13888888\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintobeautyvalues(18,\u0026#39;张飞\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;1990-4-23\u0026#39;,\u0026#39;119\u0026#39;,null,null);QueryOK,1rowaffected(0.00sec)**方式二\t**\n语法\ninsert into 表名 set 列名 = 值 , 列名 = 值 \u0026hellip;\nmysql\u0026gt;insertintobeautysetid=19,name=\u0026#39;文涛\u0026#39;,phone=\u0026#39;999\u0026#39;;QueryOK,1rowaffected(0.00sec)**两种方式的区别\t**\n 方式一支持多行插入,方式二不支持 方式一支持子查询,方式二不支持  #方式一支持子查询mysql\u0026gt;insertintobeauty(id,name,phone)select26,\u0026#39;宋西\u0026#39;,\u0026#39;11809866\u0026#39;;QueryOK,1rowaffected(0.01sec)Records:1Duplicates:0Warnings:0#方式一支持多行插入mysql\u0026gt;insertintobeauty(id,name,phone)selectid,boyname,\u0026#39;120\u0026#39;fromboyswhereid\u0026lt;3;ERROR1062(23000):Duplicateentry\u0026#39;1\u0026#39;forkey\u0026#39;beauty.PRIMARY\u0026#39;修改语句 修改单表的记录(重要)\nupdate 表名 set 列=新值 , 列=新值 where 筛选条件 ;\nupdatebeautysetphone=\u0026#39;11010011\u0026#39;wherenamelike\u0026#39;唐%\u0026#39;;updateboyssetboyname=\u0026#39;张飞\u0026#39;,userCp=10whereid=2;修改多表的记录(补充)\nsql92语法\nupdate 表1 别名 , 表2 别名\nset 列=值 , \u0026hellip; where 连接条件 and 筛选条件 ;\nsql99语法\nupdate 表1 别名 inner join 表2 别名 on 连接条件 set 列=值, \u0026hellip; where 筛选条件\n#修改张无忌的女朋友的手机号为114mysql\u0026gt;updatebeautybjoinboysonb.boyfriend_id=boys.idsetphone=\u0026#39;114\u0026#39;whereboys.boyname=\u0026#39;张无忌\u0026#39;;QueryOK,3rowsaffected(0.00sec)Rowsmatched:3Changed:3Warnings:0#也可以使用修改单表使用子查询mysql\u0026gt;updatebeautybsetphone=\u0026#39;115\u0026#39;whereb.boyfriend_id=(selectidfromboyswhereboyname=\u0026#39;张无忌\u0026#39;);QueryOK,3rowsaffected(0.00sec)Rowsmatched:3Changed:3Warnings:0#修改没有男朋友的女神的男朋友编号都为2号#先selectmysql\u0026gt;selectb.name,b.boyfriend_id,boynamefrombeautybleftjoinboysonb.boyfriend_id=boys.idwhereboyfriend_idisnotnullandboynameisnull;+--------+--------------+---------+ |name|boyfriend_id|boyname|+--------+--------------+---------+ |柳岩|8|NULL||苍老师|9|NULL||周冬雨|9|NULL||岳灵珊|9|NULL||双儿|9|NULL||夏雪|9|NULL|+--------+--------------+---------+ 6rowsinset(0.00sec)#再updatemysql\u0026gt;updatebeautybleftjoinboysonb.boyfriend_id=boys.idsetb.boyfriend_id=2whereboyfriend_idisnotnullandboynameisnull;QueryOK,6rowsaffected(0.00sec)Rowsmatched:6Changed:6Warnings:0#再查一下mysql\u0026gt;selectb.name,b.boyfriend_id,boynamefrombeautybleftjoinboysonb.boyfriend_id=boys.idwhereboyfriend_idisnotnullandboynameisnull;Emptyset(0.00sec)删除语句 方式一 delete\n方式二 truncate\n语法:truncate table 表名 (删除的是所有的 不能加筛选条件)\n单表的删除\n语法:delete from 表名 where 筛选条件\n多表的删除\n语法:\nsql92语法\ndelete 表1的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表1的数据内容\ndelete 表2的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表2的数据内容\ndelete 表1的别名, 表2的别名 from 表1 别名 , 表2 别名 where 连接条件 and 筛选条件 ; //删除的是表1和表2的数据内容\nsql99语法\ndelete 表1的别名,表2的别名 from 表1 别名 join 表2 别名 on 连接条件 where 筛选条件\n#单表的删除deletefrombeautywherephonelike\u0026#39;%9\u0026#39;;#删除张无忌的女朋友的信息#多表删除mysql\u0026gt;deletebfrombeautybjoinboysboyonb.boyfriend_id=boy.idwhereboy.boyname=\u0026#39;张无忌\u0026#39;;QueryOK,3rowsaffected(0.01sec)#删除黄晓明和他女朋友的信息mysql\u0026gt;deleteg,bfrombeautygjoinboysbong.boyfriend_id=b.idwhereb.boyname=\u0026#39;黄晓明\u0026#39;;QueryOK,2rowsaffected(0.00sec)方式二 truncate语句\n直接清空 truncate table boys ;\ndelete和truncate的区别  delete可以加where条件 , truncate不能加 truncate 删除, 效率高一丢丢 假如要删除的表中有自增长列,如果用delete删除后,再插入数据,自增长列的值依旧是从断点开始,而如果truncate删除后,再插入数据,自增长列的值从1开始 truncate删除没有返回值,delete删除有返回值 truncate删除回滚,delete删除可以回滚  练习一下 mysql\u0026gt;descusers;+---------------+-------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+---------------+-------------+------+-----+---------+-------+ |id|int|YES||NULL|||userid|varchar(10)|YES||NULL|||department_id|int|YES||NULL||+---------------+-------------+------+-----+---------+-------+ mysql\u0026gt;insertintomy_employees(First_name,Last_name,Userid,salary)values(\u0026#39;patel\u0026#39;,\u0026#39;Ralph\u0026#39;,\u0026#39;Rpatel\u0026#39;,895),(\u0026#39;Dance\u0026#39;,\u0026#39;Betty\u0026#39;,\u0026#39;Bdancs\u0026#39;,860),(\u0026#39;Biri\u0026#39;,\u0026#39;Ben\u0026#39;,\u0026#39;Bbiri\u0026#39;,1100),(\u0026#39;Newman\u0026#39;,\u0026#39;Chad\u0026#39;,\u0026#39;Cnewman\u0026#39;,750),(\u0026#39;Ropeburn\u0026#39;,\u0026#39;Audrey\u0026#39;,\u0026#39;Aropebur\u0026#39;,1150);QueryOK,5rowsaffected(0.01sec)Records:5Duplicates:0Warnings:0#也可以这样mysql\u0026gt;insertintomy_employees(First_name,Last_name,Userid,salary)select\u0026#39;patel\u0026#39;,\u0026#39;Ralph\u0026#39;,\u0026#39;Rpatel\u0026#39;,895unionselect\u0026#39;Dance\u0026#39;,\u0026#39;Betty\u0026#39;,\u0026#39;Bdancs\u0026#39;,860unionselect\u0026#39;Biri\u0026#39;,\u0026#39;Ben\u0026#39;,\u0026#39;Bbiri\u0026#39;,1100unionselect\u0026#39;Newman\u0026#39;,\u0026#39;Chad\u0026#39;,\u0026#39;Cnewman\u0026#39;,750unionselect\u0026#39;Ropeburn\u0026#39;,\u0026#39;Audrey\u0026#39;,\u0026#39;Aropebur\u0026#39;,1150;mysql\u0026gt;insertintousers(userid,id)values(\u0026#39;Rpatel\u0026#39;,10),(\u0026#39;Bdancs\u0026#39;,10),(\u0026#39;Bbiri\u0026#39;,20),(\u0026#39;Chewman\u0026#39;,30),(\u0026#39;Aropebur\u0026#39;,40);QueryOK,5rowsaffected(0.01sec)Records:5Duplicates:0Warnings:0mysql\u0026gt;updatemy_employeessetlast_name=\u0026#39;drelxer\u0026#39;whereid=3;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0mysql\u0026gt;updatemy_employeessetsalary=1000wheresalary\u0026lt;900;QueryOK,3rowsaffected(0.00sec)Rowsmatched:3Changed:3Warnings:0mysql\u0026gt;deleteme,ufrommy_employeesmejoinusersuonme.userid=u.useridwhereu.userid=\u0026#39;Bbiri\u0026#39;;QueryOK,2rowsaffected(0.00sec)mysql\u0026gt;truncatetableusers;DDL 数据定义语言\n库和表的管理\n库的管理 创建/修改/删除\n表的管理 创建/修改/删除\n创建:create\n修改:alter\n删除:drop\n库的管理 库的创建 语法 create database [if not exists] 库名 ;\n#如果已存在这样执行会报错mysql\u0026gt;createdatabasebooks;QueryOK,1rowaffected(0.01sec)#会先判断一下mysql\u0026gt;createdatabaseifnotexistsbooks;QueryOK,1rowaffected,1warning(0.00sec)库的修改 更改库的字符集\nalterdatabasebookscharactersetgbk;库的删除 dropdatabasebooks;dropdatabaseifexistsbooks;表的管理 表的创建 createtable表名(列名列的类型[(长度)约束],列名列的类型[(长度)约束],列名列的类型[(长度)约束],列名列的类型[(长度)约束],列名列的类型[(长度)约束],...)mysql\u0026gt;selectdatabase();+-------------+ |database()|+-------------+ |myemployees|+-------------+ 1rowinset(0.00sec)mysql\u0026gt;usebooks;Databasechangedmysql\u0026gt;createtablebook(idint,bNamevarchar(20),pricedouble,authorIdint,publishDatedatetime);QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;descbook;+-------------+-------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------------+-------------+------+-----+---------+-------+ |id|int|YES||NULL|||bName|varchar(20)|YES||NULL|||price|double|YES||NULL|||authorId|int|YES||NULL|||publishDate|datetime|YES||NULL||+-------------+-------------+------+-----+---------+-------+ 5rowsinset(0.00sec)mysql\u0026gt;createtableauthor(idint,au_namevarchar(20),nationvarchar(10));QueryOK,0rowsaffected(0.02sec)表的修改 alter table 表名 add column / drop column / change column /modify column /raname to 列名/列类型/表名\n 修改列名 修改列的类型或约束 添加新列 删除列 修改表名  #修改列名mysql\u0026gt;altertablebookchangecolumnpublishDatepbDatedatetime;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#修改列的类型或约束mysql\u0026gt;altertablebookmodifycolumnpbdatetimestamp;QueryOK,0rowsaffected(0.05sec)Records:0Duplicates:0Warnings:0#添加新列mysql\u0026gt;altertableauthoraddcolumnannualdouble;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#删除列mysql\u0026gt;altertablebookdropcolumnannual;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0#修改表名mysql\u0026gt;altertableauthorrenametobook_author;QueryOK,0rowsaffected(0.01sec)表的删除 drop table 表\ndrop table if exist 表\n通用的写法:\ndrop database if exists 旧库名 ;\ncreate database 库名 ;\ndrop table if exists 旧表名;\ncreate table 表名 (\u0026hellip;) ;\n表的复制  仅仅复制表的结构  mysql\u0026gt;createtablecopylikeauthor;QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;select*fromcopy;Emptyset(0.00sec) 复制表的结构和数据  #子查询mysql\u0026gt;createtablecopy2select*fromauthor;QueryOK,4rowsaffected(0.02sec)Records:4Duplicates:0Warnings:0mysql\u0026gt;select*fromcopy2;+------+----------+--------+ |id|au_name|nation|+------+----------+--------+ |1|村上春树|日本||2|莫言|中国||3|冯唐|中国||4|金庸|中国|+------+----------+--------+ 4rowsinset(0.00sec) 只复制部分数据  #根据一张表的部分数据建立另一张表mysql\u0026gt;createtablecopy3selectid,au_namefromauthorwherenation=\u0026#39;中国\u0026#39;;QueryOK,3rowsaffected(0.02sec)Records:3Duplicates:0Warnings:0mysql\u0026gt;select*fromcopy3;+------+---------+ |id|au_name|+------+---------+ |2|莫言||3|冯唐||4|金庸|+------+---------+ 3rowsinset(0.00sec) 仅仅复制某些字段  #这样就只会复制字段,并且不满足条件不携带任何一条数据过来mysql\u0026gt;createtablecopy4selectidfromauthorwhere0;QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;select*fromcopy4;Emptyset(0.00sec)练习一下 mysql\u0026gt;createdatabasetest;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;createtabledept1(idint(7),namevarchar(25));QueryOK,0rowsaffected,1warning(0.03sec)#将departments中的数据插入新表mysql\u0026gt;createtabledept2select*frommyemployees.departments;QueryOK,27rowsaffected(0.02sec)Records:27Duplicates:0Warnings:0mysql\u0026gt;createtableemp5(idint(7),first_namevarchar(25),last_namevarchar(25),dept_idint(7));QueryOK,0rowsaffected,2warnings(0.02sec)#这样是修改列名和类型的mysql\u0026gt;altertableemp5changecolumnlast_namelast_namevarchar(50);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#这样只是修改类型的mysql\u0026gt;altertableemp5modifycolumnlast_namevarchar(50);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#复制结构mysql\u0026gt;createtableemployees2likemyemployees.employees;QueryOK,0rowsaffected,2warnings(0.03sec)mysql\u0026gt;droptableemp5;QueryOK,0rowsaffected(0.02sec)#修改表的名字mysql\u0026gt;altertableemployees2renametoemp5;QueryOK,0rowsaffected(0.02sec)#增加列mysql\u0026gt;altertabledept1addcolumntest_columnint;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;altertableemp5addcolumntest_columnint;QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#删除列mysql\u0026gt;altertableemp5dropcolumndepartment_id;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0常见的数据类型 数值型\n 整形 小数  定点数 浮点数    字符型\n 较短的文本 char varchar 较长的文本 text blob(较长的二进制数据)  日期型:\n整形\n\rimage-20210926214209015\r\n分类\ntinyint smallint mediumin int/interger bigint\n1 2 3 4 8\n特点\n 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字 如果插入的数值超出了类型的范围,会报out of range异常 ,但是与mysql5.0不同的是,现在不会插入数据了,mysql5.0会插入临界值 如果不设置长度,会有默认的长度  如何设置无符号和有符号\nmysql\u0026gt;desctab_int;+-------+------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+------+------+-----+---------+-------+ |t1|int|YES||NULL||+-------+------+------+-----+---------+-------+ 1rowinset(0.01sec)#说明能够插入负数说明默认的int是有符号的intmysql\u0026gt;insertintotab_intvalues(-123456);QueryOK,1rowaffected(0.01sec)#mysql\u0026gt;droptableifexiststab_int;QueryOK,0rowsaffected(0.02sec)#插入无符号int类型mysql\u0026gt;createtabletab_int(t1int,t2intunsigned);QueryOK,0rowsaffected(0.02sec)#想给无符号整数插入负数的话会报错0行一共但是在mysql5.5会插入然后默认填充0mysql\u0026gt;insertintotab_intvalues(-123456,-123456);ERROR1264(22003):Outofrangevalueforcolumn\u0026#39;t2\u0026#39;atrow1mysql\u0026gt;select*fromtab_int;Emptyset(0.00sec)#zerofill默认长度不够以0填充默认是无符号数int(7)不是2的7位,代表的是显示的最大宽度mysql\u0026gt;createtableint_zeroFill(t1int(7)zerofill,t2int(7)zerofill);QueryOK,0rowsaffected,4warnings(0.02sec)mysql\u0026gt;descint_zeroFill;+-------+--------------------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+--------------------------+------+-----+---------+-------+ |t1|int(7)unsignedzerofill|YES||NULL|||t2|int(7)unsignedzerofill|YES||NULL||+-------+--------------------------+------+-----+---------+-------+ 2rowsinset(0.01sec)mysql\u0026gt;insertintoint_zerofillvalues(123,123);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromint_zerofill;+---------+---------+ |t1|t2|+---------+---------+ |0000123|0000123|+---------+---------+ 1rowinset(0.00sec)小数 \rimage-20210929224058024\r\n浮点型\nfloat(M,D)\ndouble(M,D)\n定点型\ndec(M,D)\ndecimal(M,D)\n特点:\n M和D什么意思  m是小数部位+整数部位 d是小数部位 如果超过范围, 则插入临界值   m和d都可以省略  如果是decimal , 则m默认为10,d默认为0 如果是float和double,则会根据插入的数值的精度来决定精度   定点型和浮点型的区别  定点型的精确度较高,如果要求插入数值的精度较高如货币运算等则考虑使用    #小数mysql\u0026gt;createtabletab_float(f1float(5,2),f2double(5,2),f3decimal(5,2));QueryOK,0rowsaffected,2warnings(0.02sec)mysql\u0026gt;insertintotab_floatvalues(123.45,123.45,123.45);QueryOK,1rowaffected(0.01sec)#会被截取位数太长的话mysql\u0026gt;insertintotab_floatvalues(123.456,123.456,123.456);QueryOK,1rowaffected,1warning(0.00sec)#短了就自动填充mysql\u0026gt;insertintotab_floatvalues(123.4,123.4,123.4);QueryOK,1rowaffected(0.00sec)#(5,2)2代表小数后几位mysql\u0026gt;select*fromtab_float;+--------+--------+--------+ |f1|f2|f3|+--------+--------+--------+ |123.45|123.45|123.45||123.46|123.46|123.46||123.40|123.40|123.40|+--------+--------+--------+ 3rowsinset(0.00sec)#超出位数了超出的话mysql8.0将不会插入(5,2)5代表一共多少位数,如果小数位2位,那整数位最多3位,所以整数最多999mysql5.0会插入最大值mysql\u0026gt;insertintotab_floatvalues(1523.4,1523.4,1523.4);ERROR1264(22003):Outofrangevalueforcolumn\u0026#39;f1\u0026#39;atrow1mysql\u0026gt;select*fromtab_float;+--------+--------+--------+ |f1|f2|f3|+--------+--------+--------+ |123.45|123.45|123.45||123.46|123.46|123.46||123.40|123.40|123.40|+--------+--------+--------+ 3rowsinset(0.00sec)#如果不填写m和ddecimal默认是(10,0)小数后面是0位mysql\u0026gt;createtabletab_float_default(f1float,f2double,f3decimal);QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;desctab_float_default;+-------+---------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+---------------+------+-----+---------+-------+ |f1|float|YES||NULL|||f2|double|YES||NULL|||f3|decimal(10,0)|YES||NULL||+-------+---------------+------+-----+---------+-------+ 3rowsinset(0.01sec)#如果插入了多了,会自动截断mysql\u0026gt;insertintotab_float_defaultvalues(123.456,123.456,123.456);QueryOK,1rowaffected,1warning(0.01sec)mysql\u0026gt;select*fromtab_float_default;+---------+---------+------+ |f1|f2|f3|+---------+---------+------+ |123.456|123.456|123|+---------+---------+------+ 1rowinset(0.00sec)选择类型的原则 所选择的类型越简单越好,能保存数值的类型越小越好\n字符型 较短的文本:\nchar\nvarchar\n较长的文本:\ntext\nblob(较大的二进制)\n其他:\nbinary和varbinary用于保存较短的二进制数据\nenum用于保存枚举\nset用于保存集合\n\rimage-20210929230011199\r\n特点:\n char char(m) m代表最大的字符数,可以省略,默认为1 代表固定长度的字符 效率高一点 varchar varchar(m) m代表最大的字符数,不可以省略 可变长度的字符 比较节省 效率低一点  \rimage-20210929230312590\r\n#类型为enum的字段mysql\u0026gt;createtabletab_char(c1enum(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;));QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;desctab_char;+-------+-------------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+-------------------+------+-----+---------+-------+ |c1|enum(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;)|YES||NULL||+-------+-------------------+------+-----+---------+-------+ 1rowinset(0.01sec)mysql\u0026gt;insertintotab_charvalues(\u0026#39;a\u0026#39;);QueryOK,1rowaffected(0.01sec)#不区分大小写mysql\u0026gt;insertintotab_charvalues(\u0026#39;A\u0026#39;);QueryOK,1rowaffected(0.00sec)#没有定义的插入不进去mysql\u0026gt;insertintotab_charvalues(\u0026#39;m\u0026#39;);ERROR1265(01000):Datatruncatedforcolumn\u0026#39;c1\u0026#39;atrow1mysql\u0026gt;select*fromtab_char;+------+ |c1|+------+ |a||a|+------+ 2rowsinset(0.00sec)\rimage-20210929230732259\r\n可以从在一个字段里插入多个元素辣\n#创建类型为set的字段mysql\u0026gt;createtabletab_set(s1set(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;));QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;insertintotab_setvalues(\u0026#39;a\u0026#39;);QueryOK,1rowaffected(0.01sec)mysql\u0026gt;insertintotab_setvalues(\u0026#39;a,B\u0026#39;);QueryOK,1rowaffected(0.00sec)#不符合的不会插入mysql\u0026gt;insertintotab_setvalues(\u0026#39;a,m\u0026#39;);ERROR1265(01000):Datatruncatedforcolumn\u0026#39;s1\u0026#39;atrow1mysql\u0026gt;select*fromtab_set;+------+ |s1|+------+ |a||a,b|+------+ 2rowsinset(0.00sec)日期型 分类:\ndate只保存日期\ntime只保存时间\nyear只保存年\ndatetime 保存日期+时间\ntimestamp 保存日期+时间\n特点:\ndatetime 字节 8 范围 1000-9999 不受时区影响\ntimastamp 字节 4 范围 1970-2038 受时区影响\n\rimage-20210929233916597\r\n\rimage-20210929234007359\r\nmysql\u0026gt;select*fromtab_date;+---------------------+---------------------+ |t1|t2|+---------------------+---------------------+ |2021-09-2923:40:53|2021-09-2923:40:53|+---------------------+---------------------+ 1rowinset(0.00sec)#时区如果将时区改成其他时区,timestamp可以更加真实地反映当前时区的真实时间而不是不变mysql\u0026gt;showvariableslike\u0026#39;time_zone\u0026#39;;+---------------+--------+ |Variable_name|Value|+---------------+--------+ |time_zone|SYSTEM|+---------------+--------+ 1rowinset,1warning(0.00sec)复习一下 联合查询\nunion 联合 , 将多次查询结果合并为一个结果\n查询语句1 union [all] 查询语句2 \u0026hellip;\n**意义\t**\n 将一条比较复杂的查询语句拆分为多条语句 适用于查询多个表的时候,查询的列基本是一致的  特点\n 要求多条查询语句的查询列数必须一致 要求多条查询语句的查询的各列类型/顺序最好一致 不一致会视图隐式转换 union会默认去重 和 union all 可以包含重复项  查询的语法:\nselect * ⑦\nfrom 表1 别名 ①\njoin 表2 别名 ②\non 连接条件 ③\nwhere 筛选条件 ④\ngroup by 分组条件 ⑤\nhaving 分组后筛选条件 ⑥\norder by 排序条件 ⑧\nlimit(起始索引,条目数)选多少个 ⑨\nunion \u0026hellip;\nDML语言 插入\ninsert into 表名 (字段名 , \u0026hellip;) values (\u0026hellip;) //一一对应\n特点\n 要求值的类型和字段的类型要一致或兼容 字段的个数和顺序不一定与原始表中的字段的个数和顺序一致,但必须保证值和字段一一对应 假如可以为null的字段,注意可以通过以下两种方式插入null值  字段和值都省略 字段写上,然后值也使用null插入   字段和值的个数必须一致 字段名可以省略,但是默认为所有列  插入2\ninsert into 表名 set 字段名 = 值 , 字段名 = 值 \u0026hellip;\n两种方式的区别\n  方式一支持子查询\n insert into 表名 (select * from 表名 where \u0026hellip;)    方式一支持一次插入多行,方式二不支持\n insert into 表名 values (\u0026hellip;),(\u0026hellip;) \u0026hellip;    修改单表的记录 update 表名 set 字段=值 , 字段= 值 where 筛选条件\n修改多表的记录 update 表名 别名 join 表名 别名 on 连接条件 set 字段=值 , 字段 = 值 where 筛选语句\n删除 方式一使用delete 删除单表的记录\ndelete from 表名 where 筛选条件 [limit 条目数]\nmysql\u0026gt;select*fromcopy_girls;+----+--------+------+---------------------+-------------+--------------+--------------+ |id|name|sex|borndate|phone|photo|boyfriend_id|+----+--------+------+---------------------+-------------+--------------+--------------+ |1|柳岩|女|1988-02-0300:00:00|18209876577|NULL|2||2|苍老师|女|1987-12-3000:00:00|18219876577|NULL|2||4|热巴|女|1993-02-0300:00:00|18209876579|NULL|2||5|周冬雨|女|1992-02-0300:00:00|18209179577|NULL|2|mysql\u0026gt;deletefromcopy_girlslimit1;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;select*fromcopy_girls;+----+--------+------+---------------------+-------------+--------------+--------------+ |id|name|sex|borndate|phone|photo|boyfriend_id|+----+--------+------+---------------------+-------------+--------------+--------------+ |2|苍老师|女|1987-12-3000:00:00|18219876577|NULL|2||4|热巴|女|1993-02-0300:00:00|18209876579|NULL|2|删除多表的记录\ndelete 表1 别名1, 表2 别名2 from 表名 别名 join 表名 别名 on 连接条件 where 筛选条件\n方式二使用truncate\n两种方式的区别\n  delete不会让自增列归零,从断点开始,truncate会让自增列归零\n  delete可以加筛选条件,truncate 不能加筛选条件\n  truncate 效率较高\n  truncate 没有返回值,delete可以返回受影响的行数\n  truncate不可以回滚,delete可以回滚\n  DDL语言 库的管理 创建库\ncreate database [if not exists] 库名 [character set 字符集名] ;\n修改库\nalter database 库名 character set 字符集名 ;\n修改库名很少用,不行就换个库呗何必呢,如果实在要改,就先net stop mysql80 然后到mysql8.0下的data文件夹中重命名某个数据库名,然后net start mysql80 ,刷新数据库管理工具\n删除库\ndrop database [if exists] 库名 ;\n表的管理\n创建表\ncreate table [if not exists] 表名(字段名 类型 [约束], 字段名 类型 [约束] \u0026hellip;) ;\n修改表\n添加列\nalter table 表名 add column 列名 列的类型 [first|after 字段名];\nmysql\u0026gt;createtabletest_add_column(-\u0026gt;t1int,-\u0026gt;t2int,-\u0026gt;t3int);QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;desctest_add_column;+-------+------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+------+------+-----+---------+-------+ |t1|int|YES||NULL|||t2|int|YES||NULL|||t3|int|YES||NULL||+-------+------+------+-----+---------+-------+ 3rowsinset(0.01sec)mysql\u0026gt;altertabletest_add_columnaddcolumnt11bigintfirst;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;desctest_add_column;+-------+--------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+-------+--------+------+-----+---------+-------+ |t11|bigint|YES||NULL|||t1|int|YES||NULL|||t2|int|YES||NULL|||t3|int|YES||NULL||+-------+--------+------+-----+---------+-------+ 修改列的类型或者约束\nalter table 表名 modify column 列名 新类型[新约束] ;\n修改列名\nalter table 表名 change column 旧列名 新列名 类型;\n删除列名\nalter table 表名 drop column 列名 ;\n修改表名\nalter table 表名 rename to 新表名\n删除表\ndrop table [if exists] 表名;\n复制表 可以跨库\n仅仅复制表的结构 create table 表名 like 原表 ;\n复制表的结构+数据\ncreate table 表名 select * from 原表 ;\ncreate table 表名 select 特定字段 from 原表 where 筛选条件\n数据类型 数值型\n 整型  tinyint smallint mediumint int integer bigint 1 2 3 4 8 特点  都可以设置无符号和有符号 默认是有符号 ,通过 unsigned设置无符号 如果超出范围,out of range 异常,mysql5.0 和 8.0 不同 长度可以不指定,默认会有一个长度 长度代表的是显示的最大宽度,而不是只有2的长度位那个范围,但需要搭配zerofill,搭配之后将默认变为无符号整型     浮点型  定点数 decimal(m,d) 默认为(10,0) 浮点数 float(m,d) 4位字节 double(m,d) 8位字节 默认为可变的 特点  m代表整数+小数部位的个数,d代表小数部位 如果超出范围,则报out of range异常,并且插入临界值 m和d都可以省略,但对于定点数,m默认为10,d默认为0 如果精度要求较高,则有限考虑使用定点数      字符型\nchar varchar binary varbinary enum set text blob\nchar:固定长度的字符,写法为char(M) ,最大长度不能超过M ,其中M可以省略,默认为1\nvarchar:可变长度的字符 写法varchar(M),最大长度不能超过M,其中M不可以省略\n日期型\nyear 年\ndate 日期\ndatetime 日期+时间 8\ntime 时间\ntimestamp 时间戳 4 1970-2038 比较容易受到时区,语法模式,版本的影响,更能反映当前时区的真实时间\n新的一杰克 常见约束 含义 : 一种限制 , 用于限制表中的数据,为了保证表中的数据的准确和可靠性\n分类 六大约束\n  NOT NULL 非空 用于保证该字段的值不能为空 比如姓名/学号等等\n  default 默认 , 用于保证该字段有默认值\n  PRIMARY KEY 主键 用于保证该字段的值具有唯一性,并且非空,如学号,工号\n  UNIQUE 唯一,用于保证该字段的值具有唯一性,可以为空 如座位号/老婆\n  CHECK 检查约束 [mysql 不支持] 比如性别 只能男和女 或者青年人年龄\n  FOREIGN KEY 外键,用于限制两个表的关系,用于保证该字段的值必须来自于主表的关联列的值 在从表添加外键约束,用于引用主表中的某列的值 例如学生表的专业编号,员工表的部门编号,员工表的工种编号\n  添加约束的时机:\n 创建表时 修改表时  约束的添加分类:\n 列级约束 NOT NULL DEFAULT PRIMARY KEY UNIQUE CHECK FOREIGN KEY 六大约束语法上都支持,但是外键约束没有效果 表级约束 除了非空/默认,其他的都支持  createtable表(字段名字段类型列级约束,字段名字段类型,表级约束)创建表时添加约束\n添加列级约束\n语法:直接在字段名和类型后面追加约束类型即可\n只支持:默认/非空/主键\nmysql\u0026gt;createdatabasestudents;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;usestudents;Databasechanged#创建列级约束mysql\u0026gt;createtablestuinfo(idintprimarykey,stuNamevarchar(20)notnull,genderchar(1)check(gender=\u0026#39;男\u0026#39;orgender=\u0026#39;女\u0026#39;),seatintunique,ageintdefault18,majorIdintreferencesmajor(id));QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;descstuinfo;+---------+-------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+---------+-------------+------+-----+---------+-------+ |id|int|NO|PRI|NULL|||stuName|varchar(20)|NO||NULL|||gender|char(1)|YES||NULL|||seat|int|YES|UNI|NULL|||age|int|YES||18|||majorId|int|YES||NULL||+---------+-------------+------+-----+---------+-------+ 6rowsinset(0.00sec)#查看索引唯一/主键/外键都可以查看mysql\u0026gt;showindexfromstuinfo;添加表级约束\n语法:在各个字段的最下面\n[constraint 约束名] 约束类型(字段名) \u0026hellip;\nmysql\u0026gt;createtablestuinfo(idint,stunamevarchar(20),genderchar(1),seatint,ageint,majoridint,constraintpkprimarykey(id),constraintuqunique(seat),constraintckcheck(genderin(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)),constraintfk_stuinfo_majorforeignkey(majorid)referencesmajor(id));QueryOK,0rowsaffected(0.04sec)mysql\u0026gt;showindexfromstuinfo;\rimage-20211001160138048\r\nconstraint 约束名 可以去掉\nmysql\u0026gt;createtablestuinfo(idint,stunamevarchar(20),genderchar(1),seatint,ageint,majoridint,primarykey(id),unique(seat),check(genderin(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;)),foreignkey(majorid)referencesmajor(id));QueryOK,0rowsaffected(0.06sec)\rimage-20211001160643505\r\n通用写法\ncretetableifnotexistsstuinfo(idintprimarykey,stunamevarchar(20)notnull,sexchar(1)ageintdefault18,seatintunique,majoridint,constraintfk_stuinfo_majorforeignkey(majroid)referencesmajor(id))主键和唯一的大对比\n    保证唯一性 是否允许为空 一个表中可以有几个 是否允许组合键     主键 对 不对 一个表中至多有一个 是,但不推荐   唯一 对 对 可以有多个 是,但不推荐    primarkey(id,stuname)unique(seat,majorid)外键:\n 要求在从表设置外键关系 从表的外键列的类型和主表的关联列一致或兼容,名称无所谓 主表的关联咧必须是一个key或者唯一键 插入数据时,先插入主表,再插入从表 删除数据时,先删除从表,再删除主表  修改表时添加约束\n 添加列级约束 alter table 表名 mofidy column 字段名 字段类型 新约束 ; 添加表级约束 alter table 表名 add [constraint 约束名] 约束类型(字段名) [外键的引用] ;  添加非空约束\n添加列级约束\nmysql\u0026gt;droptableifexistsstuinfo;QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;createtablestuinfo(idint,stunamevarchar(20),genderchar(1),seatint,ageint,majoridint);QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;altertablestuinfomodifycolumnstunamevarchar(20)notnull;QueryOK,0rowsaffected(0.03sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;descstuinfo;+---------+-------------+------+-----+---------+-------+ |Field|Type|Null|Key|Default|Extra|+---------+-------------+------+-----+---------+-------+ |id|int|YES||NULL|||stuname|varchar(20)|NO||NULL|||gender|char(1)|YES||NULL|||seat|int|YES||NULL|||age|int|YES||NULL|||majorid|int|YES||NULL||+---------+-------------+------+-----+---------+-------+ 6rowsinset(0.00sec)mysql\u0026gt;altertablestuinfomodifycolumnageintdefeault18;mysql\u0026gt;altertablestuinfomodifycolumnageintdefault18;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;altertablestuinfomodifycolumnidintprimarykey;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0添加表级约束\nmysql\u0026gt;altertablestuinfoaddunique(seat);QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0添加外键\nmysql\u0026gt;altertablestuinfoaddconstraintfk_studentinfo_majorforeignkey(majorid)referencesmajor(id);QueryOK,0rowsaffected(0.05sec)Records:0Duplicates:0Warnings:0修改表时删除约束\n#取消非空约束mysql\u0026gt;altertablestuinfomodifycolumnstunamevarchar(20)null;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0#取消默认约束mysql\u0026gt;altertablestuinfomodifycolumnageint;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0#删除主键mysql\u0026gt;altertablestuinfodropprimarykey;QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0#删除唯一键mysql\u0026gt;altertablestuinfodropindexseat;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;showindexfromstuinfo;+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |stuinfo|1|fk_studentinfo_major|1|majorid|A|0|NULL|NULL|YES|BTREE|||YES|NULL|+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 1rowinset(0.01sec)#删除外键mysql\u0026gt;altertablestuinfodropforeignkeyfk_studentinfo_major;QueryOK,0rowsaffected(0.01sec)Records:0Duplicates:0Warnings:0练习一下 #添加主键约束mysql\u0026gt;createtableemp2(idint,constraintmy_emp_id_pkprimarykey(id));QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;usetest;Databasechanged#添加主键约束mysql\u0026gt;altertabledept2addconstraintmy_dept_id_pkprimarykey(department_id);QueryOK,0rowsaffected(0.03sec)Records:0Duplicates:0Warnings:0#拷贝数据和结构mysql\u0026gt;createtableemp2select*fromstudents.emp2;QueryOK,0rowsaffected(0.03sec)Records:0Duplicates:0Warnings:0mysql\u0026gt;showtables;+-------------------+ |Tables_in_test|+-------------------+ |dept1||dept2||emp2||emp5||int_zerofill||tab_char||tab_date||tab_float||tab_float_default||tab_int||tab_set||test_add_column|+-------------------+ 12rowsinset(0.00sec)mysql\u0026gt;altertableemp2addcolumndept_idint;QueryOK,0rowsaffected(0.02sec)Records:0Duplicates:0Warnings:0#添加外键约束mysql\u0026gt;altertableemp2addforeignkey(dept_id)referencesdept2(department_id);QueryOK,0rowsaffected(0.04sec)Records:0Duplicates:0Warnings:0表级约束和列级约束的区别\n​\t位置\t支持的约束类型\t是否可以起约束名\n列级约束 列的后面 支持所有语法,但是外键没有效果\t不可以起约束名\n表级约束 所有列的下面 默认和非空不支持,其他支持\t可以起约束名\n标识列 又称为自增长列\n可以不用手动的插入值，系统提供默认的序列值\n创建表时设置标识列\n特点\n 标识列必须和主键搭配吗？不一定，但要求是一个key 一个表可以有多少个标识列？至多一个 标识列的类型只能是数值型 一般是int 标识列可以通过 set auto_increment =3 ;设置步长 标识列可以通过手动的方式设置起始值  mysql\u0026gt;createtabletab_identity(idintprimarykey,namevarchar(20));QueryOK,0rowsaffected(0.02sec)mysql\u0026gt;insertintotab_identityvalue(1,\u0026#39;john\u0026#39;);QueryOK,1rowaffected(0.01sec)#不是自增的话，搞不定会主键重复的mysql\u0026gt;insertintotab_identityvalue(1,\u0026#39;john\u0026#39;);ERROR1062(23000):Duplicateentry\u0026#39;1\u0026#39;forkey\u0026#39;tab_identity.PRIMARY\u0026#39;mysql\u0026gt;droptableifexiststab_identity;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;createtabletab_identity(idintprimarykeyauto_increment,namevarchar(20));QueryOK,0rowsaffected(0.02sec)#可以给他不设置列值mysql\u0026gt;insertintotab_identity(name)values(\u0026#39;john\u0026#39;);QueryOK,1rowaffected(0.01sec)#或者可以给他设置为null就好了mysql\u0026gt;insertintotab_identityvalues(null,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintotab_identityvalues(null,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;insertintotab_identityvalues(null,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromtab_identity;+----+------+ |id|name|+----+------+ |1|john||2|jwt||3|jwt||4|jwt|+----+------+ 4rowsinset(0.00sec)mysql不支持设置起始的数值，但是可以通过取巧的办法手动设置\n#查看自增长变量mysql\u0026gt;showvariableslike\u0026#39;%auto_increment%\u0026#39;;+--------------------------+-------+ |Variable_name|Value|+--------------------------+-------+ |auto_increment_increment|1||auto_increment_offset|1|+--------------------------+-------+ 2rowsinset,1warning(0.00sec)#设置自增长的步长mysql\u0026gt;setauto_increment_increment=3;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;showvariableslike\u0026#39;%auto_increment%\u0026#39;;+--------------------------+-------+ |Variable_name|Value|+--------------------------+-------+ |auto_increment_increment|3||auto_increment_offset|1|+--------------------------+-------+ 2rowsinset,1warning(0.00sec)mysql\u0026gt;insertintotab_identityvalues(null,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromtab_identity;+----+------+ |id|name|+----+------+ |1|john||2|jwt||3|jwt||4|jwt||7|jwt|+----+------+ 5rowsinset(0.00sec)#手动设置起始值这样就可以达到效果了mysql\u0026gt;insertintotab_identityvalues(100,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromtab_identity;+-----+------+ |id|name|+-----+------+ |1|john||2|jwt||3|jwt||4|jwt||7|jwt||100|jwt|+-----+------+ 6rowsinset(0.00sec)mysql\u0026gt;insertintotab_identityvalues(null,\u0026#39;jwt\u0026#39;);QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromtab_identity;+-----+------+ |id|name|+-----+------+ |1|john||2|jwt||3|jwt||4|jwt||7|jwt||100|jwt||103|jwt|+-----+------+ 7rowsinset(0.00sec)修改表时设置标识列\naltertabletab_identitymodifycolumnidintprimarykeyauto_increment;修改表时删除标识列\naltertabletab_identitymodifycolumnidint;TCL Transaction Control Languaue 事务控制语言\n事务 一个或者一组sql语句组成一个执行单元,这个执行单元要么全部执行,要么全部不执行\n事务的特点\nACID\n 原子性 一个事务不可再分割,要么执行要么都不执行 一致性 一个事务执行会使数据从一个一致状态切换到另一个一致状态 持久性 一个事务的执行不受其他事务的干扰 隔离性 一个事务一旦提交,则会永久的改变数据库的数据  案例 转账\n事务:事务由单独单元的一个或多个语句组成,在这个单元中,每个mysql语句是相互以来的.而整个单独单元作为一个不可分割的整体,如果单元中某条sql语句一旦执行失败或产生错误,整个单元将会回滚.所有受到影响的数据将返回到事务开始以前的状态;如果单元中的所有sql语句均执行成功,则事务被顺利执行.\n存储引擎  概念:在mysql中的数据用各种不同的技术存储在文件(或内存)中 通过show engines 来查看mysql支持的存储引擎 在mysql中用的最多的存储引擎有 innodb myisam memory 等 其中innodb支持事务,而myisam/memory等不支持事务  mysql\u0026gt;showengines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ |Engine|Support|Comment|Transactions|XA|Savepoints|+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ |MEMORY|YES|Hashbased,storedinmemory,usefulfortemporarytables|NO|NO|NO||MRG_MYISAM|YES|CollectionofidenticalMyISAMtables|NO|NO|NO||CSV|YES|CSVstorageengine|NO|NO|NO||FEDERATED|NO|FederatedMySQLstorageengine|NULL|NULL|NULL||PERFORMANCE_SCHEMA|YES|PerformanceSchema|NO|NO|NO||MyISAM|YES|MyISAMstorageengine|NO|NO|NO||InnoDB|DEFAULT|Supportstransactions,row-levellocking,andforeignkeys|YES|YES|YES||BLACKHOLE|YES|/dev/nullstorageengine(anythingyouwritetoitdisappears)|NO|NO|NO||ARCHIVE|YES|Archivestorageengine|NO|NO|NO|+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9rowsinset(0.00sec)事务的ACID属性\n 原子性A 事务是一个不可分割的工作单位,事务中的操作要么都发生,要么都不发生 持久性D 持久性是指一个事务一旦被提交,它对数据库中数据的改变就是永久性的,接下来的其他操作和数据库故障不应该对其有任何影响 隔离性I 事务的隔离性是指一个事务的执行不能被其他事务干扰,即一个事务内部的操作及使用的数据对并发的其他事务是隔离的,并发执行的各个事务之间不能互相干扰 一致性C 事务必须使数据库从一个一致性状态变换到另一个一致性状态  事务的创建\n 隐式事务:事务没有明显的开启和结束的标记  比如insert / update / delete 语句\nmysql\u0026gt;showvariableslike\u0026#39;autocommit\u0026#39;;+---------------+-------+ |Variable_name|Value|+---------------+-------+ |autocommit|ON|+---------------+-------+ 1rowinset,1warning(0.00sec) 显式事务:事务具有明显的开启和结束标记 前提是必须先设置自动提交功能为禁用  #只是针对当前事务有效所以每次开启显式事务的时候都要手动的关闭自动提交功能setautocommit=0;步骤1 : 开启事务\nset autocommit = 0\nstart transaction ; 可选的\n步骤2 : 编写事务中的sql语句 select insert update delete \u0026hellip;\n语句1\n语句2\n\u0026hellip;\n步骤3 : 结束事务\ncommit ; 提交事务\nrollback ; 回滚事务\nsavepoint 节点名 ; 设置保存点\nmysql\u0026gt;createtableaccount(idintprimarykeyauto_increment,usernamevarchar(20),balancedouble);QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;insertintoaccount(username,balance)values(\u0026#39;张无忌\u0026#39;,1000),(\u0026#39;赵敏\u0026#39;,1000);QueryOK,2rowsaffected(0.00sec)Records:2Duplicates:0Warnings:0mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|张无忌|1000||4|赵敏|1000|+----+----------+---------+ 2rowsinset(0.00sec)#禁用自动提交开启事务mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)#开启事务mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;updateaccountsetbalance=500whereusername=\u0026#39;张无忌\u0026#39;;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0#在navicat里查看好像是10001000mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|张无忌|500||4|赵敏|1000|+----+----------+---------+ 2rowsinset(0.00sec)#回滚试了试mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)#是可以的mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|张无忌|1000||4|赵敏|1000|+----+----------+---------+ 2rowsinset(0.00sec)#体验一下事务mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;updateaccountsetbalance=500whereusername=\u0026#39;张无忌\u0026#39;;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0mysql\u0026gt;updateaccountsetbalance=1500whereusername=\u0026#39;赵敏\u0026#39;;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0#提交mysql\u0026gt;commit;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|张无忌|500||4|赵敏|1500|+----+----------+---------+ 2rowsinset(0.00sec)数据库的隔离级别   对于同时运行的多个事务,当这些事务访问数据库中相同的数据时,如果没有采取必要的隔离机制,就会导致各种并发问题\n 脏读:对于两个事务T1 , T2 ,T1读取了已经被T2更新,但是还没有被提交的字段,之后,若T2回滚,T1读取的内容就是临时且无效的 不可重复读:对于两个事务T1 , T2 , T1 读取了一个字段,然后T2 更新了该字段.之后,T1再次读取同一个字段,值就不同了 幻读:对于两个事务T1 , T2 , T1从一个表中读取了一个字段,然后T2在该表中插入了一些新的行.之后,如果T1再次读取同一个条,就会多出几行.    数据库事务的隔离性:数据库系统必须具有隔离并发运行各个事务的能力,使他们不会互相影响,避免各种并发问题.\n  一个事务与其他事务隔离的程度称为隔离级别.数据库规定了多种事务隔离级别,不同隔离级别对应不同的干扰程度,隔离级别越高,数据一致性就越好,但并发性就越弱\n  数据库提供的4中隔离级别\n read uncommitted(读未提交数据) 允许事务读取未被其他事务提交的变更.脏读/不可重复读/幻读的问题都会出现 read commit(读已经提交的数据) 只允许事务读取已经被其他事务提交的变更,可以避免脏读,但不可重复度和幻读的问题仍然可能出现 repeatable read(可重复读) 确保事务可以多次从一个字段中读取相同的值,在这个事务持续期间,禁止其他事务对这个字段进行更新.可以避免脏读和不可重复读,但幻读的问题仍然存在. serializable(串行化) 确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表执行插入,更新和删除操作.所有并发问题都可以避免,但性能十分低下    oracle支持的2种事务隔离级别:read commited , serializable . oracle默认的事务隔离级别为:read commited\n  mysql支持4种事务隔离级别 mysql默认的事务隔离级别为 repeatable read\n  测试一下read uncommitted\n#重启服务可以保证恢复默认的隔离级别吧好像PSC:\\Users\\Administrator.YOURTREEDAD\u0026gt;netstopmysql80此命令的语法是:NETSTOPservicePSC:\\Users\\Administrator.YOURTREEDAD\u0026gt;netstartmysql80请求的服务已经启动。请键入NETHELPMSG2182以获得更多的帮助。PSC:\\Users\\Administrator.YOURTREEDAD\u0026gt;mysql-uroot-pEnterpassword:******#查看隔离级别mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |REPEATABLE-READ|+-------------------------+ 1rowinset(0.00sec)#设置隔离级别为readuncommitted读未提交数据这样会导致脏读/不可重复读/幻读mysql\u0026gt;setsessiontransactionisolationlevelreaduncommitted;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |READ-UNCOMMITTED|+-------------------------+ 1rowinset(0.00sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)#看!还没提交mysql\u0026gt;updateaccountsetusername=\u0026#39;john\u0026#39;whereid=1;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0mysql\u0026gt;在另一个界面打开设置隔离级别为 read uncommitted\n就可以看到脏读的数据\n\rimage-20211002112133588\r\n假若原来的回滚了,那就离谱了\nmysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)\rimage-20211002112511055\r\n所以会出现脏读幻读不可重复读都可能出现在这种隔离级别下\n测试一下 read committed\nmysql\u0026gt;setsessiontransactionisolationlevelreadcommitted;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)#还没提交mysql\u0026gt;updateaccountsetusername=\u0026#39;john\u0026#39;whereid=1;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0\rimage-20211002113519057\r\n这边也确实在第二个事务中没有看到还没提交的数据\n但是!!! 但是 说明这可以避免脏读,但是不可重复读和幻读 嘿嘿!不行!\n\rimage-20211002113728187\r\n**测试一下 repeatable read **\nmysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |REPEATABLE-READ|+-------------------------+ 1rowinset(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|john|500||4|赵敏|1500|+----+----------+---------+ 2rowsinset(0.01sec)mysql\u0026gt;showvariableslike\u0026#39;autocommit\u0026#39;;+---------------+-------+ |Variable_name|Value|+---------------+-------+ |autocommit|ON|+---------------+-------+ 1rowinset,1warning(0.01sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)#更新还未提交mysql\u0026gt;updateaccountsetusername=\u0026#39;刘备\u0026#39;whereid=1;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0\rimage-20211002151741957\r完全没问题,避免了脏读\n#提交之后在看看mysql\u0026gt;commit;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|刘备|500||4|赵敏|1500|+----+----------+---------+ 2rowsinset(0.00sec)\rimage-20211002151946236\r\n下面演示一下为什么这种隔离级别会出现幻读\ncmd中开启事务,插入一条数据\n\rimage-20211002152534283\r\npowershell中开启事务,查询数据\nmysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)#暂时没查到mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|刘备|500||4|赵敏|1500|+----+----------+---------+ 2rowsinset(0.00sec)cmd中commit了\n\rimage-20211002152659690\r\n#sql中也没有问题保证数据一致性所以么有出现不可重复读不会多出来刚刚插入的那条数据mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|刘备|500||4|赵敏|1500|+----+----------+---------+ 2rowsinset(0.00sec)#但是!但是!下面出问题了本来希望在事务的开始的时候,表里有两条数据,我希望把两条数据的username改一下,但是这时候另一个事务中插入了一条在更新的时候把插入的也更新了username这样的话就裂开了出现幻读mysql\u0026gt;updateaccountsetusername=\u0026#39;mmm\u0026#39;;QueryOK,3rowsaffected(0.00sec)Rowsmatched:3Changed:3Warnings:0mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|mmm|500||4|mmm|1500||5|mmm|1000|+----+----------+---------+ 3rowsinset(0.00sec)\rimage-20211002153254274\r\n测试一下 serializable powershell中尝试开启事务 并且更新数据\nmysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;setsessiontransactionisolationlevelserializable;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |SERIALIZABLE|+-------------------------+ 1rowinset(0.00sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|mmm|500||4|mmm|1500||5|mmm|1000|+----+----------+---------+ 3rowsinset(0.00sec)mysql\u0026gt;updateaccountsetusername=\u0026#39;www\u0026#39;;这时还没有更新,cmd中开启了一个事务尝试往这张表中插入数据\n\rimage-20211002154329103\r\n这就会将表锁住,因为上一个事务在使用这张表,为了防止数据库出现幻读的操作,该隔离级别将表锁住了,这样子完全插入不了,做更新的时候就可以保证更新的数据条目和查出来的数据条目是一致的了.\n\rimage-20211002154520024\r\n在mysql中设置隔离级别  每启动一个mysql程序,就会获得一个单独的数据库连接.每个数据库连接都有一个全局变量@@tx_isolation,表示当前的事务隔离级别 查看当前的隔离级别: select @@tx_isolation ; 设置当前mysql连接的隔离级别: set transaction isolation level read committed ; 设置数据库系统的全局的隔离级别: set global transaction isolation level read committed ;  事务的隔离级别     脏读 不可重复读 幻读     read uncommitted 会 会 会   read committed 不会 会 会   repeated read 不会 不会 会   serializable 不会 不会 不会    mysql中默认的是repeated read ;\noracle中默认的是read committed\n查看 select @@transaction_isolation ;\n设置 set session/global transaction isolation level serilizable\u0026hellip;\ndelete和truncate的区别 mysql\u0026gt;showvariableslike\u0026#39;autocommit\u0026#39;;+---------------+-------+ |Variable_name|Value|+---------------+-------+ |autocommit|OFF|+---------------+-------+ 1rowinset,1warning(0.00sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)#删除数据mysql\u0026gt;deletefromaccount;QueryOK,3rowsaffected(0.00sec)#回滚mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.01sec)#数据还在mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|mmm|500||4|mmm|1500||5|mmm|1000|+----+----------+---------+ 3rowsinset(0.00sec)mysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)#删除数据mysql\u0026gt;truncateaccount;QueryOK,0rowsaffected(0.03sec)#回滚mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)#无法恢复mysql\u0026gt;select*fromaccount;Emptyset(0.01sec)savepoint的使用\nmysql\u0026gt;setautocommit=0;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;starttransaction;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;deletefromaccountwhereid=1;QueryOK,1rowaffected(0.00sec)mysql\u0026gt;deletefromaccountwhereid=2;QueryOK,1rowaffected(0.00sec)#设置保存点mysql\u0026gt;savepointa;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;deletefromaccountwhereid=3;QueryOK,1rowaffected(0.00sec)#回到保存点mysql\u0026gt;rollbacktoa;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |3|关羽|3000|+----+----------+---------+ 1rowinset(0.00sec)#还可以再回滚mysql\u0026gt;rollback;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select*fromaccount;+----+----------+---------+ |id|username|balance|+----+----------+---------+ |1|刘备|1000||2|张飞|2000||3|关羽|3000|+----+----------+---------+ 3rowsinset(0.00sec)视图 虚拟表,和普通表一样使用,通过普通表动态生成的数据\nmysql5.1开始提供视图功能.一种虚拟存在的表,行和列的数据来自定义视图的查询中使用的表,并且是在使用视图时动态生成的,只保存了sql逻辑,不保存查询结果\n 应用场景  多个地方用到了同样的查询结果 该查询结果使用的sql语句较为复杂    创建视图\n语法 create view 视图名 as 查询语句\nmysql\u0026gt;createviewinfoasselecte.last_name,d.department_name,j.*fromemployeesejoindepartmentsdone.department_id=d.department_idjoinjobsjonj.job_id=e.job_id;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frominfowherelast_namelike\u0026#39;%a%\u0026#39;;+------------+-----------------+------------+---------------------------------+------------+------------+ |last_name|department_name|job_id|job_title|min_salary|max_salary|+------------+-----------------+------------+---------------------------------+------------+------------+ |Kochhar|Exe|AD_VP|AdministrationVicePresident|15000|30000||DeHaan|Exe|AD_VP|AdministrationVicePresident|15000|30000|#查询各部门的平均工资级别mysql\u0026gt;selecta.department_id,g.grade_level,a.平均工资from(selecte.department_id,avg(salary)平均工资fromemployeesegroupbydepartment_id)ajoinjob_gradesgona.平均工资betweenlower_salandhighest_sal;+---------------+-------------+--------------+ |department_id|grade_level|平均工资|+---------------+-------------+--------------+ |NULL|C|7000.000000||10|B|4400.000000||20|C|9500.000000|#如果用视图来做简化一点点mysql\u0026gt;createviewmyv2asselecte.department_id,avg(salary)平均工资fromemployeesegroupbye.department_id;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;selectm.*,j.grade_levelfrommyv2mjoinjob_gradesjonm.平均工资betweenj.lower_salandj.highest_sal;+---------------+--------------+-------------+ |department_id|平均工资|grade_level|+---------------+--------------+-------------+ |NULL|7000.000000|C||10|4400.000000|B|#查询平均工资最低的部门信息mysql\u0026gt;select*fromdepartmentsdwhered.department_id=(selectdepartment_idfromemployeesegroupbye.department_idorderbyavg(salary)asclimit1);+---------------+-----------------+------------+-------------+ |department_id|department_name|manager_id|location_id|+---------------+-----------------+------------+-------------+ |50|Shi|121|1500|+---------------+-----------------+------------+-------------+ #使用视图mysql\u0026gt;select*fromdepartmentswheredepartment_id=(selectdepartment_idfrommyv2orderby平均工资limit1);+---------------+-----------------+------------+-------------+ |department_id|department_name|manager_id|location_id|+---------------+-----------------+------------+-------------+ |50|Shi|121|1500|+---------------+-----------------+------------+-------------+ #可以使用视图套视图视图的优点\n 重用sql语句 简化复杂的sql操作,不知道他的查询细节 保护数据,提高安全性  视图的修改\n 方式一  create or replace view 视图名 as 查询语句 ;\n 方式二  alter view 视图名 as 查询语句;\n视图的删除\ndrop view 视图名,视图名,\u0026hellip;\nmysql\u0026gt;dropviewemp_v1,emp_v2,info,myv2;QueryOK,0rowsaffected(0.01sec)查看视图\ndesc 视图名 ;\n查看具体的过程 show create view 视图名 ;\n练习一下 mysql\u0026gt;createorreplaceviewemp_v1asselectlast_name,salary,emailfromemployeeswherephone_numberlike\u0026#39;011%\u0026#39;;QueryOK,0rowsaffected(0.01sec)#创建视图要求查询部门的最高工资高于12000的部门信息mysql\u0026gt;createorreplaceviewemp_v2asselectd.*fromdepartmentsdjoinemployeeseone.department_id=d.department_idgroupbye.department_idhavingmax(salary)\u0026gt;12000;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*fromemp_v2;+---------------+-----------------+------------+-------------+ |department_id|department_name|manager_id|location_id|+---------------+-----------------+------------+-------------+ |90|Exe|100|1700||80|Sal|145|2500||20|Mar|201|1800|+---------------+-----------------+------------+-------------+ 视图的更新\n视图的插入\nmysql\u0026gt;createorreplaceviewmyv1asselectlast_name,emailfromemployees;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommyv1;+-------------+----------+ |last_name|email|+-------------+----------+ |K_ing|SKING||Kochhar|NKOCHHAR|#原始表也插入了张飞这条数据了mysql\u0026gt;insertintomyv1values(\u0026#39;张飞\u0026#39;,\u0026#39;101@qq.com\u0026#39;);QueryOK,1rowaffected(0.01sec)视图的更新\nmysql\u0026gt;updatemyv1setlast_name=\u0026#39;张无忌\u0026#39;wherelast_name=\u0026#39;张飞\u0026#39;;QueryOK,1rowaffected(0.01sec)Rowsmatched:1Changed:1Warnings:0#都会修改原始表视图的删除\nmysql\u0026gt;deletefrommyv1wherelast_name=\u0026#39;张无忌\u0026#39;;QueryOK,1rowaffected(0.01sec)#都会修改原始表通常情况下不会对视图进行增删改的操作的\n备注: 视图的可更新性和视图中查询的定义有关系,以下类型的视图是不能更新的\n 包含以下关键字的sql语句:分组函数/distinct/group by/having/union/union all 常量视图 select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表  #关键字的sql语句的视图不可以被更新mysql\u0026gt;createorreplaceviewmyv2asselectmax(salary)m,department_idfromemployeesgroupbydepartment_id;QueryOK,0rowsaffected(0.01sec)#想想也是,怎么能简单的更新一下max(salary)呢,聚合函数的值是算出来的mysql\u0026gt;updatemyv2setm=9000wheredepartment_id=10;ERROR1288(HY000):Thetargettablemyv2oftheUPDATEisnotupdatable#常量视图不能修改mysql\u0026gt;createorreplaceviewmyv3asselect\u0026#39;john\u0026#39;name;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommyv3;+------+ |name|+------+ |john|+------+ 1rowinset(0.00sec)mysql\u0026gt;updatemyv3setname=\u0026#39;lucy\u0026#39;;ERROR1288(HY000):Thetargettablemyv3oftheUPDATEisnotupdatable#select中包含子查询的不能修改视图mysql\u0026gt;createorreplaceviewmyv4asselect(selectmax(salary)fromemployees)最高工资;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommyv4;+----------+ |最高工资|+----------+ |24000.00|+----------+ 1rowinset(0.01sec)mysql\u0026gt;updatemyv4set最高工资=10000;ERROR1288(HY000):Thetargettablemyv4oftheUPDATEisnotupdatable#join中不能更新视图mysql\u0026gt;createorreplaceviewmyv5asselectlast_name,department_namefromemployeesejoindepartmentsdone.department_id=d.department_id;QueryOK,0rowsaffected(0.01sec)#可以更新mysql\u0026gt;updatemyv5setlast_name=\u0026#39;张飞\u0026#39;wherelast_name=\u0026#39;Whalen\u0026#39;;QueryOK,1rowaffected(0.00sec)Rowsmatched:1Changed:1Warnings:0#不能插入,可能是因为两个视图中有一个是department_id是主键叭mysql\u0026gt;insertintomyv5values(\u0026#39;陈真\u0026#39;,\u0026#39;xxxx\u0026#39;);ERROR1394(HY000):Cannotinsertintojoinview\u0026#39;myemployees.myv5\u0026#39;withoutfieldslist#由一个不可更新的视图构成的视图不可更新mysql\u0026gt;createorreplaceviewmyv6asselect*frommyv4;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommyv6;+----------+ |最高工资|+----------+ |24000.00|+----------+ 1rowinset(0.01sec)mysql\u0026gt;updatemyv6set最高工资=20000;ERROR1288(HY000):Thetargettablemyv6oftheUPDATEisnotupdatable#where子句的子查询引用了from子句中的表相当于自连接mysql\u0026gt;createorreplaceviewmyv7asselectlast_name,email,salaryfromemployeeswhereemployee_idin(selectmanager_idfromemployeeswheremanager_idisnotnull);QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;select*frommyv7;+-----------+----------+----------+ |last_name|email|salary|+-----------+----------+----------+ |K_ing|SKING|24000.00||DeHaan|LDEHAAN|17000.00||Hunold|AHUNOLD|9000.00||Kochhar|NKOCHHAR|17000.00||Greenberg|NGREENBE|12000.00||Raphaely|DRAPHEAL|11000.00||Weiss|MWEISS|8000.00||Fripp|AFRIPP|8200.00||Kaufling|PKAUFLIN|7900.00||Vollman|SVOLLMAN|6500.00||Mourgos|KMOURGOS|5800.00||Russell|JRUSSEL|14000.00||Partners|KPARTNER|13500.00||Errazuriz|AERRAZUR|12000.00||Cambrault|GCAMBRAU|11000.00||Zlotkey|EZLOTKEY|10500.00||Hartstein|MHARTSTE|13000.00||Higgins|SHIGGINS|12000.00|+-----------+----------+----------+ 18rowsinset(0.00sec)mysql\u0026gt;updatemyv7setsalary=10000wherelast_name=\u0026#39;K_ing\u0026#39;;ERROR1288(HY000):Thetargettablemyv7oftheUPDATEisnotupdatable视图和表的对比     创建语法的关键字 是否实际占用物理空间 使用     视图 create view 只是保存了sql逻辑 增删改查,只是一般不能增删改   表 create table 保存了数据 增删改查    delete和truncate在事务使用时的区别  delete可以回滚 truncate不能回滚  练习一下 #添加约束创建表但是这样列级约束中外键是不起作用的mysql\u0026gt;createtableBook(bidintprimarykey,bnamevarchar(200)notnullunique,pricefloatdefault(10),btypeIdintreferencesbooktype(id));QueryOK,0rowsaffected(0.03sec)#这里发现索引只有主键和唯一键mysql\u0026gt;showindexfrombook;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |book|0|PRIMARY|1|bid|A|0|NULL|NULL||BTREE|||YES|NULL||book|0|bname|1|bname|A|0|NULL|NULL||BTREE|||YES|NULL|+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 2rowsinset(0.01sec)#所以要改成这样mysql\u0026gt;createtableBook(bidintprimarykey,bnamevarchar(200)notnullunique,pricefloatdefault(10),btypeIdint,foreignkey(btypeId)referencesbookType(id));QueryOK,0rowsaffected(0.03sec)mysql\u0026gt;showindexfrombook;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |Table|Non_unique|Key_name|Seq_in_index|Column_name|Collation|Cardinality|Sub_part|Packed|Null|Index_type|Comment|Index_comment|Visible|Expression|+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ |book|0|PRIMARY|1|bid|A|0|NULL|NULL||BTREE|||YES|NULL||book|0|bname|1|bname|A|0|NULL|NULL||BTREE|||YES|NULL||book|1|btypeId|1|btypeId|A|0|NULL|NULL|YES|BTREE|||YES|NULL|+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+ 3rowsinset(0.01sec)mysql\u0026gt;createorreplaceviewmyvbookasselectbname,namefrombookbjoinbooktypetonb.btypeid=t.idwhereprice\u0026gt;100;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;createorreplaceviewmyvbook1asselectbname,pricefrombookwherepricebetween90and120;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;dropviewmyvbook,myvbook1;QueryOK,0rowsaffected(0.01sec)复习前一天内容 DDL语言\n常见的约束\nNOT NULL 非空,该字段的值必填\nDEFAULT 默认,该字段的值不用手动插入有默认值\nCHECK 检查 mysql不支持\nPRIMARY KEY 主键 该字段的值不可重复并且非空 unique+not null\nFOREIGN KEY 外键 该字段的值引用了另外的表的字段\nUNIQUE 唯一 该字段的值不可重复\n主键和唯一的区别\n 一个表至多有一个主键 , 但可以有多个唯一键 主键不允许为空 , 唯一可以为空 都具有唯一性,都支持组合键 , 但不推荐  外键\n 用于限制两个表的关系,从表的字段引用了主表的某字段值 要求外键列和主表的被引用列要求类型一致,意义一样,名称无要求 主表的被引用列要求是一个key(一般就是主键) 插入数据,先插入主表 删除数据,先删除从表  级联删除\n实际上就是在删除主表里的数据的时候,把从表里相关的带有该数据的行也一并删除\n#级联删除altertablestuinfoaddconstraintfk_stu_majorforeignkey(majorid)referencesmajor(id)ondeletecascade;级联置空\n实际上就是在删除主表里的数据的时候,把从表里相关的带有该数据的行的对应字段置为空\n#级联置空altertablestuinfoaddconstraintfk_stu_majorforeignkey(majorid)referencesmajor(id)ondeletesetnull;创建表时添加约束\ncreatetable表名(字段名字段类型notnull,字段名字段类型primarykey,字段名字段类型unique,字段名字段类型default,constraint约束名foreignkey(字段名)references主表(被引用列))**注意:\t**\n    支持类型 可以起约束名字     列级约束 除了外键 不可以   表级约束 除了默认,非空 可以,但是对主键无效    列级约束可以在一个字段上追加多个,中间用空格隔开,没有顺序要求\n修改表时添加或删除约束\n非空\nalter table 表名 modify column 字段名 字段类型 not null ;\n删除非空\nalter table 表名 modify column 字段名 字段类型 ;\n默认\nalter table 表名 modify column 字段名 字段类型 default 值 ;\n删除默认\nalter table 表名 modify column 字段名 字段类型;\n主键\nalter table 表名 add primary key (字段名) ;\n删除主键\nalter table 表名 drop primary key ;\n唯一\nalter table 表名 add unique (字段名) ;\n删除\nalter table 表名 drop index 索引名 ;\n外键\nalter table 表名 add foreign key (字段名) references 主表 (被引用列) ;\n删除外键\nalter table 表名 drop foreign key 约束名 ;\n自增长列\n特点\n 不用手动插入值 , 可以自动提供序列值,默认从1开始,步长为1 auto_increament_increment 如果要更改起始值:手动插入值 如果要更改步长:更改系统变量 set auto_increment_increment = 值 ; 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key  创建表时设置自增长列\ncreate table 表\n修改表时设置自增长列\ncreate table 表 modify column 字段名 字段类型 约束 auto_increment ;\n删除自增长列\nalter table 表 modify column 字段名 字段类型 约束\nTCL语言\n事务:一条或多条sql语句组成一个执行单位,一组sql句要么都执行要么都不执行\n特点(ACID)\n 原子性 一个事务是不可再分割的整体,要么都执行要么都不执行 一致性 一个事务可以使数据从一个一致状态切换到另一个一致的状态 隔离性 一个事务不受其他事务的干扰,多个事务互相隔离的 持久性 一个事务一旦提交了,则永久的持久化到本地  事务的使用步骤\n了解:\n 隐式事务(自动事务) 没有明显的开始和结束,本事就是一条事务可以自动提交,比如insert update delete 显式事务 具有明显的开启和结束  使用显式事务\n 开启事务 set autocommit = 0 start transacton ; 可以省略 编写逻辑sql语句 一条或者多条 注意 不包含create alter drop 只支持insert update delete select 设置回滚点 savepoint 回滚点名 ; 结束事务  提交 commit 回滚 rollback 回滚点 rollback to 回滚点名;    并发事务  事务的并发问题是如何发生的  多个事务同时操作同一个数据库的相同数据时\n 并发问题有哪些  脏读 一个事务读取了其他事务还没有提交的数据 读到的是其他事务\u0026quot;更新\u0026quot;的数据 不可重复读 一个事务多次读取结果不一样 重复读取可能造成数据不一致的现象 幻读 一个事务读取了其他事务还没有提交的数据 只是读到的是 其他事务\u0026quot;插入\u0026quot;的数据   如何解决并发问题  通过设置隔离级别来解决   隔离级别 脏读 不可重复读 幻读  read uncommitted 读未提交 会 会 会 read committed 读已提交 不会 会 会 (oracle默认) repeatted read 可重复读 不会 不会 会 (msyql默认) serializable 串行化 不会 不会 不会    视图 含义 mysql5.1版本出现的新特性 , 本身是一个虚拟表,是通过表数据动态生成的,查看时动态生成\n好处\n 简化sql语句 封装重用 保护了基表的数据,提高了安全性  创建\ncreate or replace view 视图名 as select \u0026hellip;\u0026hellip;\n修改\ncreate or replace view 视图名 as select \u0026hellip;..\nalter view 视图名 as select \u0026hellip;.\n删除\ndrop view 视图名,视图名\u0026hellip;\n查看\ndesc 视图名\nshow create view 视图名\n使用\ninsert delete update select\n**注意:\t**视图一般用于查询的,而不是更新的,所以具备以下的视图都不允许更新\n 带有 group by 分组函数 union having where后的子查询用到了from中的表 常量视图 从不可更新的视图中生成的视图 join  视图和表的区别\n view 和 table 视图占用较少物理空间 表占用实际数据 视图一般用于查询 表用于增删改查  变量  系统变量  全局变量 会话变量   自定义变量  用户变量 局部变量    系统变量 说明:变量由系统提供,不是用户定义,属于服务器层面\n使用的语法:\n 查看所有的系统变量 show golbal/session variables ; session是默认的 查看满足条件的部分系统变量 show global/session variables like \u0026lsquo;%char%\u0026rsquo; ; 查看指定的某个系统变量的值 select @@global/session.系统变量名字 ; session是默认的 为某个系统变量赋值  方式一 set global/session 系统变量名 = 值 ; 方式二 set @@global/session.系统变量名 = 值;    showglobalvariables;mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |REPEATABLE-READ|+-------------------------+ 1rowinset(0.00sec)注意\n如果是全局级别,则需要加global , 如果是会话级别,则需要加session , 如果不写, 则默认\n全局变量\n作用域:服务器每次启动将为所有的全局变量赋初始值,针对所有的会话连接有效,但不能跨重启\nshow gloabl variables ;\n查看部分的全局变量\nshow global variables ; show variables like \u0026lsquo;%char%\u0026rsquo; ;\n查看指定的全局变量的值\nselect @@global.autocommit ;\n为某个指定的全局变量赋值\nmysql\u0026gt; set @@global.autocommit = 0 ; Query OK, 0 rows affected (0.00 sec)\n会话变量\n作用域:仅仅针对于当前会话(连接)有效\n查看所有的会话变量\nshow session variables ;\nshow variables ;\n查看部分的会话变量\nshow variables like \u0026lsquo;%char%\u0026rsquo; ;\nshow session variables like \u0026lsquo;%char%\u0026rsquo; ;\n查看指定的某个会话变量\nselect @@transaction_isolation ;\nselect @@session.transaction_isolation ;\n为某个会话变量赋值\n方式一\nmysql\u0026gt; set @@session.transaction_isolation = \u0026lsquo;read-committed\u0026rsquo; ; Query OK, 0 rows affected (0.00 sec)\n方式二\nmysql\u0026gt; set session transaction isolation level read uncommitted ; Query OK, 0 rows affected (0.00 sec)\n方式三\nset session transaction_isolation = \u0026lsquo;serializable\u0026rsquo; ;\nmysql\u0026gt;showvariableslike\u0026#39;%char%\u0026#39;;+--------------------------+---------------------------------------------------------+ |Variable_name|Value|+--------------------------+---------------------------------------------------------+ |character_set_client|gbk||character_set_connection|gbk||character_set_database|utf8mb4||character_set_filesystem|binary||character_set_results|gbk||character_set_server|utf8mb4||character_set_system|utf8mb3||character_sets_dir|C:\\ProgramFiles\\MySQL\\MySQLServer8.0\\share\\charsets\\|+--------------------------+---------------------------------------------------------+ 8rowsinset,1warning(0.00sec)mysql\u0026gt;showsessionvariableslike\u0026#39;%char%\u0026#39;;+--------------------------+---------------------------------------------------------+ |Variable_name|Value|+--------------------------+---------------------------------------------------------+ |character_set_client|gbk||character_set_connection|gbk||character_set_database|utf8mb4||character_set_filesystem|binary||character_set_results|gbk||character_set_server|utf8mb4||character_set_system|utf8mb3||character_sets_dir|C:\\ProgramFiles\\MySQL\\MySQLServer8.0\\share\\charsets\\|+--------------------------+---------------------------------------------------------+ 8rowsinset,1warning(0.00sec)mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |REPEATABLE-READ|+-------------------------+ 1rowinset(0.00sec)mysql\u0026gt;select@@session.transaction_isolation;+---------------------------------+ |@@session.transaction_isolation|+---------------------------------+ |REPEATABLE-READ|+---------------------------------+ 1rowinset(0.00sec)mysql\u0026gt;setsessiontransactionisolationlevelreaduncommitted;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;set@@session.transaction_isolation=\u0026#39;read-committed\u0026#39;;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select@@transaction_isolation;+-------------------------+ |@@transaction_isolation|+-------------------------+ |READ-COMMITTED|+-------------------------+ 1rowinset(0.00sec)mysql\u0026gt;setsessiontransaction_isolation=\u0026#39;serializable\u0026#39;;QueryOK,0rowsaffected(0.00sec)自定义变量 说明:变量是用户自定义的,不是由系统生成的\n使用步骤:声明=\u0026gt;赋值=\u0026gt;使用(查看/比较/运算等)\n用户变量\n作用域:针对当前会话(连接)有效,同于会话变量的作用域 , 应用在任何地方,也就是begin end里面或者begin end 外面\n赋值操作符 =或者 :=\n声明并初始化 set @用户变量名 = 值 | set@用户变量名 :=值 | select @用户变量名:=值\n赋值\n 方式一 set @用户变量名 = 值 | set@用户变量名 :=值 | select @用户变量名:=值 方式二 通过 select into select 字段 into 变量名 from 表  使用\nselect @用户变量名\nmysql\u0026gt;set@name:=\u0026#39;ljs\u0026#39;;QueryOK,0rowsaffected(0.00sec)#弱类型mysql\u0026gt;set@name=1997;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;set@count=1;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;usemyemployees;Databasechanged#方式二mysql\u0026gt;selectcount(*)into@countfromemployees;QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select@name;+-------+ |@name|+-------+ |1997|+-------+ 1rowinset(0.00sec)mysql\u0026gt;select@count;+--------+ |@count|+--------+ |107|+--------+ 1rowinset(0.00sec)局部变量 作用域:仅仅在定义它的begin end中有效\n应用在begin end 中的第一句话!!!\n声明\ndeclare 变量名 类型 ;\ndeclare 变量名 类型 default 值;\n赋值\n方式一\nset 局部变量名 = 值;\n方式二\nset 局部变量名 := 值 ;\n方式三\nselect @局部变量名 := 值 ;\n方式四\nselect 值 into @局部变量名 from 表 ;\n使用\nselect 局部变量名 ;\n对比用户变量和局部变量\n    作用域 定义和使用的位置 语法     用户变量 当前会话 会话中的任何地方 需要加上@符号,不用限定类型   局部变量 begin end 中 只能在begin end中,且为第一句话 一般不用加上@符号,除非select,需要限定类型    #使用用户变量mysql\u0026gt;set@a:=1;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;selectb1into@bfrom(select1b1)b;QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select@b+@a;+-------+ |@b+@a|+-------+ |2|+-------+ #只能在beginend中才行mysql\u0026gt;declaremintdefault1;ERROR1064(42000):YouhaveanerrorinyourSQLsyntax;checkthemanualthatcorrespondstoyourMySQLserverversionfortherightsyntaxtousenear\u0026#39;declare m int default 1\u0026#39;atline1存储过程和函数 存储过程和函数:类似与java中的方法\n好处:\n 提高代码的重用性 简化操作  存储过程\n含义:一组预先编译豪的sql语句的集合,理解成批处理语句\n好处:\n 提高了代码的重用性 简化操作 减少了编译次数并减少了和数据库服务器的连接次数,提高了效率  创建语法\ncreate procedure 存储过程名(参数列表)\nbegin\n​\t存储过程体(一组合法的sql语句)\nend\n注意:\n  参数列表包含三部分 参数模式 参数名 参数类型\n IN stuname varchar(20) 参数模式  IN 该参数可以作为输入,也就是该参数需要调用方传入值 OUT 该参数可以作为输出,也就是该参数可以作为返回值 INOUT 该参数既可以作为输入又可以作为输出,也就是该参数既需要传入值,又可以返回值      如果存储过程体仅仅只有一句话 , begin end 可以省略\n存储过程体中的每条sql语句的结尾要求必须加分号;\n存储过程的结尾可以使用 DELIMITER重新设置\n语法:\nDELIMITER 结束标记\nDELIMITER $\n  调用语法\nCALL 存储过程名 (实参列表) 结束标记;\n空参列表 #实现批量插入数据mysql\u0026gt;showprocedurestatuslike\u0026#39;myp1\u0026#39;;+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ |Db|Name|Type|Definer|Modified|Created|Security_type|Comment|character_set_client|collation_connection|DatabaseCollation|+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ |girls|myp1|PROCEDURE|root@localhost|2021-10-1010:19:11|2021-10-1010:19:11|DEFINER||gbk|gbk_chinese_ci|utf8_general_ci|+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ 1rowinset(0.01sec)mysql\u0026gt;usegirls;Databasechanged#写错了就把存储过程删了重来mysql\u0026gt;dropproceduremyp1;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;showprocedurestatuslike\u0026#39;myp1\u0026#39;;Emptyset(0.01sec)mysql\u0026gt;delimiter$mysql\u0026gt;createproceduremyp1()-\u0026gt;begin-\u0026gt;insertintoadmin(username,password)-\u0026gt;values(\u0026#39;ljs\u0026#39;,\u0026#39;11\u0026#39;),(\u0026#39;jwt\u0026#39;,\u0026#39;22\u0026#39;),(\u0026#39;lje\u0026#39;,\u0026#39;33\u0026#39;),(\u0026#39;fyz\u0026#39;,\u0026#39;44\u0026#39;),(\u0026#39;wzr\u0026#39;,\u0026#39;55\u0026#39;);-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;showprocedurestatuslike\u0026#39;myp1\u0026#39;$;+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ |Db|Name|Type|Definer|Modified|Created|Security_type|Comment|character_set_client|collation_connection|DatabaseCollation|+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ |girls|myp1|PROCEDURE|root@localhost|2021-10-1011:33:35|2021-10-1011:33:35|DEFINER||gbk|gbk_chinese_ci|utf8_general_ci|+-------+------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ 1rowinset(0.01sec)#执行存储过程mysql\u0026gt;CALLmyp1()$;QueryOK,5rowsaffected(0.00sec)mysql\u0026gt;select*fromadmin$;+----+----------+----------+ |id|username|password|+----+----------+----------+ |1|john|8888||2|lyt|6666||3|ljs|11||4|jwt|22||5|lje|33||6|fyz|44||7|wzr|55|+----+----------+----------+ 7rowsinset(0.00sec)创建带IN模式参数的存储过程 #查看女神的男朋友mysql\u0026gt;DELIMITER$;mysql\u0026gt;createproceduremyp2(INgirlNamevarchar(20))-\u0026gt;begin-\u0026gt;selectbo.*fromboysborightjoinbeautybonbo.id=b.boyfriend_id-\u0026gt;whereb.name=girlName;-\u0026gt;end$;QueryOK,0rowsaffected(0.01sec)-\u0026gt;$ERROR1065(42000):Querywasemptymysql\u0026gt;CALLmyp2(\u0026#39;柳岩\u0026#39;);-\u0026gt;$+------+---------+--------+ |id|boyName|userCP|+------+---------+--------+ |2|张飞|10|+------+---------+--------+ 1rowinset(0.01sec)QueryOK,0rowsaffected,1warning(0.01sec)#传入多个参数,判断用户是否登陆成功方式一mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp3(INusernamevarchar(20),INpasswordvarchar(20))-\u0026gt;begin-\u0026gt;selectcasewhencount(*)\u0026gt;0then\u0026#39;登陆成功\u0026#39;else\u0026#39;未登陆\u0026#39;end登陆状态fromadminwhereadmin.username=usernameandadmin.password=password;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;callmyp3(\u0026#39;john\u0026#39;,\u0026#39;8888\u0026#39;)$;+----------+ |登陆状态|+----------+ |登陆成功|+----------+ 1rowinset(0.00sec)mysql\u0026gt;callmyp3(\u0026#39;john\u0026#39;,\u0026#39;8887\u0026#39;)$;+----------+ |登陆状态|+----------+ |未登陆|+----------+ 1rowinset(0.00sec)#方式二使用局部变量mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp4(inusernamevarchar(20),inpasswordvarchar(20))-\u0026gt;begin-\u0026gt;declareresultvarchar(20)default\u0026#39;\u0026#39;;-\u0026gt;selectcount(*)intoresultfromadminwhereadmin.username=usernameandadmin.password=password;-\u0026gt;selectif(result=\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;);-\u0026gt;end$;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyp4(\u0026#39;john\u0026#39;,\u0026#39;8888\u0026#39;)$;+-------------------------------------+ |if(result=\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;)|+-------------------------------------+ |登陆成功|+-------------------------------------+ 1rowinset(0.00sec)QueryOK,0rowsaffected,2warnings(0.00sec)mysql\u0026gt;CALLmyp4(\u0026#39;john\u0026#39;,\u0026#39;88887\u0026#39;)$;+-------------------------------------+ |if(result=\u0026#39;0\u0026#39;,\u0026#39;未登陆\u0026#39;,\u0026#39;登陆成功\u0026#39;)|+-------------------------------------+ |未登陆|+-------------------------------------+ 1rowinset(0.00sec)QueryOK,0rowsaffected(0.01sec)创建带out模式的存储过程 #根据女神名,返回对应男神名mysql\u0026gt;DELIMITER$mysql\u0026gt;CREATEproceduremyp5(inbeautynamevarchar(20),outboynamevarchar(20))-\u0026gt;begin-\u0026gt;selectbo.boynameintoboynamefromboysbowherebo.idin(selectboyfriend_idfrombeautywherename=beautyname);-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)#不用初始化也是可以的mysql\u0026gt;set@boyname:=\u0026#39;\u0026#39;;-\u0026gt;callmyp5(\u0026#39;柳岩\u0026#39;,@boyname)$;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select@boyname;-\u0026gt;$+----------+ |@boyname|+----------+ |张飞|+----------+ 1rowinset(0.00sec)#多个out返回值,返回男朋友的名字和魅力值mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp6(ingirlnamechar(20),outboynamechar(20),outsoulIndexint)-\u0026gt;begin-\u0026gt;selectbo.boyname,bo.usercpintoboyname,soulIndexfromboysbojoinbeautybonb.boyfriend_id=bo.idwhereb.name=girlname;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;callmyp6(\u0026#39;柳岩\u0026#39;,@boyname,@soulIndex)$;QueryOK,1rowaffected,2warnings(0.00sec)mysql\u0026gt;select@boyname$+----------+ |@boyname|+----------+ |张飞|+----------+ 1rowinset(0.00sec)mysql\u0026gt;select@soulIndex$+------------+ |@soulIndex|+------------+ |10|+------------+ 1rowinset(0.00sec)创建带INOUT模式参数的存储过程 mysql\u0026gt;DELIMITER$mysql\u0026gt;CREATEproceduremyp7(inoutaint,inoutbint)-\u0026gt;begin-\u0026gt;seta=a*2;-\u0026gt;setb=b*2;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;set@a:=1;-\u0026gt;set@b:=2;-\u0026gt;CALLmyp7(@a,@b)$;QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;select@a,@b;-\u0026gt;$+------+------+ |@a|@b|+------+------+ |2|4|+------+------+ 1rowinset(0.00sec)练习一下\n#传入用户名密码,插入admin表mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp8(inusernamevarchar(20),inpasswordvarchar(20))-\u0026gt;begin-\u0026gt;insertintoadmin(admin.username,admin.password)values(username,password);-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyp8(\u0026#39;wlz\u0026#39;,\u0026#39;hellouu\u0026#39;)$QueryOK,1rowaffected,2warnings(0.00sec)#查询传入女神编号,返回女神名称和女神电话mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp9(inidint,outgirlnamevarchar(20),outphonevarchar(11))-\u0026gt;begin-\u0026gt;selectb.name,b.phoneintogirlname,phonefrombeautybwhereb.id=id;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyp9(1,@girlname,@phone)$QueryOK,1rowaffected,2warnings(0.00sec)mysql\u0026gt;select@girlname,@phone$+-----------+-------------+ |@girlname|@phone|+-----------+-------------+ |柳岩|18209876577|+-----------+-------------+ 1rowinset(0.00sec)#比较两个日期大小并返回大小关系mysql\u0026gt;DELIMITER$mysql\u0026gt;createproceduremyp10(inbirth1datetime,inbirth2datetime,outresultint)-\u0026gt;begin-\u0026gt;selectif(datediff(birth1,birth2)\u0026gt;0,1,if(datediff(birth1,birth2)\u0026lt;0,-1,0))intoresult;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyp10(\u0026#39;1997-11-21\u0026#39;,\u0026#39;1998-11-21\u0026#39;,@result)$QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select@result$+---------+ |@result|+---------+ |-1|+---------+ 1rowinset(0.00sec)删除存储过程\ndrop procedure 存储过程名 一次只能删除一次\n查看存储过程的信息\nshow create proceduce 存储过程名\n修改存储过程\n比较麻烦,通常不这么做\n练习一下\n#传入日期,转换成xx年xx月xx日并返回mysql\u0026gt;createproceduremyptest1(inmydatedatetime,outstrDatevarchar(50))-\u0026gt;begin-\u0026gt;selectdate_format(mydate,\u0026#39;%y年%m月%d日\u0026#39;)intostrDate;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyptest1(\u0026#39;1997-11-21\u0026#39;,@strDate);-\u0026gt;select@strDate$QueryOK,1rowaffected,1warning(0.00sec)+--------------+ |@strDate|+--------------+ |97年11月21日|+--------------+ 1rowinset(0.00sec)#传入女神名字输出女神名字and男生名字最好使用右连接另外concat和null拼接永远都是null所以要用ifnull的函数防止出问题mysql\u0026gt;delimiter$mysql\u0026gt;createproceduremyptest2(inoutgirlNamevarchar(50))-\u0026gt;selectconcat(b.name,\u0026#39; AND \u0026#39;,bo.boyName)intogirlNamefrombeautybjoinboysboonb.boyfriend_id=bo.idwhereb.name=girlName;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;set@name:=\u0026#39;柳岩\u0026#39;;-\u0026gt;CALLMYPTEST2(@name);-\u0026gt;select@name$QueryOK,0rowsaffected(0.00sec)QueryOK,1rowaffected(0.00sec)+---------------+ |@name|+---------------+ |柳岩AND张飞|+---------------+ 1rowinset(0.00sec)#传入条目数和起始索引,查询beauty表的记录limitoffset,size是从offset的下一条开始的mysql\u0026gt;delimiter$mysql\u0026gt;createproceduremyptest3(insizeint,instartIndexint)-\u0026gt;begin-\u0026gt;select*frombeautylimitstartIndex,size;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;CALLmyptest3(5,3)$+----+--------+------+---------------------+-------------+--------------+--------------+ |id|name|sex|borndate|phone|photo|boyfriend_id|+----+--------+------+---------------------+-------------+--------------+--------------+ |5|周冬雨|女|1992-02-0300:00:00|18209179577|NULL|2||7|岳灵珊|女|1987-12-3000:00:00|18219876577|NULL|2||9|双儿|女|1993-02-0300:00:00|18209876579|NULL|2||11|夏雪|女|1993-02-0300:00:00|18209876579|NULL|2||13|唐艺昕|女|1990-04-2300:00:00|18988888|NULL|2|+----+--------+------+---------------------+-------------+--------------+--------------+ 5rowsinset(0.00sec)QueryOK,0rowsaffected(0.02sec)函数 含义:一组预先编译豪的sql语句的集合,理解成批处理语句\n好处:\n 提高了代码的重用性 简化操作 减少了编译次数并减少了和数据库服务器的连接次数,提高了效率  区别:\n存储过程:可以有0个返回,也可以有多个返回,适合做批量插入/批量更新\n函数:有且仅有1个返回,适合做处理数据后返回一个结果\n创建语法\ncreate function 函数名 (参数列表) return 返回类型\nbegin\n​\t函数体\nend\n注意:\n  参数列表 包含两部分\n参数名 参数类型\n  函数体:肯定会有return语句,如果没有会报错\n如果return语句没有放在函数体的最后也不报错,但不建议\nreturn 值;\n  函数体中仅有一句话,则可以省略begin end\n  使用delimeter语句作为设置结束标记\n  调用语法\nselect 函数名(参数列表)\n无参有返回\n#返回公司的员工个数#和存储过程不一样这里要声明局部变量最后一句需要return一下#mysql中要改一下全局变量这是我们开启了bin-log,我们就必须指定我们的函数是否是mysql\u0026gt;setgloballog_bin_trust_function_creators=1;-\u0026gt;$QueryOK,0rowsaffected(0.00sec)mysql\u0026gt;delimiter$mysql\u0026gt;createfunctionmyf1()returnsint-\u0026gt;begin-\u0026gt;declarecountintdefault0;-\u0026gt;selectcount(*)intocountfromemployees;-\u0026gt;returncount;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)#使用的时候用select关键字mysql\u0026gt;selectmyf1()$+--------+ |myf1()|+--------+ |107|+--------+ 1rowinset(0.00sec)有参有返回\n#根据员工名,返回他的工资mysql\u0026gt;delimiter$mysql\u0026gt;createfunctionmyf3(departmentnamevarchar(20))returnsdouble(10,2)-\u0026gt;begin-\u0026gt;set@avgsalary:=0;-\u0026gt;selectavg(salary)into@avgsalaryfromemployeesgroupbydepartment_idhavingdepartment_idin(selectdepartment_idfromdepartmentswheredepartment_name=departmentname);-\u0026gt;return@avgsalary;-\u0026gt;end$QueryOK,0rowsaffected,1warning(0.01sec)mysql\u0026gt;selectmyf3(\u0026#39;Adm\u0026#39;);-\u0026gt;$+-------------+ |myf3(\u0026#39;Adm\u0026#39;)|+-------------+ |4400.00|+-------------+ 1rowinset(0.00sec)查看函数 show create function myf3;\n删除函数\ndrop function myf3 ;\n存储过程和函数都在information_schema中的routines表中\n\rimage-20211010170437148\r\n练习一下\n#传入两个float的值返回一个和mysql\u0026gt;delimiter$mysql\u0026gt;createfunctiontest_func1(afloat,bfloat)returnsfloat-\u0026gt;begin-\u0026gt;declaresumfloatdefault0;-\u0026gt;setsum=a+b;-\u0026gt;returnsum;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;selecttest_func1(1,2)$+-----------------+ |test_func1(1,2)|+-----------------+ |3|+-----------------+ 1rowinset(0.00sec)mysql\u0026gt;selecttest_func1(1.1,-1.1)$+----------------------+ |test_func1(1.1,-1.1)|+----------------------+ |0|+----------------------+ 1rowinset(0.00sec)流程控制结构 顺序结构:程序从上往下依次执行\n分支结构:程序从两条或多条路径中选择一条去执行\n循环结构:程序在满足一定条件的基础上,重复执行一段代码\n分支结构  if函数  功能:实现简单的双分支\n语法:\nif(表达式1,表达式2,表达式3)\n如果表达式1成立,则if函数返回表达式2的值,否则返回表达式3的值\n应用:任何地方\n case结构  情况1:类似于java中的switch语句,一般用于实现等值判断\ncase 表达式|字段|变量\nwhen 要判断的值 then \u0026hellip; 或语句1 ;\nwhen 要判断的值 then \u0026hellip; 或语句2 ;\nelse \u0026hellip; 或语句n ;\nend case ;\n情况2:类似于java中的多重if语句,一般用于实现区间判断\ncase\nwhen 要判断的条件1 then \u0026hellip; 或语句1 ;\nwhen 要判断的表达式2 then \u0026hellip; 或语句2 ;\nelse \u0026hellip; 或语句n ;\nend case ;\n特点:\n 可以作为表达式,嵌套在其他语句中使用,可以放在任何地方,begin end 中或者begin end 的外面 可以作为独立的语句去使用,只能放在begin end 中 如果when中的值或条件成立,则执行对应的then后面的语句,并且结束case 如果都不满足,则执行else中的语句或值 else可以省略,如果else省略了,并且所有when条件都不满足,则返回null  \rimage-20211010203810756\r\n\rimage-20211010203829794\r\n案例\n#90-100显示A80-90显示B60-80显示C其余显示Dmysql\u0026gt;createproceduretest_case(inscoreint)-\u0026gt;begin-\u0026gt;casewhenscore\u0026gt;=90andscore\u0026lt;=100-\u0026gt;thenselect\u0026#39;A\u0026#39;;-\u0026gt;whenscore\u0026gt;=80andscore\u0026lt;90-\u0026gt;thenselect\u0026#39;B\u0026#39;;-\u0026gt;whenscore\u0026gt;=60andscore\u0026lt;80-\u0026gt;thenselect\u0026#39;C\u0026#39;;-\u0026gt;elseselect\u0026#39;D\u0026#39;;-\u0026gt;endcase;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;calltest_case(95)$+---+ |A|+---+ |A|+---+ 1rowinset(0.00sec)QueryOK,0rowsaffected(0.00sec)if结构 功能:实现多重分支\n语法:\nif 条件1 then 语句1 ;\nelse if 条件2 then 语句2 ;\n\u0026hellip;\nelse 语句n ;\nend if ;\n应用在begin end 中\n案例\n#90-100返回A80-90返回B60-80返回C其余返回D#方式一可以这样直接returnmysql\u0026gt;createfunctiontest_if(scoreint)returnsvarchar(20)-\u0026gt;begin-\u0026gt;ifscore\u0026gt;=90andscore\u0026lt;=100-\u0026gt;thenreturn\u0026#39;A\u0026#39;;-\u0026gt;elseifscore\u0026gt;80-\u0026gt;thenreturn\u0026#39;B\u0026#39;;-\u0026gt;elseifscore\u0026gt;60-\u0026gt;thenreturn\u0026#39;C\u0026#39;;-\u0026gt;else-\u0026gt;return\u0026#39;D\u0026#39;;-\u0026gt;endif;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)#或者用原始的这样这里注意endif一定要有封号!!!!mysql\u0026gt;createfunctiontest_id1(scoreint)returnsvarchar(20)-\u0026gt;begin-\u0026gt;set@grade:=\u0026#39;\u0026#39;;-\u0026gt;ifscore\u0026gt;=90andscore\u0026lt;100-\u0026gt;thenset@grade=\u0026#39;A\u0026#39;;-\u0026gt;elseifscore\u0026gt;80-\u0026gt;thenset@grade=\u0026#39;B\u0026#39;;-\u0026gt;elseifscore\u0026gt;60-\u0026gt;thenset@grade=\u0026#39;C\u0026#39;;-\u0026gt;else-\u0026gt;set@grade=\u0026#39;D\u0026#39;;-\u0026gt;endif;-\u0026gt;return@grade;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)循环结构 分类:\n while loop repeat  循环控制:\niterate类似于continue ,结束本次循环,继续下一次\nleave 类似于 break , 跳出,结束当前所在的循环\n while  [标签:] while 循环条件 do\n​\t循环体\nend while [标签]\n loop  [标签:] loop\n​\t循环体\nend loop [标签]\n可以用来模拟简单的死循环\n repeat  [标签:] repeat\n​\t循环体\nuntil 结束循环的条件\nend repeat [标签]\n案例\n#批量插入根据次数插入到admin中多条记录mysql\u0026gt;createprocedurepro_while1(ininsertcountint)-\u0026gt;begin-\u0026gt;declareiintdefault0;-\u0026gt;whilei\u0026lt;insertcountdo-\u0026gt;insertintoadmin(id,username,password)values(null,concat(\u0026#39;rose\u0026#39;,i),666);-\u0026gt;seti=i+1;-\u0026gt;endwhile;-\u0026gt;end$QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;callpro_while1(3)$QueryOK,1rowaffected(0.00sec)mysql\u0026gt;select*fromadmin;-\u0026gt;$+----+----------+----------+ |id|username|password|+----+----------+----------+ |1|john|8888||2|lyt|6666||9|rose0|666||10|rose1|666||11|rose2|666|+----+----------+----------+ 11rowsinset(0.00sec)#添加leave语句#批量插入,根据次数插入到admin表中多条记录,如果次数\u0026gt;20就停止注意安全if语句没写好一直在循环插入了300w条数据mysql\u0026gt;createproceduretest_whileleave(ininsertcountint)-\u0026gt;begin-\u0026gt;declareiintdefault0;-\u0026gt;a:whilei\u0026lt;insertcountdo-\u0026gt;ifi=20thenleavea;-\u0026gt;endif;-\u0026gt;insertintoadmin(username,password)values(concat(\u0026#39;xiaohua\u0026#39;,i),\u0026#39;0000\u0026#39;);-\u0026gt;seti=i+1;-\u0026gt;endwhilea;-\u0026gt;end#QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;calltest_whileleave(30)#QueryOK,1rowaffected(0.03sec)#添加iterate##批量插入,根据次数插入到admin表中多条记录,并且插入奇数mysql\u0026gt;createproceduretest_iterate(ininsertcountint)-\u0026gt;begin-\u0026gt;declareiintdefault1;-\u0026gt;a:whilei\u0026lt;=insertcountdo-\u0026gt;ifmod(i,2)!=1thenseti=i+1;iteratea;-\u0026gt;else-\u0026gt;insertintoadmin(username,password)values(concat(\u0026#39;jishu\u0026#39;,i),\u0026#39;1111\u0026#39;);-\u0026gt;seti=i+1;-\u0026gt;endif;-\u0026gt;endwhilea;-\u0026gt;end#QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;calltest_iterate(20)#QueryOK,1rowaffected(0.02sec)\rimage-20211010222825964\r\n练习一下 #新建表然后像该表插入指定个数的,随机字符串mysql\u0026gt;createtableifnotexistsstringcontent(idintprimarykeyauto_increment,contentvarchar(20));QueryOK,0rowsaffected,1warning(0.01sec)mysql\u0026gt;createproceduretest_randstr_insert(ininsertcountint)-\u0026gt;begin-\u0026gt;declareiintdefault0;-\u0026gt;declarestrvarchar(26)default\u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;;-\u0026gt;declarestartIndexintdefault1;-\u0026gt;declarelenintdefault1;-\u0026gt;whilei\u0026lt;insertcountdo-\u0026gt;setstartIndex=floor(rand()*26+1);-\u0026gt;setlen=floor(rand()*(20-startindex+1)+1);-\u0026gt;insertintostringcontent(content)values(substr(str,startIndex,len));-\u0026gt;seti=i+1;-\u0026gt;endwhile;-\u0026gt;end#QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;calltest_randstr_insert(10)#QueryOK,1rowaffected(0.02sec)mysql\u0026gt;select*fromstringcontent#+----+--------------+ |id|content|+----+--------------+ |1|klm||2|hijklmn||3|pqr||4|no||5|rs||6|abcde||7|bcdefghijklm||8|||9|f||10|lmn|+----+--------------+ 10rowsinset(0.00sec)复习一下 分类:\n系统变量\n说明:变量由系统提供的,不用自定义\n语法:\n 查看系统变量  show global|session variables ;如果没有显式声明,那默认是session   查看指定的系统变量的值  select @@global|session.变量名 ;   为系统变量赋值  set gloabl|session 变量名 = 值 ; set @@global.变量名 = 值 ; set @@变量名 = 值;     全局变量 服务器层面上的,必须拥有super权限才能为系统变量赋值,作用域为整个服务器,也就是针对于所有连接(会话)有效,服务器重启后失效(除非修改配置) 会话变量  服务器为每一个连接的客户端都提供了系统变量,作用域为当前的连接(会话)    自定义变量\n说明:\n用户变量\n  作用域：针对于当前连接(会话)生效\n  位置:begin end 里面, 也可以放在外面\n  使用\n  声明并赋值\n set @变量名 = 值; set @变量名:= 值; select @变量名:=值 ;    更新值\n set @变量名 = 值; set @变量名:= 值; select @变量名:=值 ; select xx into @变量名 from 表 ;    使用\n select @变量名 ;    局部变量\n 作用域:仅仅在定义它的begin end 中有效 位置:只能放在begin end 中， 而且只能放在第一句 create procedure pro1() begin declare i int default 1 ; \u0026hellip; end 声明  declare 变量名 类型 default 值;   赋值或更新  set 变量名=值; set 变量名:= 值; select @变量名 := 值; select xx into 变量名 from 表 ;   使用  select 变量名 ;    存储过程和函数\n说明:都类似于java中的方法,将一组完成特定功能的逻辑语句包装起来,对外暴露名字\n好处:\n 提高重用性 sql语句简单 减少了和数据库服务器连接的次数,提高了效率  创建\ncreate procedure 存储过程名 (参数模式 参数名 参数类型)\nbegin\n存储过程体\nend\n 注意:参数模式 in out inout 其中IN可以省略 存储过程体中的每一条sql语句都需要分号结尾  调用\nCALL 存储过程名(实参列表)\n调用in模式的参数 call sp1(\u0026lsquo;值\u0026rsquo;) ;\n调用out模式的参数 set @name :=\u0026quot;\u0026quot; ; call sp1(@name) ;\n调用inout模式的参数 set @name = 值 ; call sp1(@name) ; select @name ;\n查看存储过程\nshow create procedure 存储过程名 ;\n删除存储过程\ndrop procedure 存储过程名 ;\n函数\n创建\ncreate function 函数名 (参数名 参数类型) returns 返回值类型\nbegin\ndeclare a int default 0 ;\n\u0026hellip;\nreturn a ;\nend\n**注意:\t**函数体中肯定需要有return语句\n调用\nselect 函数名 (实参列表) ;\n查看 show create function 函数名 ;\n删除\ndrop functioon 函数名 ;\n流程控制结构\n顺序结构 :程序从上往下依次执行 ;\n分支结构:: 程序按条件进行选择执行, 从两条或多条路径中选择一条执行 ;\n循环结构: 程序满足一定条件下,重复执行一组语句\n分支结构\n if函数  功能:简单实现双分支 if(条件, 值1 , 值2 ) 位置:任何位置   case 结构  功能:实现多分支 case 表达式字段 when 值1 then \u0026hellip; when 值2 then \u0026hellip; else \u0026hellip; end [case]; 位置:可以放在任何位置, 如果放在begin end 外面,作为表达式结合着其他语句使用 , 如果放在begin end 里面, 一般作为独立的语句使用   if结构  功能:实现多分支 if 条件1 then \u0026hellip;; elseif 条件2 then \u0026hellip;; else then \u0026hellip; ; end if ; 位置: 只能放在begin end中    循环结构\n注意:只能放在begin end 中\n特点:都能实现循环结构\n对比:\n 这三种循环都可以省略名称,但如果循环中添加了循环控制语句(leave或iterate)则必须添加名称 loop 一般用于实现简单的死循环 while先判断后执行 repeat 先执行后判断,无条件至少执行一次    while\n  [标签:] while 循环条件 do\n循环体\nend while [标签] ;\n    loop\n  [标签:] loop\n循环体\nend loop [标签]\n    repeat\n  [标签:] repeat\n循环体\nuntil 结束条件\nend repeat [名称]\n    循环控制语句\nleave:类似于 break , 用于跳出所在的循环\niterate:类似于continue , 用于结束本次循环, 继续下一次\n完结撒花😋😜💕🤣\n","date":"2021-10-10T23:44:44+08:00","permalink":"https://linjianshu.github.io/p/mysql%E5%9F%BA%E7%A1%80/","title":"Mysql基础"},{"content":"致中山樵 ​\t我想告诉你\n​\t任何故土的消息\n​\t好也罢坏也罢\n​\t我想告诉你\n​\t碧云寺的彩塑依旧\n​\t钟山却已初秋\n​\t我想告诉你\n​\t故国的消息\n​\t风也好雨也好\n​\t祖国已思念她的游子多时\n​\t殊不知你已与这片大地相濡以沫\n​\t我想告诉你\n​\t才人的汹涌\n​\t如山间的松涛\n​\t一年胜过一年\n​\t我想告诉你\n​\t这盛世已定\n​\t你若在\n​\t太容易泪湿满襟\n​\t姓名:林健树\n​\t学院:机械工程学院\n​\t年级:20级033班\n​\t专业:工业工程与管理\n​\t学生类别:全日制\n😜💖💕😋\n","date":"2021-10-09T10:57:55+08:00","permalink":"https://linjianshu.github.io/p/%E8%AE%B0%E8%BE%9B%E4%BA%A5%E9%9D%A9%E5%91%BD110%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E6%9C%89%E6%84%9F/","title":"记辛亥革命110周年大会有感"},{"content":"数据结构与算法 解决问题方法的效率，跟数据的组织方式有关。\n循环和递归\n解决问题方法的效率，跟空间的利用效率有关。\n\rimage-20210818161452286\r\n\rimage-20210818162018882\r\n解决问题方法的效率，跟算法的巧妙程度有关\n数据结构 数据对象在计算机中的组织方式\n 逻辑结构：线性结构和树结构、图结构 物理存储结构：数组、链表  数据对象必定与一系列加在其上的操作相关联\n完成这些操作所用的方法就是算法\n抽象数据类型(Abstract Data Type)  数据类型  数据对象集 数据集合相关联的操作集   抽象：描述数据类型的方法不依赖于具体实现  与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关    只描述数据对象集和相关操作集是什么，并不涉及如何做到的问题\n抽象 \rimage-20210818163548512\r\n算法  一个有限指令集 接收一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须  有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖与任何一种计算机语言以及具体的实现手段    \rimage-20210818164049310\r\n什么是好算法  空间复杂度sn  根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。\n 时间复杂度Tn  根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。\n递归的时候会占用内存，因为递归下一层的时候要暂存上一层的结果\nSn = C*N\n\rimage-20210818164648695\r\n加减比乘除算的快\n\rimage-20210818164842726\r\n在分析一般算法的效率时，我们经常关注下面两种复杂度\n 最坏情况复杂度T worst(n) 平均复杂度T avg(n)  基本上就是第一种：最坏情况复杂度\n\rimage-20210818165255964\r\n\rimage-20210818165445992\r\n\rimage-20210818165457903\r\n\rimage-20210818165643710\r\n\rimage-20210818165759487\r\n\rimage-20210818191956566\r\n\rimage-20210818193405280\r\n\rimage-20210818193945679\r\n\rimage-20210818194726647\r\n什么是线性表 多项式表示问题的启示  同一个问题可以有不同的表示（存储）方法 有一类共性问题：有序线性序列的组织和管理  线性表 由同类型数据元素构成有序序列的线性结构\n 表中元素个数成为线性表的长度 线性表没有元素时，称为空表 表起始位置称表头，表结束位置称表尾  \rimage-20210818195144256\r\n链式存储实现\n\rimage-20210818200032485\r\n广义表  广义表是线性表的推广 对于线性表而言，n个元素都是基本的单元素 广义表中，这些元素不仅可以是单元素也可以是另一个广义表  \rimage-20210818201230986\r\n多重链表 多重链表：链表中的节点可能同时隶属于多个链\n 多重链表中结点的指针域会有多个，如前面例子包含了netx和sublist两个指针域 但包含两个指针域的链表并不一定是多重链表，比如在双向链表不是多重链表  多重链表有广泛的用途：\n基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储\n堆栈 \rimage-20210818203628155\r\n堆栈stack ：具有一定操作约束的线性表\n 只有一端（栈顶，top）做插入、删除 插入数据：push入栈 删除数据：pop出栈 后入先出：LIFO  \rimage-20210818203949646\r\n\rimage-20210818204030156\r\n中缀表达式转成后缀表达式\n\rimage-20210818210009984\r\n\r\n堆栈的其他应用：\n 函数调用及递归实现 深度优先搜索 回溯算法  队列及实现\n队列：queue具有一定操作约束的线性表\n 插入和删除操作：只能在一端插入，而在另一端删除 数据插入 入队列 AddQ 数据删除 出队列DeleteQ 先来先服务 先进先出 FIFO  \rimage-20210819200815843\r\n\rimage-20210819200925663\r\n\rimage-20210819201437552\r\n\rimage-20210819201758339\r\n\rimage-20210819202139270\r\n\rimage-20210819202326934\r\n\rimage-20210819203439780\r\n\rimage-20210819203707397\r\n什么是树 分层次组织在管理上具有更高的效率\n数据管理的基本操作之一：查找\n如何实现有效率的查找\nsearching\n\rimage-20210819205601090\r\n\rimage-20210819205951769\r\n二分查找\n\rimage-20210819210521234\r\n\rimage-20210819211054628\r\n\rimage-20210819212247115\r\n\rimage-20210819212402458\r\n\rimage-20210819212620945\r\n\rimage-20210819212737409\r\n\rimage-20210819213128752\r\n\rimage-20210819213227642\r\n\rimage-20210819213322280\r\n\rimage-20210819213454497\r\n\rimage-20210819214643681\r\n\rimage-20210819214812719\r\n\rimage-20210819215245013\r\n\rimage-20210819215345900\r\n\rimage-20210819215519052\r\n\rimage-20210819220012636\r\nDBEFAGHCI\n\rimage-20210819220312388\r\nDEFBHGICA\n\rimage-20210819220547376\r\n路线是一样的， 第一次碰到就输出的叫做先序、第二次的叫做中序、第三次的叫做后序\n\rimage-20210819220744178\r\n\rimage-20210822092825462\r\n\rimage-20210822093926951\r\n​\t\rimage-20210822094347290\r\n\rimage-20210822094920689\r\n\rimage-20210822095028474\r\n\rimage-20210822095125615\r\n\rimage-20210822095254235\r\n\rimage-20210822095400071\r\rimage-20210822095400133\r\n\rimage-20210822095600852\r\n\rimage-20210822095753944\r\n\rimage-20210822095955430\r\n\rimage-20210822100108869\r\n\rimage-20210822100248441\r\n判断同构\n\rimage-20210822100435562\r\n\rimage-20210822100843208\r\n\rimage-20210822101301912\r\n判断有没有哪个节点没有被指向 哪个节点就是根\n例如231被指向了,那么意思就是0这个节点是根节点\n\rimage-20210822101644943\r\n\rimage-20210822101656356\r\n\rimage-20210822102023363\r\n使用check来判断根节点\n\rimage-20210822102155154\r\n\rimage-20210822102200845\r\n\rimage-20210822102407846\r\n\rimage-20210822102550689\r\n\rimage-20210822102618697\r\n\rimage-20210822102638201\r\n\rimage-20210822102736696\r\n尾递归可以用循环实现\n\rimage-20210822102824536\r\n查找的效率决定于树的高度\n\rimage-20210822102911459\r\n\rimage-20210822102930132\r\n\rimage-20210822103127572\r\n\rimage-20210822103450196\r\n​\t\rimage-20210822103701343\r\n\rimage-20210822103721215\r\n\rimage-20210822103850804\r\n\rimage-20210822104154455\r\n\rimage-20210822104407357\r\n\rimage-20210822104658392\r\n\rimage-20210822105311867\r\n\rimage-20210822105726331\r\n所以走台阶问题我大概懂了\n只能一次走一阶台阶或者一次走两阶台阶\n一阶台阶有1种走法\n二阶台阶有2种走法\n那么三阶台阶无非就是1阶台阶的走法+走2阶的走法(2)\n或者2阶台阶的走法+走1阶的走法(1)\n那么四阶台阶无非就是2阶台阶的走法+走2阶的走法(2)\n或者3阶台阶的走法+走1阶的走法(1)\n所以也就是斐波那契数列的性质\nF(n)=F(n-1)+1+F(n-2)+2\n\rimage-20210822110716637\r\n\rimage-20210822111522588\r\n\rimage-20210822112334232\r\n\rimage-20210822112657646\r\n必须保证是查找树 也就是左边小右边大\n\rimage-20210822113538123\r\n\rimage-20210822113732802\r\n\rimage-20210822113938703\r\n\rimage-20210822114002650\r\n\rimage-20210822114101318\r\n\rimage-20210822114324854\r\n\rimage-20210822114521287\r\n\rimage-20210822114826316\r\n\rimage-20210822115039320\r\n\rimage-20210822151804901\r\n\rimage-20210822151947780\r\n\rimage-20210822152334294\r\n\rimage-20210822152933725\r\n\rimage-20210822153108950\r\n\rimage-20210822153304689\r\n\rimage-20210822153425949\r\n\rimage-20210822153713250\r\n\rimage-20210822153929001\r\n实现堆用完全二叉树\n根节点是最大的完全二叉树\n\rimage-20210822154053219\r\n\rimage-20210822154254474\r\n\rimage-20210822154337334\r\n\rimage-20210822154516519\r\n\rimage-20210822154705009\r\n\rimage-20210822154842548\r\ni/2就是完全二叉树的父节点\n\rimage-20210822155046618\r\n\rimage-20210822155243748\r\n因为是完全二叉树,所以要用最后一个元素替补删除掉的那个元素,才能满足完全二叉树的性质\n\rimage-20210822155357876\r\n时间复杂性就是树的高度 log2n\n\rimage-20210822160108019\r\n\rimage-20210822160408516\r\n\rimage-20210822160720461\r\n从倒数第二层开始建立堆,建完之后逐层往上建立,\n\rimage-20210822160834924\r\n\rimage-20210822160855127\r\n\rimage-20210822161110159\r\n\rimage-20210822161247647\r\n\rimage-20210822161303788\r\n如何根据节点不同的查找效率构造更有效的搜索树\n\rimage-20210822161422536\r\n\rimage-20210822161529534\r\n\rimage-20210822161639103\r\n\rimage-20210822161818080\r\n\rimage-20210822161934722\r\n由于度为1的节点就是只有一个儿子的节点\n没有度为1的节点\n那么就是n2+n1+n0=n0-1+0+n0=2n0-1\n\rimage-20210824222513996\r\n\rimage-20210824222657220\r\n第二种的意思是, 我用2的三次方也就是8种不同的符号来表示7个字符绰绰有余\n\rimage-20210824222809811\r\n\rimage-20210824222844586\r\n当所以的值都在叶节点上的时候就不可能出现一个字符的编码是另一个字符的前缀\n\rimage-20210824223228402\r\n\rimage-20210824223351755\r\n\rimage-20210824223520102\r\n\rimage-20210824223656627\r\n用数组实现\n\rimage-20210824223823443\r\n\rimage-20210824224033563\r\n\rimage-20210824224257684\r\n\rimage-20210824224312615\r\n这样做会导致一边倒,会让高度增加 find操作很难效率查\n可以尝试把集合小的挂到集合大的下面\n\rimage-20210824224547703\r\n\rimage-20210824225642477\r\n\rimage-20210824230108245\r\n\rimage-20210824230311976\r\n直接简化成把值为3对应为下标为3的数组中的,数组里存的值是他的父节点\n\rimage-20210824230758030\r\n\rimage-20210824231016070\r\n\rimage-20210824231230324\r\n\rimage-20210824231506693\r\n\rimage-20210824231623358\r\n\rimage-20210824232012169\r\n\rimage-20210824232158793\r\n\rimage-20210824232344637\r\n\rimage-20210824232443313\r\n\rimage-20210824232956745\r\n\rimage-20210824233747366\r\n\rimage-20210824233929998\r\n\rimage-20210827150052047\r\n\rimage-20210827150132906\r\n\rimage-20210827150336396\r\n无向图 对称 那么会不会空间浪费呢\n\rimage-20210827151040590\r\n\rimage-20210827161401937\r\n\rimage-20210827161523060\r\n\rimage-20210827161721941\r\n\rimage-20210827161814110\r\n\rimage-20210827162026003\r\n访问完所有的之后一定是原路返回\n\rimage-20210827162605593\r\n利用堆栈\n\rimage-20210827163115572\r\n明白为啥是深度优先了\n\rimage-20210827163414973\r\n会走的比较深\n一圈一圈的搜索\n\rimage-20210827163440795\r\n\rimage-20210827163728923\r\n\rimage-20210827163907704\r\n\rimage-20210827164150229\r\n\rimage-20210827164252208\r\n\rimage-20210827164800507\r\n\rimage-20210827165034266\r\n\rimage-20210827165238415\r\n六度空间\n\rimage-20210827165619918\r\n\rimage-20210827165905518\r\n","date":"2021-09-01T00:22:19+08:00","permalink":"https://linjianshu.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"数据结构与算法学习文档"},{"content":"Go语言学习 alt+enter\nctrl+space\nctrl+shift+space\nctrl+alt+L\nctrl+alt+M重构\nF2查看错误\nalt+6查看问题\nctrl+shift+/\nalt+F8 评估表达式\nctrl+F8 切换断点\n环境搭建，编译之后生成可执行exe文件，就可以直接使用了\n\rimage-20210725102106105\r\n\rimage-20210725102139391\r\n编译\n使用 go build\n1.在项目目录下执行go build\n2.在其他路径下执行go build ，需要在后面加上项目的路径（项目路径从gopath/src后开始写起，编译之后的可执行文件就保存在当前目录下）\n3.go build -o hello.exe\ngo run\n像执行脚本文件一样执行go代码\ngo install\n分为两步：\n1.先编译得到一个可执行文件\n2.将可执行文件拷贝到gopath的bin目录\n交叉编译，可以跨平台跑程序\n例如在windows平台编译一个能在linux平台上执行的可执行文件\n这个似乎要在源文件位置处使用cmd命令操作,并且要用大写!!!\nE:\\project\\GOproject\\code.oldboyedu.com\\day1\u0026gt;SET CGO_ENABLE=0 E:\\project\\GOproject\\code.oldboyedu.com\\day1\u0026gt;SET GOOS=linux E:\\project\\GOproject\\code.oldboyedu.com\\day1\u0026gt;SET GOARCH=amd64 E:\\project\\GOproject\\code.oldboyedu.com\\day1\u0026gt;go build \rimage-20210725103733683\r\ngo语言的基本结构\npackage main //导入的包 import \u0026#34;fmt\u0026#34; //程序的入口函数 //函数外部只能放置标识符（变量、常量、函数、类型）的声明 func main() { fmt.Println(\u0026#34;hello world\u0026#34;) } 变量和常量\ngo语言中的变量必须先声明后使用\nvar s1 string :声明一个保存字符串数据的变量\nvar name string\nvar age int\nvar isOk bool\npackage main import \u0026#34;fmt\u0026#34; var name string var age int var isOk bool //批量声明 var ( name1 string age1 int isOk1 bool ) func main() { fmt.Println(name1) fmt.Println(age1) fmt.Println(isOk1) name1 = \u0026#34;linjianshu\u0026#34; age1 = 16 isOk1 = true //go语言中推荐使用驼峰命名 \t//go语言中非全局变量声明必须使用，不用就编译不过去 \tfmt.Println(name1) fmt.Println(age1) fmt.Println(isOk1) fmt.Printf(\u0026#34;name:%s\u0026#34;,name1) //%s占位符，使用name1这个变量去替换这个占位符  //声明变量同时赋值 \tvar studentName string = \u0026#34;ljs\u0026#34; //类型推导 \tvar studentName1 = \u0026#34;ljs\u0026#34; fmt.Println(studentName) fmt.Println(studentName1) //简短变量声明 := 只能在函数里面使用 \tstudentName2 := \u0026#34;jwt\u0026#34; fmt.Println(studentName2) x,_ :=foo() fmt.Println(x) x1 := 0 x1,_ =foo() fmt.Println(x1) } func foo() (int, string) { return 10,\u0026#34;ljs\u0026#34; } 匿名变量 用_来接收，表示我不用这个变量，匿名变量不占用命名空间，不会分配内存，所以匿名变量不存在重复声明\n注意：1.函数外的每个语句都必须以关键字开始2.同一个作用域{}中不能重复声明同名的变量\n常量\niota\nioto是go语言的常量计数器，只能在常量表达式中使用\niota在const关键字出现的时候被重置为0. const中每新增一行常量声明将使iota计数一次iota可理解为const语句块中的行索引 使用iota能简化定义，在定义枚举时很有用\npackage main import \u0026#34;fmt\u0026#34; //常量 const pi = 3.1415926 //常量定义了之后不能修改 //在程序运行期间不会改变  //批量声明常量时，如果某一行没有赋值，默认就和上一行一致 const ( pi1 = pi pi2 pi3 ) const ( i1 = iota i2 i3 ) const ( n1 = iota n2 _ n3 ) //插队 const ( k1 = iota k2 = 100 k3 k4 =iota k5 ) const ( p1,p2 = iota+1,iota+2 p3,p4 = iota+1,iota+2 ) //定义数量级 const ( _ = iota KB = 1\u0026lt;\u0026lt;(10 * iota) MB = 1\u0026lt;\u0026lt;(10 * iota) GB = 1\u0026lt;\u0026lt;(10 * iota) TB = 1\u0026lt;\u0026lt;(10 * iota) ) func main() { // 不可以 pi = 12.3 \tfmt.Println(\u0026#34;pi2:\u0026#34;,pi2) fmt.Println(\u0026#34;i1:\u0026#34;,i1) fmt.Println(\u0026#34;i2:\u0026#34;,i2) fmt.Println(\u0026#34;i3:\u0026#34;,i3) fmt.Println(\u0026#34;n1:\u0026#34;,n1) fmt.Println(\u0026#34;n2:\u0026#34;,n2) fmt.Println(\u0026#34;n3:\u0026#34;,n3) fmt.Println(\u0026#34;k1:\u0026#34;,k1) fmt.Println(\u0026#34;k2:\u0026#34;,k2) fmt.Println(\u0026#34;k3:\u0026#34;,k3) fmt.Println(\u0026#34;k4:\u0026#34;,k4) fmt.Println(\u0026#34;k5:\u0026#34;,k5) fmt.Println(\u0026#34;p1:\u0026#34;,p1) fmt.Println(\u0026#34;p2:\u0026#34;,p2) fmt.Println(\u0026#34;p3:\u0026#34;,p3) fmt.Println(\u0026#34;p4:\u0026#34;,p4) fmt.Println(\u0026#34;kb:\u0026#34;,KB) fmt.Println(\u0026#34;mb:\u0026#34;,MB) fmt.Println(\u0026#34;gb:\u0026#34;,GB) fmt.Println(\u0026#34;tb:\u0026#34;,TB) } 关键字和标识符\ngo语言有25个关键字\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var\n基本数据类型\n整型\n整型分为以下两大类：按长度分为：int8 , int16 , int32 ,int64 对应的无符号整型：uint8 , uint16 ,uint32\n其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型\n特殊整型\nuint根据电脑位数来搞\nint根据电脑位数来搞\nuintptr无符号整数，用于存放一个指针\npackage main import \u0026#34;fmt\u0026#34; func main() { i1 := 10 fmt.Printf(\u0026#34;%d\\n\u0026#34;,i1) fmt.Printf(\u0026#34;%o\\n\u0026#34;,i1) //把十进制转成8进制 \tfmt.Printf(\u0026#34;%b\\n\u0026#34;,i1) //把十进制转成2进制 \tfmt.Printf(\u0026#34;%x\\n\u0026#34;,i1) //把十进制转成16进制  //八进制 \ti2 := 077 fmt.Printf(\u0026#34;%d\\n\u0026#34;,i2) //十六进制 \ti3:= 0x123 fmt.Printf(\u0026#34;%d\\n\u0026#34;,i3) fmt.Printf(\u0026#34;%T\\n\u0026#34;,i1) //声明一个int8类型的 要明确指定类型，都则就是int类型 \ti4:= int8(9) fmt.Println(i4) } 浮点型\npackage main import \u0026#34;fmt\u0026#34; //float func main() { //maxFloat32 := math.MaxFloat32 最大值 \tf1:=1.23 //默认go语言中的小数都是float64类型 \tfmt.Printf(\u0026#34;%T\\n\u0026#34;,f1) //显式声明float32类型 \tf2:=float32(1.23) fmt.Printf(\u0026#34;%T\\n\u0026#34;,f2) f1 = float64(f2) //不能隐式转换  } 布尔值\ngo语言中以bool类型进行声明，只有true和false\n注意：\n 布尔类型变量默认为false go语言中不允许将整型强制转换为布尔型 布尔型无法参与数值运算，也无法与其他类型进行转换  package main import \u0026#34;fmt\u0026#34; func main() { //布尔值 \tb:=true var b1 bool = false fmt.Printf(\u0026#34;%v\u0026#34;,b) fmt.Println() fmt.Printf(\u0026#34;%v\u0026#34;,b1) fmt.Println() fmt.Printf(\u0026#34;Type:%T,Value:%v\u0026#34;,b,b) } 复习\npackage main import \u0026#34;fmt\u0026#34; func main() { //fmt占位符 %s %d %x %o %b %T %v  i :=2 fmt.Printf(\u0026#34;%T\\t\u0026#34;,i) fmt.Printf(\u0026#34;%v\\t\u0026#34;,i) fmt.Printf(\u0026#34;%b\\t\u0026#34;,i) fmt.Printf(\u0026#34;%d\\t\u0026#34;,i) fmt.Printf(\u0026#34;%o\\t\u0026#34;,i) fmt.Printf(\u0026#34;%x\\t\u0026#34;,i) s:=\u0026#34;linjianshu\u0026#34; fmt.Printf(\u0026#34;%s\\t\u0026#34;,s) fmt.Printf(\u0026#34;%v\\t\u0026#34;,s) fmt.Printf(\u0026#34;%#v\\t\u0026#34;,s) } 字符串 go语言中字符串是用双引号包裹的！\ngo语言中单引号包裹的是字符！！\n//字符串 s:=\u0026#34;hello ljs\u0026#34; //单独的字母、汉字、符号表示一个字符 c1 := \u0026#39;h\u0026#39; c2 := \u0026#39;1\u0026#39; c3 := \u0026#39;啥\u0026#39; //字节：1字节=8Bit（8个二进制位） //一个字符 \u0026#39;A\u0026#39; = 1个字节 //一个utf8编码的汉字‘啥’ = 一般占3个字节 字符串转义符\nGo语言的字符串常见转义符包含回车、换行、单双引号、制表符等\n\\r \\n \\t ' \\\u0026quot; \\\\\npackage main import \u0026#34;fmt\u0026#34; func main() { //fmt占位符 %s %d %x %o %b %T %v  i :=2 fmt.Printf(\u0026#34;%T\\t\u0026#34;,i) fmt.Printf(\u0026#34;%v\\t\u0026#34;,i) fmt.Printf(\u0026#34;%b\\t\u0026#34;,i) fmt.Printf(\u0026#34;%d\\t\u0026#34;,i) fmt.Printf(\u0026#34;%o\\t\u0026#34;,i) fmt.Printf(\u0026#34;%x\\t\u0026#34;,i) s:=\u0026#34;linjianshu\u0026#34; fmt.Printf(\u0026#34;%s\\t\u0026#34;,s) fmt.Printf(\u0026#34;%v\\t\u0026#34;,s) fmt.Printf(\u0026#34;%#v\\t\u0026#34;,s) } 多行字符串\ngo语言中要定义一个多行字符串时，就必须使用反引号 字符``\ns:= ` a b c ` 字符串的常用操作\nlen(str) 求长度 +或者fmt.Strintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix, strings.HasSuffx 前缀、后缀判断 strings.Index(), strings.LastIndex 子串出现的位置 strings.Join(a[] string , sep string) join操作 package main import ( fmt \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { path := \u0026#34;\\\u0026#34;C:\\\\Users\\\\Sweetie\\\\Desktop\\\\车间级MES\\\u0026#34;\u0026#34; fmt.Printf(\u0026#34;%s\\t\u0026#34; , path) s := ` 世情薄 人情恶 雨送黄昏花易落 ` fmt.Printf(\u0026#34;%s\\r\u0026#34;,s) s3:=`C:\\Users\\Sweetie\\Desktop\\车间级MES` fmt.Printf(\u0026#34;%s\\n\u0026#34;,s3) //字符串相关操作 \tfmt.Printf(\u0026#34;%d\\n\u0026#34;,len(s3)) //字符串拼接 \tname := \u0026#34;ljs\u0026#34; world := \u0026#34;shuaibi\u0026#34; describtion := name+world fmt.Printf(\u0026#34;%v\\n\u0026#34;,describtion) describtion1 := fmt.Sprintf(\u0026#34;%s%s\u0026#34;,name,world) fmt.Printf(\u0026#34;%s\\n\u0026#34;,describtion1) //分割 \ts1 := strings.Split(s3,\u0026#34;\\\\\u0026#34;) fmt.Println(s1) for i := 0; i \u0026lt; len(s1); i++ { fmt.Println(s1[i]) } //包含 \tfmt.Println(strings.Contains(describtion, name)) fmt.Printf(\u0026#34; \u0026#39;%s\u0026#39; Contains \u0026#39;%s\u0026#39; ? result:%v\u0026#34;,describtion1,name,strings.Contains(describtion, name)) fmt.Println() //前缀、后缀 \tfmt.Println(strings.HasPrefix(describtion, \u0026#34;ljs\u0026#34;)) fmt.Println(strings.HasSuffix(describtion, \u0026#34;shuaibi\u0026#34;)) //索引 查找 \ts4:=\u0026#34;abcdeb\u0026#34; fmt.Println(strings.Index(s4,\u0026#34;b\u0026#34;)) fmt.Println(strings.LastIndex(s4,\u0026#34;b\u0026#34;)) //拼接 \tvar sJoin = strings.Join(s1,\u0026#34;+\u0026#34;) fmt.Println(sJoin) } byte和rune类型\n组成每个字符串的元素叫做‘字符’，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号‘ 包裹起来，如：\nvar a:=\u0026lsquo;中\u0026rsquo;\nvar b:=\u0026lsquo;x\u0026rsquo;\nGo语言的字符有以下两种：\n1.uint8类型，或者叫byte型，代表了ascii码的一个字符\n2.rune类型，代表一个utf-8字符\n当需要处理中文、日文或者其他符合字符时，则需要用到rune类型。rune类型实际是一个int32\nGo使用了特殊的rune类型来处理unicode，让基于unicode的文本处理更方便，也可以使用byte型进行默认字符串处理，性能和扩展性都有照顾\n因为utf8编码下一个中文汉字由3-4个字节组成，所有我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中的第一行结果\n字符串底层是一个byte数据，所以可以和[]byte 类型相互转换，字符串是不能修改的 字符是由byte字节组成，所以字符串的长度是byte字节的长度 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成\n修改字符串\n要修改字符串，需要先将其转换成[]rune或 []byte ，完成后再转换为string ，都会重新分配内存，并复制字节数组\n注:rune是一个别名 实际上是类型int32 所以 \u0026lsquo;中\u0026rsquo;的类型是int32\nbyte是一个别名 实际上是类型uint8 所以\u0026rsquo;c\u0026rsquo;的类型是uint8\n类型转换\nGo语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。\n强制类型转换的基本语法如下：\nT(表达式)\n其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等\n比如计算直角三角形的斜边长使用math包的sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型，这个时候就将a和b强制类型转换为float64类型\n总结：\ngo语言的基本类型： int8 int16 int32 int64 uint8 uint16 uint32 uint64 float32 float64 bool string\nif语句\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { //if 条件判断 \tage:=19 if age\u0026gt;18 { fmt.Println(\u0026#34;性感荷官在线发牌\u0026#34;) }else { fmt.Println(\u0026#34;好好学习，以后赌博\u0026#34;) } if age \u0026gt;= 35 \u0026amp;\u0026amp; age \u0026lt; 80 { fmt.Println(\u0026#34;人到中年，不得不服\u0026#34;) }else if age \u0026gt; 18 { fmt.Println(\u0026#34;年轻力壮，不怕困难\u0026#34;) }else { fmt.Println(\u0026#34;好好学习，少吃点苦\u0026#34;) } if name := \u0026#34;linjianshu\u0026#34;; strings.Contains(name, \u0026#34;lin\u0026#34;) { fmt.Println(\u0026#34;确实确实\u0026#34;) }else { fmt.Println(\u0026#34;不敢不敢\u0026#34;) }\t} for range(键值循环)\ngo语言中可以使用for range 遍历数据、切片、字符串、map及通道channel 通过for range 遍历返回值有以下规律：\n 数组、切片、字符串返回索引和值 map返回键和值 通道channel 只返回通道内的值  内容回顾 go安装\ngopath\ngo env\n\rimage-20210726100638960\r\ngopath/bin 添加到环境变量：go install 命名会把生成的二进制可执行文件拷贝到gopath/bin\ngo 命令 go build 编译go程序\ngo build -o \u0026ldquo;xxx.exe\u0026rdquo; 指定名称\ngo run main.go 像执行脚本一样执行mai.go\ngo install 先编译后拷贝\ngo语言文件基础语法 存放go源代码的文件后缀名 .go\n文件第一行：package main 声明包名\n如果要编译可执行文件，必须要有main包和main函数（入口函数）\n单行注释和多行注释\ngo语言函数外的语句必须以关键字开头\n函数内部定义的变量必须使用\n变量 3种声明方式：\n var name string name:=\u0026ldquo;ljs\u0026rdquo; var name = \u0026ldquo;ljs\u0026rdquo; 函数内部专属  匿名变量（哑元变量）\n当有些数据必须用变量接收但是又不使用它时，就可以用_ 来接收这个值\n常量 const PI = 3.1415926\nconst UserNotExistErr = 1000\niota 实现枚举 实际上就是行索引\n三个要点：\n const关键字出现时重置为0 每新增一行常量声明，iota累加1  流程控制 if\nif 条件 { } else if 条件{ } else { } for循环\n 标准for循环 变种没有i初始 变种没有i限定 变种没有i增量  for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } i:=5 for ; i \u0026lt;10 ; i++ { fmt.Println(i) } fmt.Println(i) var i1 = 3 for i1\u0026lt;10 { fmt.Println(i1) i1++ } for\t{ fmt.Println(\u0026#34;hello world\u0026#34;) break } for i, v := range \u0026#34;hello world\u0026#34; { fmt.Printf(\u0026#34;index:%d\\t,value:%c\\n\u0026#34;,i,v) } s:=\u0026#34;hello world\u0026#34; for i, _ := range s { fmt.Printf(\u0026#34;index:%d\\t,value:%c\\n\u0026#34;,i,s[i]) } //哑元变量，不想用到的都直接给_ \tfor _, v := range s { fmt.Printf(\u0026#34;%c\\n\u0026#34;,v) } for i := 1; i \u0026lt;10 ; i++ { for j := 1; j \u0026lt;=10-i ; j++ { fmt.Printf(\u0026#34;%d x %d = %d\\t\u0026#34; , i , j , i*j) } fmt.Println() } for i := 1; i \u0026lt; 10; i++ { for j := i; j \u0026gt;0; j-- { fmt.Printf(\u0026#34;%d x %d = %d\\t\u0026#34; , i,j,i*j) } fmt.Println() } 基本数据类型 整型\n​\t无符号整型：uint8 uint16 uint32 uint64\n​\t有符号整型：int8 int16 int32 int64\n​\tuint int 具体是32位还是64位看操作系统\n​\tuintptr 表示指针\n其他进制数\ngo语言中没办法直接定义二进制数\n八进制数 %o\n二进制数 %b\n十六进制数 %x\n浮点型 float32 float64 默认64位，转成32需要强制转换\n布尔型 true\u0026amp;false 不能和其他的类型做转换\n字符串型\n常用方法\n字符串不能修改\n复数\ncomplex128和complex64\nbyte和rune类型\n是类型别名\n字符串、字符、字节都是什么 字符串：双引号包裹的是字符串\n字符：单引号包裹的是字符，单个字母、日文、韩文、中文、单个符号\n字节： 1byte = 8bit\ngo语言中字符串都是UTF8编码，UTF8编码中一个常用汉字一般占用3个字节\nswitch 表达式 switch还可以使用表达式，这时候switch语句后买呢不需要再跟判断变量。例如\nfallthrough 语法可以执行满足条件的case的下一个case，是为了兼容c语言中的case设计的\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { score:=68 switch score { case 68: fmt.Println(\u0026#34;及格\u0026#34;) default: fmt.Println(\u0026#34;未知\u0026#34;) } //简化代码 作用域问题 \tswitch i:=3 ;i{ case 1: fmt.Println(\u0026#34;wumingzhi\u0026#34;) case 2: fmt.Println(\u0026#34;zhongzhi\u0026#34;) case 3: fmt.Println(\u0026#34;damuzhi\u0026#34;) } //同时声明几种情况 \tswitch i:=10;i{ case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;this is 奇数\u0026#34;) case 2, 4, 6, 8, 10: fmt.Println(\u0026#34;this is 偶数\u0026#34;) } score1:=68 switch { case score1\u0026gt;60\u0026amp;\u0026amp;score1\u0026lt;=100: fmt.Println(\u0026#34;及格\u0026#34;) case score1\u0026lt;60: fmt.Println(\u0026#34;挂了呀\u0026#34;) } } goto表达式 break只能退出当前for语句的循环\npackage main import \u0026#34;fmt\u0026#34; func main() { flag:=false for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j==2 { flag = true break } fmt.Printf(\u0026#34;%d-%d\\n\u0026#34;,i,j) } if flag { break } } //for i := 0; i \u0026lt; 10; i++ { \t//\tfor j := 0; j \u0026lt; 10; j++ { \t//\tif j == 2 { \t//\tgoto breakTag \t//\t} \t//\tfmt.Printf(\u0026#34;%v-%v\\n\u0026#34;,i,j) \t//\t} \t//} \t//return  //breakTag: \t//\tfmt.Println(\u0026#34;结束for循环\u0026#34;) } 运算符 go语言内置的运算符有：\n 算术运算符+ - * / % 关系运算符 逻辑运算符 位运算符 赋值运算符  关系运算符 ==、！= 、\u0026gt; 、 \u0026gt;= 、\u0026lt; 、 \u0026lt;=\n逻辑运算符 \u0026amp;\u0026amp; || !\n位运算 位运算符对整数在内存中的二进制位进行操作。\n\u0026amp; 参与运算的两数各对应的二进制位相与\n| 参与运算的两位各对应的二进制位相或\n^ 参与运算的两数各对应的二进制位相异或，当两对应的二进制位相异时，结果为1\n\u0026laquo; 左移n位就是乘以2的n次方 高位丢弃，低位补0\n》》右移n位就是除以2的n次方 a\u0026raquo;b就是a右移b位\npackage main import \u0026#34;fmt\u0026#34; func main() { //运算符 \tvar( a=5 b=2 ) //算术运算符 \tfmt.Println(a+b) fmt.Println(a-b) fmt.Println(a*b) fmt.Println(a/b) fmt.Println(a%b) a++ //单独的语句，不能放在=的右边赋值 \tb++ //关系运算符 \tfmt.Println(a==b) //go语言是强类型，相同类型的变量才能比较 \tfmt.Println(a!=b) fmt.Println(a\u0026gt;b) fmt.Println(a\u0026lt;b) age:=22 if age \u0026gt; 18 \u0026amp;\u0026amp; age \u0026lt; 60 { fmt.Println(\u0026#34;上班族\u0026#34;) }else { fmt.Println(\u0026#34;不用上班\u0026#34;) } if age \u0026gt; 60 || age \u0026lt; 18 { fmt.Println(\u0026#34;不用上班\u0026#34;) }else { fmt.Println(\u0026#34;上班族\u0026#34;) } //not取反 \tb2:=true fmt.Println(!b2) //位运算：针对的是二进制数 \t//5的二进制表示 101 \t//2的二进制表示 010 \t//按位与 \tfmt.Println(101\u0026amp;010) fmt.Println(5\u0026amp;2) //按位或 \tfmt.Println(101|10) fmt.Println(5|2) //^按位异或 \tfmt.Println(101^010) //这个有点奇怪 这个是109答案？？？ \tfmt.Println(5^2) //左移右移运算 *2 和 \\2 \tfmt.Println(5\u0026lt;\u0026lt;2) //101=\u0026gt;10100 \tfmt.Println(1\u0026lt;\u0026lt;10) fmt.Println(5\u0026gt;\u0026gt;1) //101=\u0026gt;10  //注意别溢出了 \tm:=int8(1) fmt.Println(m\u0026lt;\u0026lt;10) fmt.Println(1\u0026lt;\u0026lt;2+1) //192.168.1.1 \t//权限 文件操作会将位运算实际的应用 \t//0644 \t//赋值运算符，用来给变量赋值的 \tvar x int x = 10 fmt.Println(x) x+=1 fmt.Println(x) x-=1 fmt.Println(x) x*=2 fmt.Println(x) x/=2 fmt.Println(x) x\u0026lt;\u0026lt;=2 fmt.Println(x) x\u0026gt;\u0026gt;=2 fmt.Println(x) fmt.Printf(\u0026#34;%b\u0026#34;,x) fmt.Println() x\u0026amp;=2 fmt.Println(x) fmt.Printf(\u0026#34;%b\u0026#34;,x) x|=2 x\u0026lt;\u0026lt;=2 x\u0026gt;\u0026gt;=2 x^=2 } 数组 array数组\n数组是同一种数据类型元素的集合。在go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。基本语法：\npackage main import \u0026#34;fmt\u0026#34; func main() { //数组 \t//存放元素的容器 \t//必须指定存放的元素的类型和容量（长度） \t//数组的长度是数组类型的一部分 也就是尽管类型一致但是长度不一致也不是同一个数组类型 \tvar a1 [3]bool var a2 [4]bool fmt.Printf(\u0026#34;a1:type%T, a2:type%T\u0026#34;,a1,a2) fmt.Println() //数组的初始化 \t//如果不初始化：默认元素都是零值(布尔值就是false，整型和浮点型都是0，字符串就是“”) \tfmt.Println(a1,a2) //1.初始化方式1 \tb1 :=[3]bool{true,true,true} fmt.Println(b1) //2.初始化方式2 根据初始值自动推断数组的长度是多少 \tb2 :=[...]int{1,3,4,2,6,2,73,12} fmt.Println(b2) fmt.Println(len(b2)) //3.初始化方式3 根据索引初始化 \tb3:=[5]int{1,2} fmt.Println(b3) b3=[5]int{0:1,4:2} fmt.Println(b3) //数组的遍历 \tcitys :=[...]string{\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;,\u0026#34;深圳\u0026#34;} //1.for range \tfor _, v := range citys { fmt.Println(v) } for i, _ := range citys { fmt.Println(citys[i]) } //2.根据索引遍历 \tfor i := 0; i \u0026lt; len(citys); i++ { fmt.Println(citys[i]) } //多维数组 \tc1:=[3][2]int{0:[2]int{2,3},1:[2]int{4,5}} fmt.Println(c1) c2:=[3][2]int {{1,2},{3,4}} fmt.Println(c2) //多维数组的遍历 \t//var b11:=[2][3]string{{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;},{\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;}} \t//可以这么记 go语言中 实际数组展示使用空格来区分的，但是声明的时候需要用逗号隔开 \tfor _, v := range c1 { fmt.Println(v) for _, v1 := range v { fmt.Printf(\u0026#34;%d \u0026#34;,v1) } fmt.Println() } for i := 0; i \u0026lt; len(c2); i++ { fmt.Println(c2[i]) for j := 0; j \u0026lt; len(c2[j]); j++ { fmt.Printf(\u0026#34;%d \u0026#34;,c2[i][j]) } fmt.Println() } //数组是值类型 \td1:=[...]int{1,2,3} d2:=d1 d2[0]=100 fmt.Println(d1) fmt.Println(d2) //练习 \te:=[...]int{1,3,5,7,8} sum:=0 for _, v := range e { sum+=v } fmt.Println(sum) for i, _ := range e { for j := i+1; j \u0026lt; len(e); j++ { if e[i]+e[j] == 8 { fmt.Printf(\u0026#34;(%d %d)\u0026#34;,i,j) break } } fmt.Println() } } 数组定义 var 数组变量名 [元素数量]T\n[5]int 和 [10]int 是不同的类型\n切片 切片slice是一个拥有相同类型元素的可变长度的序列。他是基于数组类型做的一层封装。他非常灵活，支持自动扩容。切片是一个引用类型，他的内部结构包含地址 、 长度 和 容量 。切片一般用于快速地操作一块数据集合。\n切片的定义\n声明切片类型的基本语法如下：\nvar name []T 其中，name是变量名字， T是元素类型\n切片的容量和长度 切片拥有自己的长度和容量，我们可以通过使用内置的len函数求长度，使用内置的cap函数求切片的容量\n基于数组定义切片 由于切片的底层就是一个数组，所以我们可以基于数组定义切片\n还支持如下方式\npackage main import \u0026#34;fmt\u0026#34; func main() { //切片的定义 \tvar s1 []int //定义一个存放int类型元素的切片 \tvar s2 []string fmt.Println(s1,s2) fmt.Println(s1==nil) fmt.Println(s2==nil) //初始化 \ts1 = []int{1,2,3} s2 = []string{\u0026#34;沙河\u0026#34;,\u0026#34;张江\u0026#34;,\u0026#34;平山村\u0026#34;} fmt.Println(s1,s2) fmt.Println(s1==nil) fmt.Println(s2==nil) //长度和容量 \tfmt.Printf(\u0026#34;len:%d,cap:%d\\n\u0026#34;, len(s1), cap(s1)) fmt.Printf(\u0026#34;len:%d,cap:%d\\n\u0026#34;, len(s2), cap(s2)) //2.由数组定义切片 \ta :=[]int{1,3,5,7,9,11,13} fmt.Println(cap(a)) b :=a[1:4] //[3 5 7] 左闭右开 基于一个数组进行切割 \tfmt.Println(b) b1 :=a[:4] //0-4 \tfmt.Println(b1) b2 :=a[2:] // \tfmt.Println(b2) b3 :=a[:] fmt.Println(b3) //切片的长度就是元素的个数，切片的容量就是底层数组从切片第一个元素到最后一个元素的数量 \tfmt.Println(len(b),cap(b)) //3.切片再切片 \tb4:=b[1:2] //[5 7] 但是b的容量已经是6了 这时候切的b从第一位切起 那么容量应该是5 \tfmt.Println(b4, len(b4), cap(b4)) fmt.Println(b) a[2] = 10 //这里说明了切片是引用类型，都指向了底层的数组，修改了底层数组，那么上层的切片值肯定会变化 \tfmt.Println(b) fmt.Println(b4) } 切片指向了一个底层的数组\n切片的长度就是它元素的个数\n切片的容量是底层数组从切片的第一个元素到最后一个元素的数量\n\rimage-20210729000908993\r\n\rimage-20210729000949711\r\n使用make函数构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make函数\nmake([]T , size ,cap) 其中：T：切片的元素类型 size：切片中元素的数量 cap：切片的容量\n上面的代码中a的内部存储空间已经分配cap个，但是实际上只是使用了len个，容量并不会影响当前元素的个数，所以len返回使用了几个，cap返回切片的容量\n切片的本质 切片就是一个框，框住了一块连续的内存。属于引用类型，真正的数据都是保存在底层数组里的。\n切片不能直接比较 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。切片唯一合法的比较操作是和nil比较。一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0.但是我们不能说一个长度和容量都是0的切片一定是nil\npackage main import \u0026#34;fmt\u0026#34; func main() { //make函数创造切片 \ts1:=make([]int,3,10) fmt.Printf(\u0026#34;s1=%v,len(s1)=%d,cap(s1)=%d,s1==nil?:%v\\n\u0026#34;,s1,len(s1),cap(s1),s1==nil) var s2 []int fmt.Printf(\u0026#34;s2=%v,len(s2)=%d,cap(s2)=%d,s2==nil?:%v\\n\u0026#34;,s2,len(s2),cap(s2),s2==nil) s3:=[]int{} fmt.Printf(\u0026#34;s3=%v,len(s3)=%d,cap(s3)=%d,s3==nil?:%v\\n\u0026#34;,s3,len(s3),cap(s3),s3==nil) s4:=make([]int,0) fmt.Printf(\u0026#34;s4=%v,len(s4)=%d,cap(s4)=%d,s4==nil?:%v\\n\u0026#34;,s4,len(s4),cap(s4),s4==nil) //切片的赋值 \ts5:=[]int {1,3,5,7} s6:=s5 //s5 和 s6都指向了同一个底层数组 \tfmt.Println(s5,s6) s5[0]=100 fmt.Println(s5,s6) //切片的遍历 \t//1.索引遍历 \tfor i := 0; i \u0026lt; len(s5); i++ { fmt.Printf(\u0026#34;%d \u0026#34;,s5[i]) } fmt.Println() //2.forrange遍历 \tfor _, v := range s5 { fmt.Printf(\u0026#34;%d \u0026#34;,v) } } 所以要判断一个切片是否是空的，要使用len(s)==0来判断\nappend方法为切片添加元素 go语言的内置函数append可以为切片动态添加元素，每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行扩容，此时该切片指向的底层数组就会更换。扩容操作往往发生在append函数调用时。\n切片的扩容策略就不说了\npackage main import \u0026#34;fmt\u0026#34; func main() { //append 为切片追加元素 \ts1:=[]string{\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;,\u0026#34;深圳\u0026#34;} fmt.Printf(\u0026#34;s1=%v len(s1)=%d cap(s1)=%d\\n\u0026#34;,s1,len(s1),cap(s1)) //s1[3] = \u0026#34;广州\u0026#34; //错误的写法 会导致编译错误：索引越界  //调用append函数必须使用原来的切片变量接收返回值 \ts1= append(s1, \u0026#34;广州\u0026#34;) //append追加元素 原来的底层数组放不下的时候 go底层就会把底层数组换一个 \t//必须用变量接收append的返回值 \tfmt.Printf(\u0026#34;s1=%v len(s1)=%d cap(s1)=%d\\n\u0026#34;,s1,len(s1),cap(s1)) s1 = append(s1,\u0026#34;杭州\u0026#34;,\u0026#34;成都\u0026#34;) fmt.Printf(\u0026#34;s1=%v len(s1)=%d cap(s1)=%d\\n\u0026#34;,s1, len(s1), cap(s1)) s2:=[]string{\u0026#34;武汉\u0026#34;,\u0026#34;西安\u0026#34;,\u0026#34;苏州\u0026#34;} s1 = append(s1,s2...) //...表示拆开 \tfmt.Printf(\u0026#34;s1=%v len(s1)=%d cap(s1)=%d\\n\u0026#34;,s1, len(s1), cap(s1)) } 使用copy复制切片 由于切片是引用类型，a和b其实是指向了同一块内存地址，所以如果单纯的赋值的话，修改了b的值的同时a的值也会发生变化\ngo语言内建的copy函数可以迅速地将一个切片的数据复制到另一个切片空间\ncopy (destSlice , srcSlice[] T) 从切片中删除元素 go语言中并没有删除切片元素的专用方法，我们可以使用切片 本身的特性来删除元素。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a1:=[]int {1,3,5} a2:=a1 var a3=[]int{} //这样声明没办法复制进去 \tvar a4 []int\t//这样声明也没办法复制进去 \tvar a5=make([]int,len(a1), cap(a1)) copy(a3,a1) copy(a4,a1) copy(a5,a1) fmt.Println(a1,a2,a3,a4,a5) a1[0] = 100 fmt.Println(a1,a2,a3,a4,a5) //删除第二个元素 \ta5 = append(a5[:1],a5[2:]...) fmt.Println(a5) fmt.Println(cap(a5)) //验证 \t//1.切片不保存具体的值 \t//2.切片对应一个底层数组 \t//3.底层数组都是占用一块连续的内存 \tx1:=[...]int{1,3,5} //数组 \tx2:=x1[:] //切片 切片指向底层数组 \tfmt.Println(x2,len(x2),cap(x2)) fmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;x1[0]) x2 = append(x1[:1],x1[2:]...) //切片截取底层数组 重新定义了底层数组的索引的值 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;x2[0]) //说明指向的底层数组地址没变 变了的是地址里的值 \tfmt.Println(x2) //切片的索引的值 \tfmt.Println(x1) //被修改后的底层数组的索引和值 } 练习\npackage main import \u0026#34;fmt\u0026#34; func main() { a1:=[...]int{1,3,5,7,9,11,13,15,17} a2:=a1[:] a2=append(a1[:1],a1[2:]...) fmt.Println(a2) fmt.Println(a1) } 指针 go语言中不存在指针操作，只需要记住两个符号\n \u0026amp; 取地址 * 根据地址取值  go语言中的指针不能进行偏移和运算，是安全指针。\n要搞明白go语言中的指针需要先知道3个概念，指针地址，指针类型和指针取值\ngo语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无需拷贝数据。类型指针不能进行偏移和运算。go语言中的指针操作非常简单，只需要记住两个符号：\u0026amp; 取地址 *根据地址取值\n指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。go语言中使用\u0026amp;字符放在变量前面对变量进行取地址操作。go语言中的值类型int / float / bool / string / array / struct 都有对应的指针类型 *int / *int64 / *string\n总结：取地址操作符\u0026amp; 和取值操作符*是一对互补操作，\u0026amp;取出地址， *根据地址取出地址指向的值，变量、指针地址、指针变量、取地址、取值的相互关系如下\n 对变量进行取地址\u0026amp;操作，可以获得这个变量的指针变量 指针变量的值是指针地址 对指针变量进行取值*操作，可以获得指针变量指向的原变量的值  package main import \u0026#34;fmt\u0026#34; func main() { //1.\u0026amp;取地址  //2.*根据地址取值  n:=18 fmt.Println(\u0026amp;n) p:=\u0026amp;n fmt.Printf(\u0026#34;%T\\n\u0026#34;,p) //*int表示int类型的指针  m:=*p fmt.Printf(\u0026#34;%v\\n\u0026#34;,m) fmt.Printf(\u0026#34;%T\\n\u0026#34;,m) var a *int fmt.Println(a) //nil 赋值会报错 空指针异常  var a1 = new(int) //使用new关键字会分配内存块 不会造成空指针  fmt.Println(a1) fmt.Println(*a1) *a1 = 100 fmt.Println(*a1) } make make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是她们的指针类型，因为这三种类型就是引用类型，没有必要返回她们的指针了。make函数的函数签名\nfunc make (t Type,size ... IntergerType) Type make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对她们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节中详细说明\nmake和new的区别  make和new都是用来申请内存的 new很少用，一般用来给基本数据类型申请内存，string / int 返回的是对应类型的指针，例如*string . *int。 make是用来给slice 、 map 、 chan申请内存的，make函数返回的是对应的这三个类型本身  map go语言中提供的映射关系容器为map，其内部使用散列表hash实现\nmap是一种无序的基于key-value的数据结构，go语言中的map是引用类型，必须初始化才能使用\nmap[KeyType]valueType map类型的变量默认初始值为nil，需要使用make函数来分配内存\nmake(map[keyType] valueType,[cap]) 判断某个键是否存在 特殊写法\nvalue,ok:=map[key] 遍历map 使用for range即可\n使用delete函数删除键值对 类型为map的切片\n值的类型为切片的map\npackage main import \u0026#34;fmt\u0026#34; func main() { //map和slice的组合 \ta:=[]map[string]int{} //元素类型为map的切片 \tvar a1 = make([]map[string]int,10,10) //没有对内部的map做初始化 \ta1[0] = make(map[string]int,10) a1[0][\u0026#34;ljs\u0026#34;] = 9 a1[0][\u0026#34;jwt\u0026#34;] = 8 fmt.Println(a) fmt.Println(a1) //值为切片类型的map \tvar a2 = make(map[string][]string,10) a2[\u0026#34;ljs\u0026#34;] = make([]string,10,10) a2[\u0026#34;ljs\u0026#34;] = []string{\u0026#34;giegie\u0026#34;} fmt.Println(a2) a2[\u0026#34;ljs\u0026#34;] = append(a2[\u0026#34;ljs\u0026#34;],[]string{\u0026#34;jiejie\u0026#34;,\u0026#34;didi\u0026#34;}...) fmt.Println(a2) } 内容回顾 运算符 算术运算符\n逻辑运算符\n赋值运算符+= -= *= /= \u0026amp;= |= ^=\n位运算符 \u0026raquo; \u0026laquo; | \u0026amp; ^\n比较运算符\n数组array [\u0026hellip;]int{3,5} 数组包含元素的类型和元素的个数 数组的长度属于数组类型的一部分\n数组是值类型\n多维数组\npackage main import \u0026#34;fmt\u0026#34; func main() { var name string name = \u0026#34;ljs\u0026#34; fmt.Println(name) var ages [30]int ages[0] = 1 ages = [30]int{2,3,5} fmt.Println(ages) ages1:=[...]int{2,3,6,8,9} fmt.Println(ages1) ages2:=[...]int{1:1,99:99} fmt.Println(ages2) //二维数组 \ta:=[3][2]string{} a[0][1] = \u0026#34;ljs\u0026#34; a[0][0] = \u0026#34;jwt\u0026#34; fmt.Println(a) //多维数组是值类型 \ta1:=[3][2]string{{\u0026#34;ljs\u0026#34;,\u0026#34;jwt\u0026#34;},{\u0026#34;fyz\u0026#34;,\u0026#34;lje\u0026#34;}} fmt.Println(a1) var a2 =[3][2]int{[2]int{1,2},[2]int{3,4}} fmt.Println(a2) //数组是值类型 \ta3:=[3]int{1,2,3} fmt.Println(a3) f1(a3) fmt.Println(a3) a4:=[]int{1,2,3} fmt.Println(a4) f2(a4) fmt.Println(a4) } func f1(a [3]int) { //go语言中函数传递的都是值 ctrl+c ctrl+v \ta[1] = 100 } func f2(a []int) { a[1] =100 } 切片 切片不存值，像一个框，在底层的数组里取值\n切片的定义：指针、长度、容量\nvar name []T\n切片的扩容策略\n 如果申请的容量大于原来的2倍，那就直接扩容至新申请的容量 如果小于1024，那么就直接两倍 如果大于1024，就按照1.25倍去扩容 具体存储的值类型不同，扩容策略也有一定的不同  a4:=[]int{1,2,3} fmt.Println(a4) f2(a4) fmt.Println(a4) //切片 \ta5:=[]int{} fmt.Println(a5) fmt.Println(a5==nil) //没有分配内存 零切片声明 nil \tvar a6 []int fmt.Println(a6) fmt.Println(a6==nil) //make初始化 分配内存 \ta7 := make([]int, 5, 5) fmt.Println(a7) fmt.Println(a7==nil) s1 :=[]int{1,2,3} s2:=s1 fmt.Println(s1) s2[1] = 100 fmt.Println(s2) fmt.Println(s1) //切片不存值 指向同一个数组  var s3 []int //append将自动初始化分配内存+扩容 \ts3 = append(s3,1) fmt.Println(s3) var s4 []int s4 = make([]int,1,1) copy(s4,s3) //copy函数必须先将dest切片声明好并且初始化好分配好内存和长度 \tfmt.Println(s4) 指针 //指针 \t//go里面的指针只能读不能修改 \taddr:=\u0026#34;沙河\u0026#34; addrpointer:=\u0026amp;addr fmt.Println(addrpointer) fmt.Printf(\u0026#34;%T\\n\u0026#34;,addrpointer) fmt.Printf(*addrpointer) map map存储的是键值对的数据。他也是需要申请内存的\n//map \tvar m map[string]int m = make(map[string]int,5) m[\u0026#34;ljs\u0026#34;] = 99 m[\u0026#34;jwt\u0026#34;] = 98 fmt.Println(m) fmt.Println(m[\u0026#34;jiwuming\u0026#34;]) //如果不存在key ，返回的将是value类型的默认值 \tscore,ok:=m[\u0026#34;jiwuming\u0026#34;] if ok { println(score) }else{ println(\u0026#34;查无此人\u0026#34;) } delete(m,\u0026#34;lalala\u0026#34;) //如果没有的话，什么都不干，不报错 \tdelete(m, \u0026#34;jwt\u0026#34;) fmt.Println(m) 复习 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;unicode\u0026#34; ) func main() { s1:=\u0026#34;hello沙河\u0026#34; sum:=0 for _, v := range s1 { //if v \u0026gt;= 128 { \t//\tsum++ \t//}  if unicode.In(v, unicode.Han) { sum++ } } fmt.Println(sum) s2:=\u0026#34;how do you do\u0026#34; s3:= strings.Split(s2,\u0026#34; \u0026#34;) fmt.Println(s3) m:= make(map[string]int, 5) for _, v := range s3 { //if m[v] == 0 { \t//\tm[v] =1 \t//}\telse { \t//\tm[v] ++ \t//} \tif _,ok := m[v];!ok{ m[v]=1 }else { m[v]++ } } fmt.Println(m) //回文判断 \t//字符串从左往右读和从右往左读是一样的，就是回文 \t//黄山落叶松叶落山黄 \ts4:=\u0026#34;黄山落叶松叶落山黄\u0026#34; s5:= make([]string, len(s4)) for i, v:= range s4 { s5[len(s4)-i-1]=string(v) //fmt.Println(i, string(v)) \tfmt.Println(s5) } var s6 string s6 = strings.Join(s5,\u0026#34;\u0026#34;) fmt.Println(s6) fmt.Println(s6==s4) runes:= make([]rune, 0, len(s4)) for _, rune := range s4 { runes =append(runes, rune) } fmt.Println(\u0026#34;rune[] :\u0026#34;,runes) for i := 0; i \u0026lt; len(runes)/2; i++ { if runes[i]!=runes[len(runes)-i-1] { return } } println(\u0026#34;回文\u0026#34;) } 函数func package main import \u0026#34;fmt\u0026#34; func main() { println(f4(1, 2, 3, 4)) } func f1() { fmt.Println(\u0026#34;hello 沙河\u0026#34;) } func f2(name string) { fmt.Println(\u0026#34;hello\u0026#34;,name) } func f3(x, y int) int { return x+y //y是一个可变长度的切片类型 } func f4(x int, y ...int) int { sum:=x for _, v := range y { sum+=v } return sum } func f5(x, y int) (sum int) { sum = x+y return } func f6(x, y int) (x1, y1 int) { x1=x y1=y return } defer语句 go语言中的defer语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，将延迟处理的语句按照defer定义的逆序进行执行，也就是说先被defer的语句最后被执行，后被defer的语句最先被执行\ndefer执行时机 在go语言的函数中，return语句在底层并不是原子性操作，他分为给返回值赋值和ret指令两步。而defer语句执行的实际就是在返回值赋值操作后，ret指令执行前，具体如图\n\rimage-20210731151015069\r\npackage main import \u0026#34;fmt\u0026#34; //go语言中的函数的return不是原子操作，在底层是分为两步来执行 //第一步：返回值赋值 //第二步：真正的return返回 //函数中如果存在defer，那么defer执行的时机是在第一步和第二步之间 func main() { fmt.Println(f1()) //5 \tfmt.Println(f2()) //6 \tfmt.Println(f3()) //5 \tfmt.Println(f3_1()) //[100 2] } func f1() int { x :=5 defer func() { x++ //修改的是x不是返回值 \t}() return x } func f2() (x int) { defer func() { x++ }() return 5 //返回值是x x又++了 所以返回6 } func f3() (y int) { x:=5 defer func() { x++ //是因为int是值类型 所以y是拷贝值而不是拷贝地址的原因吗 \t}() return x } func f3_1() (y []int) { x:=[]int{1,2} defer func() { x[0]=100 //因为[]int 切片是引用类型 所以y拷贝的是地址而不是值 \t}() return x } func f4() (x int) { defer func(x int) { x++ //改变的是函数的副本 \t}(x) //(x)代表的是传入参数 \treturn 5 } 变量 全局变量 局部变量 局部变量又分为两种，函数内定义的变量无法在该函数外使用\n如果局部变量和全局变量重名，优先访问局部变量\n语句块作用域 函数类型和变量 我们可以使用type关键字来定义一个函数类型\ntype calculation func(int,int) int 定义了一个函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Printf(\u0026#34;%T \\n\u0026#34;,f1) fmt.Printf(\u0026#34;%T \\n\u0026#34;,f2) fmt.Printf(\u0026#34;%T \\n\u0026#34;,f3) f3(f2) a := f4(f2) fmt.Printf(\u0026#34;%T\\n\u0026#34;,a) } func f1() { fmt.Println(\u0026#34;hello 沙河\u0026#34;) } func f2() int { return 5 } //函数也可以作为参数的类型 func f3(x func() int) { fmt.Println(x()) } //函数还可以作为返回值的类型 func f4(x func() int) func(int,int) int { return f5 } func f5(x, y int) int { return x+y } 今日内容 函数 函数的定义 基本格式 参数的格式\n有参数的函数\n参数类型简写\n可变参数\n返回值的格式 有返回值\n无返回值\n命名返回值\n变量的作用域  全局作用域 函数作用域  先在函数内部找变量，找不到往外层找 函数内部的变量，外部访问不到   代码块作用域  高阶函数 函数也是一种类型，它可以作为一种参数，也可以作为返回值\n匿名函数 没有名字的函数\npackage main import \u0026#34;fmt\u0026#34; func main() { println(a(10)) //但是通常匿名函数不是这么用的 通常是由于函数内部不允许定义函数，所以使用匿名函数现写现用  a:= func(x,y int) int { return x+y } println(a(10, 20)) //如果只是调用一次的函数，还可以简写成立即执行函数  i := func(x, y int) int { return x * y }(10, 20) fmt.Println(i) } var a = func (x int) int { return x } 闭包 package main import \u0026#34;fmt\u0026#34; func main() { f1(f3(1,2)) f1(f4(1, 2)) f1(f5(f2,1,2)) } func f1(f func()) { fmt.Println(\u0026#34;this is f1\u0026#34;) f() } func f2(x, y int) { fmt.Println(\u0026#34;this is f2\u0026#34;) fmt.Println(x+y) } //如何让f1调用的时候执行f2 也就是两个同事写的代码相互兼容 //由于f1的形参是一个无形参无返回值的函数类型，因此需要构造一个函数，让其返回值是无形参无返回值的函数类型f3 //当然为了兼容f2，f3的形参需要和f2的形参相匹配，这样一来在执行f3的时候，内部调用了f2，并且返回类型满足f1所需 func f3(x,y int) func() { func(x,y int) { f2(x,y) }(x,y) return func() { } } func f4(x, y int) func() { return func() { f2(x,y) } } func f5(f func(int, int), x, y int) func() { //把原来需要传递两个int类型的参数包装成一个不需要传参的函数 \treturn func() { f(x,y) } } 闭包=函数 + 外部变量的引用\npackage main import \u0026#34;fmt\u0026#34; func main() { //闭包是什么 \t//闭包是一个函数，这个函数包含了他外部作用域的一个变量 \t//底层 \t//1.函数可以作为返回值 \t//2.函数内部查找变量的顺序，先在自己内部找，找不到往外层找 \tret := adder(100) i:= ret(200) fmt.Println(i) } func adder(x int) func(int) int { return func(y int) int { x +=y return x } } package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { suffixFunc:= makeSuffixFunc(\u0026#34;.jpg\u0026#34;) f := makeSuffixFunc(\u0026#34;.txt\u0026#34;) fmt.Println(suffixFunc(\u0026#34;text\u0026#34;)) fmt.Println(f(\u0026#34;text\u0026#34;)) } func makeSuffixFunc(suffix string) func(string2 string) string{ return func(name string) string { if !strings.HasSuffix(name, suffix) { return name+suffix } return name } } package main import \u0026#34;fmt\u0026#34; func main() { f, f2 := calc(10) fmt.Println(f(1),f2(2)) //11 9 \tfmt.Println(f(3),f2(4))\t//12 8 \tfmt.Println(f(5),f2(6))\t//13 7  } func calc(base int) (func(int)int ,func(int)int) { add :=func(i int)int{ base+=i return base } sub := func(i int)int{ base-=i return base } return add,sub } defer进阶 package main import ( \u0026#34;fmt\u0026#34; ) func main() { a:=1 b:=2 defer calc(\u0026#34;1\u0026#34;,a,calc(\u0026#34;10\u0026#34;,a,b)) a=0 defer calc(\u0026#34;2\u0026#34;,a,calc(\u0026#34;20\u0026#34;,a,b)) b=1 //defer会先把预定的值先算出来等着最后执行函数 \t//defer calc(\u0026#34;1\u0026#34;,1,calc(\u0026#34;10\u0026#34;,1,2)) \t//输出 \u0026#34;10\u0026#34; 1 2 3 \t//defer calc(\u0026#34;1\u0026#34;,1,3) \t//a=0 \t//defer calc(\u0026#34;2\u0026#34;,1,calc(\u0026#34;20\u0026#34;,0,2)) \t//输出 \u0026#34;20\u0026#34; 0 2 2 \t//defer calc(\u0026#34;2\u0026#34;,0,2) \t//b=1 \t//程序退出 \t//执行 defer calc(\u0026#34;2\u0026#34;,0,2) \t//输出 \u0026#34;2\u0026#34; 0 2 2 \t//执行 defer calc(\u0026#34;1\u0026#34;,1,3) \t//输出 \u0026#34;1\u0026#34; 1 3 4 } func calc(index string, a, b int) int { ret :=a+b fmt.Println(index,a,b,ret) return ret } 内置函数介绍 close 主要用来关闭channel\nlen 用来求长度 string array slice map channel\nnew 用来分配内存，主要用来分配值类型，比如int struct 返回的是指针\nmake 用来分配内存，主要用来分配引用类型，比如chan map slice\nappend 用来追加元素到数组 slice中\npanic和recover 用来做错误处理\npanic/recover go语言中目前是没有异常机制的，但是使用panic/recover模式来处理错误。panic可以在任何地方引发，但recover只有在defer调用的函数中有效。\n程序运行期间funcB如果引发了panic导致的程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行。\npackage main import \u0026#34;fmt\u0026#34; func main() { A() B() C() } func A() { fmt.Println(\u0026#34;A\u0026#34;) } func B() { //假设此时打开了个数据库连接 \tdefer func() { error := recover() fmt.Println(error) fmt.Println(\u0026#34;要尝试在出错的时候释放数据库连接...\u0026#34;) }() panic(\u0026#34;fatal error!\u0026#34;) //程序奔溃退出 \tfmt.Println(\u0026#34;B\u0026#34;) } func C() { fmt.Println(\u0026#34;C\u0026#34;) } 注意：\n recover必须搭配defer使用 defer一定要在可能引发panic的语句之前定义  go语言fmt.printf使用指南 fmt fmt包实现了类似C语言printf和scanf的格式化I/O 主要分为向外输出内容和获取输入内容两大部分\n向外输出 print 直接输出\nprintln输出带换行符\nprintf格式化输出\n   占位符 说明     %v 值的默认格式   %+v 类似%v,但输出结构体时会添加字段名   %#v 值的go语法表示   %T 打印值的类型   %% 百分号   %t 布尔值   %b 对于整型而言，是二进制数，对于浮点数而言，是二进制指数的科学计数法   %c    %d    %o    %x    %X    %U    %q    %e 科学计数法   %E 科学计数法   %f    %F    %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）   %G    %s    %q    %x 每个字节用两字符十六进制数表示   %9f 宽度9，默认精度   %9.2f 宽度9，精度2   %5.2s 一共5个 保留2个   %-5s 有空格补在前面    获取输入 fmt.scan fmt.scanf fmt.scanln\n scan从标准输入扫描文本，读取由空白符分割的值保存到传递给本函数的参数中，换行符视为空白符 本函数返回成功扫描的数据个数和遇到的任何错误，如果读取的数据个数比提供的参数少，会返回一个错误报告原因  sprint\nsprint系列函数会把传入的数据生成并返回一个字符串\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Print(\u0026#34;hello world\u0026#34;) fmt.Println(\u0026#34;hello world\u0026#34;) fmt.Printf(\u0026#34;%p\u0026#34;,\u0026#34;helloworld\u0026#34;) //%d 十进制 \t//%v 值 \t//%o 八进制 \t//%x 十六进制 \t//%T 类型 \t//%s 字符串 \t//%p 指针 \t//%b 二进制 \t//%c 字符s \t//%f 浮点数 \t//%t 布尔值 \tfmt.Println() var m map[string]int m= make(map[string]int) m[\u0026#34;ljs\u0026#34;]=98 fmt.Printf(\u0026#34;%v\\n\u0026#34;,m) fmt.Printf(\u0026#34;%#v\\n\u0026#34;,m) fmt.Printf(\u0026#34;%q\\n\u0026#34;,65) printfPersentage(98) fmt.Printf(\u0026#34;%b\\n\u0026#34;,5.6) n:=12.34 fmt.Printf(\u0026#34;%f\\n\u0026#34;,n) fmt.Printf(\u0026#34;%9f\\n\u0026#34;,n) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;,n) fmt.Printf(\u0026#34;%9.2f\\n\u0026#34;,n) fmt.Printf(\u0026#34;%9.f\\n\u0026#34;,n) s:=\u0026#34;小王子\u0026#34; fmt.Printf(\u0026#34;%s\\n\u0026#34;,s) fmt.Printf(\u0026#34;%5s\\n\u0026#34;,s) fmt.Printf(\u0026#34;%-5s\\n\u0026#34;,s) fmt.Printf(\u0026#34;%5.7s\\n\u0026#34;,s) fmt.Printf(\u0026#34;%-5.7s\\n\u0026#34;,s) //一共5个 只留2个 \tfmt.Printf(\u0026#34;%5.2s\\n\u0026#34;,s) fmt.Printf(\u0026#34;%05s\\n\u0026#34;,s) var s1 string fmt.Scan(\u0026amp;s1) fmt.Println(s1) var ( name string age int class string ) //fmt.Scanf(\u0026#34;%s %d %s\\n\u0026#34;,\u0026amp;name,\u0026amp;age,\u0026amp;class) \tfmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;,name,age,class) fmt.Scanln(\u0026amp;name,\u0026amp;age,\u0026amp;class) fmt.Printf(\u0026#34;%s %d %s\\n\u0026#34;,name,age,class) } func printfPersentage(a int) { fmt.Printf(\u0026#34;%d%%\\n\u0026#34;,a) } 今日难点  函数的定义 高阶函数 函数类型 闭包 defer panic/recover  \rimage-20210802002337782\r\n结构体 struct 方法\n实际上类似于类\n内容回顾 函数的定义\nfunc name () 返回值 {}\n函数进阶\n  ​\t高阶函数：函数可以作为参数，也可以作为返回值\n  ​\t闭包：函数和其外部变量的引用\n  ​\tdefer：延迟调用 多用于处理资源释放\n  ​\t内置函数：\n ​\tpanic/recover    递归 package main import \u0026#34;fmt\u0026#34; func main() { //递归:自己调用自己 \t//递归适合处理那种问题相同但是规模越来越小的场景 \t//递归一定要有一个明确的退出条件 \tprintln(Factorial(7)) fmt.Println(taijie(4)) } func Factorial(n int) (result int) { if n == 1 { return 1 } else{ result =n * Factorial(n-1) return } } //上台阶面试题 //n个台阶 一次可以走1步 一次可以走2步 有多少种走法 func taijie(n int) (result int) { if n == 1 { result =1 //如果只有1个台阶就一种走法 \treturn }else if n == 2 { return 2 } return taijie(n-1)+taijie(n-2) } 自定义类型和类型别名 在go语言中有一些基本的数据类型，如string bool int float等数据类型，go语言中可以使用type关键字来定义自定义类型\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义\n类型别名规定typealias只是type的别名，本质上是一个类型，这些名字都指向一个类型\n区别 ： 自定义类型编译后类型是自定义的 类型别名只会在代码中存在，编译完成只会有原类型\n\rimage-20210806225811170\r\npackage main import \u0026#34;fmt\u0026#34; //type后面跟的是类型 type myInt int //自定义类型 type yourInt = int //类型别名  func main() { //自定义类型和类型别名 \tvar n myInt n = 100 fmt.Println(n) fmt.Printf(\u0026#34;%T\\n\u0026#34;,n) var m yourInt m = 100 fmt.Println(m) fmt.Printf(\u0026#34;%T\\n\u0026#34;,m) var r rune r = \u0026#39;中\u0026#39; fmt.Printf(\u0026#34;%c\\n\u0026#34;,r) fmt.Printf(\u0026#34;%T\\n\u0026#34;,r) } 结构体 go语言中没有类的概念，也不支持类的继承等面向对象的概念。go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\ngo语言中的基础数据类型可以表示一些事务的基本属性，但是当我们想表达一个事务的全部或者部分属性时，这时候再用一些基本数据类型明显就无法满足需求了，go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct 也就是我们可以通过struct来定义自己的类型\ngo语言中通过struct来实现面向对象\n结构体的定义 使用type和struct关键字来定义结构体\npackage main import \u0026#34;fmt\u0026#34; //结构体  type person struct { name string age int hobby []string gender string } func main() { //声明一个person类型的变量 \tvar f person //通过字段赋值 \tf.gender = \u0026#34;男\u0026#34; f.hobby = make([]string,10) f.hobby[0] =\u0026#34;football\u0026#34; f.hobby[1] =\u0026#34;basketball\u0026#34; f.age = 18 f.name = \u0026#34;ljs\u0026#34; fmt.Println(f) fmt.Printf(\u0026#34;%T\\n\u0026#34;,f) fmt.Println(f.hobby) var f1 person f1.name = \u0026#34;jwt\u0026#34; fmt.Println(f1) } //匿名结构体 多用于临时场景 \ts := struct { name string age int }{age: 18,name: \u0026#34;fyz\u0026#34;} fmt.Println(s) var s1 = struct { name string sex int }{sex : 1,name:\u0026#34;lje\u0026#34;} fmt.Println(s1) 结构体是值类型\n在Go语言中只存在值传递（要么是该值的副本，要么是指针的副本），不存在引用传递。之所以对于引用类型的传递可以修改原内容数据，是因为在底层默认使用该引用类型的指针进行传递，但是也是使用指针的副本，依旧是值传递。 \rimage-20210807001149451\r\n 创建指针类型结构体 取结构体地址实例化 结构体初始化  使用键值对初始化 使用值的列表初始化    package main import ( \u0026#34;fmt\u0026#34; ) type person struct { name string sex string } func main() { //结构体是值类型 \tp :=person{ name: \u0026#34;ljs\u0026#34;, sex: \u0026#34;男\u0026#34;, } fmt.Println(p) var p1 person p1.name =\u0026#34;lje\u0026#34; p1.sex = \u0026#34;nan\u0026#34; var p2 person p2 = p1 p2.name =\u0026#34;fyz\u0026#34; fmt.Println(p2) fmt.Println(p1) func(x person){ x.sex = \u0026#34;女\u0026#34; //传的是值 \t}(p2) fmt.Println(p2) func(x *person){ (*x).sex = \u0026#34;nv\u0026#34; //传的是地址 \t//x.sex = \u0026#34;nv\u0026#34; //语法糖 一样的同上 \t}(\u0026amp;p2) fmt.Println(p2) //创建一个指针类型的person \tvar p3 = new (person) //new 返回的是指针地址 这个类型 \tp3.sex = \u0026#34;nan\u0026#34; (*p3).name = \u0026#34;www\u0026#34; //语法糖 一样的同上 \tfmt.Println(p3) fmt.Printf(\u0026#34;%T\\n\u0026#34;,p3) fmt.Printf(\u0026#34;%p\\n\u0026#34;,p3) //返回的是这个指针的值 p3保存的值就是一个内存地址 \tfmt.Printf(\u0026#34;%v\\n\u0026#34;,p3) fmt.Printf(\u0026#34;%T\\n\u0026#34;,\u0026amp;p3) fmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;p3) //返回的是这个指针类型的值的地址  //key value 初始化 \tvar p4 =\u0026amp;person{ name: \u0026#34;lll\u0026#34;, } fmt.Println(p4) //使用值 列表的形式初始化 顺序保持一致 \tp5:=person{ \u0026#34;nv\u0026#34;, \u0026#34;slkdjf\u0026#34;, } fmt.Println(p5) } package main import \u0026#34;fmt\u0026#34; func main() { var a int a = 100 b := \u0026amp;a fmt.Printf(\u0026#34;%T %p\\n\u0026#34;,\u0026amp;a,\u0026amp;a) fmt.Printf(\u0026#34;%T %p\\n\u0026#34;,b,b) //b的值 \tfmt.Printf(\u0026#34;%T %v\\n\u0026#34;,b,b) //b的值 \tfmt.Printf(\u0026#34;%T %p\\n\u0026#34;,\u0026amp;b,\u0026amp;b) //b的内存地址 } 结构体的内存布局 占用连续内存\npackage main import \u0026#34;fmt\u0026#34; type x struct { a ,b ,c int8 } func main() { //结构体占用一块连续的内存空间 \tx :=x{ a: 10, b: 20, c: 30, } fmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(x.a)) fmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(x.b)) fmt.Printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;(x.c)) } 结构体是值类型 赋值的时候是拷贝\n构造函数：返回一个结构体变量的函数\n构造函数和方法\n方法和接收者 go语言中的方法method是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者receiver 接收者的概念就类似于其他语言中的this或者self\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } package main import \u0026#34;fmt\u0026#34; //标识符：变量名、函数名、类型名、方法铭 //go语言中如果标识符首字母是大写的，就表示对外部包可见（暴露的，公有的）  //Dog 这是一个狗的结构体注释 type Dog struct { name string } func newDog(name string) Dog { return Dog{ name: name, } } type person struct { name string age int } func newPerson(name string, age int) person { return person{ name: name, age: age, } } //方法是作用于特定类型的函数 //接受者表示的是调用该方法的具体类型变量，多用类型变量首字母小写表示 func (d Dog) wangwang() { fmt.Println(d.name+\u0026#34;汪汪汪\u0026#34;) } //使用值接收者：传拷贝进去 func (p person) guonian() { p.age++ } //操作指针 指针接收者：传地址进去 func (p *person) guonian1() { (*p).age++ } func main() { newDog(\u0026#34;jwt\u0026#34;).wangwang() p := newPerson(\u0026#34;ljs\u0026#34;, 18) fmt.Println(p.age) p.guonian() fmt.Println(p.age) p1:=newPerson(\u0026#34;jwt\u0026#34;,19) fmt.Println(p1.age) p1.guonian1() fmt.Println(p1.age) } 什么时候应该使用指针类型接收者  需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者  任意类型添加方法 package main import \u0026#34;fmt\u0026#34; //给自定义类型添加方法 //不能给别的包里面的类型添加方法，只能给自己的包里的类型添加方法 type myInt int func (i myInt) hello() { fmt.Println(\u0026#34;this is a int\u0026#34;+(string(i))) } func main() { var i myInt i= 10 i.hello() } 结构体的匿名字段 package main import \u0026#34;fmt\u0026#34; //匿名字段 type person struct { string int } func main() { a:=person{ \u0026#34;ljs\u0026#34;, 10, } fmt.Println(a.string) fmt.Println(a.int) } 结构体嵌套 实际上就是包含关系或者继承嘛感觉\n匿名嵌套结构体 匿名嵌套结构体的字段冲突\npackage main import \u0026#34;fmt\u0026#34; type person struct { name string age int addr address } type company struct { name string address //匿名嵌套结构体 可以直接拿到匿名结构体里面的字段 } type address struct { province string city string } func main() { p1:=person{ name: \u0026#34;ljs\u0026#34;, age: 18, addr: address{city: \u0026#34;fuzhou\u0026#34;,province: \u0026#34;fujian\u0026#34;}, } fmt.Println(p1.addr.province) c1:=company{ name: \u0026#34;alibaba\u0026#34;, address: address{province: \u0026#34;zhejiang\u0026#34;,city: \u0026#34;hangzhou\u0026#34;}, } fmt.Println(c1.city) //先在自己结构体找这个字段 找不到就去匿名嵌套的结构体中查找该字段 } 结构体的“继承” go语言中使用结构体也可以实现其他编程语言中面向对象的继承\npackage main import \u0026#34;fmt\u0026#34; type animal struct { name string } func (a animal) move() { fmt.Println(string(a.name)+\u0026#34;会动\u0026#34;) } type dog struct { feet byte animal } func (d dog) wang() { fmt.Println(d.name+\u0026#34;wangwangwang\u0026#34;) } func newDog(a animal, feet byte) dog { return dog{ feet,a, } } func newAnimal(name string) animal { return animal{name:name} } func main() { //结构体模拟实现其他语言中的继承  newDog(newAnimal(\u0026#34;jwt\u0026#34;),4).wang() d1:=dog{ 4, animal{name: \u0026#34;ljs\u0026#34;}, } d1.move() //只能匿名嵌套结构体才能实现类似于继承的效果 如果有名字好像就调用不了  } 结构体与json package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { //结构体与json  //1.序列化 把go语言中的结构体变量 --\u0026gt; json格式的字符串  //2.反序列化 把json格式的字符串 --\u0026gt; go语言中能够识别的结构体变量  p1:=person{ Name: \u0026#34;ljs\u0026#34;, Age: 18, } //序列化  v,err:=json.Marshal(p1) if err != nil { fmt.Println(\u0026#34;marshal fail \u0026#34;) fmt.Println(err) fmt.Printf(\u0026#34;%v %T\\n\u0026#34;,err,err) return } fmt.Println(v) fmt.Printf(\u0026#34;%v %T\\n\u0026#34;,string(v),v) //反序列化 传指针进去  var v1 person err1 := json.Unmarshal(v, \u0026amp;v1) if err1 != nil { fmt.Println(err1) return } fmt.Println(v1) fmt.Println(v1.Age) fmt.Println(v1.Name) s:=`{\u0026#34;name\u0026#34;:\u0026#34;ljs\u0026#34;,\u0026#34;age\u0026#34;:18}` var v2 person //传指针进去  json.Unmarshal([]byte(s),\u0026amp;v2) fmt.Printf(\u0026#34;%#v\\n\u0026#34;,v2) } type person struct { Name string `json:\u0026#34;name\u0026#34; db:\u0026#34;dbname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } day05内容回顾 自定义类型和类型别名 type myInt int 自定义类型 type myInt1 = int 类型别名 在编译过程中 类型别名只在代码编写过程中有效，编译完之后就不存在，内置的byte和rune都属于类型别名\n结构体 基本数据类型 ：表示现实中的物体有局限性\n结构体是一种数据类型，一种我们可以自己造的可以保存多个维度的类型\ntype person struct{ name string age int addr address } 匿名结构体 多用于了临时场景\n结构体的初始化 构造函数 方法和接收者 方法是有接收者的函数，接收者指的是哪个类型的变量可以调用这个函数\n接收者可以是指针 结构体是值类型\n结构体的嵌套 结构体的匿名字段 JSON序列化与反序列化 经常出现的问题\n 结构体内部的字段要大写 不然别人是访问不到的 反序列化时要传递指针  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type temp struct { X int `json:\u0026#34;x\u0026#34;` Y int `json:\u0026#34;y\u0026#34;` } func main() { var a = struct { x int y int }{x:2,y: 1} fmt.Println(a) var a1 temp a1.X = 1 a1.Y = 2 a2:=temp{ X: 0, Y: 0, } fmt.Println(a2) //调用构造函数  a3:=newTemp(1,2) fmt.Println(a3) a3.dream() a3.exchange() fmt.Println(a3) marshal, err := json.Marshal(a3) if err != nil { fmt.Println(err) } fmt.Println(string(marshal)) s1:=`{\u0026#34;x\u0026#34;:2,\u0026#34;y\u0026#34;:4}` var a4 temp err1 := json.Unmarshal([]byte(s1), \u0026amp;a4) if err1 != nil { fmt.Println(err1) } fmt.Println(a4) } //构造函数 返回值是对应的结构体类型 func newTemp(x, y int) temp { return temp{ X: x, Y: y, } } //接收者是用对应类型的首字母小写 //指定接收者之后 只有该类型的变量才有资格调用 func (t temp) dream() { fmt.Println(\u0026#34;temp也有梦想\u0026#34;) fmt.Println(t.X+t.Y) } //指针接收者 //1.需要修改结构体变量的值时需要使用指针接收者 //2.结构体本身比较大，拷贝的内存开销比较大时也要使用指针接收者 //3.保持一致性：如果有一个方法使用了指针接收者，其他的方法为了统一也要使用指针接收者 func (t *temp) exchange() { temp:=t.X t.X = t.Y t.Y = temp } type addr struct { city , province string } type student struct { name string addr //匿名嵌套结构体，就是用类型名字作为名称 } 接口interface 接口是一种类型，是一种特殊的类型，他规定了变量有哪些方法\n在编程中会遇到一下场景\n我不关心一个变量是什么类型，我只关心能调用他的什么方法\npackage main import \u0026#34;fmt\u0026#34; //引出接口的实例  type cat struct { } type dog struct { } func (c cat) speak() { fmt.Println(\u0026#34;miaomiaomiao~\u0026#34;) } func (d dog) speak() { fmt.Println(\u0026#34;wangwangwang~\u0026#34;) } type speaker interface { speak() //只要实现了speak方法的变量都是speaker类型 } func fuck(a speaker) { a.speak() } func main() { c:=cat{} d:=dog{} fuck(c) fuck(d) var ss1 speaker //定义一个接口类型 ：speaker的变量  ss1=d ss1.speak() ss:=speaker(c) ss.speak() } 接口的定义 type name interface{ methodname(参数1，参数2) (返回值1，返回值2) ... } 用来给变量/参数/返回值 等设置类型\n接口的实现 一个变量如果实现了接口中规定的所有的方法，那么这个变量就实现了这个接口，可以理解称为接口类型的变量。\n\rimage-20210808151410287\r\n\rimage-20210808151514714\r\n接口类型的变量 接口类型变量能够存储所有实现了该接口的实例\n值接收者和指针接收者实现接口的区别 前者可以传值，也可以传指针\n后者只能传指针\npackage main import ( \u0026#34;fmt\u0026#34; ) //使用值接收者和指针接收者的区别 type animal interface { move() eat(string) } type cat struct { name string feet int } ////使用值接收者实现了接口的所有方法 //func (c cat) move() { // fmt.Println(\u0026#34;走猫步\u0026#34;) //} // //func (c cat) eat(a string) { // fmt.Println(\u0026#34;猫吃\u0026#34;+a) //}  //使用指针接收者实现了接口的所有方法 func (c *cat) move() { fmt.Println(\u0026#34;走猫步\u0026#34;) } func (c *cat) eat(a string) { fmt.Println(\u0026#34;猫吃\u0026#34;+a) } func main() { var a1 animal c1:=cat{ name: \u0026#34;tom\u0026#34;, feet: 4, } c2:=\u0026amp;cat{ name: \u0026#34;假老练\u0026#34;, feet: 4, } a1=\u0026amp;c1 fmt.Println(a1) a1.eat(\u0026#34;bianbian\u0026#34;) a1=c2 fmt.Println(a1) a1.eat(\u0026#34;大便便\u0026#34;) } 类型与接口的关系 多个类型可以实现同一个接口\n一个类型可以实现多个接口\n接口可以嵌套接口\npackage main import \u0026#34;fmt\u0026#34; //接口还可以嵌套 type animal interface { mover eater } //同一个结构体可以实现多个接口 type mover interface { move() } type eater interface { eat(string) } type cat struct { name string feet byte } //一个结构体可以实现多个接口 func (c *cat) move() { fmt.Println(c.name+\u0026#34; is moving\u0026#34;) } func (c *cat) eat(something string) { fmt.Println(c.name+\u0026#34; is eating \u0026#34;+something) } func main() { c1:=cat{ name: \u0026#34;tom\u0026#34;, feet: 4, } mover.move(\u0026amp;c1) eater.eat(\u0026amp;c1,\u0026#34;猫粮\u0026#34;) } 空接口 type xxx interface{ } interface{} //既然是空接口 那就不需要名字了 所有的类型都实现了空接口这种类型，也就是任意类型的变量都能保存到空接口中。\n空接口的应用\n 作为函数的参数 作为map的值  package main import \u0026#34;fmt\u0026#34; //空接口 func main() { m1 := make(map[interface{}]interface{},10) m1[1]=\u0026#34;hello world\u0026#34; m1[\u0026#34;hello world\u0026#34;] = 1 m1[false] =[...]string{\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;} m1[[...]int{1,2}]=[]bool{true,false} fmt.Println(m1) show(m1) } func show(a interface{}) { fmt.Printf(\u0026#34;%T %v\\n\u0026#34;,a,a) } 类型断言 package main import ( \u0026#34;fmt\u0026#34; ) //类型断言 func main() { assert(\u0026#34;100\u0026#34;) assert(float32(32.1)) } func assert(a interface{}) { fmt.Printf(\u0026#34;%T %v\\n\u0026#34;,a,a) s,ok := a.(string) //类型断言  if !ok { fmt.Println(\u0026#34;error \u0026#34;) return } fmt.Println(s) switch i:=a.(type) { case string: fmt.Printf(\u0026#34;this is a string %T %v\\n\u0026#34;,i,i) case int: fmt.Printf(\u0026#34;this is a int %T %v\\n\u0026#34;,i,i) case bool: fmt.Printf(\u0026#34;this is a bool %T %v\\n\u0026#34;,i,i) case float64,float32: fmt.Printf(\u0026#34;this is a float %T %v\\n\u0026#34;,i,i) } } 接口的注意事项 只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时消耗\n包package 包是多个go源码的集合，是一种高级的代码复用方案，go语言为我们提供了很多内置包，如fmt、os、io等\n定义包\npackage 包名 注意：\n 一个文件夹下只能有一个包，同样一个包的文件不能在多个文件夹下 包名可以不和文件夹的名字一样，包名不能包含符号 - 包名为main的包为程序的入口包，编译时不包含main包的源代码是不会得到可执行文件的  包的导入  import导入语句通常放在文件开头包声明语句的下面 导入的包名需要使用双引号包裹起来 包名是从 $gopath/src/后开始计算的 ， 使用 / 路径进行分割 go语言禁止循环导入包  单行导入 、 多行导入、自定义导入、匿名导入包 _\ninit()初始化函数 在go语言程序执行时导入包语句会自动触发包内部init（）函数的调用\ninit()函数没有参数也咩有返回值 init()函数在程序运行时自动被调用执行 不能在代码中主动调用它\n\rimage-20210808175802083\r\n\rimage-20210808175917585\r\n文件操作 自己写一个日志库\n接口：用处？日志可以输出到终端，可以输出到文件，输出到卡夫卡\n文件操作\n打开和关闭文件 os.Open函数能够打开一个文件 返回一个*File 和一个err ，对得到的文件实例调用close()方法能够关闭文件\n为了防止文件忘记关闭 我们通常使用defer注册文件关闭语句\nfile.Read() bufio读取文件 ioutil读取整个文件 文件写入操作 os.openfile()函数能够以指定模式打开文件，从而实现文件写入相关功能\nfunc OpenFile(name string , flag int , perm FileMode) (*File,error){ } flag是文件打开的模式\n os.O_WRONLY os.O_CREATE os.O_RDONLY os.O_RDWR os.O_TURNC os.O_APPEND  perm：文件权限，一个八进制数。r读 o4 w写 o2 x执行 o1\nfile.write\nfile.writestring\nwriter:= bufio.NewWriter(file) ioutil.WriteFile\rpackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; ) func readFromFile1() { fileObj,err:=os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;open file failed...\u0026#34;) return } //记得关闭文件 \tdefer fileObj.Close() var b =make([]byte,128) for { n,err:=fileObj.Read(b) if err == io.EOF { fmt.Println(\u0026#34;读完了\u0026#34;) return } if err != nil { fmt.Println(\u0026#34;read from file failed , error\u0026#34;) return } fmt.Println(n) fmt.Println(string(b)) if n \u0026lt;128 { return } } } //利用bufio这个包读取文件 func readFromFileByBufio() { fileObjFile,err :=os.Open(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Printf(\u0026#34;err, %v\u0026#34;,err) return } defer fileObjFile.Close() reader:=bufio.NewReader(fileObjFile) for { string,err:=reader.ReadString(\u0026#39;\\n\u0026#39;) if err==io.EOF { return } if err != nil { fmt.Printf(\u0026#34;read line failed , err : %v\u0026#34;,err) return } fmt.Print(string) } } func readFromFileByIoutil() { file, err := ioutil.ReadFile(\u0026#34;./main.go\u0026#34;) if err != nil { fmt.Printf(\u0026#34;err , cause: %v\\n\u0026#34;,err) } fmt.Println(string(file)) } //打开文件 func main() { //readFromFile1() \t//readFromFileByBufio() \treadFromFileByIoutil() } package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; ) func write() { fileObj , err :=os.OpenFile(\u0026#34;./xx.txt\u0026#34;,os.O_WRONLY|os.O_CREATE|os.O_TRUNC,0644) if err != nil { fmt.Printf(\u0026#34;err cause: %v\\n\u0026#34;,err) return } //write \tfileObj.Write([]byte{97,98,99}) fileObj.Write([]byte(\u0026#34;this is a b c \u0026#34;)) fileObj.WriteString(\u0026#34;hello world!\u0026#34;) defer fileObj.Close() } func writeByBufIo() { file, err := os.OpenFile(\u0026#34;./xx.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { fmt.Printf(\u0026#34;err cause : %v\\n\u0026#34;,err) return } writer:= bufio.NewWriter(file) writer.WriteString(\u0026#34;comeon baby!\u0026#34;) //bufio是做了一个缓存 \twriter.Flush() defer file.Close() } func writeByIoutil() { str:=\u0026#34;hello 北京\u0026#34; err := ioutil.WriteFile(\u0026#34;./xx.txt\u0026#34;, []byte(str), 0666) if err != nil { fmt.Printf(\u0026#34;error cause : %v\\n\u0026#34;,err) return } } func main() { //write() \t//writeByBufIo() \twriteByIoutil() } 拷贝文件 可以借助io.copy()实现一个拷贝文件函数\npackage main import ( \u0026#34;io/ioutil\u0026#34; ) func main() { copyFile(\u0026#34;./xxcopy.txt\u0026#34;,\u0026#34;./xx.txt\u0026#34;) } func copyFile(dstName,srcName string) (written int64,err error) { //以读的方式打开文件 \t//file, err := os.OpenFile(srcName, os.O_RDONLY, 0644) \t//if err != nil { \t//\treturn 0, err \t//} \t//reader:= bufio.NewReader(file) \treadFile, err := ioutil.ReadFile(srcName) if err != nil { return 0, err } err1 := ioutil.WriteFile(dstName, readFile, 0644) if err1 != nil { return 0, err1 } return 1,nil } 通过文件操作获取终端输入\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //useScan() \tioscan() } func useScan() { fmt.Println(\u0026#34;请输入内容！\u0026#34;) var s string fmt.Scanln(\u0026amp;s) fmt.Printf(\u0026#34;你输入的内容是 %v\\n\u0026#34;,s) } func ioscan() { fmt.Println(\u0026#34;请输入内容！\u0026#34;) var s string reader := bufio.NewReader(os.Stdin) s,_=reader.ReadString(\u0026#39;\\n\u0026#39;) fmt.Println(s) } 日志库作业 需求：\n 可以往不同的输出位置记录日志 日志可以分为五种级别  内容回顾 包 包的定义 package，包名通常是和目录名一致，不能包含-\n 一个文件夹就是一个包 文件夹里面放的都是.go文件  包的导入 import\n ​\t单行导入 和 多行导入 ​ 包导入路径是从gopath\\src后面的路径开始写起 ​ 给导入的包起别名 匿名导入 \u0026mdash;\u0026gt; sql包导入时会讲 不支持循环导入  包中标识符(变量名、函数名、结构体、接口、常量\u0026hellip;) 可见性 标识符首字母大写\ninit()\n 包导入的时候会自动执行 一个包里只有一个init() init()没有参数也没有返回值也不能调用他 多个包的init执行顺序 一般用于初始化操作\u0026hellip;  接口 接口是一种类型，一种抽象的类型\n接口就是你要实现的方法的清单\n接口的定义 type mover interface{ 方法签名(参数)(返回值) } 接口的实现 实现了接口的所有方法就实现了这个接口\n实现了接口就可以当成这个接口类型的变量\n接口的变量 实现了一个变量，可以保存所有实现了我这个接口类型的值\n通常作为函数的参数出现\n空接口 接口中没有定义任何方法，也就是所任意类型都实现了空接口==\u0026gt;任何类型的变量都可以存到这个空接口变量中\ninterface {} 作为函数参数fmt.println()\nmap[string]interface{}\n接口底层  动态类型 动态值  类型断言 做类型断言的前提是 一定要是一个接口类型的变量\nx.(T)\n使用switch来做类型断言\n文件操作 打开文件和关闭文件 \rimage-20210810185410507\r\n缓冲区\n\rimage-20210810185806983\r\nread\nbufio\nioutil\n写文件 os.openfile()\nwrite 和 writestring\nbufio.newwriter\nioutil\n在文件中插入东东\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { //OpenFile() \tInsertFile() } func InsertFile() { //打开文件 \tfile, err := os.OpenFile(\u0026#34;./sb.txt\u0026#34;, os.O_RDWR, 0644) if err != nil { fmt.Printf(\u0026#34;err cause : %v\\n\u0026#34;,file) return } defer file.Close() //读首两个字节 \tvar b = [2]byte{} n, _ := file.Read(b[:]) //创建文件 写首两个字节 \topenFile, _ := os.OpenFile(\u0026#34;./sbinsert.txt\u0026#34;, os.O_CREATE|os.O_WRONLY, 0644) openFile.Write(b[:n]) defer openFile.Close() //尝试移动光标 \t_, err1 := file.Seek(2, 0) //光标移动 \tif err1 != nil { return } //尝试写要插入的数据 \topenFile.Write([]byte{\u0026#39;c\u0026#39;}) //尝试读光标下一个字节的数据 \tvar a [128]byte read, err2 := file.Read(a[:]) if err2 != nil { return } fmt.Println(string(a[:read])) openFile.Write(a[:read]) os.Rename(\u0026#34;./sbinsert.txt\u0026#34;,\u0026#34;./sb.txt\u0026#34;) //writer := bufio.NewWriter(file) \t//writer.WriteString(\u0026#34;c\u0026#34;) \t//writer.Flush()  } func OpenFile() { open, err := os.Open(\u0026#34;./xx.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;err cause: %v\\n\u0026#34;,open) return } defer open.Close() var b [128]byte for { read, err1 := open.Read(b[:]) if err1 != nil { fmt.Printf(\u0026#34;read err cause: %v\\n\u0026#34;,err1) return } fmt.Println(string(b[:])) if read \u0026lt;128 { return } } } 今日内容 time标准库 时间类型\ntime.time类型表示时间 我们可以通过time.now() 函数获取当前的时间对象 然后获取时间对象的年月日时分秒等信息。示例代码如下：\n时间戳 时间间隔 add sub equal before after 定时器time.tick 时间格式化 时间类型有一个自带的方法Format进行格式化，需要注意的是go语言中格式化时间模版不是常见的y-m-d h:/m:/s 而是使用go诞生的时间2006 1 2 3 4\n补充：如果想要格式化为12小时方式，需要指定PM\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { f2() } func f1() { now := time.Now() fmt.Printf(\u0026#34;%v \\n\u0026#34;,now) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Year()) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Month()) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Day()) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Hour()) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Minute()) fmt.Printf(\u0026#34;%v \\n\u0026#34;,now.Second()) fmt.Println(now.Date()) //时间戳  fmt.Println(now.Unix()) fmt.Println(now.UnixNano()) //time.Unix()  unix:= time.Unix(now.Unix(), 0) fmt.Println(unix) //时间间隔  fmt.Println(time.Second) //now +24 hours  fmt.Println(time.Now().Add(time.Hour*24)) //定时器  //tick := time.Tick(time.Second)  //for i := range tick {  // fmt.Println(i)  //}  //格式化时间 把语言中时间对象 转换成字符串类型的时间  //2021/08/10  fmt.Println(time.Now().Format(\u0026#34;2006/01/02\u0026#34;)) fmt.Println(time.Now().Format(\u0026#34;2006-1-2 15:04:05\u0026#34;)) fmt.Println(time.Now().Format(\u0026#34;2006-1-2 03:04:05\u0026#34;)) fmt.Println(time.Now().Format(\u0026#34;2006-1-2 15:04:05 PM\u0026#34;)) fmt.Println(time.Now().Format(\u0026#34;2006:01:02 15:04:05.000 PM\u0026#34;)) //按照对应的格式 解析字符串类型的时间  value, err := time.Parse(\u0026#34;2006-01-02\u0026#34;, \u0026#34;2019-05-20\u0026#34;) if err != nil { fmt.Println( \u0026#34; err \u0026#34;,err) return } fmt.Println(value) fmt.Println(time.Now().Sub(time.Now().Add(-time.Hour))) fmt.Println(\u0026#34;beginning\u0026#34;) //sleep  time.Sleep(time.Second*2) fmt.Println(\u0026#34;ending...\u0026#34;) } func f2() { now:= time.Now() //获取的是当前时区的时间  fmt.Println(now) //按照东八区的时区和格式解析一个字符串格式的时间  time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2021-08-11 21:33:05\u0026#34;) //根据字符加载时区  location, err := time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) if err!=nil { fmt.Printf(\u0026#34;load loc failed , err :%v\\n\u0026#34;,err) return } //按照指定时区解析时间  parseInLocation, err := time.ParseInLocation(\u0026#34;2006-01-02 15:05:05\u0026#34;, \u0026#34;2021-08-11 21:33:05\u0026#34;, location) fmt.Println(time.Now().Sub(parseInLocation)) } 日志库 需求分析\n  支持往不同的地方输出日志\n  分级别输出\n debug info warning error fatal    日志要支持开关控制，比如说开发的时候什么级别的日志都能输出，但是上线之后只有INFO级别往下才能输出\n  完整的日志记录要包含日志要有时间、行号、文件名、日志级别、日志信息\n  日志文件要切割\n 按文件大小切割  每次记录日志之前都判断一下当前写的这个文件的文件大小   按日期切割  在日志结构体中设置一个字段记录上一次切割的小时数 在写日志之前检查一下当前时间的小时数和之前保存的是否一致，不一致就要切割      package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { consoleLogger := NewConsoleLogger(ERROR) Logger.Debug(consoleLogger,\u0026#34;hello world\u0026#34;) Logger.Info(consoleLogger,\u0026#34;hello world\u0026#34;) Logger.Warning(consoleLogger,\u0026#34;hello world\u0026#34;) Logger.Error(consoleLogger,\u0026#34;hello world%d\u0026#34;,10) Logger.Fatal(consoleLogger,\u0026#34;hello world\u0026#34;) fileLogger := NewFileLogger(ERROR, \u0026#34;.\u0026#34;, \u0026#34;logdemo.txt\u0026#34;, \u0026#34;logdemoerr.txt\u0026#34;, 128) Logger(fileLogger).Debug(\u0026#34;hello world %d\u0026#34;,10) Logger(fileLogger).Error(\u0026#34;fatal error %v\u0026#34;,\u0026#34;某树被榨干了...\u0026#34;) } type Logger interface { Debug(string,...interface{}) Info(string,...interface{}) Warning(string,...interface{}) Error(string,...interface{}) Fatal(string,...interface{}) } type ConsoleLogger struct { LogLevel MODE } type MODE = int const ( DEBUG MODE =iota INFO WARNING ERROR FATAL ) func NewConsoleLogger(logLevel MODE) ConsoleLogger { return ConsoleLogger{ LogLevel: logLevel, } } func (m ConsoleLogger) Debug(s string,a...interface{}) { if m.LogLevel\u0026gt;=DEBUG { var msg string if a == nil { msg=s } else { msg=fmt.Sprintf(s,a) } fmt.Printf(\u0026#34;[%v] [DEBUG] this is a debug log, value :%v\\n\u0026#34;,time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;),msg) fmt.Println(getInfo(2)) } } func (m ConsoleLogger) Info(s string,a ...interface{}) { if m.LogLevel\u0026gt;=INFO { var msg string if a == nil { msg=s } else { msg=fmt.Sprintf(s,a) } fmt.Printf(\u0026#34;[%v] [INFO] this is a info log, value :%v\\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Println(getInfo(2)) } } func (m ConsoleLogger) Warning(s string , a ...interface{}) { if m.LogLevel\u0026gt;=WARNING { var msg string if a == nil { msg=s } else { msg=fmt.Sprintf(s,a) } fmt.Printf(\u0026#34;[%v] [WARNING] this is a warning log, value :%v\\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Println(getInfo(2)) } } func (m ConsoleLogger) Error(s string,a ...interface{}) { if m.LogLevel\u0026gt;=ERROR { var msg string if a == nil { msg=s } else { msg=fmt.Sprintf(s,a) } fmt.Printf(\u0026#34;[%v] [ERROR] this is a error log, value :%v \\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Println(getInfo(2)) } } func (m ConsoleLogger) Fatal(s string,a...interface{}) { if m.LogLevel\u0026gt;=FATAL { var msg string if a == nil { msg=s } else { msg=fmt.Sprintf(s,a) } fmt.Printf(\u0026#34;[%v] [FATAL] this is a fatal log, value :%v\\n\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Println(getInfo(2)) } } func getInfo(n int) string { caller, file, line, ok := runtime.Caller(n) if !ok { return \u0026#34;error\u0026#34; } name:= runtime.FuncForPC(caller).Name() return \u0026#34;fileLocation: \u0026#34;+path.Base(file)+\u0026#34;, method: \u0026#34;+name+\u0026#34;, line: \u0026#34;+strconv.Itoa(line) } type FileLogger struct { LogLevel MODE fileName string //日志文件的名称 \tfilePath string\t//日志文件的路径 \terrFileName string //错误日志单独记录 \tmaxFileSize int64 fileObj *os.File errFileObj *os.File } func NewFileLogger(logLevel MODE,filePath, fileName , errFileName string , maxFileSize int64)*FileLogger { file, err := os.OpenFile(path.Join(filePath,fileName), os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Println(err) return nil } errfile, err := os.OpenFile(path.Join(filePath,errFileName),os.O_CREATE|os.O_APPEND|os.O_WRONLY,0644) if err != nil { return nil } return \u0026amp;FileLogger{ LogLevel: logLevel, fileName: fileName, filePath: filePath, errFileName: errFileName, maxFileSize: maxFileSize, fileObj: file, errFileObj: errfile , } } func (f *FileLogger) Close() { f.fileObj.Close() f.errFileObj.Close() } func (f *FileLogger) checkSize(fileObj *os.File) bool { stat, err := fileObj.Stat() if err != nil { return false } if stat.Size() \u0026gt; f.maxFileSize { return true }else{ return false } } func (f *FileLogger)SplitLogFile() { //需要切割文件 \t//1.关闭当前文件 \tf.fileObj.Close() //2.rename 备份一下 xx.log -\u0026gt; xx.log.bak201908031709 \tnowStr:=time.Now().Format(\u0026#34;20060102150405000\u0026#34;) bakFilePath := path.Join(f.filePath, f.fileName)+\u0026#34;.bak\u0026#34;+nowStr err := os.Rename(path.Join(f.filePath, f.fileName), bakFilePath) if err != nil { return } //3.打开一个新的日志文件 \tnewFile, err := os.OpenFile(path.Join(f.filePath, f.fileName), os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644) if err != nil { return } //4.将打开的新日志文件对象赋值给 f.fileObj \tf.fileObj = newFile } func (f *FileLogger) Debug(s string, a ...interface{}) { if f.LogLevel\u0026gt;=DEBUG { if f.checkSize(f.fileObj) { f.SplitLogFile() } msg := fmt.Sprintf(s, a) msg = fmt.Sprintf(\u0026#34;[%v] [DEBUG] this is a debug log, value :%v\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Fprintln(f.fileObj) fmt.Fprintln(f.fileObj,msg) fmt.Fprintln(f.fileObj,getInfo(2)) f.Close() } } func (f *FileLogger) Info(s string, a ...interface{}) { if f.LogLevel\u0026gt;=INFO { msg := fmt.Sprintf(s, a) msg = fmt.Sprintf(\u0026#34;[%v] [INFO] this is a info log, value :%v\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Fprintln(f.fileObj) fmt.Fprintln(f.fileObj,msg) fmt.Fprintln(f.fileObj,getInfo(2)) f.Close() } } func (f *FileLogger) Warning(s string, a ...interface{}) { if f.LogLevel\u0026gt;=WARNING { msg := fmt.Sprintf(s, a) msg = fmt.Sprintf(\u0026#34;[%v] [WARNING] this is a warning log, value :%v\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Fprintln(f.fileObj) fmt.Fprintln(f.fileObj,msg) fmt.Fprintln(f.fileObj,getInfo(2)) f.Close() } } func (f *FileLogger) Error(s string, a ...interface{}) { if f.LogLevel\u0026gt;=ERROR { msg := fmt.Sprintf(s, a) msg = fmt.Sprintf(\u0026#34;[%v] [ERROR] this is a error log, value :%v\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Fprintln(f.fileObj) fmt.Fprintln(f.fileObj,msg) fmt.Fprintln(f.fileObj,getInfo(2)) fmt.Fprintln(f.errFileObj) fmt.Fprintln(f.errFileObj,msg) fmt.Fprintln(f.errFileObj,getInfo(2)) f.Close() } } func (f *FileLogger) Fatal(s string, a ...interface{}) { if f.LogLevel\u0026gt;=FATAL { msg := fmt.Sprintf(s, a) msg = fmt.Sprintf(\u0026#34;[%v] [FATAL] this is a Fatal log, value :%v\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15-04-05\u0026#34;), msg) fmt.Fprintln(f.fileObj) fmt.Fprintln(f.fileObj,msg) fmt.Fprintln(f.fileObj,getInfo(2)) fmt.Fprintln(f.errFileObj) fmt.Fprintln(f.errFileObj,msg) fmt.Fprintln(f.errFileObj,getInfo(2)) f.Close() } } 反射 反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。\n支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型名称、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改她们。\ngo程序在运行期使用reflect包访问程序的反射信息。\n空接口可以存储任意类型的变量，那么我们如何知道空接口保存的数据是什么呢？反射就是在运行时动态的获取一个变量的类型信息和值信息。\nreflect包 在go语言的反射机制中，任何接口值都是由一个具体类型和具体类型的值两部分组成的。在go语言中反射的相关功能有内置的reflect包提供，任意接口值在反射中都可以理解为有reflect.Type 和 reflect.Value 两部分组成，并且reflect包提供了reflect.TypeOf 和 reflect.ValueOf两个函数来获取任意对象的value和type\ntypeof\nvalueof\ntype name 和 type kind 在反射中关于类型还划分为两种：类型type和种类kind 在go语言中我们可以使用type关键字构造很多种自定义类I型那个，而种类kind就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类kind\nvalueof package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { reflectType(int64(8)) reflectType(int32(8)) reflectType(\u0026#34;hello world\u0026#34;) reflectType(map[interface{}]interface{}{1:\u0026#34;hello\u0026#34; , \u0026#34;hello world\u0026#34;:[]bool{true}}) reflectType(cat{name: \u0026#34;tomcat\u0026#34;}) reflectValue(int64(8)) b:=int64(20) //reflectSetValue1(b) //这样不行会引发panic错误  reflectSetValue2(\u0026amp;b) fmt.Println(b) var a *int fmt.Println(reflect.ValueOf(a).IsNil()) fmt.Println(reflect.ValueOf(a).IsValid()) c := cat{name: \u0026#34;tomcat\u0026#34;} fmt.Println(reflect.ValueOf(c).FieldByName(\u0026#34;name\u0026#34;)) fmt.Println(reflect.ValueOf(c).MethodByName(\u0026#34;name\u0026#34;).IsValid()) m:=map[string]int{\u0026#34;娜扎\u0026#34;:1} fmt.Println(reflect.ValueOf(m).MapIndex(reflect.ValueOf(\u0026#34;娜扎\u0026#34;)).IsValid()) } func reflectType(a interface{}) { v := reflect.TypeOf(a) fmt.Printf(\u0026#34;%T %v\\n\u0026#34;,v,v) fmt.Printf(\u0026#34;type %v kind %v \\n\u0026#34;,v.Name(),v.Kind()) } func reflectValue(a interface{}) { v:=reflect.ValueOf(a) kind := v.Kind() switch kind { case reflect.Int64: fmt.Printf(\u0026#34;type is int64,value is %d\\n\u0026#34;,int64(v.Int())) case reflect.Float32: fmt.Printf(\u0026#34;type is float32, value is %f\\n\u0026#34;,float32(v.Float())) } } func reflectSetValue1(x interface{}) { value := reflect.ValueOf(x) if value.Kind() == reflect.Int64 { value.SetInt(200) //修改的是副本 reflect包会引发panic  } } func reflectSetValue2(x interface{}) { value :=reflect.ValueOf(x) if value.Elem().Kind() == reflect.Int64 { value.Elem().SetInt(200) } } type cat struct { name string } 通过反射设置变量的值 想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的elem()方法来获取指针对应的值\nisNil和isValid 报告持有的值是否为nil，持有的值的分类必须是通道、函数、接口、映射、指针、切片之一，否则会导致panic\nisvalid返回v是否持有一个值，如果v是value的零值就会返回假，如果v除了isvalid、string、kind之外的方法都会导致panic\n区别 isnil常被用于判断指针是否为空，isvalid常被用于判定返回值是否有效\npackage main import ( json2 \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { s:=student{ Name: \u0026#34;xwz\u0026#34;, Score: \u0026#34;90\u0026#34;, } //最终要得到 {\u0026#34;name\u0026#34;:\u0026#34;xwz\u0026#34;,\u0026#34;score\u0026#34;:90}  typeof := reflect.TypeOf(s) json:=`{` for i := 0; i \u0026lt; typeof.NumField(); i++ { fmt.Println(typeof.FieldByIndex([]int{i}).Name) //fmt.Println(typeof.Field(i).Name)  fmt.Println(typeof.FieldByIndex([]int{i}).Tag.Get(\u0026#34;json\u0026#34;)) json+=\u0026#34;\\\u0026#34;\u0026#34;+typeof.Field(i).Tag.Get(\u0026#34;json\u0026#34;)+\u0026#34;\\\u0026#34;\u0026#34;+\u0026#34;:\u0026#34; structField, b := typeof.FieldByName(typeof.Field(i).Name) fmt.Println(structField.Name) fmt.Println(structField.Type) fmt.Println(structField.Index) valueof:= reflect.ValueOf(s) fmt.Println(valueof.Field(i)) sprint := fmt.Sprint(valueof.Field(i)) if b { json+=\u0026#34;\\\u0026#34;\u0026#34;+sprint+\u0026#34;\\\u0026#34;\u0026#34;+\u0026#34;,\u0026#34; } } s2 := json[:len(json)-1] json = s2 json+=\u0026#34;}\u0026#34; fmt.Println(json) var s1 student json2.Unmarshal([]byte(json),\u0026amp;s1) fmt.Println(s1) //反序列化实例 } type student struct { Name string `json:\u0026#34;name\u0026#34;` Score string `json:\u0026#34;score\u0026#34;` } 内容回顾 time 时间类型  time.Time : Time.Now() 时间戳:  time.Now().Unix() time.Now().UnixNano():1971.1.1到现在的纳秒数    时间间隔类型  time.Duration ：时间间隔类型  time.Second time.Hour time.Minute    时间操作 时间对象+-一个时间间隔对象\nafter 、 before\n时间格式化 format\n定时器 //定时器 //tick := time.Tick(time.Second) //for i := range tick { // fmt.Println(i) //} 解析字符串格式的时间（时区） now:= time.Now() //获取的是当前时区的时间 fmt.Println(now) //按照东八区的时区和格式解析一个字符串格式的时间 time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, \u0026#34;2021-08-11 21:33:05\u0026#34;) //根据字符加载时区 location, err := time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) if err!=nil { fmt.Printf(\u0026#34;load loc failed , err :%v\\n\u0026#34;,err) return } //按照指定时区解析时间 parseInLocation, err := time.ParseInLocation(\u0026#34;2006-01-02 15:05:05\u0026#34;, \u0026#34;2021-08-11 21:33:05\u0026#34;, location) fmt.Println(time.Now().Sub(parseInLocation)) 日志库 time\n文件操作\nruntime.caller()\n反射 接口类型的变量分为两部分，动态类型和动态值。\n反射的应用：json等数据解析 ORM等工具\u0026hellip;\n反射的两个方法：  reflect.Typeof() reflect.Valueof()  今日内容 strconv标准库介绍 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { str:=\u0026#34;1000\u0026#34; parseInt, err := strconv.ParseInt(str, 10, 64) //10进制 int64  if err != nil { return } fmt.Printf(\u0026#34;%T %v\\n\u0026#34;,parseInt,parseInt) parseInt1, err := strconv.ParseInt(str,10,0) if err != nil { return } fmt.Printf(\u0026#34;%T %v\\n\u0026#34;,parseInt1,parseInt1) atoi,_:=strconv.Atoi(\u0026#34;1000\u0026#34;)//go语言继承c语言而来的 a是array 因为string底层实际上是array的byte数组 i是int  fmt.Println(atoi) i :=97 fmt.Println(string(i)) //a  sprint := fmt.Sprint(i) //97  //字符串中解析出bool值  s2:=\u0026#34;true\u0026#34; parseBool, _ := strconv.ParseBool(s2) fmt.Println(parseBool) fmt.Println(strconv.ParseFloat(\u0026#34;2.14\u0026#34;,32)) fmt.Println(sprint) } 并发 并发是编程里面一个非常重要的概念，go语言在语言层面天生支持并发，这也是go语言流行的一个很重要的原因。\ngo语言的并发编程 并发与并行 并发：同一时间段内执行多个任务\n并行：同一时刻执行多个任务\ngo语言的并发通过goroutine实现。goroutine类似于线程，属于用户态的线程.我们可以根据需要创建成千上万个goroutine个并发工作。goroutine由go语言的运行时runtime调度完成，而线程是由操作系统调度完成的。\ngo语言还提供channel在多个goroutine间进行通信。goroutine和channel是go语言秉承CSP communication sequential process 并发模式的重要实现基础.\ngoutine 在java和c++中我们要实现并发编程的时候,我们通常要自己维护一个线程池,并且需要自己去包装一个又一个任务,同时需要自己去调度线程执行任务并维护上下文切换,这一切通常会耗费程序员大量的心智.那么能不能有一种机制,程序员只需要定义很多个任务,让系统去帮助我们吧这些任务分配到CPU上实现并发执行呢?\ngo语言中的goroutine就是这样一种机制,goroutine的概念类似于线程,但goroutine是由go的运行时runtime调度和管理的.go程序会智能地将goroutine中的任务合理的分配给每个cpu.go语言之所以被成为现代化的编程语言,就是因为他在语言层面已经内置了调度和上下文切换的机制.\n在go语言变成中你不需要自己去写进线程/线程/协程,你的技能包里只有一个技能 \u0026mdash;- goroutine,当你需要让某个任务并发执行的时候,你只需要把这个任务包装成一个函数,开启一个goroutine去执行这个函数就可以了,就是这么简单粗暴.\n使用goroutine go语言中使用goroutine非常简单,只需要在调用函数的时候在前面加上go关键字,就可以为一个函数创建一个goroutine\n一个goroutine必定对应一个函数,可以创建多个goroutine去执行相同的函数\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) //程序启动之后会创建一个主goroutine去执行 func main() { for i := 0; i \u0026lt; 10; i++ { //go hello(i) //开启一个单独的goroutine去执行hello函数（任务）  //匿名  //go func() {  // fmt.Println(i)  //}() //闭包 会出现i外层是1 内部输出1 外部这时候已经跑到10了 那么这时候内部就输出10  //  go func(i int) { fmt.Println(i) //用的是函数参数的那个i ， 不再是外面的那个i了  }(i) } fmt.Println(\u0026#34;main\u0026#34;) //main函数结束了 由main函数启动的goroutine也都结束了  time.Sleep(time.Second) } func hello(i int) { fmt.Println(\u0026#34;hello\u0026#34;,i) } goroutine什么时候结束 goroutine对应的函数执行结束 goroutine就结束了\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { //waitGroup  //f1()  for i := 0; i \u0026lt;10 ; i++ { wg.Add(1) go f2(i) } //如何知道这10个goroutine都结束了  wg.Wait() //等待wg的计数器减为0 } var wg sync.WaitGroup func f1() { rand.Seed(time.Now().UnixNano()) for i := 0; i \u0026lt; 5; i++ { i1 := rand.Int() i2 := rand.Intn(10) //左开右闭  fmt.Println(i1,i2) } } func f2(i int) { time.Sleep(time.Millisecond*time.Duration(rand.Intn(300))) fmt.Println(i) defer wg.Done() } rand func f1() { rand.Seed(time.Now().UnixNano()) for i := 0; i \u0026lt; 5; i++ { i1 := rand.Int() i2 := rand.Intn(10) //左开右闭  fmt.Println(i1,i2) } } goroutine与线程 可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB），一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和减小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大，所以在go语言中一次创建10w左右的goroutine也是可以的。\ngoroutine调度 GMP是go语言运行时runtime层面的实现，是go语言自己实现的一套调度系统。区别与操作系统调度OS线程。\n G很好理解，就是个goroutine的，里面除了存放goroutine信息外 还有与所在P的绑定等信息 M machine是Go运行时runtine对操作系统内核线程的虚拟，M与内核线程一般是一一映射的关系，一个goroutine最终是要放到M上执行的 P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针、堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。  P与M一般也是一一对应的。她们关系是：P管理着一组G挂载在M上运行。当一个G长久的阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时，回收掉旧的M\nP的个数是通过runtime.GOMAXPROCS设定的，最大为256 go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话会得不偿失\n单从线程调度讲，Go语言相比起来其他语言的优势在于OS线程是有OS内核来调度的。goroutine则是由Go运行时 runtime自己的调度器调度的。这个调度器使用一个成为m：n调度技术（复用/调度m个goroutine到n个OS线程）其一大特点是goroutine的调度是在用户态下完成的，不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放都是在用户态维护着一大块的内存池，不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。另一方面充分利用了多核的硬件资源，近似的吧若干goroutine均分在物理线程上，再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。\nGOMAXPROCS go运行时的调度使用gomaxprocs参数来确定需要使用多少个OS线程来同时执行go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把go代码同时调度到8个OS线程上(GOMAXPROCS是m：n调度中的n)\ngo语言中可以通过runtime.gomaxprocs()函数来设定当前程序并发时占用的CPU逻辑核心数\ngo1.5版本之前，默认使用的是单核心执行。go1.5版本之后，默认使用全部的CPU逻辑核心数\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func main() { runtime.GOMAXPROCS(2) //默认CPU的逻辑核心数，默认跑满整个CPU  fmt.Println(runtime.NumCPU()) wg.Add(2) go a() go b() wg.Wait() } func a() { for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;A:%d\\n\u0026#34;,i) } defer wg.Done() } func b() { for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;B:%d\\n\u0026#34;,i) } defer wg.Done() } go语言中的操作系统线程和goroutine的关系  一个操作系统线程对应用户态多个goroutine go程序可以同时使用多个操作系统线程 goroutine和OS线程是多对多的关系，即m:n  goroutine调度模型 GMP\nm：n\ngoroutine初始栈的大小是2k\nchannel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行的意义\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，但这种做法势必造成性能问题。\ngo语言的并发模型是CSP communication sequential processes 提倡通过通信共享内存而不是通过共享内存而实现通信\n如果说goroutine是go程序并发的执行体，channel就是他们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制\ngo语言中的通道channel是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出fifo的规则，保证收发数据的顺序。每一个通道都是具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nchannel类型 var 变量 chan 元素类型 通道必须使用make函数初始化才能使用\n发送 将一个值发送到通道中\nch \u0026lt;- 10 //把10发送到ch 接收 从一个通道接收值\nx := \u0026lt;- ch //从ch中接收值并赋值 \u0026lt;- ch //从ch中接收值，忽略结果 关闭 我们通过调用内置的close函数来关闭通道\nclose(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，他和关闭文件不一样，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n 对一个关闭的通道再发送值就会导致panic 对一个关闭的通道进行接收就会一直获取直到通道为空 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值 关闭一个已经关闭的通道会导致panic  无缓冲通道 无缓冲的通道又称为阻塞的通道。无缓冲的通道只在有人接收值的时候才能发送值。无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这个值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被成为同步通道\n有缓冲通道 在使用make初始化的时候为其指定通道的容量\n只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量\n如何优雅的从通道循环取值 当通过通道发送有限的数据时，我们可以通过close函数关闭通道来告知从该通道接收值的goroutine停止等待。当通道被关闭时，往该通道发送值会引发panic，从该通道里接收的值一直都是类型的零值。那么如何判断一个通道是否被关闭了呢？\n单向通道 有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如只能发送或只能接收。go语言中提供了单向通道来处理这种情况。\nvar ch1 \u0026lt;-chan //只能取值 var ch2 chan\u0026lt;- //只能存值 \rimage-20210813220847452\r\nworker pool （goroutine池） 编写代码实现一个计算随机数的每个位置数字之和的程序。要求使用goroutine和channel构建生产者和消费者模式，可以指定启动的goroutine数量-worker pool模式\n在工作中我们通常会用worker pool模式，控制goroutine数量，防止goroutine泄漏和暴涨\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) var jobs chan int var results chan int func main() { jobs = make(chan int , 100) results = make(chan int , 100) for i := 1; i \u0026lt;= 3; i++ { go worker(i,jobs,results) } for i := 1; i \u0026lt;= 5; i++ { jobs\u0026lt;-i } for i := 0; i \u0026lt; 5; i++ { \u0026lt;-results } //for result := range results {  // fmt.Println(result)  //} } func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for j := range jobs { fmt.Println(\u0026#34;worker \u0026#34;,id,\u0026#34; start job \u0026#34;,j) time.Sleep(time.Second) results\u0026lt;-2*j fmt.Println(\u0026#34;worker \u0026#34;,id,\u0026#34; end job\u0026#34; , j) } } 练习 select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现\n\rimage-20210813232439809\r\n这种方式虽然可以实现从多个通道接收值的要求，但是运行性能会差很多。为了应对这种场景，go内置了select关键字，可以同时响应多个通道的操作。select的使用类似于switch语句，他有一些case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。\n\rimage-20210813232707904\r\n使用select语句能提高可读性\n 可处理一个或多个channel的发送/接收操作 如果有多个case同时满足，select会随机选择一个 对于没有case的select{}会一直等待，可用于阻塞main函数  package main import \u0026#34;fmt\u0026#34; func main() { ch:=make(chan int , 1) for i := 0; i \u0026lt; 10; i++ { select { case x:=\u0026lt;-ch: fmt.Println(x) case ch\u0026lt;-i: default: fmt.Println(\u0026#34;hiahiahia\u0026#34;) } } } 并发安全和锁 作业  日志库中channel怎么用 什么时候起后台的goroutine去写日志到文件中  day08 今日内容 并发のgoroutine 并发和并行的区别\ngoroutine的启动 go\n将并发执行的任务包装成一个函数，调用函数的时候前面加上go关键字，就能够开启一个goroutine去执行该函数\ngoroutine对应的函数执行完，该goroutine就结束了\n程序启动的时候会自动的创建一个goroutine去执行main函数，main函数结束了那么程序就结束了所有开启的goroutine也都结束了\nsync.waitGroup 等待组\nvar wg waitGroup wg.add(1):计数器+1 wg.done()：计数器-1 wg.wait()：等待 goroutine的本质 goroutine的调度模型GMP\nm：n 把m个goroutine分配给n个操作系统的线程\ngoroutine与操作系统线程（OS）的区别 goroutine是用户态的线程，比内核态的线程更轻量级一点，初始值2Kb\nruntime.GOMAXPROCS() go1.5之后模式就是操作系统的逻辑核心数,默认跑满cpu\nruntime.GOMAXPROCS(1)只占用一个核心\nwork pool 模式 开启一定数据的goroutine去干活。\nchannel为什么需要 想通过channel实现多个goroutine的通信\nCSP ：通过通信来共享内存\nchannel是一种类型，一种引用类型。make函数初始化才能使用（slice / map /channel）\nchannel的声明 var ch chan int\nchannel的初始化 make(chan 元素类型，[缓冲区大小])\nchannel的操作：\n  发送\u0026lt;-\n  接收\u0026lt;-\n  关闭close\n  带缓冲区的通道和无缓冲区的通道\n单向通道 通常是用做函数的参数，只读和只写\nselect 同一时刻有多个通道要操作的场景，使用select\nsync包 互斥锁 互斥锁是一种常用的控制共享资源访问的方法，他能够保证同时只有一个goroutine可以访问资源，go语言中使用sync包的mutex类型来实现互斥锁。使用互斥锁来修复上面的代码\n使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁，当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的\n读写互斥锁 互斥锁是完全互斥的，但是很多实际场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在go语言中使用sync包中的rwmutex类型。\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获取锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。\nsync.waitgroup 在代码中生硬的使用time.sleep肯定是不合适的，go语言中可以使用sync.waitgroup来实现并发任务的同步\nwg.add\nwg.done\nwg.wait\nsync.waitgroup内部维护着一个计数器，计数器的值可以增加和减少。当我们启动了n个并发任务，就将计数器增加n，每个任务完成时通过调用done方法将计数器减一，通过调用wait来等待并发任务执行完，当计数器为0时，表示所有并发任务已经完成。\nsync.once 在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等\ngo语言中的sync包中提供了一个针对只执行一次场景的解决方案\u0026ndash;sync.once\nsync.once只有一个do方法\nfunc (o *Once) Do (f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用\nsync.map map并发多了之后执行就会报fatal error: concurrent map writes 错误\n像这种场景下就需要为map加锁来保证并发的安全性了，go语言的sunc包中提供了一个开箱即用的并发安全版map\u0026mdash;-sync.map 开箱即用表示不用向内置map一样使用make函数初始化就能直接使用。同时sync.map内置了诸如store 、 load 、 loadorstore 、 delete 、 range等操作方案\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;sync\u0026#34; ) var wg = sync.WaitGroup{} var m = sync.Map{} func main() { for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(i int) { key:=strconv.Itoa(i) set(key,i) //必须使用sync.map内置的store方法设置键值对  fmt.Printf(\u0026#34;k=%v v=%v\\n\u0026#34;,key,get(key)) //必须使用sync.map内置的load方法根据key取值  wg.Done() }(i) } wg.Wait() } func set(key string , value int) { m.Store(key,value) } func get(key string) interface{} { value,_:=m.Load(key) return value } atomic包 func loadint32\nfunc storeint32\nfunc addint32\nfunc swapint32\nfunc compareandswapint32\n网络编程 如何才能让我们的程序通过网络互相通信呢？本文只是演示了如何使用net包进行tcp和udp通信。\n互联网协议介绍 互联网的核心是一系列协议，总称为互联网协议internet protocol suite ， 正是这些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过复杂和庞大，只能介绍日常开发中接触较多的几个协议\n互联网分层模型 互联网的逻辑实现被分为好几层。每一层都有自己的功能。互联网按照不同的模型划分会有不同的分层，但是不论是按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠经硬件。在软件开发中我们使用最多的是将互联网划分为五个分层的模型。\n\rimage-20210815154839385\r\n物理层 我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、 无线电波等方式。这就叫做“实物理层”，他就是把电脑连接起来的物理手段。他主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。\n数据链路层 单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：多少个电信号算一组？每个信号为有何意义？这就是数据链路层的功能，他在物理层的上方，确定了物理层传输0和1的分组方式及代表的意义。早起的时候，每家公司都有自己的电信号分组方式。逐渐的，一种叫做以太网ethernet的协议占据了主导地位。\n以太网规定，一组电信号构成一个数据包，叫做帧frame。每一帧分为两部分：标头head和数据data。其中表头包含数据包的一些说明项，比如发送者、接收者、数据类型等等。数据则是数据包的具体内容。标头的长度固定为18字节。数据的长度最短为46字节，最长为1600字节。因此，整个帧最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。\n那么，发送者和接收者是如何标识的呢？以太网规定，连入网络的所有设备都必须具有网卡接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数来表示。前6个十六进制是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n我们会通过ARP协议来获取接收方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？ 其实这里以太网采用了一种很原始的方式，他不是把数据准确的送到接收方，而是向本网络内所有的计算机都发送，让每台计算机读取这个包的标头，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做广播broadcast\n网络层 按照以太网协议的规则我们可以依靠MAC 地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在师姐另一个儿角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一包，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。\n因此，必须找到一种方法区分那些MAC地址属于同一个子网络，那些不是。如果是同一个子网络，就采用广播方式发送，否则就采用路由方式发送。这就导致了网络层的诞生。他的作用是引进一套新的地址，使得我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址，简称网址\n网络层出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包发送到该子网络中的目标网卡上。因此，从逻辑上可以推断，必定是先处理网络地址，然后在处理MAC地址。\n规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4.IPv4这个版本规定，网络地址由32个二进制为组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255\n根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为标头和数据两个部分：标头部分主要包括版本、长度、IP地址等信息，数据部分则是IP数据包的具体内容，IP数据包的标头部分的长度为20到60字节，整个数据包的总长度最大为65535字节。\n传输层 有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做端口port，他其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n端口是0到65535之间的整数，正好是16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。 有了IP和端口我们就能实现唯一确定互联网上的一个程序，进而实现网络间的程序通信。\n我们必须在数据包中加入端口信息，这就是需要新的协议。最简单的实现叫做UDP协议，他的格式几乎就是在数据的前面，加上端口号。UDP数据包，也就是由标头和数据两部分组成：标头部分主要定义了发出端口和接收端口，数据部分就是具体的内容。UDP数据包非常简单，标头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据包。\nUDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这种问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。他的缺点是过程复杂、实现困难、消耗较多的资源、TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\n应用层 应用程序收到传输层的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。应用层的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。\n如图，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。\rimage-20210815163841064\r\nsocket编程 socket是BSD UNIX的进程通信机制，通常也称为套接字，用于描述IP地址和端口，是一个通信链的句柄。socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过套接字向网络发出请求或者应答网络的请求。\nsocket图解 socket是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，socket其实就是一个门面模式，他把复杂的TCP/IP协议族隐藏在socket后面，对用户来说只需要调用socket规定的相关函数，让socket去组织符合指定的协议数据然后进行通信。\n\rimage-20210815165946914\r\ngo语言实现TCP通信 TCP协议 TCP/IP transmission control protocol 、 internet protocol即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据就像水流一样传输，会存在粘包问题。\nTCP服务端 一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。\nTCP服务端程序的处理流程：\n 监听端口 接收客户端请求建立链接 创建goroutine处理连接  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) //tcp server端 func main() { //1.本地端口启动服务  listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:20000\u0026#34;) if err != nil { fmt.Println(\u0026#34;start server on 127.0.0.1:20000 failed , err : \u0026#34;,err) return } for { //2.等待别人来跟我连接  accept, err := listen.Accept() if err != nil { fmt.Println(\u0026#34;build connect failed , err : \u0026#34;,err) return } go func(conn net.Conn) { for { //3.与客户端通信  var temp [128]byte read, err := conn.Read(temp[:]) if err != nil { fmt.Println(\u0026#34;attemp read failed , err : \u0026#34;,err) return } fmt.Println(string(temp[:read])) } }(accept) } } client\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) //tcp client func main() { //1.与server建立连接  dial, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:20000\u0026#34;) if err != nil { fmt.Println(\u0026#34;dial 127.0.0.1:20000 failed , err : \u0026#34;,err) return } //2.发送数据  //var write1 = make([]byte,100)  //if len(os.Args)\u0026lt;2 {  // write1 = []byte(\u0026#34;hello world\u0026#34;)  //}else {  // write1 = []byte(os.Args[1])  //}  for { reader := bufio.NewReader(os.Stdin) //dial.Write(write1)  line, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) if string(line)==\u0026#34;exit\u0026#34; { break } dial.Write([]byte(line)) } dial.Close() } TCP黏包 黏包可发生在发送端也可发生在接收端：\n 由Nagle算法造成的发送端的黏包：nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，如有会一次把这两段数据发送出去。 接收端接收不及时造成的接收端黏包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。 \rimage-20210816200320281\r  server\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { dial, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;dial failed , error : \u0026#34;,err) return } defer dial.Close() for i := 0; i \u0026lt; 20; i++ { dial.Write([]byte(\u0026#34;how are you , hello !\u0026#34;)) } } server\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; ) func main() { listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;listen port failed , err : \u0026#34;,err) return } defer listen.Close() for { accept, err := listen.Accept() if err != nil { fmt.Println(\u0026#34;connect accept failed , err :\u0026#34;, err) return } go func(conn net.Conn) { defer conn.Close() for { var b [1024]byte read, err := conn.Read(b[:]) if err == io.EOF { break } if err != nil { fmt.Println(\u0026#34;try to read failed , err : \u0026#34;,err) return } fmt.Println(\u0026#34;received data : \u0026#34;,string(b[:read])) } }(accept) } } 解决方法 出现黏包的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。\n封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了（过滤非法包时封包会加入”包尾“内容）。包头部分的长度是固定的，并且他存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。\n我们可以自己定义一个协议，比如数据包的前四个字节为包头，里面存储的是发送的数据的长度。\n大端小端模式\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;src/code.oldboyedu.com/day8/11nianbao_jiejue/protocol\u0026#34; ) func main() { dial, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;dial failed , error : \u0026#34;,err) return } defer dial.Close() for i := 0; i \u0026lt; 20; i++ { encode, err := protocol.Encode(\u0026#34;how are you , hello!\u0026#34;) if err != nil { return } dial.Write(encode) //dial.Write([]byte(\u0026#34;how are you , hello !\u0026#34;))  } } protocol\npackage protocol import ( \u0026#34;bufio\u0026#34; \u0026#34;bytes\u0026#34; \u0026#34;encoding/binary\u0026#34; ) //Encode 将消息编码 func Encode(message string )([]byte,error) { //读取消息的长度，转换为int32  length := int32(len(message)) pkg := new(bytes.Buffer) //写入消息头  err := binary.Write(pkg, binary.LittleEndian, length) if err != nil { return nil, err } //写入消息体  err1 := binary.Write(pkg, binary.LittleEndian, []byte(message)) if err1 != nil { return nil, err1 } return pkg.Bytes(),err } //Decode 解码消息 func Decode(reader *bufio.Reader) (string, error) { //读取消息的长度  peek, err := reader.Peek(4) if err != nil { return \u0026#34;\u0026#34;, err } //读取前四个字节的数据  buffer := bytes.NewBuffer(peek) var length int32 err1 := binary.Read(buffer, binary.LittleEndian, \u0026amp;length) if err1 != nil { return \u0026#34;\u0026#34;, err1 } //Buffered 返回缓冲区中现有的可读取的字节数  if int32(reader.Buffered()) \u0026lt; length+4 { return \u0026#34;\u0026#34; , err } //读取真正的消息数据  pack:=make([]byte,int(4+length)) _,err2:=reader.Read(pack) if err2!=nil { return \u0026#34;\u0026#34;,err2 } return string(pack[4:]),nil } server\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;src/code.oldboyedu.com/day8/11nianbao_jiejue/protocol\u0026#34; ) func main() { listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:30000\u0026#34;) if err != nil { fmt.Println(\u0026#34;listen port failed , err : \u0026#34;,err) return } defer listen.Close() for { accept, err := listen.Accept() if err != nil { fmt.Println(\u0026#34;connect accept failed , err :\u0026#34;, err) return } go func(conn net.Conn) { defer conn.Close() for { reader := bufio.NewReader(conn) decode, err := protocol.Decode(reader) if err != nil { return } fmt.Println(\u0026#34;received data : \u0026#34;,decode) } }(accept) } } UDP协议 UDP协议 user datagram protocol中文名称是用户数据报协议，是OSI open system interconnection ， 开放式系统互联，参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的，没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域\nUDP服务端 server\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;strings\u0026#34; ) func main() { udp, err := net.ListenUDP(\u0026#34;udp\u0026#34;,\u0026amp;net.UDPAddr{ IP: net.IPv4(127,0,0,1), Port: 40000, }) if err != nil { fmt.Println(\u0026#34;listen failed , error : \u0026#34;,err) return } //不需要建立链接，直接收发数据  var b [1024]byte defer udp.Close() for { n, addr, err := udp.ReadFromUDP(b[:]) if err != nil { fmt.Println(\u0026#34;read from udp failed , err: \u0026#34; , err) return } fmt.Println(b[:n]) reply:=strings.ToUpper(string(b[:n])) //发送数据  udp.WriteToUDP([]byte(reply),addr) } } client\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { //UDP client  socket, err := net.DialUDP(\u0026#34;udp\u0026#34;,nil,\u0026amp;net.UDPAddr{ IP: net.IPv4(127, 0, 0, 1), Port: 40000, }) if err != nil { fmt.Println(\u0026#34;dial failed , error : \u0026#34;,err) return } defer socket.Close() reader := bufio.NewReader(os.Stdin) var reply [1024]byte for { readString, err := reader.ReadString(\u0026#39;\\n\u0026#39;) if err != nil { return } socket.Write([]byte(readString)) //收回复的数据  n, adder, err := socket.ReadFromUDP(reply[:]) if err != nil { return } fmt.Println(\u0026#34;received data: ,addr : \u0026#34;,string(reply[:n]),adder) } } day09 日志收集项目\ngin框架和微服务\ndocker和k8s\n今日分享 注释/日志/单元测试\n今日内容 context\n单元测试\npprof调试工具\n内容回顾 互斥锁 sync.mutex\n是一个结构体 是值类型 。给函数传参数的时候要传指针\nlock 和 unlock\n为什么要用锁 防止同一时刻多个goroutine操作同一资源\n读写互斥锁 适用于读多写少的场景下,才能提高程序的执行效率\n特点:\n 如果是读的人来获取的是读锁,后续的goroutine能读不能写 如果是写的goroutine来了,获取的是写锁,后续的goroutine不管是读还是写,都要等待获取锁  rwlock.rlock()\nrwlock.wlock()\nrwlock.lock()\nrwlock.unlock()\n等待组 sync.waitgroup\n用来等goroutine执行完再继续\n是一个结构体,是值类型,给函数传参数的时候要传指针\nwg.add()\nwg.done()\nwg.wait()\nsync.Once 使用场景\n某些函数只需要执行一次的时候，就可以使用sync.once\nonce.Do(func ( ) )\n接收无参数无返回值的函数参数\nsync.Map 使用场景\n并发操作一个map的时候，内置的map不是并发安全的\n使用，是一个开箱即用的(不需要make）并发安全的map\nvar map sync.Map\nload()\nstore()\nloadorstore()\ndelete()\nrange()\n原子操作 go语言内置了一些针对内置的基本数据类型的一些并发安全的操作\nvar i int64 =10 atomic.addint64(\u0026amp;i,1) 网络编程 互联网协议 OIS七层模型\n应用层 表示层 会话层 传输层 网络层 数据链路层 物理层\nHTTP客户端和服务端 go语言内置的net/http包提供了http客户端和服务端的实现\nHTTP协议 超文本传输协议HTTP hypertext transfer protocol 是互联网上应用最为广泛的一种网络传输协议，所有www文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\nHTTP客户端 使用net / http 包编写一个简单的发送HTTP请求的client端\n\rimage-20210817000221229\r\nHTTP：超文本传输协议\n规定了：浏览器和网站服务器之间通信的规则\nHTML：超文本标记语言\n学的就是标记的符号、标签\nCSS：层叠样式表\n规定了HTML中标签的具体样式（颜色、背景、大小、位置、浮动\u0026hellip;）\nJS：一种跑在浏览器上的编程语言\nhttp_server\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) //net / http server func main() { http.HandleFunc(\u0026#34;/posts/go/15_socket/\u0026#34;,f1) http.HandleFunc(\u0026#34;/xxx/\u0026#34;,f2) http.ListenAndServe(\u0026#34;127.0.0.1:9090\u0026#34;,nil) } func f2(writer http.ResponseWriter, request *http.Request) { //对于get请求 参数都放在URL上 （query param）请求体中是没有数据的 \tfmt.Println(request.URL) fmt.Println(request.Method) fmt.Println(ioutil.ReadAll(request.Body)) writer.Write([]byte(\u0026#34;ok!\u0026#34;)) queryParam :=request.URL.Query() fmt.Println(queryParam) name:=queryParam.Get(\u0026#34;name\u0026#34;) fmt.Println(name) age:=queryParam.Get(\u0026#34;age\u0026#34;) fmt.Println(age) } func f1(w http.ResponseWriter, r *http.Request) { file, err := ioutil.ReadFile(\u0026#34;./xx.txt\u0026#34;) if err != nil { w.Write([]byte(fmt.Sprintf(\u0026#34;%v\u0026#34;,err))) return } w.Write(file) } http_client\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) //net/http client func main() { f1() f2() f3() } //构造一个client var client= http.Client{ Transport: \u0026amp;http.Transport{ DisableKeepAlives:false}} func f3() { //构造参数  urlparams := url.Values{} urlparams.Add(\u0026#34;name\u0026#34;,\u0026#34;ljs\u0026#34;) urlparams.Add(\u0026#34;score\u0026#34;,\u0026#34;100\u0026#34;) //构造头部  urlParse, _ := url.ParseRequestURI(\u0026#34;http://127.0.0.1:9090/xxx\u0026#34;) //拼接url  urlParse.RawQuery = urlparams.Encode() //构造一个请求 request  request, _ := http.NewRequest(\u0026#34;get\u0026#34;, urlParse.String(), nil) response, _ := client.Do(request) defer response.Body.Close() ioutil.ReadAll(response.Body) } func f2() { //构造请求  uri, _ := url.ParseRequestURI(\u0026#34;http://127.0.0.1:9090/xxx\u0026#34;) data:=url.Values{} data.Set(\u0026#34;name\u0026#34;,\u0026#34;林の树\u0026#34;) data.Set(\u0026#34;age\u0026#34;,\u0026#34;18\u0026#34;) urlStr := data.Encode() fmt.Println(urlStr) uri.RawQuery=urlStr fmt.Println(uri) request, err := http.NewRequest(\u0026#34;Get\u0026#34;, uri.String(), nil) if err != nil { fmt.Println(\u0026#34;request failed ,error : \u0026#34;,err) return } //发请求  response, err := http.DefaultClient.Do(request) if err != nil { return } defer response.Body.Close() //一定要记得关闭resp.body  all, err := ioutil.ReadAll(response.Body) if err != nil { return } fmt.Println(string(all)) } func f1() { response, err := http.Get(\u0026#34;http://127.0.0.1:9090/xxx?name=ljs\u0026amp;age=18\u0026#34;) if err != nil { fmt.Println(\u0026#34;get failed , error : \u0026#34;,err) return } //从response中吧服务端返回的数据读出来  read, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(\u0026#34;read failed , error : \u0026#34;,err ) return } fmt.Println(string(read)) } http.get\nhttp.post\nhttp.postform\n单元测试 开发自己给自己的代码写测试\ngo语言中的测试依赖go test命令。编写测试代码和编写普通的go代码过程是类似的，并不需要学习新的语法、规则或工具。\ngo test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build 编译到最终的可执行文件中。\n在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。\n   类型 格式 作用     测试函数 函数名前缀为test 测试程序的一些逻辑行为是否正确   基准函数 函数名前缀为benchmark 测试函数的性能   示例函数 函数名前缀为example 为文档提供实力文档    go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件\n测试函数 测试函数的格式 每个测试函数必须导入testing包，基本格式如下：\nfunc TestName (t *testing.T) { } //testing.T拥有的方法如下 Error Errorf Fail FailNow Failed Fatal Fatalf Log Logf Name Parallel Run Skip SkipNow Skipf Skipped 测试用例和测试组和子测试 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) var m = make([]string,4) //Split 切割字符串 a b c =\u0026gt; [a c] func Split(str ,sep string) []string { i:=0 judge(str,sep,i) return m } func judge(s string,sep string,i int) { if !strings.Contains(s,sep){ return } index:=strings.Index(s,sep) if s[:index] != \u0026#34;\u0026#34; { m[i] = s[:index] }else { m[i]=s[index+1:] } if s[index+1:]!=\u0026#34;\u0026#34; { m[i+1] = s[index+1:] } judge(m[i+1],sep,i+1) } func main() { got:=Split(\u0026#34;abcb\u0026#34;,\u0026#34;b\u0026#34;) fmt.Println(got) } 测试用例写\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) func TestSplit(t *testing.T) { got:=Split(\u0026#34;abcb\u0026#34;,\u0026#34;b\u0026#34;) want:=[]string{\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34; \u0026#34;} if !reflect.DeepEqual(got, want) { fmt.Println(\u0026#34;测试用例失败\u0026#34;) t.Errorf(\u0026#34;want %v but got %v\\n\u0026#34;,want,got) } } func TestSplit2(t *testing.T) { got:=Split(\u0026#34;a:b:c\u0026#34;,\u0026#34;:\u0026#34;) want:=[]string{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;} if !reflect.DeepEqual(got, want) { t.Errorf(\u0026#34;want %v but got %v\\n\u0026#34;,want,got) } } //测试组 func TestSplitGroup(t *testing.T) { type TestCase struct { str string sep string got string want []string } testCase :=[]TestCase{ { str: \u0026#34;abcb\u0026#34;, sep: \u0026#34;b\u0026#34;, want: []string{\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;\u0026#34;}, }, { str:\u0026#34;a:b:c\u0026#34;, sep: \u0026#34;:\u0026#34;, want:[]string{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;}, }, } for _, v := range testCase { if !reflect.DeepEqual(Split(v.str,v.sep),v.want){ t.Errorf(\u0026#34;want %v but got %v\\n\u0026#34;,v.want,Split(v.str,v.sep)) } } } func TestSingle(t *testing.T) { type TestCase struct { str string sep string got string want []string } testCase:=map[string]TestCase{ \u0026#34;case1\u0026#34;:{ str: \u0026#34;abcb\u0026#34;, sep: \u0026#34;b\u0026#34;, want: []string{\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;\u0026#34;}, }, \u0026#34;case2\u0026#34;:{ str:\u0026#34;a:b:c\u0026#34;, sep: \u0026#34;:\u0026#34;, want:[]string{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;}, }, } for name, v := range testCase { t.Run(name, func(t *testing.T) { got:=Split(v.str,v.sep) if !reflect.DeepEqual(got, v.want) { t.Errorf(\u0026#34;want %v but got %v\\n\u0026#34;,v.want,got) } }) } } 尝试新的跨平台 PowerShell https://aka.ms/pscore6 PS E:\\project\\GOproject\\src\\code.oldboyedu.com\\day9\\02splitString\u0026gt; go test -run=TestSingle/case2 --- FAIL: TestSingle (0.00s) --- FAIL: TestSingle/case2 (0.00s) split_test.go:77: want [a b c] but got [a b c ] FAIL exit status 1 FAIL src/code.oldboyedu.com/day9/02splitString 0.240s 测试覆盖率 go test -cover\n函数覆盖率100%\n代码覆盖率60%\n基准测试 基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：\nfunc BenchName(b *testing.B)\n\rimage-20210818211645228\r\n性能比较测试 默认情况下每个基准测试至少运行1s，如果在benchmark函数 返回时没有到1s，则b.N的值会按1,2,5,50\u0026hellip;增加,并且函数再次运行\n可以指定benchtime\n重置时间 b.ResetTimer之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。\n并行测试 runparallel会以并行的方式执行给定的基准测试\n可以调用setparallelism来确定cpu核数\nsetUp和teardown 测试程序有时需要在测试之前进行额外的设置setup或者在测试之后进行拆卸teardown\n示例函数 ExampleName\nprof调试工具 go语言项目中的性能优化主要有以下几个方面：\n CPU profile：报告程序的CPU使用情况，按照一定频率去采集应用程序在CPU和寄存器上面的数据 Memory Profile (Heap Profile) :报告程序的内存使用情况 Block Profiling: 报告goroutines不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈 Goroutine Profiling:报告goroutines的使用情况，有那些goroutine，她们的调用关系是怎么样的  采集性能数据 go语言内置了获取程序的运行数据的工具，包括一下两个标准库\n runtime/pprof:采集工具型应用运行数据进行分析 net/http/pprof:采集服务型应用运行时数据进行分析  pprof开机后，每个一段时间10ms就会收集当前的堆栈信息，获取各个函数占用的cpu以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。\n注意，我们只应该在性能测试的时候才在代码中引入pprof\nCPU性能分析 pprof.StartCPUProfile(w io.Writer)\npprof.stopCPUPorfile()\n应用执行结束后，就会生成一个文件，保存了我们的CPUprofiling数据。得到采样数据之后，使用go tool pprof工具进行CPU性能分析\n等待30s\n内存性能优化 pprof.WriteHeapProfile(w io.Writer)\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/pprof\u0026#34; \u0026#34;time\u0026#34; ) func main() { var isCPUPprof bool //是否开启cpuprofile标志位  var isMemPprof bool //是否开启内存profile标志位  flag.BoolVar(\u0026amp;isCPUPprof,\u0026#34;cpu\u0026#34;,false,\u0026#34;turn cpu pprof on\u0026#34;) flag.BoolVar(\u0026amp;isMemPprof,\u0026#34;mem\u0026#34;,false,\u0026#34;turn mem pprof on\u0026#34;) flag.Parse() if isCPUPprof { create, err := os.Create(\u0026#34;./cpu.pprof\u0026#34;) if err != nil { fmt.Println(\u0026#34;create file failed , error : \u0026#34;,err) return } pprof.StartCPUProfile(create) //往文件中记录cpu profile信息  defer create.Close() defer pprof.StopCPUProfile() } for i := 0; i \u0026lt; 6; i++ { go logicCode() } time.Sleep(20*time.Second) if isMemPprof{ create, err := os.Create(\u0026#34;./mem.pprof\u0026#34;) if err != nil { fmt.Println(\u0026#34;create file failed , error : \u0026#34;,err) return } pprof.WriteHeapProfile(create) defer create.Close() } } func logicCode() { var c chan int //nil  for { select { case v:=\u0026lt;-c: //阻塞  fmt.Printf(\u0026#34;received from chan , value : %v\\n\u0026#34;,v) default: time.Sleep(time.Millisecond*500) } } } 命令行交互界面 使用go工具链里的pprof来分析一下\n服务型应用 flag 通过flag.string or flag.stringvar 定义好命令行flag参数后，需要通过调用flag.parse()来对命令行参数进行解析\n支持的命令行参数格式有以下几种\n -flage xxx \u0026ndash;flag xxx -flag=xxx \u0026ndash;flag=xxx  其中，布尔类型的参数必须使用等号方式指定\nflag解析在第一个非flag参数之前停止 或者在终止符-之后停止\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) //flag 获取命令行参数 func main() { //创建一个标志位参数flag  name :=flag.String(\u0026#34;name\u0026#34;,\u0026#34;ljs\u0026#34;,\u0026#34;请输入名字\u0026#34;) age :=flag.Int(\u0026#34;age\u0026#34;,100,\u0026#34;请输入年龄\u0026#34;) married :=flag.Bool(\u0026#34;married\u0026#34;,false,\u0026#34;结婚了么\u0026#34;) cTime:=flag.Duration(\u0026#34;duration\u0026#34;,time.Second,\u0026#34;有多快\u0026#34;) //使用flag  //flag.Parse()  fmt.Println(*name) fmt.Println(*age) fmt.Println(*married) fmt.Println(*cTime) var name1 string flag.StringVar(\u0026amp;name1,\u0026#34;name1\u0026#34;,\u0026#34;name1\u0026#34;,\u0026#34;请输入name1\u0026#34;) flag.Parse() fmt.Println(name1) fmt.Println(flag.NArg()) //返回除了规定的参数之外的命令行参数有几个  fmt.Println(flag.NFlag()) //返回规定的flag命令行参数有几个  fmt.Println(flag.Args()) //返回除了规定的参数之外的命令行参数具体是  } 面试题 \rimage-20210819001237778\r\n本周复习 两个面试题\nleetcode刷题每天一道题\n数据结构和算法很重要，要找机会抓紧补上\n内容回顾 net/http包的用法 如何发请求\n当需要频繁发送请求的时候（每5s从阿里云接口同步数据）：定义一个全局的client，后续发请求的操作都使用这个全局的client\n单元测试 xxx/ccc.go\n单元测试的文件名必须是xxx/ccc_test.go\ngo内置的单元测试工具：\ngo test 单元测试函数\n//Test开头后接函数名 func TestSplit(t *testing.T) { } 性能测试/基准测试 函数格式\nfunc BenchmarkSplit(b *testing.B) { //b.N:被测试函数执行的次数 } 执行命令：\ngo test -bench=Split -v 并行测试 setup和teardown pprof 记录cpu和内存的快照信息\nflag标准库 os.Args\nflag.stringvar()返回的是一个指针变量\n必须调用flag.parse()\n./xxx -name = \u0026#34;lsj\u0026#34; -age=90 flag.args\nflag.nargs\nflag.nflag\n今日内容 Mysql：主流的关系型数据库 类似的还有postgreSQL\nredis：kv数据库\nnsq:go语言开发的分布式消息队列\n包的依赖管理go module go1.1之后官方出的依赖管理工具\nMySql 数据库\n常见的数据库：oracle sqlite文件数据库 mysql sqlserver\n关系型数据库：用表来存一类数据\n表结构设计的三大范式《漫画数据库》\nmysql知识点\nsql语句：结构化查询语言\n存储引擎 mysql支持插件式的存储引擎\n常见的存储引擎：myisam、innodb\nmyisam：\n 查询速度快 只支持表锁 不支持事务  innodb：\n 整体速度快 支持表锁和行锁 支持事务  事务：把多个操作当成一个整体\n事务的特点：\nACID\n 原子性：事务要么成功，要么失败，没有中间状态 一致性：数据库的完整性没有被破坏 持久性：事务操作的结果是不会被丢失的 隔离性：事务之间是相互隔离的  隔离级别  读未提交 读提交 可重复读 串行化      索引 索引的原理是：B树和B+树\n索引类型：\n索引的命中\n分库分表\nSQL注入\nSQL慢查询优化\nMysql主从：binlog\nMysql读写分离\nGo操作MySql 连接 go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入至少一个数据库驱动。\n我们常用的数据库基本上都有完整的第三方实现。\ndatabase/sql 原生支持连接池，是并发安全的\n这个标准库没有具体实现，只是列出了一些需要第三方库实现的具体内容。\n下载依赖 go get -u github.com/go-sql-driver/mysql\n使用Mysql驱动 func Open(driverName , dataSourceName string)(*DB , error)\nopen一个drivername指定的数据库，datasourcename指定数据源，一般包至少包括\n\rimage-20210820105514841\r\ngo get包的路径就是下载第三方的依赖\n将第三方的依赖默认保存在$gopath/src/\n使用驱动 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;log\u0026#34; ) func main() { //go连接mysql实例  //数据库源信息  dsn:=\u0026#34;root:123456@tcp(127.0.0.1:3306)/tset\u0026#34; //连接数据库  db, err := sql.Open(\u0026#34;mysql\u0026#34;, dsn) //不会校验用户名和密码是否正确  if err != nil { log.Printf(\u0026#34;dsn %s invalid , err : %v\\n\u0026#34;,dsn,db) return } err = db.Ping() if err != nil { log.Printf(\u0026#34;open %s failed , err : %v\\n\u0026#34;,dsn , err) return } fmt.Println(db,\u0026#34;连接数据库成功!\u0026#34;) } github上的mysql驱动如何关联到database/sql这个包里呢？\n\rimage-20210820123021805\r\n单行查询 单行查询db.queryrow()执行一次查询，并期望返回最多一行结果row。queryrow总是返回非nil值，直到返回值的scan方法被调用时，才会返回被延迟的错误（如未找到）\nsetmaxopenconns方法 设置与数据库连接池的最大连接数\nsetmaxidleconns方法 setmaxidleconnes设置连接池中的最大闲置连接数。如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。如果n\u0026lt;=0 不会保留闲置连接\n多行查询 多行查询db.query()执行一次查询，返回多行结果（rows），一般用于执行select命令。参数args表示query中的占位参数\n插入数据 插入、更新和删除操作都使用方法 Exec\n删除也是一样的\nMySQL预处理 什么是预处理 普通sql语句执行过程:\n 客户端对SQL语句进行占位符替换得到完整的SQL语句 客户端发送完整的SQL语句到MySQL服务端 mysql服务端执行完整的sql语句并将结果返回给客户端  预处理执行过程:\n 把sql语句分成两部分,命令部分与数据部分 先把命令部分发送给mysql服务端,mysql服务端进行sql预处理 然后吧数据部分发送给mysql服务端,mysql服务端对sql语句进行占位符替换 mysql服务端执行完整的sql语句并将结果返回给客户端  为什么要预处理 1.优化mysql服务器重复执行sql的方法,可以提升服务器性能,提前让服务器编译,一次编译多次执行,节省后续编译的成本\n2.避免sql注入的问题\ngo实现mysql预处理 prepare方法会先将sql语句发送给mysql服务端,返回一个准备好的状态用于之后的查询和命令.返回值可以同时执行多个查询和命令\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;log\u0026#34; ) type student struct { sno ,sname,ssex string sage int } var db *sql.DB //是一个连接池对象 func main() { initDB() //queryOne(\u0026#34;2016210867\u0026#34;)  //queryMany()  //insert()  //update()  prepareSelect() } func initDB() (err error) { dsn:=\u0026#34;root:123456@tcp(127.0.0.1:3306)/tset\u0026#34; db,err =sql.Open(\u0026#34;mysql\u0026#34;,dsn) if err != nil { log.Printf(\u0026#34;dsn %s is invalid , error : %v\\n\u0026#34;,dsn,err) } err = db.Ping() if err != nil { log.Printf(\u0026#34;open %s failed , err : %v\\n\u0026#34;,dsn,err) return err } //设置数据库连接池最大连接数 如果超过了就会阻塞等待其他的程序  db.SetMaxOpenConns(10) //最大空闲连接数  db.SetMaxIdleConns(5) return nil } func queryOne(sno string) { var s student //查找  row := db.QueryRow(\u0026#34;select * from student where sno = ?\u0026#34;,sno) //从连接池中拿一个连接出来去数据库查询单挑记录  //扫描+释放连接 必须对rowobj调用scan方法  row.Scan(\u0026amp;s.sno,\u0026amp;s.sname,\u0026amp;s.ssex,\u0026amp;s.sage) var sname string db.QueryRow(\u0026#34;select sname from student where sno = ?\u0026#34;,sno).Scan(\u0026amp;sname) fmt.Printf(\u0026#34;student: %v \\n\u0026#34;,s) fmt.Println(sname) } func queryMany() { rows, err := db.Query(\u0026#34;select sno , sname , ssex , sage from student \u0026#34;) if err != nil { fmt.Println(\u0026#34;db query failed , error : %v\\n\u0026#34;,err) return } //非常重要 一定要关闭rows  defer rows.Close() //循环取值  for rows.Next(){ var s student rows.Scan(\u0026amp;s.sno,\u0026amp;s.sname,\u0026amp;s.ssex,\u0026amp;s.sage) fmt.Println(s) } } func insert() { sql:=\u0026#34;insert into student values (\u0026#39;2020170281\u0026#39;,\u0026#39;ljs\u0026#39;,\u0026#39;man\u0026#39;,23)\u0026#34; exec, err := db.Exec(sql) if err != nil { fmt.Println(\u0026#34;exec insert %s failed , err : %v\\n\u0026#34;,sql,err) return } //如果是插入数据的操作,能够拿到插入数据的id  id, err := exec.LastInsertId() if err != nil { fmt.Println(\u0026#34;get id failed ,err : %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;id:\u0026#34;,id) } func update() { exec, err := db.Exec(\u0026#34;update student set sname = \u0026#39;ljsnew\u0026#39; where sno=\u0026#39;2020170281\u0026#39; \u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(exec.RowsAffected()) } //预处理方式select多条数据 func prepareSelect() { prepare, err := db.Prepare(\u0026#34;select * from student where sno like ? \u0026#34;)//吧sql语句先发给mysql预处理一下  if err != nil { return } rows, err := prepare.Query(\u0026#34;%2016%\u0026#34;) //后续只需要传值就行了  if err != nil { return } defer prepare.Close() defer rows.Close() for rows.Next () { var s student rows.Scan(\u0026amp;s.sno,\u0026amp;s.sname,\u0026amp;s.ssex,\u0026amp;s.sage) fmt.Println(s) } } go语言实现mysql事务 事务相关方法:begin / commit / rollback\nsqlx使用 第三方库 sqlx 能够简化操作,提高开发效率\n安装 go get github.com/jmoiron/sqlx\n注意事项 SQL中的占位符 不同数据库中,SQL语句使用的占位符语法不尽相同\n   数据库 占位符语法     Mysql ?   postgresql $1,$2   sqlite ?和$1   oracle :name    sql注入 我们任何时候都不应该自己拼接sql语句\npackage main import ( \u0026#34;fmt\u0026#34; _\u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;github.com/jmoiron/sqlx\u0026#34; ) func main() { sqlInjectDemo(\u0026#34;xxx\u0026#39;or 1=1#\u0026#34;) sqlInjectDemo(\u0026#34;xxx\u0026#39; union select * from student #\u0026#34;) } var db *sqlx.DB type student struct { SNO , SNAME , SSEX string SAGE int } func sqlInjectDemo(name string) { //自己拼接sql语句  sqlStr:=fmt.Sprintf(\u0026#34;select * from student where sname =\u0026#39;%s\u0026#39;\u0026#34;,name) fmt.Println(sqlStr) var err error db, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, \u0026#34;root:123456@tcp(127.0.0.1:3306)/tset\u0026#34;) if err != nil { fmt.Println(err) return } err = db.Ping() if err != nil { fmt.Println(err) return } var s []student err = db.Select(\u0026amp;s, sqlStr) if err != nil { fmt.Println(err) return } fmt.Println(s) } \rimage-20210820163242826\r\nredis kv数据库\nredis的用处\n cache缓存 简单的队列 排行榜  redis是一个开源的内存数据库,redis提供了多种不同类型的数据结构,很多业务场景下的问题都可以很自然地映射到这些数据结构上.除此之外,通过复制/持久化和客户端分片等特性,我们可以很方便的将redis扩展成为一个能够包含数百GB数据/每秒处理上百万次请求的系统\nredis支持的数据结构 redis支持诸如字符串strings 哈希hashes 列表lists 集合sets 带范围查询的排序集合 sorted sets 位图bitmaps hyperloglogs 带半径查询和流的地理空间索引等数据结构 geospatial indexes\nredis应用场景  缓存系统,减轻主数据库mysql的压力 计数场景,比如微博/抖音中的关注数和粉丝数 热门排行榜,需要排序的场景特别适合使用zset 利用list可以实现队列的功能  redis与memcached比较 memcache中的值只支持简单的字符串,redis支持更丰富的5种数据结构类型.redis的性能比memcache好很多.redis支持rdb持久化和aof持久化.redis支持master/slave模式\n安装 go语言中使用第三方库连接redis数据库并进行操作.使用以下命令下载并安装\ngo get -u github.com/go-redis/redis\nget和set zset package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis\u0026#34; ) var redisDb *redis.Client func main() { err := initRedis() if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;连接redis成功\u0026#34;) redisExample() redisExample2() } func initRedis() (err error) { redisDb = redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;127.0.0.1:6379\u0026#34;, Password: \u0026#34;\u0026#34;, DB: 0, }) result, err := redisDb.Ping().Result() if err != nil { return err } fmt.Println(result) return } func redisExample() { err := redisDb.Set(\u0026#34;score\u0026#34;, 100, 0).Err() if err != nil { fmt.Println(err) return } val1, err := redisDb.Get(\u0026#34;score\u0026#34;).Result() if err != nil { return } fmt.Println(\u0026#34;scoer\u0026#34;,val1) val2, err := redisDb.Get(\u0026#34;name\u0026#34;).Result() if err == redis.Nil { fmt.Println(\u0026#34;name does not exist\u0026#34;) } else if err != nil { fmt.Println(err) return }else { fmt.Println(val2) } } func redisExample2() { //zset  key:=\u0026#34;rank\u0026#34; items:=[]redis.Z{ redis.Z{ Score: 99, Member: \u0026#34;php\u0026#34;, }, redis.Z{ Score: 96, Member: \u0026#34;golang\u0026#34;, }, redis.Z{ Score: 97, Member: \u0026#34;python\u0026#34;, }, redis.Z{ Score: 99, Member: \u0026#34;java\u0026#34;, }, } fmt.Println(items) //把元素都追加到key中  num, err := redisDb.ZAdd(key,items...).Result() if err != nil { return } fmt.Println(num) //加分数  newScore, err := redisDb.ZIncrBy(key, -1, \u0026#34;java\u0026#34;).Result() if err != nil { return } fmt.Println(newScore) //取分数最高的  scoreList, err := redisDb.ZRevRangeWithScores(key,0,3).Result() if err != nil { return } for _, z := range scoreList { fmt.Println(z.Member,z.Score) } //取95到100分的  option := \u0026amp;redis.ZRangeBy{ Min: \u0026#34;95\u0026#34;, Max: \u0026#34;100\u0026#34;, } ret, err := redisDb.ZRangeByScoreWithScores(key,*option).Result() if err != nil { return } for _, z := range ret { fmt.Println(z.Member,z.Score) } } NSQ NSQ是目前比较流行的一个分布式的消息队列,本文主要介绍了NSQ及go语言如何操作NSQ\nNSQ介绍 NSQ是go语言编写的一个开源的实时分布式内存消息队列,其性能十分优异.NSQ的优势有:\n NSQ提倡分布式和分散的拓扑,没有单点故障,支持容错和高可用性,并提供可靠的消息交付保证 NSQ支持横向扩展,没有任何集中式代理 NSQ易于配置和部署,并且内置了管理界面  NSQ的应用场景 通常来说,消息队列都适用于以下场景\n异步处理 利用消息队列把业务流程中的非关键流程异步化,从而显著降低业务请求的响应时间\n\rimage-20210820235216910\r\n应用解耦 通过使用消息队列将不同的业务逻辑解耦,降低系统间的耦合,提高系统的健壮性.后续有其他业务要使用订单数据可直接订阅消息队列,提高系统的灵活性\n\rimage-20210820235428939\r\n流量削峰 类似秒杀等场景下,某一时间可能会产生大量的请求,使用消息队列能够为后端处理请求提供一定的缓冲区,保证后端服务的稳定性\n\rimage-20210820235659875\r\nNSQ组件 nsqd nsqd是一个守护进程,它接收/排队并向客户端发送消息\n启动nsqd,指定-broadcast-address=127.0.0.1来配置广播地址\n如果是在搭配nsqdlookupd使用的模式下还需要指定nsqdlookupd地址\n如果是部署了多个nsqlookupd节点的集群,那还可以指定多个-lookupd-tcp-address\nnsqlookupd nsqlookupd是维护所有nsqd状态/提供服务发现的守护进程.他能为消费者查找特定topic下的nsqd提供了运行时的自动发现服务.他不是维持持久状态,也不需要与任何其他的nsqdlookupd实例协调以满足查询.因此根据系统的冗余要求尽可能多地部署nsqlookupd节点.她们消耗的资源很少,可以与其他服务共存,我们的建议是为每个数据中心运行至少三个集群\nnsqadmin\n一个实时监控集群状态/执行各种管理任务的web管理平台,启动nsqdadmin,指定nsqlookupd地址\n我们可以使用浏览器打开http://127.0.0.1:4171访问管理界面\n\rimage-20210821104437565\r\ntopic和channel 每个nsqd实例旨在一次处理多个数据流.这些数据流成为topics,一个topic具有一个或者多个channels,每个channel都会收到topic所有消息的副本,实际上上下游的服务是通过对应的channel来消费topic消息\ntopic和channel不是预先设置的.topic在首次使用时创建,方法是将其发布到指定topic,或者订阅指定topic上的channel. channel是通过订阅指定的channel在第一次使用时创建的\ntopic和channel都互相独立地缓冲数据,防止缓慢的消费者导致其他channel的积压(同样适用于topic级别)\nchannel可以并且通常会连接多个客户端.假设所有连接的客户端都处于准备接收消息的状态,则每条消息将被传递到随机客户端\n总而言之,消息是从topic-\u0026gt;channel(每个channel接收该topic的所有消息的副本) 多播的,但是从channel-\u0026gt;consumers均匀分布(每个消费者接收到该channel的一部分消息)\n\rimage-20210821105522944\r\n\rimage-20210821105528935\r\nNSQ特性  消息默认不持久化,可以配置成持久化模式. nsq采用的方式是内存+硬盘的模式,当内存达到一定程度时就会将数据持久化到硬盘上.  如果将 \u0026ndash;mem-queue-size 设置为0 服务器重启时也会将当时在内存中的消息持久化   每条消息至少传递一次 消息不保证有序  go操作nsq day11课上笔记 今日内容 依赖管理go module context 服务端agent开发 日志项目架构设计 kafka和zookeeper tailf介绍 为什么需要依赖管理 最早的时候,go所依赖的所有第三方库 放在gopath这个目录下面.这就导致了同一个库只能保存一个版本的代码.如果不同的项目依赖同一个第三方的库的不同版本,应该怎么解决\ngodep go语言从v1.5开始引入vendor模式,如果项目目录下有vendor目录,那么go工具链会优先使用vendor内的包进行编译/测试 等等\ngodep是一个通过vendor模式实现的go语言的第三方依赖管理工具,类似的还有由社区维护准官方包管理工具dep\ngo module go1.11之后退出的官方版本管理工具,从go1.13版本开始,go module将是go语言默认的依赖管理工具\ngo111module\n要启用go module 支持首先要设置环境变量 go111module,通过他可以开启和关闭模块支持,他可以有三个可选值:\noff on auto 默认值是auto\noff就是禁用模块支持,编译时会从gopath和vendor文件夹中查找包\non就是启用模块支持,编译时会忽略gopath和vendor文件夹,只根据go.mod下载依赖\nauto就是当gopath外有go.mod文件时,开启模块支持\n简单来说,设置on之后就可以使用go module了\n使用go module管理依赖后会在项目根目录下生成两个文件go.mod和go.sum\ngoproxy go1.11之后设置goproxy命令,由于国内无法访问,所以建议设置goproxy\ngo mod命令 go mod download go mod edit go mod graph go mod init go mod tidy go mod vendor go mod verify go mod why go.mod go.mod文件记录了项目所有的依赖信息,其结构大致如下\n其中:\n module用来定义包名 require用来定义依赖包及版本 indirect表示简介引用  go.sum 详细包和版本信息\ngo get 下载依赖包,并且还可以指定下载的版本\ngo mod edit 因为我们可以手动修改go.mod文件,所以有时候需要格式化该文件/添加依赖项/移除依赖项\n在项目中使用go module 既有项目 如果需要对一个已经存在的项目启用go module,可以按照以下步骤\n 在项目目录下执行go mod init , 生成一个go.mod文件 执行go get , 查找并记录当前项目的依赖,同时生成一个go. sum记录每个依赖库的版本和哈希值  新项目  执行go mod init 项目名 , 在当前项目文件夹下创建一个go.mod文件 手动编辑go.mod中的require依赖项或执行go get自动发现/维护依赖  context 非常重要!!!\n如何优雅的控制子goroutine退出\n在go http包的server中,每一个请求在都有一个对应的goroutine去处理,请求处理函数通常会启动额外的goroutine用来访问后端服务,比如数据库和rpc服务.用来处理一个请求的goroutine,通常需要访问一些与请求特定的数据,比如终端用户的身份认证信息/验证相关的token/请求的截止时间.当一个请求被取消或超时时,所有用来处理该请求的goroutine都应该迅速退出,然后系统才能释放这些goroutine占用的资源\n使用全局变量 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) //第一种就是通过全局变量 来控制goroutine退出 var notify bool var wg sync.WaitGroup //为什么需要context func main() { wg.Add(1) go f() //如何通知子goroutine退出  time.Sleep(time.Second) notify=true wg.Wait() } func f() { defer wg.Done() for !notify { fmt.Println(\u0026#34;ljs\u0026#34;) time.Sleep(time.Millisecond*500) } } 使用通道 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var i = make(chan bool,1) var wg sync.WaitGroup //为什么需要context func main() { wg.Add(1) go f() //如何通知子goroutine退出  time.Sleep(time.Second) i\u0026lt;-true wg.Wait() } func f() { defer wg.Done() LOOP: for { fmt.Println(\u0026#34;ljs\u0026#34;) time.Sleep(time.Millisecond*500) select { case \u0026lt;-i: break LOOP default: } } } 使用context package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var wg sync.WaitGroup func main() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(2) go f(ctx) //如何通知子goroutine退出  time.Sleep(time.Second) //通知子goroutine退出  cancel() wg.Wait() } func f(ctx context.Context) { defer wg.Done() go f2(ctx) LOOP: for { fmt.Println(\u0026#34;ljs\u0026#34;) time.Sleep(time.Millisecond*500) select { case \u0026lt;-ctx.Done(): break LOOP default: } } } func f2(ctx context.Context) { defer wg.Done() LOOP: for { fmt.Println(\u0026#34;jwt\u0026#34;) time.Sleep(time.Millisecond*250) select { case\u0026lt;-ctx.Done(): break LOOP default: } } } context初识 go1.7加入了一个新的标准库context,他定义了context类型,专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据/取消信号/截止时间等相关操作,这些操作可能涉及多个api调用\n对服务器传入的请求应该创建上下文,而对服务器的传出调用应该接受上下文.她们之间的函数调用链必须传递上下文,或者可以使用withcancle/withdeadline/withtimeout或withvalue创建的派生上下文,当一个上下文被取消时,他派生的所有上下文也被取消\n其中:\n deadline方法需要返回当前context被取消的时间,也就是完成工作的截至时间(deadline) done方法需要返回一个channel,这个channel会在当前工作完成或者上下文被取消之后关闭,多次调用done方法会返回同一个channel err方法会返回当前context结束的原因,他只会在done返回的channel被关闭时才会返回非空的值  如果当前context被取消就会返回canceled错误 如果当前context超市就会返回deadlineexceeded   value方法会从context中返回键对应的值,对于同一个上下文来说,多次调用value并传入相同的key会返回相同的结果,该方法仅用于传递跨api和进程间跟请求域的数据  background和todo go内置两个函数:background和todo,这两个函数分别返回了一个实现了context接口的background和todo.我们代码中最开始都是以这两个内置的上下文对象作为最顶层的parent context,衍生出更多的子上下文对象\nbackground主要用于main函数/初始化以及测试代码中,作为context这个树结构的最顶层的context,也就是根的context\ntodo,它目前还不知道具体的使用场景,如果我们不知道该使用什么context的时候,可以使用这个\nbackground和todo本质上都是emptyctx结构体类型,是一个不可取消,没有设置截止时间,没有携带任何值的context\nwith系列函数 withcancel func withcancel (parent context) (ctx context , cancel cancelFunc) withcancel返回带有新done通道的父节点的副本.当调用返回的cancel函数或当关闭父上下文的done通道时,将关闭返回上下文的done通道,无论先发生什么情况.\n取消此上下文将释放与其关联的资源\nwithdeadline func withdeadline(parent context , deadline time.time) (context , cancelfunc) 返回父上下文的副本,并将deadline调整为不迟于d.如果父上下文的deadline已经早于d,则withdeadline(parent,d)在语义上等同于父上下文,当截止日过期时,当调用返回的cancel函数时,或者当父上下文的done通道关闭时,返回上下文的done通道将被关闭,以最先发生的情况为准\n取消此上下文将释放与其关联的资源,因此代码应该在此上下文中运行的操作完成后立即调用cancel\nwithtimeout withtimeout的函数签名如下\nfunc WithTimeout (parent context ,timeout time.Duration) (context , cancelfunc) withtimeout返回withdeadline(parent,time.now().add(timeout))\n取消此上下文将释放与其相关的资源,因此代码应该在此上下文中运行的操作完成后立即调用cancel,通常用于数据库或者网络连接的超时控制\nwithvalue withvalue函数能够将请求作用域的数据与context对象建立关系\nfunc WithValue(parent context , key , val interface{}) context withvalue 返回父节点的副本,其中与key关联的值为val\n仅对api和进程间传递请求域的数据使用上下文值,而不是使用他来传递可选参数给函数\n所提供的键必须是可比较的,并且不应该是string类型或任何其他内置类型,以避免使用上下文在包之间发生冲突.withvalue的用户应该为键自己定义自己的类型.为了避免在分配给interface{}时进行分配,上下文键通常使用具体类型struct{}.或者导出的上下文关键变量的静态类型应该是指针或接口\ngo.sum文件 详细的包名和版本信息\n常见的命令 go mod init //初始化项目 go mod tidy //检查代码里的依赖去更新go.mod文件中的依赖 go get go mod download 日志收集项目 \rimage-20210823155422863\r\n\rimage-20210823155631862\r\n组件介绍： logagent：日志收集客户端，用来收集服务器上的日志\nkafka：高吞吐量的分布式队列（linkin开发，apache顶级开源项目）\nElasticSearch：开源的搜索引擎，提供基于http restful 的web接口\nkibana：开源的ES数据分析和可视化工具\nhadoop：分布式计算框架，能够对大量数据进行分布式处理的平台\nstorm：一个免费并开源的分布式实时计算系统\n消息队列的通信模式 点对点模式queue 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并消费消息。一条消息被消费以后，queue中就没有了，不存在重复消费。\n发布/订阅topic 消息生产者（发布）将消息发布到topic中，同时 有多个消息消费者（订阅）消费该消息。和点对点模式不同，发布到topic的消息会被所有订阅者消费（类似于关注了微信公众号的人都能收到推送的文章）\n补充：发布订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。实际上现实场景中是多个订阅者节点组成一个订阅组负载均衡消费topic消息即分组订阅，这样订阅者很容易实现消费能力的线性扩展。可以看成是一个topic下有多个queue，每个queue是点对点的方式，queue之间是发布订阅方式\nkafka apache kafka最初用来设计解决海量日志传输等问题。kafka使用scala编写。是一个分布式数据流平台，可以运行在单台服务器上，也可以在多台服务器上部署形成集群。它提供了发布和订阅功能，使用者可以发送数据到kafka中，也可以从kafka中读取数据（以便进行后续的处理）。kafka具有高吞吐量、低延迟、高容错等特点。\n\rimage-20210823161642535\r\n\rimage-20210823161731945\r\n\rimage-20210823161916638\r\n\rimage-20210823162018291\r\n\rimage-20210823162112407\r\n\rimage-20210823162150526\r\n\rimage-20210823162256871\r\nkafka  kafka集群的架构  broker topic partition分区，把同一个topic分成不同的分区，提高负载  leader：分区的主节点，boss flower：分区的从节点   consumer group   生产者往kafka发送数据的流程  获取集群的leader 生产者发送给leader leader落盘 follower从leader拉取 follower落盘回复ack leader回复生产者   kafka选择分区的模式  指定往哪个分区写 指定key，kafka根据key做hash然后决定写哪个分区 轮询   生产者往kafka发送数据的模式  0 把数据发给leader就成功，效率最高、安全性最低 1 把数据发给leader，等待leader回ack all 把数据发给leader，follower拉取后回ack，leader再回ack，安全性最高   为什么快？ 落盘的时候不是随机的而是顺序的  \rimage-20210823163451045\r\n\rimage-20210823163547230\r\n\rimage-20210823163621907\r\n\rimage-20210823163708974\r\n\rimage-20210823163926776\r\n\rimage-20210823164008727\r\n\rimage-20210823164021727\r\n启动zookeeper   下载kafka\n  kafka内置zookeeper\n  修改config下zookeeper.properties配置文件\rimage-20210823191107893\r\n  命令行启动zookeeper\nD:\\Softwares\\kafka_2.12-2.8.0\u0026gt;bin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties   修改config下kafka.properties配置文件\rimage-20210823192529505\r\n  命令行启动kafka\nD:\\Softwares\\kafka_2.12-2.8.0\u0026gt;bin\\windows\\kafka-server-start.bat config\\server.properties 要用管理员身份打开命令行\n  zookeeper \rimage-20210823192857710\r\n类似于consul 服务注册与发现\ntail第三方日志库demo tail作用 尝试读取某个log日志文件\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/nxadm/tail\u0026#34; \u0026#34;time\u0026#34; ) func main() { //tail用法  fileName:=\u0026#34;./my.log\u0026#34; config:=tail.Config{ Location: \u0026amp;tail.SeekInfo{Offset: 0,Whence: 2}, //从文件的那个地方开始读  ReOpen: true, //重新打开  MustExist: false, //文件不存在不报错  Poll: true, Pipe: false, Follow: true, //是否跟随  MaxLineSize: 0, RateLimiter: nil, Logger: nil, } tails, err := tail.TailFile(fileName, config) if err != nil { fmt.Println(\u0026#34;tail file failed , err: \u0026#34;,err) return } var ( line *tail.Line ok bool ) for { line, ok =\u0026lt;-tails.Lines if !ok { fmt.Printf(\u0026#34;tail file close reopen , filename :%s\\n\u0026#34;,tails.Filename) time.Sleep(time.Second) continue } fmt.Println(\u0026#34;msg: \u0026#34;,line.Text) } } sarama第三方库demo 作用:向kafka发送消息\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/Shopify/sarama\u0026#34; ) func main() { config := sarama.NewConfig() //tailf包使用  config.Producer.RequiredAcks= sarama.WaitForAll //发送完数据需要 leader 和 follower 都确认  config.Producer.Partitioner = sarama.NewRandomPartitioner //新选出一个 partitioner  config.Producer.Return.Successes = true //成功交付的消息将在success channel 返回  //构造一个消息  msg:= \u0026amp;sarama.ProducerMessage{} msg.Topic = \u0026#34;web_log\u0026#34; msg.Value = sarama.StringEncoder(\u0026#34;this is a test blog\u0026#34;) //连接kafka  client, err := sarama.NewSyncProducer([]string{\u0026#34;127.0.0.1:9092\u0026#34;}, config) if err != nil { fmt.Println(\u0026#34;producer closed, err : \u0026#34;, err) return } defer client.Close() //发送消息  pid, offSet, err := client.SendMessage(msg) if err != nil { fmt.Println(\u0026#34;send msg failed , err : \u0026#34;, err) return } fmt.Printf(\u0026#34;pid:%v offSet:%v\\n\u0026#34;,pid,offSet) } \rimage-20210823202230801\r\n\rimage-20210823202240537\r\n索引\n接下来就是日志收集项目  初始化sarama 让他连接上kafka 以便给kafka发送消息 初始化tail 让他能够读取日志文件 使用初始化好的sarama 将tail读取到的东西发送给kafka  kafka模块代码\npackage kafka import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/Shopify/sarama\u0026#34; ) //专门往kafka写日志的模块 var ( client sarama.SyncProducer //声明一个全局的连接kafka的生产者client ) //Init 初始化client func Init(address []string)(err error) { config := sarama.NewConfig() //tailf包使用  config.Producer.RequiredAcks= sarama.WaitForAll //发送完数据需要 leader 和 follower 都确认  config.Producer.Partitioner = sarama.NewRandomPartitioner //新选出一个 partitioner  config.Producer.Return.Successes = true //成功交付的消息将在success channel 返回  //连接kafka  client, err = sarama.NewSyncProducer(address, config) if err != nil { fmt.Println(\u0026#34;producer closed, err : \u0026#34;, err) return } return } func SendToKafka(topic, msg string) { //构造一个消息  saramaMsg:= \u0026amp;sarama.ProducerMessage{} saramaMsg.Topic = topic saramaMsg.Value = sarama.StringEncoder(msg) //发送消息  pid, offSet, err := client.SendMessage(saramaMsg) if err != nil { fmt.Println(\u0026#34;send msg failed , err : \u0026#34;, err) return } fmt.Printf(\u0026#34;pid:%v offSet:%v\\n\u0026#34;,pid,offSet) } tail模块代码\npackage tail import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/nxadm/tail\u0026#34; ) var tails *tail.Tail //Init 专门收集日志 func Init(address string) (err error){ //tail用法  fileName:=address config:=tail.Config{ Location: \u0026amp;tail.SeekInfo{Offset: 0,Whence: 2}, //从文件的那个地方开始读  ReOpen: true, //重新打开  MustExist: false, //文件不存在不报错  Poll: true, Pipe: false, Follow: true, //是否跟随  MaxLineSize: 0, RateLimiter: nil, Logger: nil, } tails, err = tail.TailFile(fileName, config) if err != nil { fmt.Println(\u0026#34;tail file failed , err: \u0026#34;,err) return } return } func ReadLog() \u0026lt;-chan *tail.Line { return tails.Lines } main模块代码\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;src/code.oldboyedu.com/logAgent/kafka\u0026#34; tail \u0026#34;src/code.oldboyedu.com/logAgent/tail_log\u0026#34; \u0026#34;time\u0026#34; ) func main() { //1.初始化kafka连接  err := kafka.Init([]string{\u0026#34;127.0.0.1:9092\u0026#34;}) if err != nil { fmt.Println(\u0026#34;init kafka failed, err : \u0026#34; ,err) return } fmt.Println(\u0026#34;init kafka success!\u0026#34;) //2.打开日志文件准备收集日志  err = tail.Init(\u0026#34;./my.log\u0026#34;) if err != nil { fmt.Println(\u0026#34;init taillog failed, err : \u0026#34;,err) return } fmt.Println(\u0026#34;init tail success!\u0026#34;) run() } func run() { //1.收集日志  for { select { case line:=\u0026lt;-tail.ReadLog(): //2.发送给kafka  kafka.SendToKafka(\u0026#34;web_log\u0026#34;,line.Text) default: time.Sleep(time.Second) } } } 定义消费者\nbin\\windows\\kafka-console-consumer.bat --bootstrap-server=127.0.0.1:9092 --topic=web_log --from-beginning \rimage-20210823210549292\r\n优化版配置文件中读取\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;gopkg.in/ini.v1\u0026#34; \u0026#34;src/code.oldboyedu.com/logAgent/kafka\u0026#34; tail \u0026#34;src/code.oldboyedu.com/logAgent/tail_log\u0026#34; \u0026#34;time\u0026#34; ) type appConf struct { KafkaConf `ini:\u0026#34;Kafka\u0026#34;` TailLogConf `ini:\u0026#34;Taillog\u0026#34;` } type KafkaConf struct { Address string `ini:\u0026#34;Address\u0026#34;` Topic string `ini:\u0026#34;Topic\u0026#34;` } type TailLogConf struct { FileName string `ini:\u0026#34;Filename\u0026#34;` } var appCfg =new(appConf) func main() { //0.加载配置文件 获取ip:端口 日志文件 发送的topic  err := ini.MapTo(appCfg, \u0026#34;./config.ini\u0026#34;) if err != nil { fmt.Println(\u0026#34;config init failed, err : \u0026#34;,err) return } //1.初始化kafka连接  fmt.Println(appCfg.KafkaConf.Address) fmt.Println(appCfg.KafkaConf.Topic) fmt.Println(appCfg.TailLogConf.FileName) err = kafka.Init([]string{appCfg.KafkaConf.Address}) if err != nil { fmt.Println(\u0026#34;init kafka failed, err : \u0026#34; ,err) return } fmt.Println(\u0026#34;init kafka success!\u0026#34;) //2.打开日志文件准备收集日志  err = tail.Init(appCfg.TailLogConf.FileName) if err != nil { fmt.Println(\u0026#34;init taillog failed, err : \u0026#34;,err) return } fmt.Println(\u0026#34;init tail success!\u0026#34;) run() } func run() { //1.收集日志  for { select { case line:=\u0026lt;-tail.ReadLog(): //2.发送给kafka  kafka.SendToKafka(appCfg.KafkaConf.Topic,line.Text) default: time.Sleep(time.Second) } } } 内容复习 go module 依赖管理工具\ncontext goroutine管理\ncontext.Context\n两个根节点 context.todo context.background\n四个方法 context.withTimeout() context.withCancel() context.withdeadline() context.withvalue()\n日志收集项目 ELK:部署的时候麻烦,每一个filebeat都需要配置一个配置文件\n使用etcd来管理被收集的日志项\n项目的架构 \rimage-20210824195131980\r\n上节课项目进度  kafka:消息队列 tailf:从文件里读日志 sarama:向kafka发送数据 go-ini:解析配置文件  今日内容 etcd 使用etcd优化日志收集项目 \rimage-20210824195924259\r\nraft协议\n 选举 日志复制机制 异常处理  zookeeper的zad协议和raft协议的区别\n\rimage-20210824201151410\r\n\rimage-20210824201255712\r\n\rimage-20210824201531623\r\n\rimage-20210824201641847\r\n\rimage-20210824201859917\r\n\rimage-20210824201921279\r\n\rimage-20210824202013396\r\n\rimage-20210824202041613\r\n\rimage-20210824202051395\r\n\rimage-20210824202203749\r\n\rimage-20210824202403398\r\n清华学神尹成\n\rimage-20210826231049867\r\n\rimage-20210826231828312\r\nLogTransfer 从kafka里面把日志取出来,写入ES\nElastic Search ES是一个基于lucene构建的开源的/分布式/restful接口的全文搜索引擎.elastic search还是一个分布式文档数据库,其中每个字段均可被索引,而且每个字段的数据均可被搜索,ES能够横向扩展至数以百计的服务器存储以及处理PB级的数据.可以在极短的时间内存储/搜索和分析大量的数据.通常作为具有复杂搜索场景情况下的核心发动机.\nElasticSearch能做什么  当你经营一家网上商店,你可以让你的客户搜索你卖的商品.在这种情况下,你可以使用Elastic search来存储你的整个产品目录和库存信息,为客户提供精准搜索,可以为客户推荐相关商品. 当你想收集日志或者交易数据的时候,需要分析和挖掘这些数据,寻找趋势,进行统计,总结,或者发现异常.在这种情况下,你可以使用logstash或者其他工具来进行收集数据,当这引起数据存储到elastic search中.你可以搜索和汇总这些数据,找到任何你感兴趣的信息 对于程序员来说,比较有名的案例是github.github的搜索是基于elasticsearch构建的,在github.com/search页面,你可以搜索项目,用户/issue/pull request,还有代码.公有40-50个索引库,分别用于索引网站需要跟踪的各种数据,虽然只索引项目的主分支master,但这个数据量依然巨大,包括20亿个索引文档,30TB的索引文件.  ElasticSearch基本概念 near realtime 几乎实时 elasticsearch是一个几乎实时的搜索凭条,意思是,从索引一个文档到这个文档可以被搜索只需要一点点的延迟,这个时间一半为毫秒级\ncluster集群 集群是一个或者多个节点服务器的集合,这些节点共同保存整个数据,并在所有节点上提供联合索引和搜索功能.一个集群由一个唯一集群ID确定,并指定一个集群名(默认为elasticsearch).该集群名非常重要,因为节点可以通过这个集群名加入集群,一个节点只能是集群的一部分.\n确保在不同的环境中不要使用相同的集群名称,否则可能会导致连接错误的集群节点,例如你可以使用logging\u0026ndash;dev/ logging-stage/ logging-prod 分别为开发/阶段产品/生产集群做记录.\nnode节点 节点是单个服务器实例\nindex索引 索引是具有相似特性的文档集合\ntype类型 在索引中,可以定义一个或者多个类型,类型是索引的逻辑类别/分区,其语义完全取决于你.\ndocument文档 文档是可以被索引的信息的基本单位.例如,你可以为单个客户提供一个文档,单个产品提供另一个文档,以及单个订单提供另一个文档.\nshards\u0026amp;replicas分片与副本 ES基本概念与关系型数据库的比较    ES概念 关系型数据库     index索引支持全文检索 database数据库   type类型 table表   document文档,不同文档可以有不同的字段集合 row数据行   field字段 column数据列   mapping映射 schema模式    ES API 下载安装\n\rimage-20210902001925922\r\n查看\n\rimage-20210902001948107\r\n查看心跳\n\rimage-20210902002107349\r\n查询当前es集群中所有的indices\ncurl -X get 127.0.0.1:9200/_cat/indices?v\n\rimage-20210902002202915\r\ngin学习 hello world demo\npackage main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { //1.创建路由  engine := gin.Default() //2.绑定路由规则,执行的函数  //gin.context , 封装了request和response  engine.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK,\u0026#34;hello world!!!\u0026#34;) }) //3.监听端口 默认在8080端口  engine.Run(\u0026#34;:8000\u0026#34;) } gin路由 基本路由  gin框架中采用的路由库是基于tprouter做的 地址为:https://github.com/julienschmidt/httprouter  restful风格的API  gin支持restful风格的API 即representational state transfer 的缩写 直接翻译是表现层状态转化,是一种互联网应用程序的api设计理念,url定位资源,用http描述操作  获取文章 /blog/getxxx get blog/xxx\n添加 /blog/addxxx\tpost blog/xxx\n修改 /blog/updatexxx put blog/xxx\n删除 /blog/delxxx delete blog/xxx\nAPI参数  可以通过context的param方法来获取api参数 localhost:8000/xxx/zhangsan  localhost:8000/user/zhangsan/lisi\nURL参数  URL参数可以通过defaultquery()或者query()方法来取 defaultquery()若参数不存在,返回默认值 query()若参数不存在,返回空字符串  localhost:8000/welcome?name=yourtreedad\n表单参数  表单传输为post请求,http常见的传输格式化为四种  application/json json传参 application/x-www-urlencoded 表单传参 application/xml xml传参 multipart/form-data 表单上传文件   表单参数可以通过postform()方法获取,该方法默认解析的是x-www-form-urlencoded 或 from-data格式的参数  上传单个文件  multipart/form-data格式用于文件上传 gin 文件上传与原生的net/http 方法类似,不同在于gin把原生的request封装到了c.Request中  上传多个文件 MultipartForm使用这个方法获得所有文件的\n使用multipartForm.File[\u0026ldquo;files\u0026rdquo;]来取所有文件指针\n遍历, 然后存着就行了\nroutes Group  routes Group 是为了管理一些相同的URL  路由原理  httprouter 会将所有路由规则构造成一个前缀树  命令行也可以尝试传post和get指令\n\rimage-20210828214026568\r\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { //1.创建路由  //默认使用了2个中间件 Logger(), Recovery()  engine := gin.Default() //engine:=gin.New()也可以的  //2.绑定路由规则,执行的函数  //gin.context , 封装了request和response  //路由组 实际上就是便于管理 少写点东西  routerGroup := engine.Group(\u0026#34;/Get\u0026#34;) routerGroup.GET(\u0026#34;/v1\u0026#34;, func(context *gin.Context) { query := context.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;getParam\u0026#34;) context.String(http.StatusOK,query) }) group := engine.Group(\u0026#34;/Post\u0026#34;) group.POST(\u0026#34;/v1\u0026#34;, func(context *gin.Context) { postParam := context.DefaultPostForm(\u0026#34;name\u0026#34;, \u0026#34;postParam\u0026#34;) context.String(http.StatusOK,postParam) }) //index 界面  engine.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK,\u0026#34;hello world!!!\u0026#34;) }) //api参数 用 : 来取  engine.GET(\u0026#34;/user/:name/*action\u0026#34;, func(context *gin.Context) { //  name:= context.Param(\u0026#34;name\u0026#34;) action := context.Param(\u0026#34;action\u0026#34;) context.String(http.StatusOK,name+\u0026#34; is \u0026#34;+action) }) //url参数 ?name=\u0026#34;xxx\u0026#34;  engine.GET(\u0026#34;/welcome\u0026#34;, func(context *gin.Context) { query := context.DefaultQuery(\u0026#34;name\u0026#34;, \u0026#34;Jack\u0026#34;) context.String(http.StatusOK,fmt.Sprintf(\u0026#34;Hello %s !\u0026#34;,query)) }) //form表单传参  engine.POST(\u0026#34;/PostForm\u0026#34;, PostFormParams) //from上传单个文件  engine.POST(\u0026#34;/Upload\u0026#34;,UploadFile) //限制表单上传大小 8mb,默认值为32mb  engine.MaxMultipartMemory = 8\u0026lt;\u0026lt;20 //form上传多个文件  engine.POST(\u0026#34;UploadFiles\u0026#34;,UploadFiles) engine.PUT(\u0026#34;/xxxput\u0026#34;) //3.监听端口 默认在8080端口  engine.Run(\u0026#34;:8000\u0026#34;) } func UploadFiles(context *gin.Context) { multipartForm, err := context.MultipartForm() if err != nil { fmt.Println(\u0026#34;received multiple files failed , err :\u0026#34;,err) context.String(http.StatusBadRequest,fmt.Sprintf(\u0026#34;get err %s \u0026#34;,err.Error())) return } //获取所有文件  files := multipartForm.File[\u0026#34;files\u0026#34;] //遍历所有files  for _, file := range files { //逐个存  err := context.SaveUploadedFile(file, file.Filename) if err != nil { context.String(http.StatusBadRequest,fmt.Sprintf(\u0026#34;upload err %s \u0026#34;,err.Error())) return } } context.String(200,fmt.Sprintf(\u0026#34;upload ok %d files!\u0026#34;, len(files))) } func UploadFile(context *gin.Context) { //从表单中取文件  file, err := context.FormFile(\u0026#34;file\u0026#34;) if err != nil { fmt.Println(\u0026#34;receive file error, cause : \u0026#34;,err) return } log.Println(file.Filename) //传到项目的根目录, 名字就用本身的就好  err = context.SaveUploadedFile(file, file.Filename) if err != nil { fmt.Println(\u0026#34;file save failed , error : \u0026#34;,err) return } //打印信息  context.String(200,fmt.Sprintf(\u0026#34;\u0026#39;%s\u0026#39; has already uploaded!\u0026#34;,file.Filename)) } func PostFormParams(context *gin.Context) { //表单参数 设置默认值  type1 := context.DefaultPostForm(\u0026#34;type\u0026#34;, \u0026#34;alert\u0026#34;) //接收其他的  userName := context.PostForm(\u0026#34;username\u0026#34;) password := context.PostForm(\u0026#34;password\u0026#34;) //多选框  hobbys := context.PostFormArray(\u0026#34;hobby\u0026#34;) context.String(http.StatusOK,fmt.Sprintf(\u0026#34;type is %s, username is %s, password is %s , hobbys is %v\u0026#34;,type1,userName,password,hobbys)) } html前端界面\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登陆\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://127.0.0.1:8000/PostForm\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;application/x-www-form-urlencoded\u0026#34;\u0026gt; 用户名:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 密\u0026amp;nbsp\u0026amp;nbsp码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 兴\u0026amp;nbsp\u0026amp;nbsp趣: \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;run\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;跑步 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;game\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;游戏 \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;money\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt;金钱 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登陆\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;form action=\u0026#34;http://127.0.0.1:8000/Upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 头像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form action=\u0026#34;http://127.0.0.1:8000/UploadFiles\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 上传多个文件: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; gin数据解析和绑定 json数据解析和绑定  客户端传参,后端接收并解析到结构体  使用ShouldBindJSON来解析到结构体\nengine.GET(\u0026#34;loginJSON\u0026#34;, func(context *gin.Context) { //声明接收的变量  var json Login //将request的body中的数据,自动按照json格式解析到结构体  err := context.ShouldBindJSON(\u0026amp;json) if err != nil { //返回错误信息  //gin.H 封装了生成json数据的工具  context.JSON(http.StatusBadRequest,gin.H{\u0026#34;error \u0026#34;:err.Error()}) return } //判断用户名密码是否正确  if json.User!=\u0026#34;2020170281\u0026#34;||json.Password!=\u0026#34;lalala123\u0026#34; { context.JSON(http.StatusBadRequest,gin.H{\u0026#34;status\u0026#34;:\u0026#34;304\u0026#34;}) return } context.JSON(http.StatusOK,gin.H{\u0026#34;status\u0026#34;:\u0026#34;200\u0026#34;}) }) \rimage-20210828224803650\r\n表单数据解析和绑定 使用Bind来解析结构体\nengine.GET(\u0026#34;loginForm\u0026#34;, func(context *gin.Context) { var form Login //bind()默认解析并绑定form格式  //根据请求头中的content-type自动推断  err := context.Bind(\u0026amp;form) if err != nil { context.JSON(http.StatusBadRequest,gin.H{\u0026#34;error\u0026#34;:err.Error()}) return } if form.User!=\u0026#34;2020170281\u0026#34;||form.Password!=\u0026#34;lalala123\u0026#34;{ context.JSON(http.StatusBadRequest,gin.H{\u0026#34;status\u0026#34;:\u0026#34;304\u0026#34;}) return } context.JSON(http.StatusOK,gin.H{\u0026#34;status\u0026#34;:\u0026#34;200\u0026#34;}) }) html界面\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登陆\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;http://127.0.0.1:8000/loginForm\u0026#34; method=\u0026#34;get\u0026#34; enctype=\u0026#34;application/x-www-form-urlencoded\u0026#34;\u0026gt; 用户名:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 密\u0026amp;nbsp\u0026amp;nbsp码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登陆\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; URI数据解析和绑定 使用shouldbinduri方法\nengine.GET(\u0026#34;loginURI/:user/:password\u0026#34;, func(context *gin.Context) { var URI Login err := context.ShouldBindUri(\u0026amp;URI) if err != nil { context.JSON(http.StatusBadRequest,gin.H{\u0026#34;error\u0026#34;:err.Error()}) return } if URI.User!=\u0026#34;2020170281\u0026#34;||URI.Password!=\u0026#34;lalala123\u0026#34; { context.JSON(http.StatusBadRequest,gin.H{\u0026#34;status\u0026#34;:304}) return } context.JSON(http.StatusOK,gin.H{\u0026#34;status\u0026#34;:200}) }) \rimage-20210828231200951\r\n响应类型  xml json protobuf yaml  package main\rimport (\r\u0026quot;github.com/gin-gonic/gin\u0026quot;\r\u0026quot;github.com/gin-gonic/gin/testdata/protoexample\u0026quot;\r\u0026quot;net/http\u0026quot;\r)\r//多种响应方式\rfunc main() {\r//1.创建路由\r//2.默认使用了2个中间件logger recovery\rengine := gin.Default()\r//1.json\rengine.GET(\u0026quot;/someJson\u0026quot;, func(context *gin.Context) {\rcontext.JSON(http.StatusOK,gin.H{\u0026quot;message\u0026quot;:\u0026quot;someJson\u0026quot;,\u0026quot;Status\u0026quot;:200})\r})\r//2.结构体响应\rengine.GET(\u0026quot;someStruct\u0026quot;, func(context *gin.Context) {\rcontext.JSON(http.StatusOK, struct {\rName , Message string\rNumber int\r}{\u0026quot;root\u0026quot;,\u0026quot;message\u0026quot;,123})\r})\r//3.XML响应\rengine.GET(\u0026quot;/someXML\u0026quot;, func(context *gin.Context) {\rcontext.XML(http.StatusOK,gin.H{\u0026quot;message\u0026quot;:\u0026quot;xml\u0026quot;})\r})\r//4.yaml响应\rengine.GET(\u0026quot;/someYaml\u0026quot;, func(context *gin.Context) {\rcontext.YAML(http.StatusOK,gin.H{\u0026quot;name\u0026quot;:\u0026quot;YAML\u0026quot;})\r})\r//5.protobuf格式 副歌开发的高校存储读取的工具\rengine.GET(\u0026quot;/someProtoBuf\u0026quot;, func(context *gin.Context) {\rreps:=[]int64{1,2}\r//定义返回数据\rlabel:=\u0026quot;protobuf\u0026quot;\rdata:=\u0026amp;protoexample.Test{\rLabel: \u0026amp;label,\rReps: reps,\r}\rcontext.ProtoBuf(http.StatusOK,data)\r})\rengine.Run(\u0026quot;:8000\u0026quot;)\r}\rHTML 模版渲染  gin支持加载html模版,然后根据模版参数进行配置并返回相应的数据,本质上就是字符串的替换 loadhtmlglob()方法可以加载模版文件  func main() { engine:= gin.Default() //加载模版文件  engine.LoadHTMLGlob(\u0026#34;templates/*\u0026#34;) //以下这种方式也可以啦  //engine.LoadHTMLFiles(\u0026#34;templates/index.tmpl\u0026#34;)  engine.GET(\u0026#34;/index\u0026#34;, func(context *gin.Context) { //根据文件名渲染  //最终json将title替换  context.HTML(http.StatusOK,\u0026#34;index.tmpl\u0026#34;,gin.H{\u0026#34;title\u0026#34;:\u0026#34;我的标题\u0026#34;}) }) engine.Run(\u0026#34;:8000\u0026#34;) } \rimage-20210828234359001\r\n重定向 func main() { engine := gin.Default() engine.GET(\u0026#34;/redirect\u0026#34;, func(context *gin.Context) { //支持内部和外部的重定向  context.Redirect(http.StatusMovedPermanently,\u0026#34;http://www.baidu.com\u0026#34;) }) engine.Run(\u0026#34;:8000\u0026#34;) } 同步异步  goroutine机制可以方便地实现异步处理 另外,在启动新的goroutine时,不应该使用原始上下文,必须使用他的只读副本  unc main() { engine := gin.Default() //1.异步  engine.GET(\u0026#34;/long_async\u0026#34;, func(context *gin.Context) { //需要搞一个只读的副本  copyContext := context.Copy() //模仿异步处理  go func() { time.Sleep(3 *time.Second) log.Println(\u0026#34;异步执行...\u0026#34;+copyContext.Request.URL.Path) }() }) //2.同步  engine.GET(\u0026#34;/long_sync\u0026#34;, func(context *gin.Context) { time.Sleep(3*time.Second) log.Println(\u0026#34;同步执行...\u0026#34;+context.Request.URL.Path) }) engine.Run(\u0026#34;:8000\u0026#34;) } gin中间件 \rimage-20210828235642323\r\n gin可以构建中间件,但它只对注册过的路由函数起作用 对于分组路由,嵌套使用中间件,可以限定中间件的作用范围 中间件分为全局中间件,单个路由中间件和群组中间件 gin中间件必须是一个gin.handlerfunc类型  全局中间件  所有请求都经过此中间件  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) //定义全局中间件 func MiddleWare() gin.HandlerFunc { return func(context *gin.Context) { t:=time.Now() fmt.Println(\u0026#34;中间件开始执行了...\u0026#34;) //设置变量到context的key中,可以通过get取  context.Set(\u0026#34;request\u0026#34;,\u0026#34;中间件\u0026#34;) //执行函数  context.Next() //中间件执行完后续的一些事情  status := context.Writer.Status() fmt.Println(\u0026#34;中间件执行完毕\u0026#34;,status) fmt.Println(\u0026#34;用时 : \u0026#34;,time.Now().Sub(t)) } } func main() { engine:= gin.Default() //注册中间件  engine.Use(MiddleWare()) { engine.GET(\u0026#34;/middleware\u0026#34;, func(context *gin.Context) { //取值  request, _ := context.Get(\u0026#34;request\u0026#34;) fmt.Println(request) //页面接收  context.JSON(http.StatusOK,gin.H{\u0026#34;request\u0026#34;:request}) }) } engine.Run(\u0026#34;:8000\u0026#34;) } next()方法 看原码 实际上就是遍历了注册的所有中间件的个数,\n局部中间件 //如此就是在这个路由之下定义了新的中间件,可以视为单个中间件 engine.GET(\u0026#34;/middlewareDouble\u0026#34;,MiddleWare(), func(context *gin.Context) { //取值  request, _ := context.Get(\u0026#34;request\u0026#34;) fmt.Println(request) //页面接收  context.JSON(http.StatusOK,gin.H{\u0026#34;request\u0026#34;:request}) }) 练习 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;time\u0026#34; ) func middleTimer() gin.HandlerFunc { return func(context *gin.Context) { now := time.Now() context.Next() fmt.Println(\u0026#34;用时: \u0026#34;,time.Now().Sub(now)) } } func main() { engine := gin.Default() engine.Use(middleTimer()) group := engine.Group(\u0026#34;/timer\u0026#34;) group.GET(\u0026#34;/countTimer\u0026#34;, func(context *gin.Context) { time.Sleep(3*time.Second) }) group.GET(\u0026#34;/counTimer1\u0026#34;, func(context *gin.Context) { time.Sleep(5*time.Second) }) engine.Run(\u0026#34;:8000\u0026#34;) } 会话控制 cookie是什么  http是无状态协议,服务器不能记录里浏览器的访问状态,也就是说服务器不能区分两次请求是否是由同一个客户端发出的 cookie就是解决http协议无状态的方案之一,中文是小甜饼的意思 cookie实际上就是服务器保存在浏览器上的一段信息,浏览器有了cookie之后,每次向服务器发送请求时都会同时将该信息发送给服务器,服务器收到请求后,就可以根据该信息处理请求 cookie由服务器创建,并发送给浏览器,最终由浏览器保存  cookie用途  保持登陆状态 京东购物车  cookie的使用  服务端发送cookieid  cookie练习  模拟实现权限验证中间件  有两个路由,login用来设置cookie home用来访问    package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func MiddleWareAuth() gin.HandlerFunc { return func(context *gin.Context) { cookie, err := context.Cookie(\u0026#34;loginToken\u0026#34;) if err != nil { //返回错误  context.JSON(http.StatusOK, gin.H{\u0026#34;error\u0026#34;: \u0026#34;StatusUnauthorized\u0026#34;}) context.Abort() return } if cookie == \u0026#34;true\u0026#34; { context.Next() } } } func main() { engine := gin.Default() engine.GET(\u0026#34;/login\u0026#34;, func(context *gin.Context) { http.SetCookie(context.Writer, \u0026amp;http.Cookie{ Name: \u0026#34;loginToken\u0026#34;, Value: \u0026#34;true\u0026#34;, }) context.String(http.StatusOK, \u0026#34;Login successful\u0026#34;) }) engine.GET(\u0026#34;/home\u0026#34;, MiddleWareAuth(), func(context *gin.Context) { context.JSON(http.StatusOK, gin.H{\u0026#34;data\u0026#34;: \u0026#34;home\u0026#34;}) }) engine.Run(\u0026#34;:8000\u0026#34;) } cookie的缺点  不安全 明文 增加带宽消耗 可以被禁用 cookie有上限  session是什么  session可以弥补cookie的不足,session必须依赖于cookie才能使用,生成一个sessionid放在cookie里传给客户端就可以了  \rimage-20210829104620811\r\n\rimage-20210829104914310\r\nsession存在服务端中\nsession中间件开发   设计一个通用的session服务,支持内存存储和redis存储\n  session模块设计\n 本质上是k-v系统,通过key来进行增删改查 session可以存储在内存或者redis(2个版本)    \rimage-20210829105225472\r\n session接口设计  set get del save session存储,redis的实现延迟加载   sessionmgr接口设计  init 初始化 加载redis地址 createsession 创建一个新的session getsession 通过sessionid获取对应的session对象   memorysession设计  定义memorysession对象 字段sessionid 存kv的map 读写锁 构造函数 为了获取对象   sessionmgr设计  定义memorysessionmgr对象 字段存放所有的session的map,读写锁 构造函数 init cretesession getsession   redisression设计  定义redissession对象 ssionid字段 存kv的map 读写锁 redis连接池 记录内存中map否被修改的标记 构造函数 set将session存到内存中的map get取数据实现延迟加载 del save 将session存到redis   redissessionmgr设计  定义redissessionmgr对象    \rimage-20210829110208079\r\n这里还是要重申一下 http传参啊\n首先 传参可以分为网址传参和表单传参\n网址传参又分为api传参和url传参\napi传参使用/book/:name\nname:= context.Param(\u0026#34;name\u0026#34;) url传参使用/book\nquery := context.Query(\u0026#34;name\u0026#34;) 表单传参\n分为get和post get的话我们发现 get的method最终会变成url\nquery := context.Query(\u0026#34;searchThing\u0026#34;) post就使用\nsearchThing, ok := context.GetPostForm(\u0026#34;searchThing\u0026#34;) form := context.PostForm(\u0026#34;searchThing\u0026#34;) Elastic Search \rimage-20210903210305686\r\n查看健康 curl -X GET127.0.0.1:9200/_cat/health?v\n创建索引 curl -X PUT 127.0.0.1:9200/www\n删除索引 curl -X DELETE 127.0.0.1:9200/www\n插入数据 \rimage-20210903210614663\r\n检索数据 \rimage-20210903211123288\r\ngo操作ES 微服务 注册中心选型 consul / zookeeper / etcd / euerka\n选项设计模式 package main import \u0026#34;fmt\u0026#34; func main() { newOptions(\u0026#34;str1\u0026#34;, \u0026#34;str2\u0026#34;, \u0026#34;str3\u0026#34;, 1, 2, 3) newOptionsNew(WithStrOption(\u0026#34;str1\u0026#34;)) } type OptionsNew struct { strOption1 string strOption2 string strOption3 string intOption1 int intOption2 int intOption3 int } // Option 先声明一个函数类型,用于传参 type Option func(option *OptionsNew) // WithStrOption 定义具体给某个字段赋值的方法 返回一个方法 通过这个方法给结构体赋值 func WithStrOption(str string) Option { return func(option *OptionsNew) { option.strOption1 = str } } //初始化结构体 func newOptionsNew(otions ...Option) { options :=\u0026amp;OptionsNew{} //遍历otions,得到每一个函数  for _, fun:= range otions { //调用函数, 在函数里,给传进去的对象赋值  fun(options) } fmt.Printf(\u0026#34;init options %#v\\n\u0026#34;,options) } type Options struct { strOption1 string strOption2 string strOption3 string intOption1 int intOption2 int intOption3 int } func newOptions(strOption1, strOption2, strOption3 string, intOption1, intOption2, intOption3 int) { options := Options{ strOption1: strOption1, strOption2: strOption2, strOption3: strOption3, intOption1: intOption1, intOption2: intOption2, intOption3: intOption3, } fmt.Printf(\u0026#34;init option %#v\\n\u0026#34;, options) } 注册组件接口开发  目标  支持多注册中心,既支持consul又支持etcd 支持可扩展 提供基于名字的插件管理函数,用来注册插件    \rimage-20210903224236637\r\n流行RPC框架的对比 dubbo / motan / thrift / grpc\ngRPC简介  pc语言中立/平台中立/开源的远程过程调用系统 grpc由客户端和服务端可以在多种环境中运行和交互,例如写一个java服务端,可以用go语言写客户端调用  grpc与protobuf介绍  微服务架构中,由于每个服务对应的代码库是独立运行的,无法直接调用,彼此间的通信就是个大问题 grpc可以实现微服务,将大的项目拆分为多个小且独立的业务模块,也就是服务,各服务之间使用高校的protobuf协议进行rpc调用,grpc默认使用protocol buffers,这个google开源的一套成熟的结构数据序列化机制(当然也可以使用其他数据格式如json) 可以用proto files 创建grpc服务,用message类型来定义方法参数和返回类型  安装grpc和protubuf git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc\ngit clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net\ngit clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text\ngo get -u github.com/golang/protobuf/{proto,protoc-gen-go}\ngit clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto\n进入src,并install cd $GOPATH/src/\ngo install google.golang.org/grpc\n","date":"2021-08-24T00:17:57+08:00","permalink":"https://linjianshu.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/","title":"Go语言学习"},{"content":"docker学习   docker概述\n  docker安装\n  docker命令\n 镜像命令 容器命令 操作命令 \u0026hellip;    docker镜像\n  容器数据卷\n  dockerfile\n  docker网络原理\n  idea整合docker\n  以上单机版本docker\n 集群 docker compose docker swarm 简化版k8s ci/cd jenkins  docker概述\n开发\u0026ndash;上线 两套环境 应用环境，应用配置\n开发人员 运维人员\n开发即运维！\n环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop\u0026hellip;）费事费力\n发布项目 jar（redis mysql jdk es） war\njar带上环境进行发布，项目能不能带上环境安装打包\n之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台\nwindows与linux\n传统：开发提供jar 运维部署环境\n现在：开发打包部署上线，一套流程做完\ndocker给以上的问题，提出解决方案\njava\u0026mdash;apk\u0026mdash;发布（应用商店） \u0026mdash;张三使用apk \u0026mdash;安装即可用\njava\u0026mdash;jar（环境）\u0026mdash;打包项目带上环境（镜像） \u0026mdash;-docker仓库：商店 \u0026mdash;- 下载我们发布的镜像 \u0026ndash;直接运行即可\ndocker思想就来自于集装箱！\njre\u0026mdash;多个应用 （端口冲突）\u0026mdash;原来都是交叉的\n隔离：Docker核心思想，打包装箱！每个箱子都是互相隔离的！\ndocker通过隔离机制，可以将服务器利用到极致\n本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习。\ndocker历史\n容器化技术命名就是docker\n刚刚诞生的时候没有引起行业注意！dotcloud，开源\n开源，docker优点\n在容器技术出来之前，我们都是使用虚拟机技术，\n虚拟机：在windows中装一个虚拟机软件vmware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！\n虚拟机：也是属于虚拟化技术，docker容器技术，也是一种虚拟化技术\nvm：linux centos 原生镜像（一个电脑） 隔离：需要开启多个虚拟机 几分钟 docker：隔离 镜像机制（最核心的环境 4m +jdk+mysql）十分小巧，运行镜像就可以了 几M 几s docker是基于go语言开发的！开源\ndocker的文档超级详细\n仓库地址：pull push\ndocker能干嘛\n之前的虚拟机技术！\n从内核到库函数到app\n虚拟机技术缺点：\n1.资源占用十分多\n2.冗余步骤多\n3.启动很慢\n容器化技术\n容器化技术不是模拟一个完整的操作系统\n比较docker和虚拟机技术的不同：\n 传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了 每个容器间互相隔离，每个容器内都有一个属于自己的文件系统，互不影响  devops\n更快速的交付和部署\n传统：一堆帮助文档，安装程序\ndocker：一键运行，打包镜像，发布测试\n更便捷的升级和扩缩容\n使用了docker之后，我们部署应用就和搭积木一样\nspringboot1.5 redis5 tomcat8\n项目打包为一个镜像，扩展，服务器A！开服务器B，做扩展\n更简单的系统运维\n在容器化之后，我们的开发，测试环境高度一致\n更高效的利用计算资源：\n1核 2g的服务器！\ndocker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例，服务器的性能可以运行到极致\ndocker的基本组成\n镜像：image 就是一个类，好比一个模版，可以通过这个模版来创建容器服务，tomcat镜像\u0026ndash;\u0026gt;run\u0026mdash;\u0026ndash;\u0026gt;tomcat01容器（提供服务） 通过这个镜像可以创建多个容器（最终服务或者项目运行就是在容器中）\n容器：container docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动、停止、删除、基本命令！目前就可以吧容器理解为就是一个简易的linux系统\n仓库：respository 仓库就是存放镜像的地方 仓库分为公有仓库和私有仓库！ dockerhub 阿里云 都有容器服务器（配置镜像加速）！\n安装docker\n1.需要linux基础\n2.centos7\n3.使用xshell连接远程服务器进行操作\n\rimage-20210607214021379\r\n\rimage-20210607214316440\r\n查看一下下载的这个hello-world镜像\n\rimage-20210607214400376\r\n阿里云镜像加速\n1.登陆阿里云\n2.容器镜像服务\n\rimage-20210607215031767\r\n3.配置使用\nsudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://lufuant6.mirror.aliyuncs.com\u0026#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 回顾helloworld流程\n开始\u0026ndash;\u0026gt;本地寻找镜像\u0026ndash;\u0026gt;如果有就使用这个镜像运行，如果没有就去仓库下载pull\n底层原理\ndocker怎么工作的\ndocker是一个client\u0026ndash;server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问\ndockerserver接收到docker-client的指令，就会执行这个命令\ndocker为什么比vm快\n1.docker有着比虚拟机更少的抽象层\n2.docker利用的是宿主机的内核，vm需要guest OS\n所以新建一个容器的时候， docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载guestOS，分钟级别的，而docker是利用宿主；机加的操作系统，省略了这个复杂的过程，妙级的\ndocker的常用命令\n帮助命令\ndocker version\ndocker info\ndocker 命令 \u0026ndash;help\n镜像命令\ndocker images docker search docker pull docker rmi \rimage-20210607222535947\r\n容器命令\ndocker pull centos 新建容器并启动\ndocker run [] image --name =\u0026#34;\u0026#34; 容器名字 -d 后台方式运行 -i 使用交互方式运行， 进入容器查看内容 -t -p 指定容器的端口-p 8080:8080 主机端口：容器端口 -p 容器端口 -p ip：主机端口：容器端口 exit 从容器中退回主机 docker ps 列出所有运行容器 -a 所有正在运行的容器+运行过的容器 -n=? 显示最近创建的容器 docker ps -q 只显示容器的编号 \rimage-20210608200503679\r\n\rimage-20210608200706097\r\n退出容器\nexit 退出容器，并停止 ctrl+P+Q 删除容器\ndocker rm 容器id\tdocker rm -f $(docker ps -aq) \rimage-20210608201640486\r\n启动停止容器\ndocker start 容器id docker restart 容器id docker stop 容器id docker kill 容器id \rimage-20210608203048244\r\n常用其他命令\n后台启动\ndocker run -d centos docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 dockerlogs 查看容器当中的进程信息\ndocker top 命令 docker inspect 容器id 查看容器信息 \rimage-20210609223653271\r\n进入当前正在进行的容器\n我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 docker exec -it 容器id docker attach 容器id 正在执行当前的代码 exec进入容器后开启一个新的终端，可以在里面操作（常用） attach 进入容器正在执行的终端，不会启动新的进程 \rimage-20210609224319430\r\n从容器内拷贝文件到主机上\ndocker cp 容器id ：容器内路径 目的的主机路径 \rimage-20210609230304773\r\n当前主机目录 root@yourtreedad:~# cd /home root@yourtreedad:/home# ls kuanshen.java test.java root@yourtreedad:/home# touch kuangshen.java root@yourtreedad:/home# ls kuangshen.java kuanshen.java test.java 进入容器内部 root@yourtreedad:/home# docker attach 3a26ef468c27 [root@3a26ef468c27 /]# cd /home bash: cd: $\u0026#39;\\343/home\u0026#39;: No such file or directory [root@3a26ef468c27 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@3a26ef468c27 /]# cd /home [root@3a26ef468c27 home]# ls 创建文件 [root@3a26ef468c27 home]# touch test1.java [root@3a26ef468c27 home]# ls test1.java 退出容器 [root@3a26ef468c27 home]# exit exit root@yourtreedad:/home# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES root@yourtreedad:/home# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3a26ef468c27 centos \u0026#34;/bin/bash\u0026#34; 20 minutes ago Exited (0) 16 seconds ago suspicious_wilbur cee72dcd9187 centos \u0026#34;-it /bin/bash\u0026#34; 21 minutes ago Created eager_einstein 73d060aad5ac centos \u0026#34;/bin/bash\u0026#34; 27 hours ago Exited (255) About an hour ago optimistic_leakey 从容器内拷贝文件至主机 root@yourtreedad:/home# docker cp 3a26ef468c27:/home/test1.java /home root@yourtreedad:/home# ls kuangshen.java kuanshen.java test.java test1.java 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 docker命令很多，以上是最常用的\ndocker安装nginx\n1.搜索镜像\n2.下载镜像\n3.启动镜像\n\rimage-20210609233757534\r\n测试\n\rimage-20210609234211565\r\n端口映射\n进入容器，查看文件\n\rimage-20210609234650627\r\n思考问题：每次改动nignx配置文件，都需要进入容器内部？都十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件，容器内部就可以自动修改？ -v 数据卷技术\ndocker装一个tomcat\ndocker run -it --rm tomcat:9.0 之前的启动都是后台，停止了容器之后，容器还是可以查到 docker run -it --rm 一般用来测试，用完就删除 进入容器 PS C:\\Users\\Sweetie\u0026gt; docker run -d -p 3355:8080 --name tomcat01 tomcat c42f39b1590834eb3720faa3cee74b79a909550fe02bc2ed383676908c3accf2 PS C:\\Users\\Sweetie\u0026gt; docker exec -it tomcat01 /bin/bash root@c42f39b15908:/usr/local/tomcat# ls linux命令少了 没有webapps 阿里云镜像原因，默认是最小的镜像，所有的不必要的都剔除了。 保证最小可运行的环境 root@c42f39b15908:/usr/local/tomcat/webapps# cd .. root@c42f39b15908:/usr/local/tomcat# ls BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work root@c42f39b15908:/usr/local/tomcat# cd webapps.dist root@c42f39b15908:/usr/local/tomcat/webapps.dist# ls ROOT docs examples host-manager manager root@c42f39b15908:/usr/local/tomcat/webapps.dist# cd .. root@c42f39b15908:/usr/local/tomcat# cp -r webapps.dist/* webapps root@c42f39b15908:/usr/local/tomcat# cd webapps root@c42f39b15908:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager 以后要部署项目，如果每次都要进入容器是不是十分麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷技术\nwebapps，在外部放置项目，就自动同步到内部就好了！！！\ndocker容器 tomcat+网站 docker+mysql\n部署es+kibana\nes暴露的端口很多 es十分耗内存 es的数据一般需要放置在安全目录！挂载 --net somenetwork ? 网络配置 下载启动 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; elasticsearch:7.6.2 一启动就顶不住了，很好内存 docker statuc 查看cpu的状态 赶紧关闭，增加内存的限制，修改配置文件 -e 配置修改 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e ES_JAVA_OPTS=\u0026#34;-Xms64m -Xmx512m\u0026#34; elasticsearch:7.6.2 环境配置 作业：使用kibana 连接elasticsearch\n因为相互隔离，所以直接localhost来连不现实，可以使用linux内网ip来搞，需要了解docker网络原理，网络的基本知识\n可视化\n  portainer先用这个\n  rancher（CI、CD再用）\n  什么是portainer\ndocker图形化界面管理工具！提供一个后台面板，供我们操作！\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 访问测试 外网8088端口 通过它来访问 可视化面板，我们平时不会使用，测试玩玩即可 docker镜像讲解\n镜像是什么\n镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件\n所有的应用，直接打包docker镜像，就可以直接跑起来\n如何得到镜像：\n 从远程仓库下载 朋友拷贝给你 自己制作一个镜像 dockerfile  unionFS联合文件系统\n我们下载的时候看到的一层层的就是这个\nunionfs联合文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改，作为一次提交来一层层叠加，同时可以将不同目录挂在到同一个虚拟文件系统下unite several directories into a single virtual filesystem 。union文件系统是docker 镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\ndocker镜像加载原理\ndocker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS\nbootfs （boot file system ） 主要包含bootloader 和 kernel ，bootloader 主要是引导加载kernel ， linux 刚启动时会加载 bootfs 文件系统，在docker 镜像的最底层是bootfs。这一层与我们典型的linu/unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs\nrootfs（root file system），在bootfs之上，包含的就是典型linux系统中的 /dev , /proc / bin , /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu，centos等等\n平时我们安装进虚拟机的centos都是好几个G，为什么docker这里才200M\n对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版本可以共用bootfs\n分层理解\nPS C:\\Users\\Sweetie\u0026gt; docker pull redis Using default tag: latest latest: Pulling from library/redis 69692152171a: Already exists a4a46f2fd7e0: Pull complete bcdf6fddc3bd: Pull complete 2902e41faefa: Pull complete df3e1d63cdb1: Pull complete fa57f005a60d: Pull complete 我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层在下载的！\n思考：为什么docker镜像要采用这种分层的结构呢？\n最大的好处，我觉得莫过于是资源共享！比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享\n}, \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\u0026#34;, \u0026#34;sha256:ec5652c3523d96657d66169c0eb71b572ff065711c705a15ec02f60a21c212c3\u0026#34;, \u0026#34;sha256:76d3e24d63f60e6a73af70be15959eb4021dd7a5a09da6925037d3b4a1673fca\u0026#34;, \u0026#34;sha256:f06719b0aa43029f32c821c8f14f9f5941a8be6d3b61dcd9f3f884b39e9a4f23\u0026#34;, \u0026#34;sha256:b896f490f2edc62cc9d190465bbeab871619590d1e9beeffb92e4ca9cc08116d\u0026#34;, \u0026#34;sha256:e3f4077f577bf07c0940d6345ddd17014ff824d3f4f7f3effc9a8c4dae3e527b\u0026#34; ] }, \u0026#34;Metadata\u0026#34;: { \u0026#34;LastTagTime\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; } 理解：\n所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于ubuntu linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加python包，该镜像就会在基础镜像层之上创建第二个镜像层，如果继续添加一个安全不定，就会创建第三个镜像层。\n在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。\n这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像中。docker通过存储引擎（新版本采用快照机制）的方式来实现惊险层堆栈，并保证多镜像层对外展示为统一的文件系统。\nlinux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种引擎都有其独有的性能特点。\nDocker在windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和cow\ndocker镜像都是只读的，一个新的刻写层被加载到镜像的顶部！\n这一层就是我们通常说的容器层，容器之下的都叫镜像\n如何提交一个自己的镜像\ncommit镜像\ndocker commit 提交容器成为一个新的副本 docker commit -m=\u0026#34;提交的描述信息\u0026#34; -a=\u0026#34;作者\u0026#34; 容器id 目标镜像名:[TAG] 测试\n 启动默认tomcat 没有文件的webapps  root@e7c2f9ef26e4:/usr/local/tomcat# cp -r webapps.dist/* webapps root@e7c2f9ef26e4:/usr/local/tomcat# ls BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work root@e7c2f9ef26e4:/usr/local/tomcat# cd webapps root@e7c2f9ef26e4:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager  cp命令拷贝进webapps  \rimage-20210612162156751\r\n 浏览器可以访问 commit提交为一个新的镜像，我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改过的镜像  PS C:\\Users\\Sweetie\u0026gt; docker commit -m=\u0026#34;add webapps app\u0026#34; -a=\u0026#34;ljs\u0026#34; e7c2f9ef26e4 tomcatupdate1.0 sha256:2a308d5b7f5a2b5b471a193c596369ee1ec2168d04221397ced9c9201a94075e PS C:\\Users\\Sweetie\u0026gt; docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcatupdate1.0 latest 2a308d5b7f5a 8 seconds ago 672MB redis latest fad0ee7e917a 10 days ago 105MB nginx latest d1a364dc548d 2 weeks ago 133MB tomcat latest c43a65faae57 4 weeks ago 667MB portainer/portainer latest 580c0e4e98b0 2 months ago 79.1MB centos latest 300e315adb2f 6 months ago 209MB elasticsearch 7.6.2 f29a1ee41030 14 months ago 791MB elasticsearch latest 5acf0e8da90b 2 years ago 486MB \rimage-20210612162537739\r\n如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像。\n就好比以前我们学习VM的时候，快照\n到这里才算入门\n容器数据卷、dockerfile、docker网络：docker精髓\n企业实战\ndocker compose\ndocker swarm\nci 、 cd jenkins 流水线\n容器数据卷\n什么是容器数据卷\ndocker的理念回顾：\n将应用和环境打包成一个镜像！\n数据？如果数据都在容器中，那么我们把容器删除，数据就会丢失！\n需求：数据可以持久化\nMYsql，容器删了，删库跑路!\n需求：MYsql的数据可以存储在本地！\n容器之间可以有一个容器共享的技术！docker容器中产生的数据，同步到本地！\n这就是数据卷技术！目录的挂载，将容器内的目录挂载linux上\n总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！\n使用数据卷\n方式一：直接使用命令挂载 -v docker run -it -v 主机目录地址：容器内目录地址 -p 主机端口：容器端口 root@yourtreedad:~# cd /home root@yourtreedad:/home# ls kuangshen.java kuanshen.java test.java test1.java root@yourtreedad:/home# cd .. root@yourtreedad:/# docker run -it -v /home/ceshi:/home centos /bin/bash \rimage-20210612164241555\r\n使用 docker inspect 容器id 查看具体信息\n在外面建立文件，可以看到里面也有\n[root@ffb011d1322a /]# cd home [root@ffb011d1322a home]# ls outtoint.txt 在里面见文件，可以看到里面也有\n[root@ffb011d1322a home]# touch intoout.java [root@ffb011d1322a home]# ls intoout.java outtoint.txt [root@ffb011d1322a home]# exit exit root@yourtreedad:/# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ffb011d1322a centos \u0026#34;/bin/bash\u0026#34; 12 minutes ago Up 10 minutes eager_heyrovsky e7c2f9ef26e4 tomcat:latest \u0026#34;catalina.sh run\u0026#34; 34 minutes ago Up 34 minutes 0.0.0.0:5555-\u0026gt;8080/tcp sweet_ramanujan b90d3528ae04 portainer/portainer \u0026#34;/portainer\u0026#34; 6 hours ago Up 37 minutes 0.0.0.0:8088-\u0026gt;9000/tcp, :::8088-\u0026gt;9000/tcp confident_villani root@yourtreedad:/# cd home root@yourtreedad:/home# cd ceshi root@yourtreedad:/home/ceshi# ls intoout.java outtoint.txt root@yourtreedad:/home/ceshi# 容器停止了，但是只要容器还在，就能实现同步数据，类似双向绑定\n\rimage-20210612165925505\r\n好处：我们以后修改只需要在本地修改即可，容器内会自动同步！\n实战：安装mysql\n思考：mysql的数据持久化的问题！\n获取镜像 docker pull mysql 运行容器，需要做数据挂载，需要配置密码，这需要注意 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag -d 后台运行 -p 端口映射 -v 数据卷挂在 -e 环境配置 --name docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 启动成功之后，我们在本地使用 sqlyog 来测试一下 sqlyog --h -u -p 连接到服务器的3310 ----3310 和容器内的3306进行映射，这个时候我们就可以连接上了 在本地测试创建一个数据库，查看一下映射的路径是否ok 假设我们将容器删除，发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能 \rimage-20210612172111412\r\n具名挂载和匿名挂载\n匿名挂载 -v 容器内路径 相当于不指定主机的地址，直接指定容器地址 root@yourtreedad:/# docker run -d -P --name nginx01 -v /etc/nginx nginx 查看所有卷的情况 docker volume ls 这里发现 DRIVER VOLUME NAME local 0faef3ffc2187555023c9a8e5dca5c11e47f0b436657e48f95e972e33c951c49 这种就是匿名挂载，我们-v的时候只写了容器的路径，没有写容器外的路径！ 通过-v 卷名：容器内路径 这就是具名挂载 root@yourtreedad:/# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx 11c306e0a80402c0c235042326f5db9da58570e01abac55379414d9d53abc797 root@yourtreedad:/# docker volume ls DRIVER VOLUME NAME local 0faef3ffc2187555023c9a8e5dca5c11e47f0b436657e48f95e972e33c951c49 local 3c63eeef73128b24bbf1830f9cec7d383aae8413e232a857f1216456fb07fedf local 941b4501fa7cefd9a341366fbe18cfeddd0f2d223c1eb87addf1a77a42c2ace8 local 3826373b692739fc44eac10a00d8ddada7b0200c5833963c459d6db001384a70 local 8440372a24dc57f1bcf100c1ef256abbff5713f1c96c2bd65276aea10f54864d local cb64d53be430f816088a1f1bbd1f5aea8885a1be33ddd98a5fb98a9d452fa03c local juming-nginx 查看一下这个卷挂载在主机的哪个位置了呢 root@yourtreedad:/# docker volume inspect juming-nginx [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2021-06-13T02:11:30Z\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/juming-nginx/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;juming-nginx\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] 所有docker容器内的卷，如果没有指定目录的情况下，都是在/var/lib/docker/volumes/xxxx下 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用的是具名挂载 \rimage-20210613100849422\r\n如何确定是具名挂载还是匿名挂载 ，还是指定路径挂载 -v 容器内路径 这就是匿名挂载 -v 卷名：容器内路径 这就是具名挂载 -v /宿主机路径：/容器内路径 这就是指定路径挂载 拓展： 通过 -v 容器内路径，ro 、 rw 改变读写权限 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx 只读ro readonly 可读可写rw readwrite 一旦设置了ro 容器对我们挂载出来的内容就有限定了！ ro只要看到ro，就说明这个路径只能通过宿主机来操作，容器内部是无法操作的 初识dockerfile\n方式二：\ndockerfile就是用来构建docker镜像的构建文件！命令脚本！先体验一下！\nctrl+U 删除当前命令 mkdir 生成文件夹 rm -rf 文件夹名字 强制删除文件夹名字 pwd 查看当前在那个目录中 进入文件后 esc 再：wq就是保存并退出 vim 使用文本编辑器进入文件 a后就可以编辑 通过脚本可以生成镜像，镜像是一层一层的 touch 创建一个文件 ##创建一个dockerfile文件，名字可以随机，建议 dockerfile ##文件中的内容 指令都是大写 参数 ##这里的每个命令，都是镜像的一层 FROM centos VOLUME[\u0026#34;volume01\u0026#34;,\u0026#34;volume02\u0026#34;] CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash 好像要空行！！！！ 通过dockerfile 去构建镜像 root@yourtreedad:/home/docker-test-volume# docker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos:1.0 . 启动一下自己的生成的容器\nroot@yourtreedad:/# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcatupdate 1.0 ee149e8cdc20 5 hours ago 672MB portainer/portainer-ce latest 45be17a5903a 2 weeks ago 209MB nginx latest d1a364dc548d 2 weeks ago 133MB tomcat latest c43a65faae57 4 weeks ago 667MB mysql latest c0cdc95609f1 4 weeks ago 556MB portainer/portainer latest 580c0e4e98b0 2 months ago 79.1MB kuangshen/centos 1.0 f75a47123694 6 months ago 209MB root@yourtreedad:/# docker run -it f75a47123694 /bin/bash 但是这个地方报错了，好象是说现在的destination 不能为相对路径 docker: Error response from daemon: OCI runtime create failed: invalid mount {Destination:volume01 Type:bind Source:/var/lib/docker/volumes/67cb8e440bfc475a6b8e0f091779f2c56fed443d1ca4e6edd10ca37f37d09e05/_data Options:[rbind]}: mount destination volume01 not absolute: unknown. ERRO[0000] error waiting for container: context canceled 查看一下卷挂载的路径\n\rimage-20210613192809990\r\n测试一下刚才的文件是否同步出去了，可以在卷里写个文件，在宿主机的挂载位置处查看是否有这个文件就可以辣\n这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！\n假设构建镜像的时候没有挂载卷，要手动镜像挂载 -v卷名：容器内路径\n数据卷容器：多个容器之间同步数据\n两个mysql同步数据！\n主从复制之类的就可能使用这个技术 使用 --volumes-from docker run -it --name docker02 --volumes-from docker01 centos docker run -it --name docker03 --volumes-from docker01 centos 很像继承 启动3个容器，通过我们刚才自己写的镜像启动 启动完了就测试，测试的时候在主docker01中创建文件看看docker0203中会不会有就好了\nroot@yourtreedad:/# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfb328e8f37f centos \u0026#34;/bin/bash\u0026#34; 3 minutes ago Up 2 minutes docker03 5787d6ea92e4 centos \u0026#34;/bin/bash\u0026#34; 5 minutes ago Up 3 minutes docker02 c8ba46a34155 centos \u0026#34;/bin/bash\u0026#34; 13 minutes ago Up 12 minutes docker01 root@yourtreedad:/# docker attach c8ba46a34155 [root@c8ba46a34155 /]# cd bin [root@c8ba46a34155 bin]# cd bash bash: cd: bash: Not a directory [root@c8ba46a34155 bin]# cd .. [root@c8ba46a34155 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@c8ba46a34155 /]# mkdir ceshi [root@c8ba46a34155 /]# ls bin ceshi dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@c8ba46a34155 /]# cd ceshi [root@c8ba46a34155 ceshi]# ls [root@c8ba46a34155 ceshi]# touch ceshi.java [root@c8ba46a34155 ceshi]# ls ceshi.java [root@c8ba46a34155 ceshi]# cd .. [root@c8ba46a34155 /]# cd .. [root@c8ba46a34155 /]# exit exit 没问题\noot@yourtreedad:/# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfb328e8f37f centos \u0026#34;/bin/bash\u0026#34; 6 minutes ago Up 6 minutes docker03 5787d6ea92e4 centos \u0026#34;/bin/bash\u0026#34; 8 minutes ago Up 7 minutes docker02 c8ba46a34155 centos \u0026#34;/bin/bash\u0026#34; 17 minutes ago Up 41 seconds docker01 root@yourtreedad:/# docker attach c8ba46a34155 [root@c8ba46a34155 /]# ls bin ceshi dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@c8ba46a34155 /]# cd ceshi [root@c8ba46a34155 ceshi]# ls ceshi.java [root@c8ba46a34155 ceshi]# 问题：如果docker01 删除了，那么数据还有在docker02和docker03上有吗\n有的，它是一种拷贝的概念 ，可能是链接吧\n结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止\n但是一旦你持久化到了本地，那么数据就可以持久化保存了，本地的数据是不会删除的\ndockerfile\ndockerfile核心是用来构建docker images 的文件！命令参数脚本！\n构建步骤：\n1.编写一个dockerfile文件\n2.docker build 构建一个镜像\n3.docker run 运行镜像\n4.docker push 发布镜像（dockerhub 、 阿里云镜像仓库）\n查看一下官方是怎么做的\n很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！\n官方既然可以制作镜像，我们也可以！\ndockerfile构建过程\n很多指令：\n基础知识：\n1.每个保留关键字（指令） 都必须是大写字母\n2.执行从上到下顺序执行\n3.#表示注释\n4.每个指令都会创建提交一个新的镜像层，并提交\ndockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单\ndocker 镜像 例如构建一个springboot 微服务 镜像\ndocker镜像主键成为企业交付的标准，必须要掌握\n步骤：开发运维上线部署\ndockerfile：构建文件，这个文件定义了一切的步骤，源代码\ndockerimages：通过dockerfile构建生成的镜像，这就是最终发布和运行的产品\ndockercontainer：容器就是镜像运行起来提供服务的\ndockerfile的指令：\n以前的话我们都是使用别人的，现在我们知道了这些指令后，我们来练习自己写一个镜像！\nFROM 基础镜像 一切从这里开始构建 MAINTAINER 镜像是谁写的，有你的姓名+邮箱 RUN docker镜像构建的时候需要运行的命令 ADD 步骤：tomcat镜像，这个tomcat压缩包坑定要被添加进去嘛 WORKDIR 镜像的工作目录 VOLUME 容器卷，要挂载的目录 EXPOSE 指定暴露端口 CMD 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代 ENTRYPOINT 指定这个容器启动的时候要运行的命令，可以追加的命令 ONBUILD 当构建一个被继承的dockerfile时候 就会运行onbuild指令，触发指令 COPY 类似ADD,将我们的文件拷贝到镜像中 ENV\t构建的时候设置环境变量 实战测试！\ndocker hub 中 99% 都是从这个基础镜像过来的 FROM scratch ， 然后配置需要的软件和配置来进行的构建\n\rimage-20210613202655507\r\n创建一个自己的centos\n\rimage-20210613203001901\r\n问题：vim clear 等命令都不支持，我们可以在此镜像的基础上在加一点完善一下\n1.编写dockerdile的文件 root@yourtreedad:/# cd home root@yourtreedad:/home# ls docker-test-volume mysql nginx tomcat root@yourtreedad:/home# mkdir dockerfile root@yourtreedad:/home# ls docker-test-volume dockerfile mysql nginx tomcat root@yourtreedad:/home# cd dockerfile root@yourtreedad:/home/dockerfile# ls root@yourtreedad:/home/dockerfile# vim mydockerfile root@yourtreedad:/home/dockerfile# cat mydockerfile FROM centos MAINTAINER ljs\u0026lt;1018814650@qq.com\u0026gt; ENV MYPATH /uer/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install clear RUM yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \u0026#34;-----end-----\u0026#34; CMD /bin/bash root@yourtreedad:/home/dockerfile# 2.通过这个文件构建镜像 docker build -f dockerfile文件路径 -t 镜像名：[tag] root@yourtreedad:/home/dockerfile# docker build -f mydockerfile -t mycentos:0.1 . [+] Building 2.2s (8/8) FINISHED =\u0026gt; [internal] load build definition from mydockerfile 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 245B 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/centos:latest 0.0s =\u0026gt; [1/4] FROM docker.io/library/centos 0.0s =\u0026gt; CACHED [2/4] WORKDIR /uer/local 0.0s =\u0026gt; CACHED [3/4] RUN yum -y install vim 0.0s =\u0026gt; [4/4] RUN yum -y install net-tools 1.8s =\u0026gt; exporting to image 0.3s =\u0026gt; =\u0026gt; exporting layers 0.3s =\u0026gt; =\u0026gt; writing image sha256:2734e41a96b14a3e45a820363638a9f62dfd2c7d901757ea5e2a9ba25ababf50 0.0s =\u0026gt; =\u0026gt; naming to docker.io/library/mycentos:0.1\t3.测试 root@yourtreedad:/home/dockerfile# docker run -it --name mycentosdemo mycentos:0.1 [root@51e42c44c78d local]# pwd /uer/local [root@51e42c44c78d local]# ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 172.17.0.4 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:04 txqueuelen 0 (Ethernet) RX packets 9 bytes 726 (726.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 对比:之前的原生的centos，工作目录默认根目录，没有vim ifconfig 命令\n现在：基于原生centos，添加了这些命令\n我们可以列出本地镜像的变更历史\ndocker history imageId \rimage-20210613204852480\r\n所以我们平时拿到一个镜像，可以研究一下他是怎么做的了\nCMD 和 ENTRYPOINT 的区别\nCMD 指定这个容器启动的时候需要运行的命令，只有最后一个会生效，可被替代 cmd的情况下 -l 替换了CMD的[\u0026#34;ls\u0026#34;,\u0026#34;-a\u0026#34;]命令，-l 不是命令所以报错 ENTRYPOINT 指定这个容器启动的时候需要运行的命令你，可以追加命令 \rimage-20210613235037903\r\n\rimage-20210613235823435\r\n\rimage-20210613235940096\r\n不会替换人家的命令\n我们的追加命令，是直接凭借在我们的ENTRYPOINT 命令的后面！\ndockerfile中很多命令都十分相似，我们需要了解她们的区别，我们最好的学习就是对比她们然后测试效果\n实战：\ntomcat镜像\n1.准备镜像文件 tomcat压缩表，jdk的压缩包！\n\rimage-20210614104621398\r\n2.编写dockerfile文件 ， 官方命名Dockerfile ，build会自动寻找这个文件，就不需要-f 指定了\nroot@yourtreedad:/home/kuangshen# cat Dockerfile FROM centos MAINTAINER ljs\u0026lt;1018814650@qq.com\u0026gt; COPY readme.txt /usr/local/readme.txt ADD jdk-8u291-linux-aarch64.tar.gz /usr/local/ ADD apache-tomcat-9.0.46.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_291 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.46 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.46 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.46/bin/startup.sh \u0026amp;\u0026amp; tail -F /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.out root@yourtreedad:/home/kuangshen# \rimage-20210614112215796\r\n3.构建镜像\n\rimage-20210614110353773\r\nroot@yourtreedad:/home/kuangshen# docker build -f Dockerfile -t diytomcat . [+] Building 0.1s (11/11) FINISHED =\u0026gt; [internal] load build definition from Dockerfile 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 670B 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/centos:latest 0.0s =\u0026gt; [1/6] FROM docker.io/library/centos 0.0s =\u0026gt; [internal] load build context 0.0s =\u0026gt; =\u0026gt; transferring context: 130B 0.0s =\u0026gt; CACHED [2/6] COPY readme.txt /usr/local/readme.txt 0.0s =\u0026gt; CACHED [3/6] ADD jdk-8u291-linux-aarch64.tar.gz /usr/local/ 0.0s =\u0026gt; CACHED [4/6] ADD apache-tomcat-9.0.46.tar.gz /usr/local/ 0.0s =\u0026gt; CACHED [5/6] RUN yum -y install vim 0.0s =\u0026gt; CACHED [6/6] WORKDIR /usr/local 0.0s =\u0026gt; exporting to image 0.0s =\u0026gt; =\u0026gt; exporting layers 0.0s =\u0026gt; =\u0026gt; writing image sha256:d65fc7234bf254fb93a262a640dcfb543b6f4780fa36ef881bb9992d9705359f 0.0s =\u0026gt; =\u0026gt; naming to docker.io/library/diytomcat 启动容器 分配端口 使用挂载 指定镜像 root@yourtreedad:/home/kuangshen# docker run -d -p 9090:8080 --name kuangshendiytomcat -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.46/logs diytomcat:1.0 \rimage-20210614110934343\r\nroot@yourtreedad:/home/kuangshen# docker images REPOSITORY TAG IMAGE ID CREATED SIZE diytomcat latest d65fc7234bf2 4 hours ago 464MB mycentos 0.1 2734e41a96b1 20 hours ago 284MB tomcatupdate 1.0 ee149e8cdc20 28 hours ago 672MB portainer/portainer-ce latest 45be17a5903a 2 weeks ago 209MB nginx latest d1a364dc548d 2 weeks ago 133MB tomcat latest c43a65faae57 4 weeks ago 667MB mysql latest c0cdc95609f1 4 weeks ago 556MB portainer/portainer latest 580c0e4e98b0 2 months ago 79.1MB mycentosentrypointtest 1.0 5198b187e833 6 months ago 209MB mycentostest 1.0 be8cf7de8763 6 months ago 209MB kuangshen/centos 1.0 f75a47123694 6 months ago 209MB centos latest 300e315adb2f 6 months ago 209MB root@yourtreedad:/home/kuangshen# docker run --name diytomcat01 -d -p 9090:8080 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.46/logs diytomcat 174cd08dab23fce852cae1ac5e721c985b377d1ff85a1e769384cb9dd369bde0 进入容器查看\nroot@yourtreedad:/home/kuangshen/build/tomcat# docker exec -it c7cff52b8760 /bin/bash 这里的bin/bash就会自动跳转到我们设定好的usr/local目录之下 \rimage-20210614111326218\r\n4.启动镜像\n5.访问测试\n6.发布项目（由于做了卷挂载，我们直接在本地编写项目就可以直接发布了！）\n发现项目部署成功，可以直接访问！\n我们以后开发的步骤：需要掌握dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！！！\n发布镜像\ndockerhub\n1.地址 注册自己的账号\n2.确定这个账号可以登陆\n\rimage-20210614162522282\r\n3.在服务器上提交自己的镜像\n在此之前需要打tag\nroot@yourtreedad:/# docker tag --help Usage: docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE root@yourtreedad:/# docker tag tomcatupdate:1.0 yourtreedad/tomcatupdate:2.0 \rimage-20210614165331722\r\nroot@yourtreedad:/# docker push yourtreedad/tomcateupdatehub:1.0 \rimage-20210614165502602\r\n提交的时候也是按照镜像的层级一层一层提交的\n可以发布到阿里云镜像服务上嘻嘻\n1.登陆阿里云\n2.找到容器镜像服务\n3.创建命名空间 为了隔离\n\rimage-20210614170103181\r\n4.创建容器镜像\n\rimage-20210614170213918\r\n5.浏览阿里云\n\rimage-20210614170251978\r\nroot@yourtreedad:/# docker login --username=把书掏出来 registry.cn-hangzhou.aliyuncs.com Password: Login Succeeded\t登陆\nroot@yourtreedad:/# docker tag ee149e8cdc20 registry.cn-hangzhou.aliyuncs.com/hfutie/yourtree-test:1.0 \rimage-20210614171742651\r\n上传\nroot@yourtreedad:/# docker push registry.cn-hangzhou.aliyuncs.com/hfutie/yourtree-test:1.0 \rimage-20210614171949041\r\n\rimage-20210614172425553\r\ndocker小结\ndockerfile build\nimages tag、run/push/pull/save/load\ncontainers stop/kill/start/restart/commit\ndockerrepository\nbackup.tar\n\rimage-20210614172933295\r\n精通的话需要学会docker网络（铺垫、容器编排、集群部署）\ndocker网络\n理解docker网络 docker0\n清空所有环境\n测试\n\rimage-20210614185814918\r\n好多个网络，docker是如何处理容器网络访问的？\nES之前的问题\nroot@yourtreedad:/# docker run -d -P --name tomcat01 tomcat 查看容器的内部网络地址 ip addr,发现容器启动的时候会得到一个eth0@if22 ip地址，docker分配的 root@yourtreedad:~# docker exec -it tomcat01 ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: sit0@NONE: \u0026lt;NOARP\u0026gt; mtu 1480 qdisc noop state DOWN group default qlen 1000 link/sit 0.0.0.0 brd 0.0.0.0 21: eth0@if22: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 发现windows好像ping不通啊 linux可以ping通 docker容器内部 原理\n192.168.0.1路由器\n192.168.0.3 同一个网段是能ping通的\n1.我们每安装一个docker容器 ， docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，（windows for docker好像咩有） ， 桥接模式，使用的技术是evth-pair技术！\n再次测试 ip addr之后\n\rimage-20210614190941605\r\n网课里说的是又多了一个，但windows中没有发现\n2.在启动一个容器测试\n网课里说的是又多了一个，但windows中没有\n\rimage-20210614191119464\r\n我们发现这个容器带来的网卡，都是一对一对的 veth-pair 就是一对的虚拟设备接口，她们都是成对出现的，一端连着协议，一端彼此相连 正因为有这个特性 我们就使用veth-pair 充当一个桥梁，连接各种虚拟网络设备的 OpenStac，Docker容器之间的链接，OVS的连接，都是使用 veth-pair技术 3.我们来测试一下tomca01 和 tomcat02 是否可以ping通\n\rimage-20210614194957533\r\n在linux中，tomcat01和宿主机和tomcat02可以相互ping通\n在windows for docker中，tomcat01和tomcat02可以通，但是不能和宿主机ping通\n结论：容器和容器之间是可以互相ping通的\n在linux中，tomcat01和tomcat02是共用的一个路由器，即docker0\n所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP\n0-255 A B C\n255.255.0.1/16 域\n00000000.00000000.00000000.00000000\n 小结\n docker使用的是linux桥接，宿主机中是一个docker容器的网桥，docker0\ndocker中的所有的网络接口都是虚拟的，虚拟的转发效率高！内网传递文件！\n只要容器删除了，对应的网桥就没了\n\u0026ndash;link\n 思考一个场景，我们编写了一个微服务，database url = ip：\n 项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来进行访问容器？\n直接ping服务名是不行的 root@yourtreedad:~# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known 解决？ 通过--link 就可以解决了网络连通 root@yourtreedad:~# docker run -d --name tomcat03 --link tomcat02 tomcat 832afb5618b02262a5f9cbe48072941cc4784c009d0f91962b371c218afa31c0 root@yourtreedad:~# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known root@yourtreedad:~# docker exec -it tomcat03 ping tomcat02 \rimage-20210614200734188\r\n默认网关docker0 ，就是这里的172.17.0.1\n\rimage-20210614201015974\r\n探究：inspect 容器id\n\rimage-20210614201318560\r\nlink的本质 查看hosts配置，在这里原理发现 root@yourtreedad:~# docker exec -it tomcat03 cat /etc/hosts \rimage-20210614201902916\r\n\u0026ndash;link 就是我们在hosts配置中，增加了一个172.18.0.3 tomcat02 的映射\n\rimage-20210614202018329\r\n由于02没有使用\u0026ndash;link，所以不能直接使用 服务名字来跳转\n实际上就是host映射\n我们现在使用docker已经不建议使用\u0026ndash;link了！\n需要自定义网络！不适用docker0！\ndocker0问题：他不支持容器名连接访问！\n自定义网络\n容器互联：\n查看所有的docker网络 docker network ls \rimage-20210614202322526\r\n网络模式\nbridge 网络桥接模式 搭桥：（默认，自己创建的推荐使用bridge模式）\nnone ：不配置网络\nhost：和宿主机共享网络\ncontainer：容器内网络连通！（用得少，局限很大）\n测试\n我们直接启动的命令 默认，这个我们看了就是我们的docker0 root@yourtreedad:~# docker run -d -P --name tomcat01 --net bridge tomcat 实际上不写--net也是默认的 docker0 特点，默认，域名不能访问 --link 可以打通连接！ 我们可以自定义一个网络！ \rimage-20210614202926510\r\n\rimage-20210614203159484\r\n创建一个自定义网络 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet 桥接、子网、网关设置 我们自己的网络就创建好了！ \rimage-20210614203427052\r\n使用自己构建的网络来创建容器，塞进去 root@yourtreedad:~# docker run -d -P --name tomcat-net-01 --net mynet tomcat 8d24df7fb899de77db6b600aedbfacc32fdd161836dd638b56666ca2014ff5bf root@yourtreedad:~# docker run -d -P --name tomcat-net-02 --net mynet tomcat eee0d29dbed8e780487fcc4bf93f1b3a9ab5ad8ffac194861a3c2ee948d8ea9e 查看网络情况 root@yourtreedad:~# docker inspect mynet \rimage-20210614203821209\r\n看看能不能ping通\n现在不使用 --link也可以ping名字了！ root@yourtreedad:~# docker exec -it tomcat-net-01 ping 192.168.0.3 root@yourtreedad:~# docker exec -it tomcat-net-01 ping tomcat-net-02 我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络！\n\rimage-20210614204033670\r\n好处：\nredis - 保证不同的集群使用不同的网络，保证集群是安全和健康的\nmysql\n网络连通\n没有确保两个集群网络连通的情况下 ， 两个子网是无法相连的\n\rimage-20210614204746483\r\n构建两个tomcat 但是默认是docker0网络下的 root@yourtreedad:~# docker run -d -P --name tomcat01 tomcat 86e292de23f4c821375058608f49f6a5bbdcd0220a5c3e36999cafa86eb25f79 root@yourtreedad:~# docker run -d -P --name tomcat02 tomcat e45223474886d4f490ed66446c2eb1b7809b273c5b104fde27301d9746f4ebf6 而tomcat-net-01是在mynet下的，所以连不通 root@yourtreedad:~# docker exec -it tomcat02 ping 192.168.0.3 不能让docker0和mynet连通，这样不安全，要单独让tomcat01 和mynet连通 如何操作 docker network connect 测试打通 tomcat01 到 mynet \rimage-20210614205014081\r\nroot@yourtreedad:~# docker network connect mynet tomcat01 root@yourtreedad:~# docker network inspect mynet 连通之后就是将tomcat01 放置到了 mynet 网络下？ 一个容器两个ip地址！ 阿里云服务，公网ip 和 私网ip \rimage-20210614205144180\r\n再试试\nroot@yourtreedad:~# docker exec -it tomcat01 ping tomcat-net-01 0102好像都可以打通\n\rimage-20210614205634156\r\n结论：假设要跨网络操作别人，就需要使用docker network connect 连通！\n实战：部署redis集群\n分片+高可用+负载均衡\nshell脚本建立！\n3主3从\n1.建立网络\nroot@yourtreedad:/# docker network create redisnet --subnet 172.38.0.0/16 root@yourtreedad:/# docker network ls root@yourtreedad:/# docker network inspect redisnet \rimage-20210617192710761\r\n2.通过脚本创建六个redis配置\nroot@yourtreedad:/# for port in $(seq 1 6); do mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt;/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done \rimage-20210617194321734\r\n\rimage-20210617194434797\r\n3.拉取镜像，启动容器，分配端口，数据卷映射\nroot@yourtreedad:/# docker run -p 6371:6379 -p 16371:16379 --name redis-1 -v /mydata/redis/node-1/data:/data -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6372:6379 -p 16372:16379 --name redis-2 -v /mydata/redis/node-2/data:/data -v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 -v /mydata/redis/node-3/data:/data -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6374:6379 -p 16374:16379 --name redis-4 -v /mydata/redis/node-4/data:/data -v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6375:6379 -p 16375:16379 --name redis-5 -v /mydata/redis/node-5/data:/data -v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6376:6379 -p 16376:16379 --name redis-6 -v /mydata/redis/node-6/data:/data -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf \rimage-20210617200000188\r\n进入容器内部\nroot@yourtreedad:/# docker exec -it redis-1 /bin/sh \rimage-20210617200316068\r\n建立集群 切片\n/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --clust er-replicas 1 \rimage-20210617200738182\r\n查看集群信息\n/data # redis-cli -c 127.0.0.1:6379\u0026gt; cluster info 127.0.0.1:6379\u0026gt; cluster nodes 127.0.0.1:6379\u0026gt; set a b \rimage-20210617201019736\r\n测试，停掉一个master主机redis会不会使用备机来顶替主机\nroot@yourtreedad:/# docker stop redis-3 root@yourtreedad:/# docker exec -it redis-1 /bin/sh /data # redis-cli -c 127.0.0.1:6379\u0026gt; cluster info 127.0.0.1:6379\u0026gt; get a \rimage-20210617201403193\r\n\rimage-20210617201528497\r\ndocker 搭建 redis集群完成！\n我们使用了docker之后，所有的技术都会慢慢变得简单起来\nspringboot 微服务打包docker镜像\n1.架构springboot项目\n2.打包应用\n3.编写dockerfile\n4.构建镜像\n5.发布运行！\n\rimage-20210617204707930\r\n\rimage-20210617204834101\r\ncmd测试\n\rimage-20210617204915044\r\n\rimage-20210617213140315\r\n回到idea中编写dockerfile\n\rimage-20210617224102830\r\n弄好之后连接linux ， 吧windows上的dockerfile和jar包传到linux服务器上，需要使用filezilla软件传输\nlinux服务器ip地址指令 ifconfig\n\rimage-20210617213836333\r\n切换用户\n把文件传到linux上\n\rimage-20210617221920977\r\n坑死了 ENTRYPOINT 与[]之间有个打空格\n通过build 构建镜像\nroot@yourtreedad:/home/idea# docker build -f Dockerfile -t kuangshen666 . \rimage-20210617224515040\r\n测试\nroot@yourtreedad:/home/idea# docker run -d --name kuangshen-springboot-web -P kuangshen666 root@yourtreedad:/home/idea# curl localhost:49158/hello \rimage-20210617225833450\r\n\rimage-20210617230044609\r\n以后我们使用了Docker之后，给别人交付的就是一个镜像即可\n预告：如果我们有很多镜像？100个\n还要学\nDocker Compost\nDocker Swarm\nK8s\nCI/CD 之 Jenkins\n尝试基于ECS快速搭建docker环境\n\rimage-20210618223452399\r\n\rimage-20210618223539027\r\n\rimage-20210618223624125\r\n\rimage-20210618223650264\r\nECS云服务器新手上路\n\rimage-20210619103343896\r\n\rimage-20210619103400085\r\n\rimage-20210619103431630\r\n下面尝试部署了一下继恩的vue和nginx\nnginx使用挂载的方式-v 来实现对容器内部nginx配置文件的替换，\n利用docker cp 来把dist文件拷贝进去\n使用-p 的方式替换端口\nroot@yourtreedad:~# docker pull nginx Using default tag: latest latest: Pulling from library/nginx b4d181a07f80: Already exists 66b1c490df3f: Pull complete d0f91ae9b44c: Pull complete baf987068537: Pull complete 6bbc76cbebeb: Pull complete 32b766478bc2: Pull complete Digest: sha256:353c20f74d9b6aee359f30e8e4f69c3d7eaea2f610681c4a95849a2fd7c497f9 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest root@yourtreedad:~# root@yourtreedad:~# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest 4cdc5dd7eaad 10 days ago 133MB yourtreedad/blazordemo latest aa1397c0af05 2 weeks ago 207MB mysql latest 5c62e459e087 3 weeks ago 556MB root@yourtreedad:~# cd .. root@yourtreedad:/# pwd / root@yourtreedad:/# cd home root@yourtreedad:/home# ls blazortest haierDemo ljs mvcwindowstest nginx tomcat consoletest1 kuangshen mvctest mysql nginxdemo webapitest root@yourtreedad:/home# cd nginxdemo root@yourtreedad:/home/nginxdemo# ls nginx-1.14.2 nginx-1.14.2.zip root@yourtreedad:/home/nginxdemo# cd nginx-1.14.2 root@yourtreedad:/home/nginxdemo/nginx-1.14.2# ls conf contrib dist docs html logs nginx.exe temp root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker run --name nginxdemo2 -p 8889:8765 -v /home/nginxdemo/nginx-1 .14.2/conf/myconf1.conf:/etc/nginx/nginx.conf:ro -d nginx 6bed1ace8c9942f62e61ea18f7f632973fa1d7536ac3a6d1ada11e3d2c093b6e root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker cp /home/nginxdemo/nginx-1.14.2/dist 6bed1ace8c9942f62e:/etc/nginx root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker exec -it 6bed1ace8c9942f62e61ea18f7f632973fa1d7536ac3a6d1ada11e3d2c093b6e /bin/bash ls ls root@6bed1ace8c99:/# ls bin docker-entrypoint.d home media proc sbin tmp boot docker-entrypoint.sh lib mnt root srv usr dev etc lib64 opt run sys var root@6bed1ace8c99:/# cd /etc root@6bed1ace8c99:/etc# cd nginx root@6bed1ace8c99:/etc/nginx# ls conf.d dist fastcgi_params mime.types modules nginx.conf scgi_params uwsgi_params root@6bed1ace8c99:/etc/nginx# cat nginx.conf #user nobody; c553c6ba5f13: Pushed #error_log logs/error.log; #error_log logs/error.log notice; Head https://registry-1.docker.io/v2/yourtreedad/nginxcontaindist/blobs/sha256:4d7903a7ce4bdf92461e0dd87d1fb712facb6881df3cbce68f55f4ec54791546: dial tcp: lookup registry-1.docker.io on 192.168.65.5:53: no such host root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; # \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; # \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; #access_log logs/access.log main; # server { # listen 8765; # listen localhost; # location / { # root dist; # index index.html index.htm; # } # } sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 8765; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root dist; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} 67f2e8eb8c87: Pushing [\u0026gt; ] 77.82kB/4.758MB # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } root@6bed1ace8c99:/etc/nginx# exit exit root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker commit -a=\u0026#34;yourtreedad\u0026#34; -m=\u0026#34;jien\u0026#39;s ui add ljs\u0026#39;s deploy new nginx that contains dist\u0026#34; 6bed1ace8c nginx:1.0 sha256:4d7903a7ce4bdf92461e0dd87d1fb712facb6881df3cbce68f55f4ec54791546 root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker push yourtreedad/nginx:1.0 The push refers to repository [docker.io/yourtreedad/nginx] An image does not exist locally with the tag: yourtreedad/nginx root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker tag nginx:1.0 yourtreedad/nginxcontaindist:1.0 root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker push yourtreedad/nginxcontaindist:1.0 The push refers to repository [docker.io/yourtreedad/nginxcontaindist] 67f2e8eb8c87: Preparing 9d1af766c818: Preparing d97733c0a3b6: Preparing c553c6ba5f13: Preparing 48b4a40de359: Preparing ace9ed9bcfaf: Waiting 764055ebc9a7: Waiting 这是部署在本地 ， 现在开始演示部署到云服务器上\n\rimage-20210718003213326\r\n通过ssh把配置文件传进去\n\rimage-20210718003244110\r\n从dockerhub上拉取镜像\n\rimage-20210718003546820\r\n\rimage-20210718003653954\r\nhttp://47.106.218.61:8888/\n","date":"2021-07-26T00:23:34+08:00","permalink":"https://linjianshu.github.io/p/docker-learning/","title":"Docker Learning"},{"content":"Git学习文档 学习git之前，我们需要先明白一个概念，版本控制！\n版本控制  什么是版本控制 版本迭代 版本管理器\n 版本控制（revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份一遍恢复以前的版本的软件工程技术。\n 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误  简单说就是用于管理多人协同开发项目的技术。\n没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将引入很多问题，如关键代码的冗余，软件过程的事物性，软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。\n多人开发就必须要使用版本控制，否则代价比较大\n 常见的版本控制工具\n 主流的版本控制器有如下这些：\n Git SVN(subversion) CVS(concurrent versions system) VSS(Microsoft Visual SourceSafe) TFS(team Foundation Server) Visual Studio Online  版本控制产品非常的多（preforce 、 rational clearcase 、 rcs 、serena dimention 、 svk 、bitkeeper、 monotone 、 bazaar 、 mercurial 、 sourcegear vault），现在影响力最大且使用最广泛的是git和svn\n 版本控制分类\n   本地版本控制\n记录文件每次的更新，可以对每个版本做一个快照，或者记录补丁文件，适合个人用，如RCS\n\rimage-20210722211743148\r\n  集中版本控制\n所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改\n\rimage-20210722211927845\r\n所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品有：SVN、CVS、VSS\n  分布版本控制 “GIT”\n  每个人都拥有全部的代码 安全隐患\n所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题，就可以恢复所有的数据，但这增加了本地存储空间的占用\n不会因为服务器损坏或者网络问题，造成不能工作的情况！\n\rimage-20210722212449100\r\n git和svn最主要区别\n svn是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所有首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要吧自己做完的推送到中央服务器。集中式版本控制是必须连网才能工作，对网络带宽要求较高。\ngit是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己的电脑上，协同的方法是这样的：比如说自己在电脑上修改了文件A，其他人也在电脑上修改了文件A，这时，你们俩之间只需要吧各自的修改推送给对方，就可以相互看到对方的修改了。git可以直接看到更新了那些代码和文件！！\nGit是目前世界上最先进的分布式版本控制系统。\n聊聊git的历史 同生活中的许多伟大事物一样，git诞生于一个极富纷争大举创新的时代。\nlinux内核开源项目有着为数众多的参与者，绝大多数的linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上1991-2002年，到了2002年，整个项目组开始启用一个专有的分布式版本控制系统bitkeeper来管理和维护代码。\n到了2005年，开发bitkeeper的商业公司通linux内核开源社区的合作关系结束，她们收回了linux内核社区免费使用bitkeeper的权力。这就迫使linux开源社区（特别是linux的缔造者linux torvalds）基于使用bitkeeper时的经验教训，开发出了自己的版本系统。也就是后来的git！\ngit是目前世界上最先进的分布式版本控制系统。\ngit开源、免费，最初git是为了辅助linux内核开发的，来替代bitkeeper。\ngit环境配置  软件下载\n 打开git，下载对应操作系统的版本\n所有东西下载慢的话就去找镜像！\n官网下载太慢，我们可以使用淘宝镜像下载\n卸载\n直接反安装、然后清理环境变量\n安装，无脑安装\ngit bash ： unix与linux风格的命令行，使用最多，推荐最多\ngit cmd ： windows风格的命令行\ngit gui ： 图形界面的git ， 不建议初学者使用，尽量先熟悉常用命令\n 基本的linux命令学习\n  cd： 改变目录 cd .. 回退到上一个目录，直接cd进默认目录 pwd 显示当前所在的目录路径 ls （ll） 列出当前目录中的所有文件，只不过ll列出的内容更为详细 touch 新建一个文件 rm 删除一个文件 mkdir 新建一个目录 ， 就是新建一个文件夹 rm - r 删除一个文件夹 rm-r src 就是删除src目录 mv 移动文件 reset 重新初始化终端、清屏 clear清屏 history查看命令历史 help帮助 exit 退出 #'' 表示注释  平时一定要多使用这些命令\n git配置\n 所有的配置文件，其实都保存在本地！\n查看配置 git config -l\n\rimage-20210722223828219\r\n用户名是必须要有的\ngit相关的配置文件\n git\\etc\\gitconfig: git 安装目录下的gitconfig \u0026ndash;system系统级 users\\administrator.gitconfig 只适用于当前登陆用户的配置 \u0026ndash;global全局 这里可以直接编辑配置文件，通过命令设置后会响应到这里   设置用户名与邮箱（用户标识、必要）\n git config \u0026ndash;global user.name \u0026ldquo;linjianshu\u0026rdquo;\ngit config \u0026ndash;global user.email 1018814650@qq.com\nGit基本理论（核心）  工作区域\n git本地有三个工作区域：工作目录（working directory）、暂存区（stage/index）、资源库（repository或Git Directory）。如果在加上远程的git仓库（Remote Directory）就可以分为四个工作区域。文件在这四个区域质检的转换关系如下：\n\rimage-20210722235632313\r\n workspace：工作区，就是你平时存放项目代码的地方 stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 history：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交的所有版本的数据。其中HEAD指向最新放入的版本 remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换本地的三个区域确切的说应该是git中HEAD指向的版本  master 主分支\n\rimage-20210723000244325\r\n directory ： 使用git管理的一个目录，也就是一个仓库，包含我们的工作空间和git的管理空间。 workspace：需要通过git进行版本控制的目录和文件，这些目录和文件组成了工作空间 .git： 存放git管理信息的目录，初始化仓库的时候自动创建 index/stage： 暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 local repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支(branch) Stash：隐藏，是一个工作状态保存栈，用于保存/恢复 WorkSpace中的临时状态。   工作流程\n git的工作流程一般是这样的:\n 在工作目录中添加、修改文件； 将需要进行版本管理的文件放入暂存区域； 将暂存区域的文件提交到git仓库  因此，git管理的文件有三种状态：已修改(modified) , 已暂存(staged) , 已提交(committed)\n\rimage-20210723000906476\r\ngit add .\ngit commit\ngit push\ngit项目搭建  创建工作目录与常用指令\n 工作目录（workspace）一般就是你希望git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。\n日常使用只要记住下图6个命令：\n\rimage-20210723232353522\r\n 本地仓库搭建\n 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库\n1.创建全新的仓库，需要用git管理的项目的根目录执行：\n# 在当前目录新建一个git代码库 $ git init 2.执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。\n 克隆远程仓库\n 1.另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！\n# 克隆一个项目和它的整个代码历史（版本信息） git clone [url] 2.去gitee或者github上克隆一个试试看\n\rimage-20210724000439421\r\ngit文件操作  文件4种状态\n 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者提交的文件没提交上。\n untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制，通过 git add 状态变为staged unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果它被修改，而变为modified ， 如果使用 git rm 移出版本库，则成为untracked文件 modified：文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处，通过git add 可进入暂存stagged状态，使用git checkout 则丢弃修改过，返回到unmodifiy状态，这个git checkout即从库中取出文件，覆盖当前修改！ staged：暂存状态， 执行git commit，则将修改同步到数据库中，这时库中的文件和本地文件又变为一致，文件为unmodify状态，执行git reset HEAD filename取消暂存，文件状态为modified  \rimage-20210724001457370\r\n\rimage-20210724001837514\r\n 查看文件状态\n 上面说文件有四种状态，通过如下命令可以查看到文件的状态：\n# 查看指定文件状态 git status [filename] # 查看所有文件状态 git status # git add . 添加所有文件到暂存区 # git commit -m 提交暂存区中的内容到本地仓库 -m 提交信息  忽略文件\n 有些时候我们不想吧某些文件纳入进版本控制中，比如数据库文件，临时文件，设计文件等\n在主目录下建立.gitignore文件 ， 此文件有如下规则：\n1.忽略文件中的空行或以#号开始的行将会被忽略\n2.可以使用linux通配符。例如星号*代表任意多个字符，问号？代表一个字符，方括号[abc]代表可选字符范围，大括号({string1},{string2})代表可选的字符串等\n3.如果名称的最前面有一个感叹号！，表示例外规则，将不被忽略\n4.如果名称的最前面是一个路径分隔符/，表示要忽略的此文件在此目录下，而子目录中的文件不忽略。\n5.如果名称的最后面是一个路径分隔符/，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）\n# 为注释 *.txt #忽略所有 .txt 结尾的文件，这样的话上传就不会被选中 !llib.txt #但lib.txt除外 /temp #仅忽略项目根目录下的todo文件，不包括其他目录temp build/ #仅忽略build/目录下的所有文件 doc/*.txt #会忽略 doc/notes.txt 但不包括doc/server/arch.txt 使用码云  github是有墙的，比较慢，在国内的话，我们一般使用gitee，公司中有时候会搭建自己的gitlab服务器\n 1.注册登陆码云，完善个人信息\n这个其实可以作为大家未来找工作的\n2.设置本机绑定ssh公钥，实现免密码登陆！（免密码登陆，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！）\n# 进入C:\\Users\\Sweetie\\.ssh 目录 # 生成公钥 ssh-keygen \rimage-20210724202958752\r\n使用ssh-keygen -t rsa 命令\n3.将公钥信息public key 添加到码云账户中即可！\n\rimage-20210724203418738\r\n4.使用码云创建一个而自己的仓库\n新建仓库\rimage-20210724203745902\r\n许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，\u0026hellip;限制！\n也就是在git上图形化界面上建立仓库，在本地通过git bash 克隆远程仓库\n\rimage-20210724203950054\r\nIEDA中集成git   新建项目，绑定git\n 将我们远程的git文件目录拷贝到项目中即可！  \rimage-20210724204839883\r\n\rimage-20210724204938532\r\n  修改文件，使用IDEA操作git\n一种方式\rimage-20210724205441507\r\n第二种方式\n\rimage-20210724205923872\r\n第三种方式 对于单个文件的add\n\rimage-20210724210043644\r\n  提交测试\n  \rimage-20210724210212802\r\ncommit只是添加到本地仓库\npush到远程仓库\ngit push 通过terminal或者可视化来搞\n在log中可以看到每次的操作\n\rimage-20210724211848407\r\n说明：git分支 分支在git中相对较难，分支就是科幻电影里的平行宇宙，如果两个平行宇宙互不干扰，哪对现在的你也没有影响。不过在某个时间点，两个平行宇宙合并了，我们就需要处理一下问题了\n\rimage-20210724212223989\r\n\rimage-20210724212233880\r\ngit分支中常用指令：\n# 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 git merge [branch] # 删除分支 git branch -d [branch-name] # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] \rimage-20210724212621289\r\n新建分支 git branch dev 但是停留在当前分支\n\rimage-20210724212732716\r\n多个分支如果并行执行，就会导致我们代码不冲突，也就是同时存在多个版本！\n如果同一个文件在合并分支时被修改了，则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！\nmaster主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完成后，比如上要发布，或者说dev分支代码稳定后可以合并到朱分支master上来。\n因此可以这样，在dev上做改动，改动完在dev上进行commit和push，这样dev就是相当于一个新的版本\n","date":"2021-07-24T16:18:59+08:00","permalink":"https://linjianshu.github.io/p/git%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"git学习文档"},{"content":"Linux学习 如果是阿里云记得配置安全组!!!\ncss js 静态文件都在wwwroot中,所以如果后台启动或者使用mvcTest.dll 的话会无法找到静态文件 因为静态文件的层级在她们上面一层 , 所以要cp一份wwwroot到存放dll那一层中 , 这样就可以看到样式了!!!\nwindows倾向于GUI操作，windows下的命令到了linux下不一定能用\nwindows有扩展名，linux中可以没有扩展名\nwindows不区分大小写，linux区分大小写\nlinux不同版本使用方法配置文件变化很大，要反复查找和调试\nlinux内核和发行版\nlinux内核是由linus及开源社区维护，内核包含内存管理、存储管理、进程管理、网络通讯等基础模块。很多公司、开元组织基于linux内核打包出很多发行版，不同的发行版的内核版本可能不一致，包含的软件也不一致，界面差别较大，但是命令行操作时互通的，大部分程序也是互通的。\n内核和发行版的关系就像android内核和小米手机系统、华为手机系统的关系一样。常用的发行版有redhat、centos、debian、ubuntu等等。这里我们用ubuntu，因为其内置的软件最适合程序员，其他发行版要自己装。\nlinux常见命令\nwindows有多根目录\nlinux是单根\n常用目录\nboot 存放用于系统引导时的各种文件\nbin 存放二进制可执行文件 例如ls，cat，mkdir等等\nsbin 存放二进制可执行文件，只有root用户才能访问\nusr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录\nopt 额外安装的可选应用程序包所放置的位置\ndev用于存放设备文件\netc存放系统配置文件\nhome存放所有用户文件的根目录\nlib存放跟文件系统中的程序运行所需要的共享库及内核模块\ntmp 用于存放各种临时文件\nvar 用于存放运行时需要改变数据的文件\nmnt 安装临时文件系统的安装点\n常见命令\npwd 显示当前工作目录 print working directory\nls 目录\ncd 更改目录 cd .. 返回上级目录 cd / 返回根目录 cd 文件夹 进入文件夹\nmkdir 创建目录\nrmdir 目录名 删除非空目录\nrm-r 目录名 删除目录及其下目录与文件（递归删除）\nmv 移动目录 mv test home/test\ncp 复制文件 cp test test1\ncat 查看文件内容\nmore 分页显示文件内容\nfind -name ‘lib*’ 查找文件\nps 查看当前用于运行进程\nps -ef 所有进程\nreboot 重启\nshutdown-now 立即关机\nexit 退出终端\nclear 清屏\nctrl+L清屏\n上下键可以查看历史命令\nctrl+C不要当前输入的指令了\n使用tab可能可以自动补齐\ntar 压缩文件\ntar -c -f name.tar t1 将t1压缩为name.tar的压缩包\ntar -x -C 解压到指定目录 -f 压缩包\nman命令 命令帮助手册\n-r \u0026ndash;recursive 是一样的\nlinux管道指令，链式调用呗\n与图形化界面相比，命令就可以粘合在一起\n例如 ps-ef |more 先查看所有进程，然后分页显示\ngrep 查找\nsudo：基于安全考虑，一般不建议超级用户权限登陆linux，而是平时使用低权限用户访问，需要高权限的操作再用sudo后跟着指令。比如在/下无法创建文件夹，但是sudo mkdir a就可以，当然需要输入密码。su就是super user 的简写，sudo就是用超级用户权限执行命令\nVI编辑器\nesc + w + q\n上下移动的话首先要按esc 然后才能上下移动\nvim是vi的加强版\ni键 插入模式 x就是x ，d就是d ， 上下左右对应着ABCD的字符呢\n按esc 命令模式 按h删掉一个字符，按dd删除一行，按上下左右就控制光标移动\n末行模式 按： 进入末行模式 w写 q退出\n\rimage-20210626201259638\r\n在末行模式中输入！指令 可以不离开vi执行指令\nshift+^ 移动到行首\nshift+$ 移动到行尾\n正则表达式 ， 匹配行首就是^ 匹配行尾就是$\nctrl + b 滚屏 ctrl + f 向下滚屏\nu就是撤销 undo\no就是在当前行下新增一行，并且自动进入插入模式\ni和a都是插入模式，就是在前面在后面插入的区别而已\na就是append i就是insert\nnano就是简化版的傻瓜式的文本编辑器\n嘻嘻嘻\nlinux下很多软件都是自己下载源码、自己编译的，有点痛苦。很多发行版都有自己的安装包格式。比如redhat使用*.rpm文件，ubuntu中使用 *.deb文件。\n自己查找、下载安装还是很麻烦的。因此很多发行版中都提供了类似于应用市场、nuget的东西。\nubuntu推荐使用apt进行下载、安装。会从ubuntu官网下载，如果下载速度慢的话，可以设置从其他镜像下载，具体搜索ubuntu atp-get 镜像\n执行某些程序的时候，如果程序没有安装还会提示你，比如执行 vim tree等等\n安装软件需要sudo执行。如：\n1.安装 sudo apt-get install 程序名\n2.卸载 sudo apt-get remove 程序名\n使用ifconfig\n网络问题\n虚拟机和主机之间组件了一个局域网，虚拟机通过主机上网。虚拟机的设置的网络可以设置不同的链接方式。主机可以通过ifconfig看到ip地址连接虚拟机的网络。\n虚拟机的网络连接方式有很多种，最主要的有三种：hostonly、nat、桥接（bridge）。hostonly配置较麻烦，需要懂很多网络工程的东西；NAT是虚拟机借助于主机网卡访问网络，藏在主机后面，网络中其他设备不能连这个虚拟机，连主机都不能，但是虚拟机能连接主机的网络，能上外网；桥接模式则是把虚主机也暴露为网络中的一个设备，主机和虚拟主机在网络内是平等的，可以互相访问，但是要求网络中没有设备访问的限制，如果有限制要修改路由器的配置。因为咱们需要主机和虚拟机相互访问，除非网络有限制，否则最好配置为桥接，配置桥接要选择通过哪个网卡上外网，不能选错了，否则就无法访问外网了。后面我们都配置为桥接（bridge）。\nssh服务\n讲运维人员是怎么远程连接到机房上的服务器的，很少使用图形界面（卡，无法自动化）\n远程登陆有专门的通信协议telnet，telnet就是通过网络进行命令行操作服务器。只有服务器端开始了远程登陆服务，客户端才能通过telnet协议控制服务器端。\n但telnet协议是使用明文传输数据，这会造成严重的安全性问题，所以现在几乎不推荐使用，而是替代协议的是ssh，ssh通讯数据是加密的。\n安装openssh\nubuntu 默认只安装了客户端 openssh-client\n安装服务器\nsudo apt-get install openssh-server\nssh服务默认端口是22，可通过修改配置文件修改端口/etc/ssh/sshd_config\n重启的话就是service ssh restart\nputty下载后直接远程连接linux\n使用mysql\n安装sudo apt-get install mysql-server\n根据提示设置root 用户的密码，测试的时候设置为root\nsudo apt-get install mysql-client 安装管理客户端\nmysql-uroot-proot 通过管理客户端连接mysql 不报错就ok\nmysql 客户端中执行（不要直接在shell中直接执行）show databases; (不要丢了结尾的英文分号) 查看有那些数据库，执行一下 select now(); 正确执行。执行quit； 退出mysql 客户端\nps ： 记得打开服务\nservice mysql start\n\rimage-20210626211935982\r\n基于安全考虑，mysql默认只能本机连接，如果想通过其他电脑连接（比如主机访问虚拟机中的mysql），就需要配置，最好不要配置成任意电脑都可以连接，因为危险，要配置成只允许某些ip访问\n配置mysql远程访问（需要网络配置为桥接网络）虚拟机情况的话\n 编辑mysql的配置文件mysqld.cnf ， 由于mysql是系统服务，因此需要以su 运行vi , 才有权限，执行sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf ， 由于不同mysql版本配置文件的位置可能不一样，因此最好的找路径的方式就是cd / dir 一级级的看看。linux下不同版本差异性很大，之前查资料都是改/etc/mysql/conf.d/mysql.cnf ，但是使用status；命令查询mysql版本之后搜索mysql5.7 远程访问，就可以找到正确的做法\rimage-20210626212914858\r 把bind-address=127.0.0.1注释掉 执行 sudo /etc/init.d/mysql restart 重启 mysql服务 在主机上执行ipconfig，查看ip地址，加入是192.168.0.11，那么就执行grant all privileges on *** . *** to root@\u0026ldquo;192.168.0.11\u0026rdquo; identified by \u0026ldquo;这里换成密码\u0026rdquo; with grant option; 再执行 flush privileges; 外部数据库管理工具navicat连接虚拟机的ip，访问mysql 主机上连接虚拟机内的mysql一定要连接虚拟机的ip，别连错了 主机的ip如果变了就要重新配置  在4之前，由于这个版本的mysql密码是空的，所以没办法呜呜呜，需要改个密码\n\rimage-20210626220925687\r\nMySQL 8.0 安装后修改root@localhost的默认空密码 - 汉家羽林郎 - 博客园 (cnblogs.com)\n\rimage-20210626220955199\r\n解决mysql8 提示 ERROR 1410 (42000): You are not allowed to create a user with GRANT_zhouzhiwengang的专栏-CSDN博客\n命令有点点不一样\nmysql8.0之后必须要先创建用户，然后才能授权\n\rimage-20210626232148904\r\n安装vsftp服务器\nfile transport protol\n 什么是ftp 。通过ftp进行文件的上传下载 sudo apt-get install vsftpd 这时候可以用linux用户登陆，能够访问/home/用户名下的文件夹。但是没有上传权限。需要 sudo vi /etc/vsftpd.conf 将write_enable=YES 前面的注释# 取消，然后执行 sudo /etc/init.d/vsftpd restart重启 对于文件数量比较多的，可以先压缩成zip，然后在linux端使用 unzip 文件名 进行解压 对于文件缩量比较多的，可以在linux端使用zip命令压缩，然后再windows端解压  .net core\n历史\n.net 设计之处就是考虑像java一样跨平台的，.net framework 是在windows下运行的，大部分类是可以兼容移植到linux下的，但是没人做这个工作。后来novell公司开发了mono，把大部分.net framework功能移植到了linux下。mono也成为xamarin（使用.net 开发Android、IOS app的技术）和unity3d （使用.Net 开发android /ios 游戏的技术）的基础。\n.net core是微软开发的另一个可以跨linux、windows、mac等平台的.net 。\n微软收购了mono的公司，xamarin。为什么还要搞.net core。因为mono完全兼容.net framework ,架构太陈旧，不利于现在云计算、集群等新的架构历年。因此微软推翻重写了.net core。\n.net framework .net core mono的关系\n.net framework .net core xamarin 有通用的类，也有特有的。为了保证代码通用。微软定义了公共的.net standard library (.net 标准库，像FileStream / List等这些)，按照.net standard library编写的代码可以在几个平台下通用。\n大部分.net framework中的类在.net core中还有，方法也还有，只是namespace可能变了，有些方法也有不一样，部分api缺失（注册表等windows平台特有的api），后面会讲区别。\n之前那些在.net framework 中调用的dll，不一定都能用在.net core (linux)中。如何判断\n在linux下需要安装.net core 的环境\n例如.net core sdk 和 .net core runtimes\nhttps://docs.microsoft.com/zh-cn/dotnet/core/install/linux-ubuntu\n安装完验证一下\n使用linux 来创建.net core 控制台应用程序并运行\n  创建控制台项目\n dotnet new console -o test1 在当前目录创建目录 test1 , 并且初始化控制台（console）类型的项目结构（第一次运行dotnet new 比较慢）。使用命令创建项目，是目前很流行的风格。 也可以手动创建test1目录，进入目录，再执行dotnet new console。也就相当于在当前目录下创建控制台项目。 dotnet restore 通过nuget还原安装当前目录的项目用到的包，一定要cd 到项目根目录下执行. restore执行消息里给出了nuget下载目录的路径 改一下项目的代码 dotnet run 编译并运行当前目录的项目,一定要在项目根目录下执行.如果编译报错就会根据报错信息该代码或者是忘了dotnet restore了。 注意.net core 下的控制台程序不是生成exe的,要通过dotnet 入口dll文件名 方式运行 三个步骤:new restore run  \rimage-20210627111809617\r\n\rimage-20210627112544733\r\n也可以执行debug里的dll文件，linux没有exe哈，执行dll就可以了\n\rimage-20210627113402515\r\n  aps .net mvc core 项目\n  dotnet new mvc -o test2 或者 dotnet new mvc\n  dotnet restore\n  改一下项目的代码\n  dotnet run web项目自带嵌入式服务器，测试阶段不用IIS等单独的服务器，部署阶段再部署到iis、nginx等上\n  再linux的服务器上的浏览器中打开http：//127.0.0.1:5000 (只能本机访问，后面讲通过nginx配置远程访问)\n  ctrl+c 停止服务器\n  修改默认端口绑定的方法：再program.cs的build之前加入useurls(\u0026ldquo;http://*.5001\u0026rdquo;);\n\rimage-20210627121128266\r\n新版有点区别\n\rimage-20210627121508698\r\nhttps://blog.csdn.net/zxy13826134783/article/details/105908201/\n\rimage-20210627121540245\r\nECS做到了呜呜呜\n\rimage-20210627122036170\r\n插入个知识点，这里我们退出终端后外网就访问不了了，因此需要程序后台运行\nhttps://www.cnblogs.com/bjxxlbm/articles/14790054.html\nnohup dotnet mvctest.dll \u0026amp;\nps -ef |grep dotnet 查看dotnet项目\nkill -9 PID（进程id就行了）\n\rimage-20210627154748097\r\n  wwwroot底下放的是静态文件\n  \rimage-20210627114214395\r\n  创建其他项目\n.net core目前只支持控制台和aps .net mvc core 不知道winform和webform\n可以创建类库、webapi、解决方案\n新建类库\ndotnet new classlib -o classlibtest\n新建webapi\ndotnet new webapi -o webapitest\n新建解决方案（一个解决方案中包括多个项目）\ndotnet new sln\n还有dotnet new \u0026ndash;help\n历史问题\n旧版本.net core 曾经使用project.json做项目描述文件，后来又改回了project.csproj\n.net core开发的两种方式\n用vi编辑代码没有自动提示，开发麻烦，所以只是进行原理展示。不会真的用vi写代码\n方式1：windows下用vs开发，然后部署到linux下部署运行\n方式2：linux下使用vscode开发，然后linux下部署运行。vscode还是没有vs强大\nwindows下可以直接使用命令行来建立项目，就像linux下操作的一样\n\rimage-20210627162043186\r\n发布dotnet publish\n\rimage-20210627162548407\r\n找到publish，并压缩成zip格式\n然后通过filezilla 传输到linux上\nlinux通过 unzip 名字 解压缩\n然后dotnet dll文件 就可以运行起来了呜呜呜\n问题：给wsl windows sub子系统 linux\n我们的linux发行版 ubuntu 是wsl\n需要给他安装一个图形化界面\nWSL2 Ubuntu GUI 图形用户界面_哔哩哔哩_bilibili\n远程桌面需要启动一下xrdp服务\n\rimage-20210627195747795\r\n使用命令行添加解决方案和引用关系\n 如何创建多个项目的解决方案  先创建解决方案文件夹rupengbbs,然后再其中dotnet new sln dotnet new mvc-o rupengbbs.web 说明：创建web项目 dotnet new classlib -o rupengbbs.common 创建common项目 dotnet new sln 说明：解决方案，解决方案名字默认是当前目录的名字 dotnet sln rupengbbs.sln add rupengbbs.common / rupengbbs.common.csproj 说明L吧rupengbbs.common项目中的rupengbbs.common.csproj添加到解决方案文件中。注意最后一个参数在/ 前后不要加空格 这里指的是rupengbbs.common目录下的rupengbbs.common.csproj文件 dotnet sln rupengbbs.sln add rupengbbs.web/rupengbbs.web.csproj 说明：把web项目添加到解决方案中 dotnet add rupengbbs.web/rupengbbs.web.csproj reference rupengbbs.common/rupengbbs.common.csproj 说明：rupengbbs.web.csproj 项目添加对rupengbbs.common.csproj项目的引用 dotnet restore 说明：在解决方案下每个项目中执行dotnet restore 如果是在某个项目下执行 dotnet restore 则只是restore 某个项目   查看一下csproj 和sln文件格式，知道如何手动修改 vscode打开解决方案文件夹即可。在common项目中建一个person.cs，写一个hello方法，然后在web项目中调用 （*）编译整个解决方案的方法，在解决方案文件夹下dotnet build rupengbbs.sln 手动创建三层项目：web项目 、 model项目、dal项目、bll项目 写一个创建三层解决方案的脚本，体现命令行的好处，脚本中的$1$2代表第1.2个参数的值  \rimage-20210627202824466\r\n\rimage-20210627203154894\r\n对着主项目运行\n\rimage-20210627203449885\r\n如果某一些操作需要反复执行，那么就可以写成脚本。\nwindows上\n.bat 批处理命令\npowershell\nlinux上\nshell脚本\n写好sh脚本之后，执行bash ./ cjsc.sh RuPeng 会自动把项目和解决方案创建起来了\n因为命令行所有脚本，因为脚本所以自动化。windows下的脚本语言有传统的bat以及新的powershell，windows10安装linux自系统后也可以使用bash\n7.项目添加nugut引用的方法：在项目下执行dotnet add package newtonsoft.json 然后dotnet resotre 一下\ndotnet add package 就等驾驭nuget 的install-package （*）还可以通过dotnet addnew nugetconfig 创建一个nuget配置文件，指定源\ndotnet core 无法在引用里引用自己家的标准程序集，.netframework 可以，.net core统一在nuget里安装\n因此如果涉密的dll还得传到nugut上，通过nuget安装，可以考虑搭建nuget私服\n6.控制台、web应用程序部署到linux等服务器上的统一方式：服务器上先安装.net core，然后再开发环境发布，然后吧发布包上传到服务器上，然后到目录下执行，dotnet 主程序 dll 即可\n注：可以通过发布到FTP、FTPS服务器上的方式，来试试看，端口是21\n\rimage-20210630110707778\r\n但是，需要给ljs用户授予777权限，然后给srv/ftp授予777权限\n否则会出现无法发布www.root 和 config的问题\nchmod -R 777 ljs chmod -R 777 srv/ftp\n\rimage-20210630230743574\r\nhttpwebrequest、webclient不支持，必须使用异步的httpclient\n反编译工具 JustDecompiler 反编译dll文件\n.net core 中配置文件的解析\n.net coer 的配置文件，不再是配置在web.config中了，而是单独的json配置文件\n只要和合法的json格式，怎么写随意，怎么写就怎么解析\n解析方法：\n1.首先nuget安装：microsoft.extensions.configuration 和 microsoft.extensions.configutation.json\n2.然后引用命名空间\n3.下面的代码就把logging下的loglevel下的default读出来了\nvar builder = new configurationbuilder().setbasepath(directory.getcurrentdirectory()).addJsonfile(\u0026#34;appsettings.json\u0026#34;) ; //设置配置文件所在路径 var configRoot = builder.Build() ; var value = configRoot.GetSection(\u0026#34;Logging\u0026#34;).getSection(\u0026#34;loglevel\u0026#34;).getsection(\u0026#34;default\u0026#34;).value ; sys.console.writeline(value) ; \rimage-20210630235351891\r\nEFcore的使用\nEfCore 是EF的.net core版本。EF core 对 sqlserver支持很好，也可以在linux下连接sqlserver。不过如果在linux下首选mysql，因此我们主要介绍mysql 中更实用efcore。sqlserver用法几乎一样，只是换一个Ef provider的nuget包而已。\nEFcore的nuget： entityFrameworkcore\n1.官方的mysql ef provider\n2.可以试试第三方的 eF core provider\n3.使用mysql efcore\n​\t把mysql数据库、表创建起来\n​\tinstall-package entityframeworkcore.mysql\n​\t编写person类\n​\n通过usemysql这样的扩展方法来配置连接字符串，这是.net core的风格！可以把连接字符串写到配置文件中，然后再读取。\nEF core 和EF的区别\n要使用 AsNoTracking 、 Include 等要using microsoft.entityframeworkdcore ，不能使用 System.Data.Entity\n目前还不支持lazyload，需要显式的include\n没有内置entitytypeconfiguration（要么手动注册config类，复习一下；要么后续课程会给大家提供一个）\n一对多关系配置从builder.hasrequired(e=\u0026gt;e.author).withmany() ; 改成了：builder.hasone(e=\u0026gt;e.author).withmany().hasforeignkey(e=\u0026gt;e.authorid).isrequired();\n或者builder.hasoptionnal(e=\u0026gt;e.author).withMyan();改成：builder.HasOne(e=\u0026gt;e.author).withmany().hasforeignkey(e=\u0026gt;e.antuorid) ;\n不要中间实体的多对多还不支持，要自己拆成用中间实体的两对一对多\n只要吧配置文件放到ui项目中即可，不再需要在Ui项目中在安装EF\naps.net core mvc\nselfhost\n\rimage-20210701213916890\r\nasp.net core ioc\n1.asp.net mvc coer 内置了ioc容器，不在需要autofac等等，当然autofac 也是支持.net core 的 ， 内置ioc是通过构造函数注入，而不是属性注入。\n2.在startup 的configureservices中进行注入的准备工作\n3.在内置的ioc有三种生命周期\ntransient : transient 服务在每次被请求的时候都会被创建。这种生命周期比较适用于轻量级的无状态服务。\nscoped：scoped生命周期的服务是每次web请求被创建\nsingleton：singleton生命周期服务在第一次被请求时创建，在后续的每个请求都会使用同一个实例。如果你的应用需要单例服务，推荐的做法是交给服务容器来负责单例的创建和生命周期管理，而不是自己来走这些事情。\n调用方法 services.addsingleton(typeof(imyservice),new myservice())； 来进行注册\n但是最好 services.addsingleton (typeof(imyservice),typeof(myeservice)) ;\n因为这样的话可以在myservcice中通过构造函数注入其他服务\n\rimage-20210701215502596\r\n\rimage-20210701215509943\r\n\rimage-20210701215618664\r\n4.controller注入\n这里引入一个问题，之前publish的都不行，原因是为什么呢！！！\n就恨他吗离谱 ， 注意运行时 ，不能选择可移植\n\rimage-20210702000338015\r\ndotnet test.dll \u0026ndash;urls http://*:5005\n手动指定端口\n单元测试\n\rimage-20210722203914320\r\n","date":"2021-06-16T00:25:03+08:00","permalink":"https://linjianshu.github.io/p/csharplinux%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"CSharpLinux环境部署学习文档"},{"content":"小程序组件\nview标签 类比p便签\ntext标签 类比span标签\nselecttable :文档是否可选\n\rimage-20210404164128223\r\ndecode标签 :选中＆ｎｂｓｐ；/lt/gt/amp.apos/ensp/emsp这样的可以识别出来\nbutton标签:\n​\ttype: primary / default / warn\n\rimage-20210404164342281\r\n​\tform-type=\u0026ldquo;submit\u0026rdquo;/reset\n​\topen-type getuserinfo/getphonenumber/contact\n\rimage-20210404164741208\r\ncheckbox \rimage-20210404165141036\r\n开闭标签,可以在开闭标签内写上复选文字内容\nvalue可以填入真实的值\ncheckboxgroup\nradio单选按钮\n开闭标签 , value可以填入真实的值 , 实现单选需要配合实现radiogroup\n\rimage-20210404165511648\r\nblock标签\n​\t标签块 , 其本身不会被渲染到页面中 , 只有内部的标签会被渲染进html页面\n\rimage-20210404170226484\r\n\rimage-20210404171030254\r\n绑定事件+编写js方法\n\rimage-20210404183815644\r\n\rimage-20210404183822112\r\ndata的数据绑定以及数据更新\n\rimage-20210404185119026\r\n\rimage-20210404190648374\r\n\rimage-20210404190705626\r\n富文本识别展示\n\rimage-20210404191510461\r\n\rimage-20210404191516120\r\n可以携带css样式结构\n\rimage-20210404191528289\r\n弹出窗体\n\rimage-20210404193546211\r\n\rimage-20210404193554023\r\n加载窗体 , 等待时间 , 图标 成功的事件\n\rimage-20210404193628433\r\n弹出确定/取消按钮\nclick事件判定\n页面跳转事件并且传参\n两种方式\n1.\rimage-20210404195554226\r\n2.\rimage-20210404195605659\r\n携带数据\n\rimage-20210404195614999\r\njs中处理\n通过webapi获取后端数据\n\rimage-20210404212911407\r\nxy+5x/2+20y/2 = (5+y)(20+x)/2\n100 + 5x + 20 y +xy = 2xy + 5x + 20y\n\rimage-20210404213731063\r\nwebapi采用的是.net 5.0 使用efcore , 所以和原来的略有不同呢 亲爱的 , 例如使用依赖诸如, appconnectionstring得写在不同的地方,在静默管道里添加sqlserver服务,并且指定特定的dbcontext,以及重构一下dbcontext的构造函数等等,此外还需要额外添加efsqlserver的nuget包\nvideo标签 以及填充样式\n\rimage-20210405105945483\r\nimage标签以及宽度修正样式\n\rimage-20210405110043711\r\n数值回传以及样式绑定\n在data里绑定静态数据\n\rimage-20210405110238337\r\n在wxml里利用wx:for来遍历data中的静态数据\n\rimage-20210405110319681\r\n通过插值判断是否页签被选中,以及页签颜色样式修正\ndata-id传值\nselectbar方法处理\n传值处都要用插值法包裹 实际上很像java的模版引擎\n\rimage-20210405110458011\r\n携带id值过来,处理data中的静态typeindex\n使用wx:if wx:else wx:for配合block来进行内容展示\n\rimage-20210405152741173\r\ndata中展示新闻的content\nview界面中使用wx：for来遍历newslist\n使用插值法取数据\n使用wx:if和else配合使用\n\rimage-20210405152813430\r\n模拟后端接收数据,onload操作\n并且存入data中\n并且在前端将data中的值取出来展示\n\rimage-20210405154550041\r\n通过wx：request方法获取，通过success回调函数来将值存入data中\n\rimage-20210405154625869\r\n接着就是前端的wxml去取数据啦\nwx:for 需要配合wx:key 使用以提高性能\n否则默认将以index为检索\n\rimage-20210405162607882\r\n\rimage-20210405162912572\r\n","date":"2021-06-01T00:27:43+08:00","permalink":"https://linjianshu.github.io/p/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"微信小程序学习文档"},{"content":"计算机组成原理学习文档 CPU\n内存\n硬盘\n主板\n计算机硬件识别数据\n高低电平0/1\n通过电信号传递数据\n金属针脚：传递电信号用的通道\n通过很多条电路，可以传递多个二进制数位，每个二进制数位称为1bit比特\n文字、数字、图像如何用二进制表示\n如何存储二进制数\nCPU如何对二进制数字进行加减乘除\n如何从内存中取出想要的数据\nCPU如何识别和执行我们写的程序\n计算机系统 = 硬件 + 软件\n硬件是计算机的实体，软件由具有各类特殊功能的程序组成\n计算机性能的好坏取决于软硬件功能的总和\n软件\n  系统软件：用来管理整个计算机系统\n 操作系统、DBMS、标准程序库、网络软件、语言处理程序、服务程序    应用软件\n 按照任务需要编制成的各种程序    硬件的发展\n第一台电子数字计算机 ENIAC1946 冯诺依曼\n逻辑元件：电子管\n第一代：电子管时代 纸带机编程\n第二代：晶体管 开始出现操作系统 开始出现高级语言\n第三代：中小规模集成电路 高级语言迅速发展 开始出现分时操作系统\n第四代：大规模、超大规模集成电路 出现微处理器、微型计算机、个人计算机PC萌芽 、 操作系统\n微处理器的发展：\n机器字长：计算机一次整数运算所能处理的二进制位数\n摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月就会增加一倍，整体性能也将提升一倍\n软件的发展：\n机器语言010101=\u0026gt;汇编语言=\u0026gt;FORTRAN/PASCAL/C++=\u0026gt;java、python\nDOC操作系统=\u0026gt;windows、android、ios\n目前的发展趋势：\n两极分化：\n1.微型计算机更微型化、网络化、高性能、多用途方向发展\n2.巨型化、超高速、并行处理、智能化方向发展\n计算机硬件的基本组成：\n1.早期冯诺依曼的结构\n2.现代计算机的结构\nENIAC手动接线来控制计算\n冯诺依曼：”存储程序“的概念是指将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。\n早期冯诺依曼机：\n数据/程序：即软件\n硬件：\n输入设备：将信息转换成机器能识别的形式\n存储器：存放数据和程序\n运算器：算术运算和逻辑运算\n控制器：指挥程序运行\n输出设备：将结果转换成人们熟悉的形式\n在计算机系统中，软件和硬件在逻辑上是等效的。\n冯诺依曼计算机的特点：\n 计算机由5大部件组成：输入设备、输出设备、存储器、运算器、控制器 指令和数据以同等地位存储于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心  输入/输出设备与存储器之间的数据传送通过运算器完成\n现代计算机的结构以存储器为中心\nCPU=运算器+控制器\n计算机组成原理中，主机的概念就是运算器+控制器（cpu）+存储器\n存储器：主存（内存）+辅存（硬盘）\n主机的存储器是内存也就是主存\n辅存是IO设备\n计算机硬件的基本组成：\n 五大部分  输入设备：将信息转换成机器能识别的形式 输出设备：将结果转换成人们熟悉的形式 主存储器：存放数据和程序 运算器：算术运算、逻辑运算 控制器：指挥各部件，使程序运行   冯诺依曼结构  首次提出存储程序概念 以运算器为中心   现代计算机结构  以存储器为中心 CPU=运算器+控制器    主存储器的基本组成：\n主存储器：\n 存储体 MAR memory address register 存储地址寄存器 MDR memory data register 存储数据寄存器  读和写\n存储器：\n 存储单元：每个存储单元存放一串二进制代码 存储字：word 存储单元中二进制代码的组合 存储字长：存储单元中二进制代码的位数 存储元：存储二进制的电子原件，通常为电容，每个存储元可存1bit  MAR位数反映存储单元的个数\nMDR位数=存储字长\nMAR4位 = 一共有2的四次方个存储单元\nMDR16位 = 每个存储单元可存放16bit 1个字word = 16bit\n混淆点\n1个字节=8bit\n1B=一个字节\n1b=1bit\n运算器的基本组成：用于实现算术运算和逻辑运算\n ACC accumulator 累加器 用于存放操作数或运算结果 MQ multiple-quotient register 乘商寄存器 ， 在乘除运算时，用于存放操作数或运算结果 ALU arithmetic and logic unit 算术逻辑单元， 通过内部复杂的电路实现算术运算、逻辑运算 X 通用的操作数寄存器， 用于存放操作数  控制器的基本组成：\n CU： control unit控制单元，分析指令，给出控制信号 IR： instruction register 指令寄存器，存放当前执行的指令 PC： program counter 程序计数器 ， 存放下一条指令地址， 有自动加1功能  完成一条指令=取指令PC + 分析指令 IR + 执行指令CU\n各硬件部件：\n 主存  MAR：内存地址寄存器，用于指明要读/写哪个存储单元。其位数反映存储单元的数量 MDR：内存数据寄存器，用于暂存要读/写的数据。其位数反映存储字长 存储体: 概念：存储元、存储单元、存储字、存储字长、地址   运算器  X 通用寄存器，存放操作数 ACC 累加计数器，存放操作数、运算结果 ALU 算术逻辑单元，用电路实现各种算术运算、逻辑运算 MQ 乘商寄存器，进行乘除法时用到   控制器  IR 指令寄存器，存放当前执行的指令 PC 程序计数器，存放下一条指令的地址 CU 控制单元，分析指令，给出控制信号   工作过程  初始：指令、数据存入主存，PC指向第一条指令 从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令    计算机系统的层次结构\n  高级语言机器 用编译程序翻译成汇编语言程序\n  汇编语言机器 用汇编程序翻译成机器语言程序\n  操作系统机器 向上提供广义指令(系统调用)\n  用机器语言的机器 执行二进制机器指令\n  微指令系统 由硬件直接执行微指令\n  三种级别的语言\n 高级语言 汇编语言 机器语言  通常高级语言得翻译成汇编语言，汇编语言翻译成机器语言才可以执行\n但有时候高级语言可以直接通过编译程序直接翻译成机器语言进行执行\n编译程序：编译、汇编、解释程序\n解释程序的语言就是解释性语言\n编译的语言就是编译性语言\n编译程序是一次全部翻译成机器语言的程序，而后再执行机器语言程序，只需要翻译一次\n解释程序是将源程序的一条语句翻译成对应于机器语言的语句并立即执行。紧接着再翻译下一句，每次执行都要翻译\n计算机的性能指标\n存储器的性能指标\nMAR位数反映存储单元的个数（对多支持多少个）\nMDR位数=存储字长=每个存储单元的大小\n总容量=存储单元个数*存储字长 bit = 存储单元个数 * 存储字长/8 byte\n2的十次方 = K\n2的二十次方=M\n2的三十次方=G\n2的四是次方=T\nCPU的性能指标\nCPU主频：CPU内部数字脉冲信号振荡的概率 = 1/CPU时钟周期\nCPI:执行一条指令所需的时钟周期\n执行一条指令的耗时：CPI * CPU 时钟周期\nCPU执行时间：整个程序的耗时\nIPS： instructions per second 每秒执行多少条指令 = 主频/平均CPI\nFLOPS:每秒执行多少次浮点运算\n系统整体的性能指标\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n吞吐量：系统在单位时间内处理请求的数量\n响应时间：用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。\n基准程序：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。\n计算机的性能指标：\n 存储器的容量  MAR的位数反映存储单元数量 MDR反映每个存储单元大小   CPU  主频 时钟频率 =1/时钟周期 单位:HZ 时钟周期 CPU中的最小单位，每个动作至少要一个时钟周期 CPU执行时间  运行一个程序所花费的时间 指令条数 * CPI /主频   CPI 执行一条指令所需的时钟周期数 IPS 每秒执行多少条指令 =主频/平均CPI FLOPS：每秒执行多少浮点运算   其他  数据通路宽度、吞吐量、响应时间、基准程序   常用数量单位  描述存储容量、文件大小时：K=2^10 M=2^20 G=2^30 t=2^40 描述频率、速率时：K=10^3 M=10^6 G=10^9 T=10^12    进位计数制\n 十进制、二进制、八进制、十六进制 其他进制=\u0026gt;十进制 二进制、八进制、十六进制之间的相互转换 十进制=\u0026gt;其他进制 真值和机器数  基数：每个数码位所用到的不同符号的个数，r进制的基数为r\n二进制：0,1\n八进制：01234567\n十进制：0123456789\n十六进制：0123456789ABCDEF\n二进制优势：\n 可以使用两个稳定状态的物理器件表示 01正好对应逻辑值的假真。方便实现逻辑运算 可以很方便地使用逻辑门电路实现算术运算  任意进制=\u0026gt;十进制\n二进制=\u0026gt;八进制、十六进制\n二进制基数为2\n八进制基数为8\n为了保证对应，应该将二进制的3位作为一组，每组转换位对应的八进制符号\n八进制=\u0026gt;二进制\n八进制基数为8\n二进制基数为2\n为了保证对应，应该将八进制的每位都用二进制的三位来代替，每3为转换位对应的二进制符号\n二进制表示 10101010B\n十六进制 349820347H 0x2234623876\n十进制 2134234D\n十进制=\u0026gt;二进制 使用 （整数部分）除基取余法+（小数部分）乘基取整法\n真值：符合人类习惯的数字\n机器数：数字实际存到机器里的形式，正负号需要被数字化\nBCD码：Binary-Coded Decimal ,用二进制编码的十进制\n 8421码 余三法 2421码  原理：用4个二进制来表示一个十进制 ， 虽然这样会造成6种冗余，因为2的四次方=16 即能表示从0-15 ， 十进制表示从0-9 ， 所以会造成6个冗余\n8421码对应关系：\nX X X X\n8 4 2 1\n所以如果想表示985 ， 8421码应该这么写 1001 1000 0101 嘻嘻嘻！\n十进制的加法 8+5\n8421码加法 8+5 = 1000 + 0101 = 1101 但是这个落在1010~10010中，也就是8421码不允许或者说没有定义的范围内，为了让他有意义，需要+6，让它进一位，也即1101+0110 = 11011 = 0001 0011 也就是1 3\n余3码：8421码+（0011）B\n2421码：改变权值定义\nX X X X\n2 4 2 1\n如果想表示985 ， 则 1111 1110 1011\n规则：0-4 第一位不能为1 ； 5-9 第一位必须为1\nBCD码\n 8421码  每4个二进制位对应一个十进制位（有6个冗余状态） 8、4、2、1分别对应每一位的权值 0000-1011 分别对应 0-9 ，进行加法后若超出该范围，则需要+0110B进行修正（强制向高位进1）   余3码  8421码 + 0011   2421码  2、4、2、1分别对应每一位的权值 表示0~4时最高位为0 ， 表示5~9时最高位为1    字符与字符串\n英文表示\nASCII码\n128位字符 用7位来表示就好 ，但1B=8bit 通常就用1B来表示一个字符\n可印刷字符：32-126 ， 其余为控制、通信字符\n97=01100001B\n122=01110110B\n汉字表示\n为了方便区分 ， 将1980版国标列出了常用的7000多个汉字，对应的是一个93 * 93 的矩阵，用矩阵的行和列来表示，即区码+位码\n区位码：94个区，每区94个位置\n但是前文提到ASCII码的0-32是用于控制和通信，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+20H （20H就是十六进制的20 ， 也就是32） 加上32之后就避开了通信和控制区域 ， 但是ASCII码32-125是可印刷字符，为了防止汉字的编码和英文的编码产生冲突，我们需要在原有的基础上+80H（80H就是十六进制的128）这样就可以越开ASCII码产生的冲突，因为ASCII码是1B，并且1B是以0xxx xxxx 表示的，高位不是1，但汉字的区位码，分为区码和位码，加上20H和80H之后，高位必然是1，如果高位是1，就代表他是汉字不是英文字符，所以要读两个B，也就是2B，所以为什么英文符号是1个字节而中文符号是2个字节了。\n汉字的输入：输入编码 例如nei2\n汉字的输出：汉字字形码\n字符串:某计算机按字节编址，编址即每个地址对应1B，从地址为2的单元开始，存储字符串为“abc\u0026quot;,那么，2-5的地址分别存，61H 62H 63H 00H（\\0） 最后一行使用'\\0\u0026rsquo;作为字符串结尾标识\n当存放”abc啊“的时候，因为汉字需要占用2B，所以2-6的地址分别存， 61H 62H 63H B0H A1H 00H 或者 61H 62H 63H A1H B0H 00H ，\n大端模式：将数据的最高有效字节存放在低地址单元中\n小端模式：将数据的最高有效字节存放在高地址当中\n字符与字符串\n ASCII码  通常用8bit表示一个字符，最高位都为0 共128个字符。0-31为控制/通信字符；32-126为可印刷字符 所有大写字母、所有小写字母、所有数字的编码都连续   汉字  区位码、国标码、汉字内码、输入编码、字形码 国标码=区位码+2020H 机内码=国标码+8080H   字符串  从低地址到高地址逐个字符存储，常采用'\\0\u0026rsquo;作为结尾标志 对于多字节的数据（如汉字），可采取大/小端存储模式 大端模式：将数据的最高有效字节存放在低地址单元中 小端模式：将数据的最高有效字节存放在高地址单元中    奇偶校验码\n奇偶校验\n 校验原理 奇偶校验  由若干位代码组成的一个字叫码字\n将两个码字逐位进行对比，具有不同的位的个数成为两个码字间的距离\n一种编码方案可能有若干个合法码字，各合法码字间的最小距离成为码距\n当码距=1时，无检错能力 ； 当码距=2时，有检错能力 ； 当码距\u0026gt;=3时，若设计合理，可能具有检错纠错能力\n奇校验码：整个校验码（有效信息位和校验位）中1的个数为奇数\n偶校验码：整个校验码（有效信息位和校验位）中1的个数为偶数\n奇偶校验中，如果偶数个位发生位错误，也就是位跳变的话是检测不出错误的\n如何求校验位：\n求偶校验位：对有效信息位进行异或运算，算的结果就是偶校验位的值\n如何进行校验：对偶校验来说，如果进行的是异或运算得到的结果是1就说明出错了\n海明校验码\n设计思路：将信息位分组进行偶校验=\u0026gt;多个校验位=\u0026gt;多个校验位标注出错位置\n多个校验位能够携带多种状态信息（对/错，错在哪里）\n1.确定海明码的位数：2^k \u0026gt;=n+k+1\nk代表多少位校验码\nn代表有效信息位\n2.确定校验位应该放在哪个位置\n将校验位放在海明位号为2^i-1次方的位置上\n3.确定校验位将和那几个有效位组成一组\n假设信息位：1010\n将一共有多少位从高到低排列，如H7 H6 H5 H4 H3 H2 H1\n将7654321转成二进制的数表示\n即0111 0110 0101 0100 0011 0010 0001\n找出有效位，也就是7653，也就是\nH7: 0111\nH6: 0110\nH5: 0101\nH3: 0011\n从尾巴开始对为1的有效位的实际值进行异或运算，得到每个校验位的值以及和那些有效位作为一组\n即P1=H7异或H5异或H3=D4异或D2异或D1=1异或1异或0=0\n即P2=H7 H6 H3 = D4 D3 D1 = 1 0 0 = 1\n即P3=H7 H6 H5 = D4 D3 D2 = 1 0 1 = 0\n   H7 H6 H5 H4 H3 H2 H1     D4 D3 D2 P3 D1 P2 P1   1 0 1  0      分组结果就是：\nP1 D4 D2 D1\nP2 D4 D3 D1\nP3 D4 D3 D2\n4.纠错\n纠错就是对分组进行偶校验，若为1就说明有问题\n异或的结果从高到低排列 010 =\u0026gt;十进制就是2 ，就代表第二位出错了\n海明码的检错、纠错能力:\n纠错能力\u0026ndash;1位\n检错能力\u0026ndash;2位\n为了防止出现2位同时出现位错误判断错误位不对的情况，我们需要在前头加上全校验位，对整体进行偶校验\n1.若S3S2S1为000并且全体偶校验成功=\u0026gt;无错误\n2.若S3S2S1不为0并且全体偶校验失败=\u0026gt;有一位错误，纠正就可以了\n3.若S3S2S1不为0并且全体偶校验码成功=\u0026gt;有两位错误，需要重传\n海明码\n  基本思想\n 分组偶校验，多个校验位可反映出错位置    求解步骤\n 确定校验位个数k个校验位，n个信息为  2^k\u0026gt;=n+k+1   确定校验位分布  P1、P2、P3\u0026hellip;分别在123416 空出来的其他位置一次填入信息位   求校验位  将信息位的位置序号用k位二进制数表示出来 校验位Pi 与位置序号第i位为1的信息为归为一组，进行偶校验   纠错  对P1、P2、P3\u0026hellip;所属各分组进行异或（相当于分组偶校验）求得S1、S2、S3 S3 S2 S1 = 000 说明无错误 S3 S2 S1 不等000 其值反映出错位置      补充\n 海明码有1位纠错，2位检错能力 为了区分1位错和2位错，还需添加“全校验位”对整体进行偶校验    循环冗余校验码\n基本思想：数据发送、接受方约定一个“除数”\nK个信息位+R个校验位 作为“被除数” ， 添加校验位后需保证除法的余数为0\n若余数非0 说明出错，则进行重传或纠错\n 构造  由生成多项式确定除数。若生成多项式中x的最高次为R，则除数有R+1位 K个信息位+R个0 ， 作为被除数 被除数、除数 进行模二除 ，得到R为余数 K个信息位+R位余数 = CRC码   校验  收到K+R位数据，与生成多项式模二除，计算R为余数 余数为0，说明无错误 余数非0，说明出错   检错、纠错能力  可以检测出所有奇数个错误 可以检测出所有双比特的错误 可以检测出所有小于等于校验位长度的连续错误 若选择合适的生成多项式，且2^R \u0026gt;=K +R +1，则可纠正单比特错    定点数与浮点数\n定点数：小数点的位置固定 \u0026ndash;常规计数法\n浮点数：小数点的位置不固定 \u0026ndash;科学计数法\n定点数的表示\n 无符号数 有符号数  原码 反码 补码 移码    无符号数：整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值。\n8位二进制数：2的八次方种不同状态，可以表示的是0到2的八次方-1这么多的十进制数。\nn为的无符号数表示范围为：0到2的n次方-1的十进制\n有符号数的定点表示：\n定点整数+定点小数\n最高位为符号位\n数值部分称为尾数\n注：可用原码、反码、补码三种方式来表示定点整数和定点小数。还可用移码表示定点整数。\n符号位0表示正数1表示负数\n原码：用尾码表示真值的绝对值，符号位0/1 ， 对应正负\n若机器字长为n+1位，则尾数占n位\n若机器字长为n+1位，原码整数的表示范围为：-（2^n-1)到2^n-1\n真值0有+0 和 -0 两种形式\n若机器字长为n+1位，原码小数的表示范围为-（1-2^-n）到1-2^-n\n真值0有+0 和 -0 两种形式\n反码：若符号位为0，则反码与原码相同\n​\t若符号位为1，则数值位全部取反\n补码：正数的补码=原码\n​\t负数的补码=反码+1\n移码：补码的基础上将符号位取反。注意：移码只能用于表示整数\n移码表示的整数很方便对比大小\n各种码的作用\n加减运算：\n无符号数的运算结果没有任何问题\n但是用原码表示有符号数的话，需要先判断符号位是不是负数，如果是负数的话，需要将负数的位改成正数位，然后将加法运算改成减法运算\n也即，使用原码运算：\n加法\u0026ndash;用加法器完成\n减法\u0026ndash;用减法器完成\n但减法器成本很高，所以考虑用加法来代替减法运算\n带余除法\u0026mdash;-设x，m属于z，m\u0026gt;0则存在唯一决定的整数q和r，使得：x=qm+r ， 0\u0026lt;=r\u0026lt;m\n实际上就是将整数分成r类，每类分别为余数从0到r-1\n模数相同的都是同一类，都是等价的\n二者绝对值之和=模的，互为补数\n模-a的绝对值=a的补数\n在mod m 的条件下，若能找到负数的补数，就可以用正数的加法来等价替代减法\n如果模数m为12的话，那么也就是余数0-11\n如果计算机的字长为8bit，也就是表示的范围是0-2^8-1，那么也就是实际上模数就是2^8呗\n所以只要模-a的绝对值=a的补数 =\u0026gt; 2^8-a的绝对值=a的补数 =\u0026gt; a的补码形式的原生定义\n补码\u0026mdash;就是让减法操作转变为加法操作，节省硬件成本 ， 这样ALU中只需要设计加法运算器就可以啦\n补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。\u0026mdash;-《数论》\n移码的作用：移码表示的整数很方便的对比大小\n定点数的表示和运算\n 表示  无符号数 有符号数  原码 补码 反码 移码     运算  移位运算 加减运算 乘法运算 除法运算    移位运算\n 算数移位  原码 补码 反码   逻辑移位 循环移位  原码 1 0010100. ==-20\n小数点位置是无法改变的，但是我们可以巧妙的改变数的位置，也就是\n原码 1 0001010. 也就是将尾数，整体右移一位，左边多出来的可以补0 ==-10\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补0，低位舍弃。若舍弃的位=0，则相当于除2；若舍弃的位不等于0，则会丢失精度\n左移：低位补0，高位舍弃。若舍弃的位=0，则相当于乘2；若舍弃的位不等于0，则会出现严重误差\n反码的算数移位\u0026ndash;正数的反码与原码相同，因此对正数反码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。\n左移：低位补0，高位舍弃。\n反码的算数移位\u0026ndash;负数的反码数值位与原码相反，因此负数反码的移位运算规则如下，\n右移：高位补1，低位舍弃\n左移：低位补1，高位舍弃\n补码的算数移位\u0026ndash;正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。\n右移：高位补0，低位舍弃。\n左移：低位补0，高位舍弃。\n补码的算数移位\u0026ndash;负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。\n规律\u0026ndash;负数补码中，最右边的1及其右边和原码相同。最右边的1的左边和反码相同\n所以，负数补码的算数移位规则如下：\n右移（同反码）：高位补1，低位舍弃\n左移（同原码）：低位补0，高位舍弃\n牛到家的例子\n-20*7\n可以理解为-20*（4+2+1）\n也就是-20左移两位，左移1位，和不移位三者之和\n逻辑移位：\n逻辑右移：高位补0，低位舍弃\n逻辑左移：低位补0，高位舍弃\n可以把逻辑移位看作是对无符号数的算数移位\n循环移位：\n循环左移和带进位位的循环左移\n应用：汉字的大端模式和小端模式相互转换的时候\n定点数移位运算\n 算数移位  左移1位相当于x基数；右移以为相当于/基数 原码：符号位不参与移位。左移右移都补0 反码：符号位不参与移位。左移右移都补1 补码：负数补码的最右边的1及其右边与源码相同，最右边的1的左边与反码相同。符号位不参与移位，左移补0，右移补1。   逻辑移位  左移、右移都补0，移出的位舍弃。   循环移位  不带进位位：用移出的位补上空缺 带进位位：移出的位放到进位位，原进位位补上空缺    注：由于原、反、补码的数位有限，因此某些时候算数移位不能精确等效乘法、除法\n加减运算\n 原码的加减法 补码的加减法 溢出判断 符号扩展  原码的加法运算：\n正+正：绝对值做加法，结果为正，可能溢出\n负+负：绝对值做加法，结果为负，可能溢出\n正+负：绝对值大的减绝对值小的，符号同绝对值大的数\n负+正：绝对值大的减绝对值小的，符号同绝对值大的数\n原码的减法运算，“减数”符号取反，转变为加法：\n正-负：正+正\n负-正：负+负\n正-正：正+负\n负+正：负-负\n太难了用减法器\n所以考虑用补码的加减运算\n负数补码=\u0026gt;原码：\n 数值位取反+1 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码  对于补码来说，无论加法还是减法，最后都会转变为加法，由加法器实现运算，符号位也参与运算\n当数太大的时候，可能会发生溢出，所以要进行溢出判断\n溢出判断\n 只有正数+正数才会上溢\u0026mdash;\u0026ndash;正+正=负 只有负数+负数才会下溢\u0026mdash;\u0026ndash;负+负=正  方法1：采用一位符号位 设A的符号位As，B的符号位Bs，运算结果的符号为Ss，则溢出逻辑表达式为\nV=AsBs（非Ss）+（非As）（非Bs）Ss\n若V=0，表示无溢出\n若V=1，表示有溢出\n方法2：采用一位符号位，根据数据位进位情况判断溢出，符号位的进位Cs 最高数值位的进位C1\n上溢：Cs=0，C1=1\n下溢：Cs=1，C1=0\n用异或来判断就好\n方法3：采用双符号位\n正数符号为00，负数符号为11\n记两个符号位为Ss1，Ss2，则V=Ss1异或Ss2\n若V=0，则表示无溢出，若V=1，表示有溢出\n双符号位补码称为：模4补码\n单符号位补码称为：模2补码\n符号扩展\n由于可能会出现溢出，所以可以考虑补位，即int-\u0026gt;long ， 如8位=\u0026gt;16位\n定点整数的符号扩展：\n在原符号位和数值位中间添加新位，正数都添0；负数原码添0，负数反、补码添1\n定点小数的符号扩展：\n在原符号位和数值位中间添加新位，正数都添0,；负数原码、补码添0，负数反码添1\n加减运算：\n 原码  加法 减法   补码：总是要转变成加法，符号位参与运算 溢出判断（补码）  Key：正+正=负（上溢）；负+负=正（下溢） 方法三：采用双符号位，正数符号为00，负数符号为11，加法运算后若双符号位=01则发生上溢错误；若双符号位为10则发生下溢错误，若两个符号位相同，则未发生错误   符号扩展  定点整数符号的扩展：在原符号位和数值位中间添加新位，正数都添0，负数原码添0，反码添1，补码添1 定点小数符号的扩展：在原符号为和数值位后面添加新位，正数都添0，负数原码、补码添0，反码添1    乘法运算\n 乘法运算的实现思想 原码的一位乘法 补码的一位乘法  手算乘法：可以考虑用移位来实现，左移就是乘法，右移就是除法\n考虑用机器来实现：\n 实际数字有正负，符号位如何处理 乘积的位数扩大一倍如何处理 4个位积都要保存下来最后统一相加吗？  原码一位乘法\n符号单独处理：符号位=xs和ys进行异或操作\n数值位进行相乘就好了\n运算器：\nALU：算术逻辑单元\nX：通用寄存器（存放被乘数）\nACC：累加、存放乘积高位\nMQ：存放乘数和乘积低位\n机器字长为n+1\n实现方法：先加法再移位，重复n次\n首先，ACC置为0，X存被乘数，MQ存乘数\n当前位=1，则ACC加上被乘数\n当前位=0，则ACC加0\n如此再通过移位运算，达到错位的效果\n补码的乘法运算\n原码的一位乘法：\n进行n轮加法、移位\n每次加法可能是+0、+x的原码\n每次移位是逻辑右移\n符号位不参与运算\n符号位最后由一个异或运算来决定\n补码的一位乘法：\n进行n轮加法、移位，最后再多来一次加法\n每次加法可能+0，+x的补码，+-x的补码\n每次移位是补码的算数右移\n符号位参与运算\n辅助位-MQ中的最低位=1，ACC+x的补码\n辅助位-MQ中的最低位=0，ACC+0\n辅助位-MQ中的最低位=-1，ACC+-x的补码\n除法运算\n 除法运算的思想 原码除法：恢复余数法 原码除法：加减交替法（不恢复余数法） 补码除法：加减交替法  恢复余数法：\n实现方法：上商0/1，得到余数，余数末尾补0\n强制类型转换：\n无符号数与有符号数：\n不改变数据内容，改变解释方式\n长整数变短整数：\n高位截断，保留低位\n短整型变长整数：\n符号扩展\n大小端模式：\n大端模式：便于人类阅读\n小段模式：便于机器处理\n边界对齐\n现代计算机通常是按字节编址，每个字节对应1个地址\n通常也支持按字、按半字、按字节寻址\n假设存储字长为32位，则1个字为=32bit ，半字=16bit 每次仿存只能读写1个字\n边界不对齐\n边界对齐访问一个字/半字都只需要一次访存 ， 即空间换时间，舍弃空间，换取最佳时间\n边界不对齐访问一个字/半字可能需要两次访存，即时间换空间，舍弃时间，换取空间密度最佳\n浮点数的表示\n 浮点数的表示  浮点数的作用和基本原理 浮点数规格化 浮点数的表示范围   IEEE 754标准 浮点数的加减运算  定点数的局限性：\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n如何在位数不变的情况下增加数据的表示范围\n阶码+尾数\n阶码=阶符+阶码的数值部分\n尾数=数符+尾数的数值部分\n浮点数的表示\n定点数：如纯小数0.1011和纯整数11110\n浮点数：阶码+尾数\n阶码：常用补码或移码表示的定点整数\n尾数：常用原码或补码表示的定点小数\n浮点数的真值：N=r的E次方*M\n阶码的底通常为2\n阶码E反映浮点数的表示范围及小数点的实际位置；\n尾数M 的数值部分的位数n反映浮点数的精度\n之所以叫做浮点数，正是由于小数点可以通过阶码的值来对尾数进行调整，从而看起来像小数点在尾数中浮动，因此叫浮点数\n浮点数尾数的规格化\n使得尾数的最高位是有效值（左规），以免丢失精度\n规格化浮点数：规定尾数的最高数值位必须是一个有效值\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码则要减1\n右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确的符号位\n浮点数的表示范围也有极限\n浮点数的表示\n  表示\n 阶码：阶符+数值部分，尾数：数符+数值部分 阶码+尾数  尾数给出具体数值，阶码指明小数点前移、后移多少位 阶码通常是用补码、移码表示的定点整数 尾数通常是用补码、原码表示的定点小数 真值：N=r的E次方*M      规格化\n 尾数的最高数值位必须是一个有效值（类比十进制科学计数法，通常我们会让数值部分最高位为非0） 左规：数值位最高位无效时，通过尾数算数左移、阶码-1的方法处理，直到尾数最高数值位有效时停止 右规：若采用双符号位表示尾数，则当运算后尾数假溢出时，可以通过尾数右移、阶码+1的方法处理 原码表示的尾数规格化：尾数的最高数值位必须是1 补码表示的尾数规格化：尾数的最高数值位必须和尾数符号位相反    表示范围\n  浮点数标准\nIEEE754\n移码：补码基础上将符号位取反。注意：移码只能用于表示整数\n移码的定义是：移码=真值+偏置值\n以往的偏置值通常是2的n-1次方\n在IEEE754标准中，偏置值将设定为2的n-1次方-1\n那么移码就会有一点点改变\n分为数符、阶码部分（用移码表示）、尾数（用原码表示，隐藏表示最高位）\n阶码全1、全0用作特殊用途\n浮点数的运算\n 加减运算 强制类型转换  1.对阶\n2.尾数加减\n3.规格化\n4.舍入\n5.判溢出\nchar-\u0026gt;int-\u0026gt;long-\u0026gt;double\nfloat-\u0026gt;double\n范围、精度从小到大，转换过程没有损失\n32位\nint：表示整数\nfloat：表示整数及小数\n因此，int-\u0026gt;float:可能损失精度\nfloat-\u0026gt;int:可能溢出及损失精度\n算数逻辑单元\n 作用、大致原理 电路基础知识 加法器的实现  ALU:MQ ACC ALU X PSW\n基本逻辑运算：与或非\n优先级：与\u0026gt;或\n分配律结合律都满足的\n复合逻辑：与非、或非、异或、同或\n加法器：\n一位全加器：\nAi+Bi+Ci-1=Si和Ci\nAi是一个输入\nBi是一个输入\nCi-1是来自低位的进位\nSi是本位的输出\nCi是来自本位的进位\n串行加法器：\n只有一个全加器，数据诸位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。\n并行加法器：\n串行进位的并行加法器：把n个全加器串接起来，尽可以进行两个n位数的相加。\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。\n算数逻辑单元：\n  ALU\n 实现算术运算、逻辑运算、辅助功能（移位、求补） 基本结构：输入、输出、控制CU    电路基础知识\n 逻辑运算：与或非、与非、或非、异或、同或 门电路：最基础的逻辑元件，用于实现逻辑运算 逻辑表达式就是电路的数学化表示。根据逻辑运算的规则对逻辑表达式进行优化，也就是在优化电路    加法器的实现\n 一位全加器的设计  本位和Si=Ai异或Bi异或Ci-1 本位向高位的进位Ci=AiBi+（Ai异或Bi）Ci-1   串行加法器  一位全加器+进位触发器，只能一位一位地加   串行进位的并行加法器  多个全加器简单串联，可多位同时相加 计算速度取决于进位产生和传递的速度      回忆\n 各种门电路的图形，全加器的图形和输入输出信号    并新加法器的优化\n并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位\n串行加法器=\u0026gt;串行进位的并行加法器=\u0026gt;组内并行、组件串行进位的加法器=\u0026gt;组内并行、组件并行进位的加法器\n系统总线\n总线的基本概念\n总线的分类\n总线特性及性能指标\n总线结构\n总线控制\n总线是连接各个部件的信息传输线，是各个部件共享的传输机制。\n总线上信息的传送\n串行\u0026mdash;\u0026ndash;\n并行\u0026mdash;-\n 总线结构\n1.单总线结构框图\n缺点：总线会成为瓶颈\n2.面向CPU的双总线结构框图\nCPU和主存之间加入M总线\n3.以存储器为中心的双总线结构框图\n总线的分类\n1.片内总线：芯片内部的总线\n2.系统总线：计算机各部件之间的信息传输线\n 数据总线：双向 与机器字长、存储字长有关 地址总线：单向 与存储地址、IO地址有关 控制总线：有出有入  3.通信总线\n用于计算机系统质检或计算机系统与其他系统之间的通信\n传输方式\n 串行通信总线 并行通信总线  总线特性及性能指标\n1.总线的物理实现\n实际上就是印刷电路板：主板\n2.总线特性\n 机械特性\t尺寸、形状、管脚数、排列顺序 电气特性 传输方向和有效的电平范围 功能特性 每根传输线的功能：地址、数据、控制 时间特性 信号的时序关系  3.总线的性能指标\n  1.总线宽度\t数据线的根数\n  2.标准传输率 每秒传输的最大字节数（MBps）\n  3.时钟同步、异步\t同步、不同步\n  4.总线复用\t地址线与数据线复用\n  5.信号线数\t地址线、数据线和控制线的总和\n  6.总线控制方式\t突发、自动、仲裁、逻辑、计数\n  7.其他指标\t负载能力\n  4.总线标准\nISA EISA VESA PCI AGP RS-232 USB\n总线结构\n 单总线结构 多总线结构  双总线结构  主存总线+通道+IO总线 CPU和主存之间加入M总线   三总线结构  主存总线、IO总线、DMA总线（IO设备和主存直接访问） CPU和cache之间的局部总线+系统总线+扩展总线   四总线结构  局部总线+系统总线+高速总线+扩展总线     多层PCI总线结构  总线控制\n总线判优控制\n主设备：对总线有控制权\n从设备：响应从主设备发来的总线命令\n总线判优控制：\n 集中式  链式查询 计数器定时查询 独立请求方式   分布式  链式查询：\nBS\u0026ndash;总线忙\nBR\u0026ndash;总线请求\nBG\u0026ndash;总线同意\nbg的判断是串行的，所以是叫链式查询\n计数器定时查询：\n计数器放在总线控制部件内部，当可以让出总线占用权的时候，轮流向IO接口通过设备地址进行访问，少了BG总线，多了设备地址线，更加灵活设定优先级顺序\n独立请求方式：\n排队控制总线中设有排队器\n发起总线请求的时候，总线控制部件同时对外发起总线占用请求\n总线通信控制：\n1.目的：解决通信双方协调配合的问题\n2.总线传输周期\n 申请分配阶段\t主模块申请，总线仲裁决定 寻址阶段 主模块向从模块给出地址和命令 传数阶段 主模块和从模块交换数据 结束阶段 主模块撤销有关信息  总线通信的四种方式\n 同步通信 由统一时标控制数据传送 异步通信 采用应答方式，没有公共时钟标准 半同步通信 同步、异步结合 分离式通信 充分挖掘系统总线每个瞬间的潜力  同步式数据输入\n总线传输周期有四个\n在不同时钟周期上升沿给出信号\n在第一个时钟上升沿，给出地址信号\n在第二个时钟上升沿，给出读命令\n在第三个时钟上升沿，给出写数据信号\n在第四个时钟上升沿，撤销读命令以及写数据信号\n在第五个时钟上升沿，撤销地址信号\n同步式数据输出\n适用于总线比较短，不同模块读写速度近似的\n异步通信：\n主设备和从设备的请求和回答\n分为：不互锁、半互锁和全互锁方式\n半同步通信（同步、异步结合）\n同步：发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别\n异步：允许不同速度的模块和谐工作，增加一条“等待”响应信号\nT1 主模块发地址\nT2 主模块发命令\nTw 当WAIT为低电平时，等待一个T\nTw 当WAIT为低电平时，等待一个T\n当WAIT为高电平时，主模块开始向从模块对接\nT3 从模块提供数据\nT4 从模块撤销数据，主模块撤销命令\n以上三种通信的共同点：\n一个总线传输周期中:\n 主模块发地址、命令\t占用总线 从模块准备数据 不占用总线 总线空闲 从模块向主模块发送数据 占用总线  第四种则是在总线空闲的时候，充分法诀系统总线每个瞬间的潜力，也就是分离式通信\n一个总线传输周期中，主模块申请占用总线，使用完后即放弃总线的使用权，在从模块准备好数据的时候，申请占用总线，将各种信息送至总线上\n分离式通信特点\n 各模块有权申请占用总线 采用同步方式通信，不等对方回答 各模块准备数据时，不占用总线 总线被占用时，无空闲  存储器\n主存储器和高速缓冲存储器很重要\n 存储器可分哪些类型 现代存储器的层次结构，为什么要分层  存储器分类\n  按照存取方式分类\n 存取时间与物理地址无关（随机访问）  随机存储器 在程序的执行过程中可读可写 只读存储器 在程序的执行过程中只读   存取时间与物理地址有关（串行访问）  顺序存取存储器\t磁带 直接存取存储器 磁盘      按在计算机中的作用分类\n  主存储器\n RAM 随机存储器 可读可写  静态RAM 动态RAM   ROM只读存储器 系统程序 不允许修改  MROM PROM EPROM EEPROM      Flash Memory 例如U盘、固态\n  高速缓冲存储器（Cache）\n  辅助存储器：磁盘、磁带、光盘\n    存储介质分类\n 半导体存储器\tTTL、MOS 易失 磁表面存储器 磁头、载磁体 不易失 磁芯存储器 硬磁材料、环状元件 不易失 光盘存储器 激光、磁光材料 不易失  存储器的层次结构\n 存储器的三个主要特性的关系  速度、容量、价格\n​\t寄存器\tCPU\t主机\t速度快\t容量小\t价格高\n​\t缓存\tCPU\t主机\n​\t主存\t主机\n​\t磁盘\t辅存\n​\t光盘\t辅存\n​\t磁带\t辅存\t速度慢\t容量大\t价格低\n软件、硬件相结合，多种存储器结合的形式，使得某一级的程序员看来，高速、大容量、低价格\n2.缓存\u0026ndash;主存层次和主存\u0026ndash;辅存层次\nCPU 缓存\t主存\t辅存\n10ns 20ns\t200ns\tms\n缓存\u0026ndash;主存 是由硬件绑定在一块儿的（主要为了解决速度问题）\n主存\u0026ndash;辅存 是由软硬件结合的形式弄在一块儿的（主要为了解决容量问题）\n缓存\u0026ndash;主存\n 主存储器的地址 实地址 物理地址  主存\u0026ndash;辅存\n 虚拟存储器 虚地址 逻辑地址  主存储器\u0026ndash;概述\n 主存的基本组成 主存与CPU之间的联系 主存中的存储单元地址的分配 主存的技术指标  基本组成\nMAR地址寄存器\n译码器\n驱动器\n存储体\n读写电路\n控制电路\nMDR数据寄存器\n主存和CPU的联系\nMDR\u0026mdash;-数据总线（双向）\u0026mdash;-主存\nCPU\u0026mdash;-读写\u0026mdash;主存\nMAR\u0026mdash;地址总线（单向）\u0026mdash;主存\n主存中存储单元地址的分配\n高位字节放在前边\u0026mdash;大端模式、大尾模式\n低位字节放在前边\u0026mdash;小端模式、小尾模式\n主存的技术指标\n 存储容量\t主存存放二进制代码的总位数 存储速度  存取时间\t存储器的访问时间 读出时间 写入时间 存取周期 连续两次独立的存储器操作（读或写）所需的最小间隔时间 读周期、写周期   存储器的带宽 位/秒  半导体存储芯片简介\n1.半导体存储芯片的基本结构\n译码驱动+存储矩阵+读写电路\n除此之外还有交互的数字线路，例如地址线（单向）、数据线（双向）、片选线、读写控制线\n地址线实际上是地址个数，例如地址线10条，也就是有2的10次方个地址\n数据线实际上是数据的位数，例如数据线有4条，也就是有4位的0101来表示一个数据\n所以芯片容量=地址线*数据线\n片选线 非CS 非CE chipselect chipenable 低电平有效\n读写控制线 非WE 写 非OE 读\n存储芯片片选线的作用\n用16K*1位的存储芯片组成64K * 8位的存储器\n那么就要求同时对8个芯片进行操作，每个芯片凑一个一位，8个同时工作就凑足8位，并且要同时凑足4组，因为1组只有2的16次方个地址，只有凑足4组才能够2的64次方这么多地址\n因此片选线的作用就是让几个存储芯片连接在一起同时工作\n半导体存储芯片的译码驱动方式\n1.线选法 通过输入的地址线，通过地址译码器来判断哪根线有效，然后将有效的线上的数据通过读写控制电路，也就是数据线输出，缺点在于如果地址线位数很多，那么也就是地址线需要很多，每根地址线要和不同的控制电路的块块相连，那么就会导致线很多\n2.重合法\t线选法使用矩阵来布线，而重合法使用二维矩阵来布线，布线的数量大大降低\n随机存取存储器RAM\n  静态RAM（SRAM）\n 保存0和1的原理是什么  通过触发器来实现存取，这部分涉及到数电的内容   基本单元单元电路的构成是什么 对单元电路如何读出和写入  通过片选信号将不同的芯片分组，通过重合法和地址线以及数据线，对低电平的地址进行选中后进行读写操作   典型芯片的结构是什么样子的 静态RAM芯片如何进行读出和写入操作    动态RAM(DRAM)\n  保存0和1的原理是什么\n 存在电容中，有电就是1，没电就是0    基本单元单元电路的构成是什么\n  对单元电路如何读出和写入\n  典型芯片的结构是什么样子的\n 单管、三管    静态RAM芯片如何进行读出和写入操作\n  动态RAM为什么要进行刷新，刷新方法\n 防止电子丢失，刷新与行地址有关 集中刷新（存在死区和死时间率） 分散刷新（刷新过快了，没有死区） 集中刷新与分散刷新相结合（异步刷新）        动态RAM和静态RAM的比较\n​\tDRAM\tSRAM\n  存储原理 电容 触发器\n集成度 高 低\n芯片引脚 少 多\n功耗 小 大\n价格\t低\t高\n速度\t慢\t快\n刷新\t有\t无\n​\t用作主存\t用作缓存\n只读存储器ROM\n早起只读存储器\u0026mdash;-不能修改\n改进1\u0026mdash;-用户可以自己写\u0026mdash;\u0026mdash;一次性\n改进2\u0026mdash;\u0026ndash;可以多次写\u0026mdash;\u0026mdash;-要能对信息进行擦除\n改进3\u0026mdash;\u0026mdash;电可擦写\u0026mdash;\u0026mdash;-特定设备\n改进4\u0026mdash;\u0026mdash;电可擦写\u0026mdash;\u0026mdash;-直接连接到计算机\n1.掩模ROM（MROM）\n行列选择线交叉处有MOS管为1\n2.PROM一次性编程\n3.EPROM（多次性编程）\nN型沟道浮动栅MOS电路\n紫外线擦除\n","date":"2021-05-14T00:26:49+08:00","permalink":"https://linjianshu.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"计算机组成原理学习文档"},{"content":"Blazor学习文档 调用webapi\n httpclient ihttpclientfactory  数据绑定\n  单项绑定\n  双向绑定\n  \u0026lt;input @bind = \u0026#34;CurrentValue\u0026#34; /\u0026gt; \u0026lt;input @bind = \u0026#34;CurrentValue\u0026#34; @bind:event = \u0026#34;oninput\u0026#34;     \u0026lt;h1\u0026gt;单向绑定\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;@Apsdetail.ProductBornCode\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;@Apsdetail.ProcedureCode\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;@Apsdetail.ProductBornCode\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;@Apsdetail.ProcedureCode\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;h1\u0026gt;双向绑定\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;产品出生证\u0026lt;/h3\u0026gt; \u0026lt;input @bind=\u0026#34;@Apsdetail.ProductBornCode\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt;工序编号\u0026lt;/h3\u0026gt; \u0026lt;input @bind=\u0026#34;@Apsdetail.ProcedureCode\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2\u0026gt;不同的触发event:\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;产品出生证\u0026lt;/h3\u0026gt; \u0026lt;input @bind=\u0026#34;@Apsdetail.ProductBornCode\u0026#34; @bind:event=\u0026#34;oninput\u0026#34;/\u0026gt; \u0026lt;h3\u0026gt;工序编号\u0026lt;/h3\u0026gt; \u0026lt;input @bind=\u0026#34;@Apsdetail.ProcedureCode\u0026#34; @bind:event=\u0026#34;oninput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @onclick=\u0026#34;@button_click\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; EditForm\n input组件  inputtext inputtextarea inputnumber inputselect inputdate inputcheckbox   数据绑定 数据验证  界面携值跳转\n在webapi中\n记得指定route属性\n如果没有fromform的话 post优先为从url传过来的数据\n如果指定了fromform的话 \rimage-20210423163845812\r\nblazor通过post传过来的东西\n\rimage-20210423170418068\r\n在webapi中直接通过实体来接收就好了!!!\n","date":"2021-04-24T00:27:56+08:00","permalink":"https://linjianshu.github.io/p/blazor%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"Blazor学习文档"},{"content":"asp .net core mvc 学习文档 控制器向界面传值 通过viewbag/viewdata 来进行弱传递\ncontroller中:\n\rimage-20210421230444662\r\nindex中:\n\rimage-20210421230455113\r\n通过model进行强类型传递\ncontroller中:\n\rimage-20210421230520009\r\nindex中:\n@model IEnumerable\u0026lt;webmvcdemo.Models.Movie\u0026gt; \u0026lt;form asp-controller=\u0026#34;Movies\u0026#34; asp-action=\u0026#34;Index\u0026#34; \u0026gt; \u0026lt;p\u0026gt; \u0026lt;select name=\u0026#34;prop\u0026#34; required=\u0026#34;\u0026#34;\u0026gt; @foreach (var item in typeof(Movie).GetProperties()) { \u0026lt;option value=@item.Name\u0026gt;@item.Name\u0026lt;/option\u0026gt; } \u0026lt;/select\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;SerachString\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; 界面向控制器传参 通过name来准确传递\nindex:\n\u0026lt;select name=\u0026#34;prop\u0026#34; required=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;SerachString\u0026#34;/\u0026gt; 控制器中:\n\rimage-20210421230911623\r\n通过定位点标记帮助程序\nhttps://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/tag-helpers/built-in/anchor-tag-helper?view=aspnetcore-5.0#asp-route-value\nRazor语法 使用@符号将c#转化为html代码提供展示 显式/隐式razor表达式 razor代码块 ​\tRazor 代码块以开头 @ ，并由括起来 {} 。 代码块内的 C# 代码不会呈现，这点与表达式不同。 一个视图中的代码块和表达式共享相同的作用域并按顺序进行定义\n控制结构@if, else if, else, and @switch 循环结构@for, @foreach, @while, and @do while 复合语句@using, @try, catch, finally @attribute 指令将给定的属性添加到生成的页或视图的类中。 以下示例添加 [Authorize] 属性： @attribute [Authorize] @code和@functions @code块使Razor 组件可以将 c # 成员添加 () 到组件的字段、属性和方法\n@functions 指令允许将 C# 成员（字段、属性和方法）添加到生成的类中\n在razor组件中,我们使用@code 来代替js所做的操作和运算\n在razor页面中,我们使用@functions 来代替js所做的操作和运算\n@functions { public string GetHello() { return \u0026#34;Hello\u0026#34;; } } \u0026lt;div\u0026gt;From method: @GetHello()\u0026lt;/div\u0026gt; @implements 指令为生成的类实现接口。 @inherits 指令对视图继承的类提供完全控制： \rimage-20210422102054166\r\n@model 和 @inherits 可在同一视图中使用。\n@inject指令使 Razor 页面可以将服务从服务容器注入到视图。 有关详细信息，请参阅视图中的依赖关系注入。\n@model 指令指定传递到视图或页面的模型类型\n@namespace 指令：\n 设置生成的 Razor 页、MVC 视图或组件的类的命名空间 Razor 。 在目录树中最近的导入文件中设置页面、视图或组件类的根派生命名空间， _ViewImports) 或 _Imports razor (组件) (视图或页面。 Razor  @page 指令具有不同的效果，具体取决于其所在文件的类型。 指令：\n 在 cshtml 文件中，指示该文件是一个 Razor 页面。 有关详细信息，请参阅自定义路由和 ASP.NET Core 中的 Razor Pages 介绍。 指定 Razor 组件应直接处理请求。 有关详细信息，请参阅 ASP.NET Core Blazor 路由。  @using 指令用于向生成的视图添加 C# using 指令：\n@using System.IO @{ var dir = Directory.GetCurrentDirectory(); } \u0026lt;p\u0026gt;@dir\u0026lt;/p\u0026gt; public class Instructor { public int ID { get; set; } [FromQuery(Name = \u0026#34;Note\u0026#34;)] public string NoteFromQueryString { get; set; } 表单标记帮助程序 ","date":"2021-04-16T00:28:25+08:00","permalink":"https://linjianshu.github.io/p/apsdotnetcoremvc%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"ApsDotnetCoreMVC学习文档"},{"content":"RabbiMQ学习文档 rabbitMQ是遵循amqp协议的一个erlang实现。\namqp协议：高级消息队列协议\nhttp协议：request、response\ntelnet协议：经常用来查看某一台ip上的指定端口是否是ping通的【远程登陆协议】\nAMQP 0-9-1 complete Reference Guide rabbitmq 实现的amqp协议的版本号\n connection =\u0026gt;open , use , close [open-ok , close , une-ok] channel =\u0026gt;open, flow , close , [构建在connection之上，在amqp中常作为长连接] exchange =\u0026gt; queue basic =\u0026gt;发布和获取 message中的一些设置 tx =\u0026gt;事务处理 confirm =\u0026gt;发布确认机制  详细设计书一样\n\rimage-20201026164558077\r\n\rimage-20201026164701153\r\n延时处理，拉长时间\n以更长的时间来换取堆积的业务逻辑\n异步处理：响应很快，增加服务器承载能力\n流量削峰：\n扩展性：UI和业务的解耦，可以独立演化\n高可用：处理器发生故障以后，不会影响可用性\n缺陷：\n即时性降低，降低了用户体验\u0026mdash;无法避免；业务上来屈服；\n复杂性提高\nvhost：避免命名冲突\nexchange：\n direct headers topic fanout  \rimage-20201026211929666\r\n在windows上是一个服务\nUI工具可以查看rabbitmq的事实状况，http api的方式也可以查看\nhttp://127.0.0.1:15672/#/\n\rimage-20201027095638965\r\nui和命令行的区别：ui只是命令行的子集\n\rimage-20201026215957380\r\n  应用层序和集群的管理 application and Cluster Management\n stop stop_app start_app reset [格式化的功能] force reset [无条件设置]    集群配置 Cluster management:ram和disk\n purge_queue {queue名} 用于清空某一个队列    用户管理 userManagement\n add_user {username} {password} [设置users的角色] set_user_tags {username} {tag \u0026hellip;} [设置用户的角色] authenticate_user {username} {password} 验证用户名，密码是否正确 list_users 展示所有users    访问控制 access Control\n set_permissions [-p vhost] {user} {conf} {write} {read} clear_permissions {user}    参数管理 parameter management 【第三方插件比较多】\n  政策管理 policy management 对queue 的全局设置用得上这个政策管理，队列镜像也是用的这个命令\n  服务器状态\n list_queues {name} {pid} {durable} list_exchanges [-p vhost] [exchangeinfoitem] list_bindings [-p vhost] [bindinginfoitem] list_connections [connectioninfoitem] list_channels [channelinfoitem]  connections =\u0026gt;channels 建立connections是长连接，channels是挂在connection之上的\n status environment Miscellaneous 混合命令    erlang和rabbitmq的区别\n一个是语言环境，一个是应用程序\n\rimage-20201026222139817\r\n\rimage-20201026222148175\r\n\rimage-20201027091016137\r\n环境配置文件：measia【erlang的分布式数据库】， config配置文件，log日志的存放路径的设置\nconfig文件。。mongodb , redis\n\rimage-20201027091602576\r\n知道端口：5673\nlog信息 默认打出来的是info格式\n{log_levels,[{connection,info},{channel,info}]}\n这样日志特别大，对磁盘的压力就很大\n{vm_memory_high_watermark,0.4}\n指定ram占内存百分比上限，connection达到阀值会阻塞blocked【报警】 让管道流变小\n{disk_free_limit,5000000} 也是会触发报警机制，让管道流变小\n使用C#连接rabbitmq .Net Client\n1.api文档 类似msdn\n2.下载方式有两种： 1）通过官网下载 2）通过nuget下载\n connectiong to a Broker  服务器配置，guest不可以被外网访问，在生产环境中，默认都是新增用户的\n这是生产者代码：\nusing System; using System.Net.Http; using System.Text; using RabbitMQ.Client; namespace RabbitmqDemo { class Program { static void Main(string[] args) { ConnectionFactory factory = new ConnectionFactory() { HostName = \u0026#34;127.0.0.1\u0026#34;, UserName = \u0026#34;datamip\u0026#34;, Password = \u0026#34;123456\u0026#34; }; //第一步：创建connection  var connection = factory.CreateConnection(); //第二步：创建channel  var channel = connection.CreateModel(); //第三步：声明交换机（因为rabbitmq已经有了自定义的amqp default exchange ，所以这里不声明也能自动创建）  //第四步：创建一个队列（queue）  channel.QueueDeclare(\u0026#34;mytest\u0026#34;, true, false, false); var msg = Encoding.UTF8.GetBytes(\u0026#34;你好\u0026#34;); //第五步：发布消息  channel.BasicPublish(string.Empty,\u0026#34;mytest\u0026#34;,basicProperties:null,body:msg); // using...  // connection.Dispose();  // channel.Dispose();  Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } 这是消费者代码：\nusing System; using System.Text; using RabbitMQ.Client; namespace RabbitmqConsumer { class Program { static void Main(string[] args) { ConnectionFactory factory = new ConnectionFactory() { HostName = \u0026#34;127.0.0.1\u0026#34;, UserName = \u0026#34;datamip\u0026#34;, Password = \u0026#34;123456\u0026#34; }; //第一步：创建connection  var connection = factory.CreateConnection(); //第二步：创建channel  var channel = connection.CreateModel(); //第三步：声明交换机（因为rabbitmq已经有了自定义的amqp default exchange ，所以这里不声明也能自动创建）  //第四步：获取消息  BasicGetResult basicGetResult = channel.BasicGet(\u0026#34;mytest\u0026#34;, true); ReadOnlyMemory\u0026lt;byte\u0026gt; msg = basicGetResult.Body; Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } 交换机机制：exchange:direct/fanout/headers/topic \rimage-20201027110100918\r\nDemo中用到的BasicGet是主动的去拉取，subscribe和publish是发布订阅的模式\nworkqueue方式\nEventingBasicConsumer:多个consumer可以分摊我们的cpu计算压力\n如果申明自定义交换机，一定要手动绑定\n//第三步：声明交换机（因为rabbitmq已经有了自定义的amqp default exchange ，所以这里不声明也能自动创建）可选  channel.ExchangeDeclare(\u0026#34;myexchange\u0026#34;,ExchangeType.Direct,true,false,null); //第四步：创建一个队列（queue）  channel.QueueDeclare(\u0026#34;mytest\u0026#34;, true, false, false); channel.QueueBind(\u0026#34;mytest\u0026#34;, \u0026#34;myexchange\u0026#34;, \u0026#34;mytest\u0026#34;, null); for (int i = 0; i \u0026lt; 100; i++) { var msg = Encoding.UTF8.GetBytes(string.Format(\u0026#34;{0}:{1}\u0026#34;,i,\u0026#34;你好\u0026#34;)); //第五步：发布消息  // channel.BasicPublish(string.Empty, \u0026#34;mytest\u0026#34;, basicProperties: null, body: msg);  channel.BasicPublish(\u0026#34;myexchange\u0026#34;, \u0026#34;mytest\u0026#34;, basicProperties: null, body: msg); } \rimage-20201027155658033\r\nRouting模式 做一个日志处理分发，将日志级别不同的存到不同的队列里去，info/debug/warn存到log_else队列中，等待消费者消费；将error存到log_error队列中，等待消费者消费；在这里注意，我们可以在生产者/消费者任意一端构建交换机、队列，因此最合适的方式是，将不同级别队列的构建放在消费者一端，在生产者端，将消息的存进不同的路由中（routekey中）\n\rimage-20201027163324742\r\n生产者：\n\rimage-20201027163944656\r\n消费者：\n\rimage-20201027164022728\r\n\rimage-20201027164030154\r\nfanout：exchange多播的现象 应用场景相当多\n1.下订单流程：如果订单提交，同时发送短信和推送\n2.cs软件弹出消息，普通情况下，我们是轮询的方式，我们在cs中绑定fanout exchange，这时候服务器有消息的话，可以及时推送\n3.客户关怀千人千面\n淘宝=\u0026gt;催付、付款后提醒、发货提醒、签收提醒\n​\t=\u0026gt;给用户关联推荐、彩信和邮件、短信给用户推荐关联推荐\n","date":"2020-12-01T00:29:59+08:00","permalink":"https://linjianshu.github.io/p/rabbitmq%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"RabbitMQ学习文档"},{"content":"Redis学习文档 nosql讲解\n阿里巴巴架构演进\nnosql数据模型\nnosql四大分类\ncap\nbase\nredis入门\nredis安装\n五大基本数据类型\nstring\nlist\nset\nhash\nzset\n三种特殊数据类型\ngeo\nhyperloglog\nbitmap\nRedis配置详解\nredis持久化\nrdb\naof\nredis事务操作\nredis实现订阅发布\nredis主从复制\nredis哨兵模式\n缓存穿透及解决方案\n缓存击穿及解决方案\n缓存雪崩及解决方案\n基础api之jedis详解\nspringboot继承redis操作\nredis的实践分析\nnosql概述\n大数据时代，一般的数据库无法进行分析处理了！\nspringboot+springcloud\n1.单机mysql年代\napp=\u0026gt;dal=\u0026gt;mysql\n90年代静态网页html 服务器没有太大的压力\n1.数据量如果太大，一台机器放不下了\n2.数据的索引 300万条就一定要建立索引，那么一个机器的内存放不下\n3.访问量，读写混合，一个服务器受不了\n2.Memcached（缓存）mysql+垂直拆分（读写分离）\n网站80%都在读，如果每次去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力，我们可以使用缓存来保证效率\n\rimage-20200923185840123\r\n发展过程：优化数据结构和索引===\u0026gt;文件缓存（IO）===\u0026gt;memchched(当时最热门的技术)===\u0026gt;\n3.分库分表+水平拆分+mysql集群\n\rimage-20200923190414174\r\n本质：数据库（读写）\n早些年mysiam：表锁（影响效率），高并发下出现严重的锁问题\n早些年innodb：行锁，慢慢的就开始使用分库分表来解决写的压力！mysql在那个年代推出了表分区，这个并没有多少公司使用！\nmysql的集群，很好的满足了那个年代的所有需求！\n4.如今最近的年代\n技术爆炸：\n2000-2010：十年间，变化太快了（热榜、音乐）\nmysql等关系型数据库就不够用了！数据量很多，变化很快！\nmysql有的使用它来存储一些比较大的文件、播客、图片！数据库表很大，效率就很低了\n如果有一种数据库来专门处理这种数据，mysql的压力就会变得十分小，（研究如何处理这些问题）大数据的io压力下，表几乎没法更改，\n 目前一个基本互联网项目！\n \rimage-20200923191743309\r\n 为什么要用nosql\n 用户的个人信息，社交温昂罗，地理位置，用户自己产生的数据，用户日志等等爆发式增长！\n这时候我们就需要使用nosql数据库的，nosql可以很好的处理以上情况\n 什么是nosql\n nosql = not only sql(不仅仅是sql)\n关系型数据库：表格，行，列（POI）\n泛指非关系型数据库的， 随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！暴露出来很多难以克服的问题，nosql在当今大数据环境下发展的十分迅速，redis是发展最快的，而且是我们当下必须掌握的一个技术！\n很多的数据类型：个人信息，社交网络，地理位置，流媒体，这些数据类型的存储不需要一个固定的格式！不需要多余的操作就可以横向扩展的，Map\u0026lt;String , Object\u0026gt;使用键值对来控制！\nGet Set\n nosql特点\n 1.方便扩展（数据之间没有关系，很好扩展）\n解耦\n2.大数据量高性能（Redis 一秒写80000次，读取110000次，nosql的缓存记录级，是一种细粒度的缓存，性能会比较高！）\n3.数据类型是多样型！（不需要事先设计数据库！随取随用！如果数据量十分大的表，很多人就无法设计了！）\n4.传统的rdbms 和nosql的区别\n传统的rdbms -结构化组织 -sql -数据和关系都存在单独的表中 -操作操作，数据定义语言 -严格的一致性 -基础的事务 -.... nosql -不仅仅是数据 -没有固定的查询语言 -键值对存储，列存储，文档存储，图形数据库（社交关系） -最终一致性 -CAP定理 和 BASE（异地多活！） 初级架构师 -高性能，高可用，高可扩 -....  了解：3V+3高\n 大数据时代的3V：主要是描述问题的\n1.海量volume\n2.多样variety\n3.实时velocity\n大数据时代的3高：主要是对程序的要求\n1.高并发\n2.高可拓（随时水平拆分，机器不够了，可以扩展机器来解决）\n3.高性能（保证用户体验和性能）\n真正在公司中的实践一定是：nosql+RDBMS一起使用才是最强的，阿里巴巴的架构演进\n技术没有高低之分，就看你如何使用\n 阿里巴巴的演进分析\n 这么多东西难道都是在一个数据库中的吗？\n\rimage-20200923195311367\r\n敏捷开发、极限编程\n开源才牛\n如果你未来想当一个架构是：没有什么是加一层解决不了的\n\rimage-20200923200304616\r\n# 1.商品基本信息 名称、价格、商家信息； 关系型数据库就可以解决了！mysql /oracle(淘宝早年就去IOE!--王坚) 淘宝内部的mysql 不是大家用的mysql #2.商品的描述、评论（文字比较多） 文档型数据库中，mongodb #3.图片 分布式文件系统 FastDFS -淘宝自己的TFS —google自己的GFS -Hadoop HDFS -阿里云的 oss #4.商品的关键字（搜索） -搜索引擎 solr elasticsearch -iseacher 多隆 所有牛逼的人都有一段苦逼的岁月 #5.商品热门的波段信息 -内存数据库 -redis tair、memarche #6.商品的交易，外部的支付接口 -三方应用 要知道，一个简单的网页背后的技术一定不是大家想的那么简单\n大型互联网应用问题：\n 数据类型太多了 数据源繁多，经常重构 数据要改造，大面积改造  \rimage-20200923202347841\r\n\rimage-20200923202441215\r\n\rimage-20200923202455222\r\n以上都是nosql入门概述\nnosql的四大分类 KV键值对：\n 新浪：redis 美团：redis+tair 阿里、百度：redis+tair+meecache  文档型数据库（Bson格式和json一样）：\n MongoDB（一般必须掌握）  MongoDB是一个基于分布式文件存储的数据库，C++编写的 主要用来处理大量的文档 MongoDB是一个介于关系型数据库和非关系型数据库中中间的产品，MongoDB是非关系型数据库中功能最丰富的，最像关系型数据库的！   conthDB  列存储数据库\n HBase 分布式文件系统  图形关系数据库\n\rimage-20200923203416066\r\n 他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！ neo4j，infogrid   四者对比\n \rimage-20200923203555105\r\nredis入门\n概述\n redis是什么\n remote dictionary server 远程字典服务\n是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n免费和开源！是当下最热门的nosql技术之一，也被人们称之为结构化数据库\n redis能干嘛\n redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\rimage-20200924092136203\r\n1.内存存储、持久化，内存中是断电即失，所以说持久化很重要（rdb、aof）\n2.效率高，可以用户高速缓存\n3.发布订阅系统\n4.地图信息分析\n5.计时器、计数器（浏览量！）\n6\u0026hellip;.\n 特性\n 1.多样的数据类型\n2.持久化\n3.集群\n4.事务\n\u0026hellip;.\n 学习中需要用到的东西\n 1.公众号\n2.redis.io\n3.windows在github上下载（停更很久了）\nredis推荐都是在linux服务器上搭建的，我们是基于linux学习\nwindows下安装 1.下载安装包\n2.下载完毕得到压缩包\n3.解压\n\rimage-20200924095526656\r\n4.开启redis，双击运行服务\n\rimage-20200924095553184\r\n默认端口号6379\n5.使用redis客户端来连接redis\n\rimage-20200924095651464\r\n\rimage-20200924095841127\r\n记住一句话，window下使用确实简单，但是redis推荐我们使用linux去开发使用\n\rimage-20200924100331170\r\n测试性能\nredis-benchmark是一个压力测试工具\n官方自带的性能测试工具！\n\rimage-20200924101324907\r\n100000并发，50台客户端并发，每次写入3个字节，只有一台服务器来处理这些请求，所有请求在2毫秒内处理完成\n基础知识 redis默认有16个数据库\n默认使用第0个，可以切换数据库\n127.0.0.1:6379\u0026gt; select 3\t#切换数据库 OK 127.0.0.1:6379[3]\u0026gt; dbsize\t#查看大小 (integer) 0 \rimage-20200924102052855\r\n\rimage-20200924102123448\r\n查看当前数据库中所有的key\n\rimage-20200924102338783\r\n删除当前数据库中flush\n\rimage-20200924102622792\r\n清空全部的数据库flushall\n思考：为什么redis端口号是6379\n redis是单线程的\n 明白redis是很快的，官方表示，redis是基于内存操作的，cpu不是redis性能瓶颈，redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就是用单线程了，所以就使用了单线程了！\nredis为什么单线程还这么快？\nredis是c语言写的，官方提供的数据为100000+的QPS，这个不比同样是使用了key-value的memecache差\nredis为什么单线程还这么快\n1.高性能服务器一定是多线程的？？\n2.多线程（CPU上下文切换）一定是单线程效率高？？\ncpu/memory/硬盘速度要有所了解！\n核心：redis是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！！！！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都在一个cpu上的，所以在内存情况下，这个就是最佳的方案！\n五大数据类型 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件. 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询. Redis 内置了 复制（replication）， LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction）， 事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel） 和自动 分区（Cluster）提供高可用性（high availability）.\n 讲解的所有命令，后面使用springboot、jedis，所有的方法都是这些命令\n单点登陆\n redis-key keys * 查看所以的key exists name 判断当前的key是否存在 move name 移除当前的key expire name 10 设置key的过期时间 单位是秒哦 ttl 查看当前key的剩余时间 type name 查看当前key的类型 \rimage-20200924104300213\r\n\rimage-20200924104451001\r\n\rimage-20200924104806660\r\n\rimage-20200924105127099\r\nstring（字符串） 90%的java程序员使用的都是redis的string类型\n\rimage-20200924105632891\r\nappend 追加字符串 ， 如果key不存在 ， 就相当于set key value exists 判断某个key是否存在 strlen 获取字符串的长度 \rimage-20200924110407868\r\nincr key 自增命令，自增1 decr key 自减命令，自减1 incrby key increment 自增多少步长 decrby key decrement 自减多少步长 \rimage-20200924110748593\r\n范围 getrange key start end 其实就是截取字符串 从0开始 如果是0到-1 就是截取全部的字符串 替换呢？ setrange key offset value 替换 key 从哪里开始算起，替换多少个字符 setex（set with expire) #设置过期时间 setnx(set if not exist) #不存在设置 \rimage-20200924111131931\r\nsetex key time value 设置过期时间ttl key 查看多久过期setnx key value 设置原本不存在的key的value值返回值是0代表没有成功 1代表成功 \rimage-20200924111716363\r\nmset 同时设置多个值 mget 同时获取多个值msetnx 是一个原子性的操作，要么一起成功，要么一起失败 \rimage-20200924112237809\r\n#对象set user1:1 {name:zhangsan,age:3}#设置user:1对象 值为json字符串来保存一个对象#这里的key是一个巧妙的设置：user：{id}：{filed}，如此设计在redis中是完全ok的 \rimage-20200924112908580\r\n\rimage-20200924113631933\r\ngetset key value 没有就设置设置完了就可以再改 \rimage-20200924150037955\r\n\rimage-20200924150059352\r\n\rimage-20200924150112188\r\nstring类似的使用场景：value除了是我们的字符串还可以是我们的数字\n   计数器 统计多单位数量 例如 uid:55646541:follow 0 粉丝数 对象缓存存储  list 在redis里，我们可以把list玩成一个栈、队列、阻塞队列！\n所有的list命令都是以L开头的\nlpush 将一个值或多个值，插入到列表头部（左）rpush 将一个值或多个值，插入到列表尾部（右）lrange key start end 获取值 \rimage-20200924151313766\r\nlpop 移除list的第一个元素rpop 移除list的最后一个元素 \rimage-20200924151853384\r\nlindex key index 通过下标获取某一个值 \rimage-20200924152048330\r\nllen list的长度 \rimage-20200924152237266\r\n移除指定的值！取消关注 uidlrem key count value 移除特定个数的指定值 \rimage-20200924152956569\r\ntrim 修剪ltrim 截断list集合并获取特定下标的集合ltrim key start end \rimage-20200924153243035\r\nrpoplpush移除列表右边最后一个元素并且将其加入到一个新的列表中rpoplpush source destination \rimage-20200924153737788\r\nlset key index value 将列表中指定下标的值替换为另外一个值，更新操作如果不存在指定下标，就会报错 \rimage-20200924154630068\r\nlist中多用lrrange、lpush、lpop而非lset\nlinsert key before/after 特定的value 要插入的value将某一个具体的value插入到列表中某个特定元素的前面或者后面 \rimage-20200924155744795\r\n 小结\n  他实际上是一个链表，before node after left right 都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移除了所有的值，空链表，也代表不存在 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点！  消息排队！lpush rpop（消息队列） lpush lpop（栈）\nset（集合） set中的值不能重复\nset通常都是以s开头的sadd key member 向集合中添加元素sismember key member 判断某元素是否在指定的集合中smembers key 查看指定集合的所有元素scard key 查看指定集合的长度 \rimage-20200924162841343\r\nsrem (s remove缩写) key value 删除指定集合里的指定元素 \rimage-20200924163026477\r\nset无需不重复集合，可以实现抽随机srandmember key 数量 随机抽取指定数量的元素从某指定集合中 \rimage-20200924163406035\r\n删除指定的key， 随机删除指定的key0spop key count 随机移除指定集合内指定数量的元素 \rimage-20200924163558641\r\n将一个指定的集合中的指定元素移除至另一个指定集合中smove source destination value \rimage-20200924163918565\r\n微博、B站、共同关注（交集）\n差集sdiff(set different) sdiff key1 key2 与 sdiff key2 key1不同，参考系不一样sunion key1 key2 sinter key1 key2 \rimage-20200924164627415\r\n微博，A用户将所有关注的人，放在一个set集合中，将他的粉丝也放在一个集合中，\n共同关注：A用户和B用户的共同关注，二度好友，推荐好友，六度分割理论\nhash（哈希） 想象成map集合，key-map集合， key -\u0026lt;key,value\u0026gt;集合，只是这个值是一个map集合，其实本质和string类型没有太大区别，还是一个简单的key-value\nhset key field value 设置值hget key field 获取值hmset key field1 value1 field2 value2 批量设置值hget key field1 field2 批量设置值hgetall key 获取所有的值 \rimage-20200924170715011\r\nset myhash field kuansheng\n所有的hash都是以H开头滴哈宝贝们\nzset\n三种特殊数据类型 geospatial\nhyperloglog\nbitmaps\n","date":"2020-09-19T00:33:33+08:00","permalink":"https://linjianshu.github.io/p/redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/","title":"Redis学习文档"}]