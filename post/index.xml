<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on think hy how to learn</title>
    <link>https://jianrongma.github.io/post/</link>
    <description>Recent content in Posts on think hy how to learn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 25 Dec 2022 10:46:00 +0800</lastBuildDate><atom:link href="https://jianrongma.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>智能优化算法笔记</title>
      <link>https://jianrongma.github.io/p/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 25 Dec 2022 10:46:00 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E6%99%BA%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</guid>
      <description>智能优化混合算法是一种以某类优化算法为基础,融合其他智能算法或理论的混合算法,可用于求解各种工程问题最优解.
智能算法在工程领域(如系统控制、生产调度、人工智能、模式识别等)的迅速推广和应用，作为一个重要的科学分支，智能优化算法激励人们从更广泛的生物或自然现象寻求启发，以构造新的只能算法或对算法不断地进行改进，从而更好地解决工程中存在的多数复杂问题。优势主要表现在：
算法原理简单，易于推广和应用 良好的算法收敛性和搜索速度，优化问题较易取得满意结果 Chapter1 绪论
智能优化算法即一种按照某规则或思想进行的搜索过程，用以得到满足用户要求的问题的解。
遗传算法于1975年由美国密歇根大学的J.Holland教授等人受生物进化论的启发而提出[1]。遗传算法是以自然界中的生物进化过程为背景，将生物进化过程中的繁殖、选择、杂交、变异和竞争等概念引入算法中。它的基本思想来源于自然界中的生物从低级、简单，发展到高级、复杂，乃至进化成人类这样的一个漫长进化过程，并借鉴了达尔文提出的物竞天择、优胜劣汰、适者生存的自然法则。遗传算法的本质是一种对问题进行高效全局搜索的方法，它在搜索过程中有效的利用已有信息来自动获取和积累有关搜索空间的知识，并自适应地控制搜索方向使其最终走向最优解。
遗传算法已经在数据挖掘、生产调度、图像处理以及函数优化等领域去的了令人鼓舞的成就，证明了其良好的性能。近年来，遗传算法被应用于诸如复杂的多目标规划问题、人工生命以及神经网络问题、机器学习问题、智能控制等问题中。
自然界中的生物遗传物质的主要载体是染色体，基因是控制生物性状的遗传物质的功能单位和结构单位，是染色体的主要组成部分，即多个基因组成染色体。在染色体中，基因所占据的位置称为基因座。同一个基因座，可能有的全部基因称为等位基因。染色体的特征即生物个体的性状就是由基因和基因座决定的。与此对应染色体有两种相应的表示模式，即基因型和表现型。所谓表现形式是指生五个题外在所表现出来的性状，而基因型则是指与表现型密切相关的基因组成。同一种基因型的生物个体在不同的外在环境条件作用下可以存在不同的表现型，因此表现型是基因型与外在环境条件下相互作用的结果。染色体带有特征的实体称为个体，个体的集合就是种群。该集合内，个体数称为群体的大小。一个个体对环境的适应程度称为适应度，生物学家使用适应度这个属于来衡量某个物种将获得更多的繁殖后代的机会；而对外在生存环境适应程度较低的物种，其放置后代的机会就会相对较少，甚至逐渐走向灭绝。复制、选择、交叉和变异是自然界中的生物不断向前进化的最重要的组成部分。
自然遗传学说与人工遗传算法中所使用的基本概念和术语之间的对应关系
染色体 解的编码 基因 解中的每一个分量的特征 基因座 特性值 个体 解 种群 选定的一组解(解的个数为种群的规模) 适应度 适应度函数值 复制 根据适应度函数值选取的一组解的操作 选择 以一定概率从种群中选择若干个解的操作 交叉 通过交配原则产生一组新解的过程 变异 通过突变原则产生一组新解的过程 执行遗传算法时必须包含两个数据转换操作，一是表现型到基因型的转换，二是基因型到表现型的转换。前者是指把实际问题中的参数或解转换成遗传算法问题中的染色体或个体。这个过程定义为编码操作；后者是对前者的一个相反操作，即把遗传算法中的染色体或者个体转换为实际问题中的解或参数，这个过程叫做译码操作。当产生初始种群之后，就按照适者生存和优胜劣汰的原理，在每一代中根据每个个体的适应度函数值大小来挑选个体，并仿照自然遗传学说中的遗传算子来进行交叉和变异，并产生出代表新的解集的种群。以此类推逐代进化并产生出越来越优异的近似解，最后一代种群中的最优个体经过解码操作，就可以作为待解决问题的近似最优解。
计算开始时，先将种群随机初始化，产生出一定数目的N个个体，并计算每个个体的适应度函数值，第一代初始种群就产生了。算法按照适应度值选择个体参与交叉编译运算，父代要通过基因重组（交叉）而产生子代，所有的子代按一定概率进行变异操作，然后子代的适应度值又被重新计算，从而产生新的下一代种群。如此反复，直到满足优化准则为止。
近些年来，国内学者也发表了大量关于遗传算法的文章，如2004年，杨晓梅、曾建潮[5]为改善当时求解车间调度问题中的遗传算法的性能,提高搜索最优调度解的速度,并借鉴遗传算法的生物学基础,提出了基于多个体交叉的遗传算法。该算法在执行遗传过程中充分利用个体自身的优良性质，对不可行的调度解根据多个体修补原则进行修补改正，以此就可保证遗传后代的合法性和种群多样性，能够显著缩短最优调度解的搜索时间。在2005年，王凌、张亮[6]针对有限缓冲区的流水线调度问题,提出了一种基于多搜索模式的遗传算法,该算法使用多个交叉和变异操作来对解空间进行探索和改良,并采用面向有向图的领域结构来增强局部搜索性能。在2007年，吴尔飞、金烨等[7]针对当前研究较少的双边装配线平衡问题,研究双边装配中具有操作方位约束的任务,以及在工位上分配任务的操作顺序与平衡结果具有直接关系等特点,提出了相对应的符合该问题特性的遗传算法。该算法采用基于序列、任务机器分配方位相组合的编码方法，并改进了更加可行的交叉与变异算子，使最优解搜索过程仅在可行解的空间内进行，提高了搜索效率，节约了搜索时间。在2009年，莫巨华、黄敏、王兴伟[8]为实现系统的最优化设计，致力于研究以满足顾客满意率要求为主要约束的多目标规划，并提出了一种改进的遗传算法与过程仿真相结合的求解方法。在该求解方法中，多目标规划通过加权平均转化为单目标规划。
遗传算法是一种模拟生物界的自然选择和自然遗传机制的随机搜索算法。在遗传算法提出之前，为解决各种优化问题，许多优化算法已经被提出，例如梯度法、单纯形法、动态规划法等。这些优化算法有各自的有点，也有各自的适用范围，同时又有各自的限制因素。遗传算法与这些传统的优化算法有很大的不同，大多数古典的优化算法是对一个单一的度量函数（评估函数）进行梯度或较高次统计，然后产生一个具有确定性的试验解序列。相反，遗传算法并不依赖于梯度信息，而是通过模拟自然界的进化过程来对最优解进行搜索，它利用某种编码技术，并作用于称为染色体的数字串上，对由这些串组成的群体的进化过程进行模拟。遗传算法通过有组织地、随机地交换信息来重新组合那些适应性较好的串，生成新的串并组成群体。
遗传算法具有自组织性、自适应性和智能性。自然选择清楚了算法设计过程中的一个最大的障碍，即需要事先对问题的全部特点进行描述，并要说明针对问题的不同特点所应采取何种措施。遗传算法的这种自组织、自适应的特征，使它同时具有根据环境的变化而自动发现环境的特性和规律的能力，从而使遗传算法可以用来解决一些复杂的非结构化问题。 遗传算法具有并行性。遗传算法在种群中是按照并行方式进行搜索的，而不是在一个单点上进行寻优的，其并行性表现在两个方面： 遗传算法具有内在并行性，使它本身及其时候大规模并行，并适合在目前所有的并行机或分布式系统上进行并行的处理； 遗传算法具有内行并行性，由于它采用种群的方式来组织搜索，因此可以同时搜索解空间内的多个区域，并相互进行信息交流。许多传统的搜索方法都是从单点开始寻优的，因而在多峰函数优化中极容易陷入局部最优解。遗传算法是从一个种群开始进行搜索的，并且可以同时向不同的方向进行搜索，从而大大提高了遗传算法的全局搜索性能，并减少了陷入局部最优解的可能性。 遗传算法使用概率搜索技术。遗传算法在搜索过程中并不采用确定性规则，而采用概率的变迁规则来指引它的搜索方向，在优化过程中，使搜索的每一步都向最终结果靠近的机制或智能性称为搜索的探索性或启发性。传统搜索方法中从一个搜索点到另一个搜索点的转移有确定性的转移方法和转移关系，这种确定性也极有可能使搜索永远也达不到最优点，因而限制了算法的应用范围，制约了算法的应用效果。遗传算法以适应度数字作为标尺、以概率作为一种工具来指引搜索过程，虽然表面上看，遗传算法好像是一种盲目的搜索方法，但实际上它却是一种导向随机搜索方法。 遗传算法把决策变量的编码作为运算对象。 遗传算法直接把目标函数值作为搜索信息。传统的优化算法不仅需要利用目标函数值，并且还需要目标函数的导数值等其他一些辅助信息才能最终确定下一步的搜索方向和搜索范围，无需使用目标函数的导数值及其他一些辅助信息。这个特性使得遗传算法在很多目标函数无法求导或很难求导的优化问题，以及组合优化问题等应用中比较方便，因为它消除了导数求导这个障碍。另外，直接利用目标函数值或个体适应度值，也可使我们把搜索范围集中到适应度较高的那部分搜索空间中，从而大大提高了搜索的效率，节省了搜索时间。 </description>
    </item>
    
    <item>
      <title>行为认知测评技巧</title>
      <link>https://jianrongma.github.io/p/%E8%A1%8C%E4%B8%BA%E8%AE%A4%E7%9F%A5%E6%B5%8B%E8%AF%84%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sat, 23 Jul 2022 11:52:38 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E8%A1%8C%E4%B8%BA%E8%AE%A4%E7%9F%A5%E6%B5%8B%E8%AF%84%E6%8A%80%E5%B7%A7/</guid>
      <description>数字规律题 标序列号 把变量和序列号放在一起比较看看 公因式法 找出最小公因式 看看有无规律 对每一位数减去第一位数 替换掉第2&amp;hellip;.位 结合上面的看看有无规律 对每一位数同时加上/乘以/除以第一位数 结合上面看看有无规律 同时除以1/2/3 加法和减法可能性稍大 能否分成奇数和偶数数组 看增幅 是否有规律 +1 +2 +4 +8 等比或者等差 前两个和/积是后一个 类斐波那契数列 前一个数是后一个数的比例关系 图形推理题 是否间隔排列或者对称排列 寻找共同特征 顺时针/逆时针 变化 白*黑=白 重合的题目 对称与不对称 轴对称与中心对称 切割三角形 相交相切 一全一半 叠加 求同存异 相对位置 内部还是外部 </description>
    </item>
    
    <item>
      <title>面试薄弱复习</title>
      <link>https://jianrongma.github.io/p/%E9%9D%A2%E8%AF%95%E8%96%84%E5%BC%B1%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 18 Jul 2022 16:34:40 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E9%9D%A2%E8%AF%95%E8%96%84%E5%BC%B1%E5%A4%8D%E4%B9%A0/</guid>
      <description> 算法
树 平衡二叉树 镜像二叉树 最低公共祖先 前序后续便利构造二叉树 节点和等于整数的路径 两个节点的最长距离 二叉查找树 链表 奇升偶降 如何有序 数组 二维数组旋转90° 2sum问题 位运算 动态规划 背包问题 0-1 背包问题 完全 排序 复杂度 冒泡 插入 归并 快排 希尔 堆排序 基数排序 桶排序 如何求中位数 大根堆与小根堆 优先队列 单调栈 单调队列 接雨水 最大矩形 滑动窗口 二分 DFS BFS 递归 回溯 LRU 辅助栈 并查集 堆栈
内存中的堆、栈、静态区 </description>
    </item>
    
    <item>
      <title>leetBook_冲刺攻略</title>
      <link>https://jianrongma.github.io/p/leetbook_%E5%86%B2%E5%88%BA%E6%94%BB%E7%95%A5/</link>
      <pubDate>Mon, 28 Feb 2022 12:11:37 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/leetbook_%E5%86%B2%E5%88%BA%E6%94%BB%E7%95%A5/</guid>
      <description>leetBook_冲刺攻略 image-20220227100312893根据提示的数据范围推定时间复杂度 根据时间复杂度推定算法集合 根据题目特征确定算法
image-20220227100007364没有给出数据范围通常使用枚举 枚举通常是n~nlog(n)的时间复杂度 然后再确定算法集合
image-20220227100056863image-20220228103152097image-20220228103157567</description>
    </item>
    
    <item>
      <title>活连上线学习文档</title>
      <link>https://jianrongma.github.io/p/%E6%B4%BB%E8%BF%9E%E4%B8%8A%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Thu, 28 Oct 2021 10:24:40 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E6%B4%BB%E8%BF%9E%E4%B8%8A%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>维保
优化内存占用 提高sql执行效率 索引 性能分析 慢查询日志 多线程上传数据 以后要设定阀值 上传数据总量等于5w(估算)的时候,先上传,放置因为很久没上传的数据因为累积过多,导致一次性上传50w数据裂开 image-20211117085507371</description>
    </item>
    
    <item>
      <title>Mysql高级</title>
      <link>https://jianrongma.github.io/p/test-chinese/</link>
      <pubDate>Tue, 12 Oct 2021 19:35:55 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/test-chinese/</guid>
      <description>Mysql高级学习文档 mysql的架构介绍 mysql简介 mysqllinux版安装 mysql配置文件 mysql逻辑架构介绍 mysql存储引擎 索引优化分析 性能下降sql慢是执行时间长还是等待时间长 常见通用的join查询 索引简介 性能分析 索引优化 查询截取分析 查询优化 慢查询日志 批量数据脚本 show profile 全局查询日志 mysql锁机制 锁的分类 主从复制 主从配置 mysql简介 高级mysql 完整的mysql优化
mysql内核 sql优化攻城狮 mysql服务器的优化 各种参数常量设定 查询语句优化 主从复制 软硬件升级 容灾备份 sql编程 mysqllinux版的安装 image-20211012195826053#查看当前ubuntu版本 yourtreedad@yourtreedad:~$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.3 LTS Release: 20.04 Codename: focal yourtreedad@yourtreedad:~$ 准备工作
#切换到root账户 yourtreedad@yourtreedad:~$ sudo passwd root New password: Retype new password: passwd: password updated successfully yourtreedad@yourtreedad:~$ su root Password: root@yourtreedad:/home/yourtreedad# #查看电脑里有没有mysql root@yourtreedad:/home/yourtreedad# service mysql status * MySQL is stopped.</description>
    </item>
    
    <item>
      <title>Mysql基础</title>
      <link>https://jianrongma.github.io/p/mysql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Oct 2021 23:44:44 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/mysql%E5%9F%BA%E7%A1%80/</guid>
      <description>mysql学习文档 一 为什么要学习数据库 二 数据库的相关概念 DBMS DB SQL
三 数据库存储数据的特点 四 初始mysql mysql产品的介绍
mysql产品的安装
mysql服务的启动和停止
mysql服务的登陆和退出
mysql的常见命令和语法规范
五DQL语言的学习 基础查询
条件查询
排序查询
常见函数
分组查询
连接查询
子查询
分页查询
union联合查询
六 DML语言的学习 插入语句
修改语句
删除语句
七 DDL语言的学习 库和表的管理
常见数据类型介绍
常见约束
保存数据的容器:
数组 集合 内存数据 断电就没了
文件 但是文件不好查找
因此把文件做成方便增删改查的软件 对文件进行操作 这样的软件就叫做数据库
数据库的好处 实现数据持久化 使用完整的管理系统统一管理,易于查询 数据库的概念 DB 数据库 database:存储数据的仓库,保存了一系列有组织的数据.
DBMS 数据库管理系统 database management system 数据库是通过dbms创建和操作的容器
常见的数据库管理系统 mysql oracle db2 sqlserver
SQL 结构化查询语言 structure query language :专门用来与数据库通信的语言</description>
    </item>
    
    <item>
      <title>数据结构与算法学习文档</title>
      <link>https://jianrongma.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:22:19 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>数据结构与算法 解决问题方法的效率，跟数据的组织方式有关。
循环和递归
解决问题方法的效率，跟空间的利用效率有关。
image-20210818161452286image-20210818162018882解决问题方法的效率，跟算法的巧妙程度有关
数据结构 数据对象在计算机中的组织方式
逻辑结构：线性结构和树结构、图结构 物理存储结构：数组、链表 数据对象必定与一系列加在其上的操作相关联
完成这些操作所用的方法就是算法
抽象数据类型(Abstract Data Type) 数据类型 数据对象集 数据集合相关联的操作集 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 与实现操作的算法和编程语言均无关 只描述数据对象集和相关操作集是什么，并不涉及如何做到的问题
抽象 image-20210818163548512算法 一个有限指令集 接收一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须 有充分明确的目标，不可以有歧义 计算机能处理的范围之内 描述应不依赖与任何一种计算机语言以及具体的实现手段 image-20210818164049310什么是好算法 空间复杂度sn 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。
时间复杂度Tn 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。
递归的时候会占用内存，因为递归下一层的时候要暂存上一层的结果
Sn = C*N
image-20210818164648695加减比乘除算的快
image-20210818164842726在分析一般算法的效率时，我们经常关注下面两种复杂度
最坏情况复杂度T worst(n) 平均复杂度T avg(n) 基本上就是第一种：最坏情况复杂度
image-20210818165255964image-20210818165445992image-20210818165457903image-20210818165643710image-20210818165759487image-20210818191956566image-20210818193405280image-20210818193945679image-20210818194726647什么是线性表 多项式表示问题的启示 同一个问题可以有不同的表示（存储）方法 有一类共性问题：有序线性序列的组织和管理 线性表 由同类型数据元素构成有序序列的线性结构
表中元素个数成为线性表的长度 线性表没有元素时，称为空表 表起始位置称表头，表结束位置称表尾 image-20210818195144256链式存储实现</description>
    </item>
    
    <item>
      <title>git学习文档</title>
      <link>https://jianrongma.github.io/p/git%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sat, 24 Jul 2021 16:18:59 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/git%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>Git学习文档 学习git之前，我们需要先明白一个概念，版本控制！
版本控制 什么是版本控制 版本迭代 版本管理器
版本控制（revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份一遍恢复以前的版本的软件工程技术。
实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术。
没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将引入很多问题，如关键代码的冗余，软件过程的事物性，软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。
多人开发就必须要使用版本控制，否则代价比较大
常见的版本控制工具
主流的版本控制器有如下这些：
Git SVN(subversion) CVS(concurrent versions system) VSS(Microsoft Visual SourceSafe) TFS(team Foundation Server) Visual Studio Online 版本控制产品非常的多（preforce 、 rational clearcase 、 rcs 、serena dimention 、 svk 、bitkeeper、 monotone 、 bazaar 、 mercurial 、 sourcegear vault），现在影响力最大且使用最广泛的是git和svn
版本控制分类
本地版本控制
记录文件每次的更新，可以对每个版本做一个快照，或者记录补丁文件，适合个人用，如RCS
image-20210722211743148集中版本控制
所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改
image-20210722211927845所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品有：SVN、CVS、VSS
分布版本控制 “GIT”
每个人都拥有全部的代码 安全隐患
所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题，就可以恢复所有的数据，但这增加了本地存储空间的占用
不会因为服务器损坏或者网络问题，造成不能工作的情况！
image-20210722212449100git和svn最主要区别
svn是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所有首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要吧自己做完的推送到中央服务器。集中式版本控制是必须连网才能工作，对网络带宽要求较高。</description>
    </item>
    
    <item>
      <title>计算机组成原理学习文档</title>
      <link>https://jianrongma.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Fri, 14 May 2021 00:26:49 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>计算机组成原理学习文档 CPU
内存
硬盘
主板
计算机硬件识别数据
高低电平0/1
通过电信号传递数据
金属针脚：传递电信号用的通道
通过很多条电路，可以传递多个二进制数位，每个二进制数位称为1bit比特
文字、数字、图像如何用二进制表示
如何存储二进制数
CPU如何对二进制数字进行加减乘除
如何从内存中取出想要的数据
CPU如何识别和执行我们写的程序
计算机系统 = 硬件 + 软件
硬件是计算机的实体，软件由具有各类特殊功能的程序组成
计算机性能的好坏取决于软硬件功能的总和
软件
系统软件：用来管理整个计算机系统
操作系统、DBMS、标准程序库、网络软件、语言处理程序、服务程序 应用软件
按照任务需要编制成的各种程序 硬件的发展
第一台电子数字计算机 ENIAC1946 冯诺依曼
逻辑元件：电子管
第一代：电子管时代 纸带机编程
第二代：晶体管 开始出现操作系统 开始出现高级语言
第三代：中小规模集成电路 高级语言迅速发展 开始出现分时操作系统
第四代：大规模、超大规模集成电路 出现微处理器、微型计算机、个人计算机PC萌芽 、 操作系统
微处理器的发展：
机器字长：计算机一次整数运算所能处理的二进制位数
摩尔定律：揭示了信息技术进步的速度，集成电路上可容纳的晶体管数目，约每隔18个月就会增加一倍，整体性能也将提升一倍
软件的发展：
机器语言010101=&amp;gt;汇编语言=&amp;gt;FORTRAN/PASCAL/C++=&amp;gt;java、python
DOC操作系统=&amp;gt;windows、android、ios
目前的发展趋势：
两极分化：
1.微型计算机更微型化、网络化、高性能、多用途方向发展
2.巨型化、超高速、并行处理、智能化方向发展
计算机硬件的基本组成：
1.早期冯诺依曼的结构
2.现代计算机的结构
ENIAC手动接线来控制计算
冯诺依曼：”存储程序“的概念是指将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
早期冯诺依曼机：
数据/程序：即软件
硬件：
输入设备：将信息转换成机器能识别的形式
存储器：存放数据和程序
运算器：算术运算和逻辑运算
控制器：指挥程序运行
输出设备：将结果转换成人们熟悉的形式
在计算机系统中，软件和硬件在逻辑上是等效的。
冯诺依曼计算机的特点：
计算机由5大部件组成：输入设备、输出设备、存储器、运算器、控制器 指令和数据以同等地位存储于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 输入/输出设备与存储器之间的数据传送通过运算器完成</description>
    </item>
    
    <item>
      <title>ApsDotnetCoreMVC学习文档</title>
      <link>https://jianrongma.github.io/p/apsdotnetcoremvc%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Fri, 16 Apr 2021 00:28:25 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/apsdotnetcoremvc%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>asp .net core mvc 学习文档 控制器向界面传值 通过viewbag/viewdata 来进行弱传递
controller中:
image-20210421230444662index中:
image-20210421230455113通过model进行强类型传递
controller中:
image-20210421230520009index中:
@model IEnumerable&amp;lt;webmvcdemo.Models.Movie&amp;gt; &amp;lt;form asp-controller=&amp;#34;Movies&amp;#34; asp-action=&amp;#34;Index&amp;#34; &amp;gt; &amp;lt;p&amp;gt; &amp;lt;select name=&amp;#34;prop&amp;#34; required=&amp;#34;&amp;#34;&amp;gt; @foreach (var item in typeof(Movie).GetProperties()) { &amp;lt;option value=@item.Name&amp;gt;@item.Name&amp;lt;/option&amp;gt; } &amp;lt;/select&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;SerachString&amp;#34;/&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34;&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; 界面向控制器传参 通过name来准确传递
index:
&amp;lt;select name=&amp;#34;prop&amp;#34; required=&amp;#34;&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;SerachString&amp;#34;/&amp;gt; 控制器中:
image-20210421230911623通过定位点标记帮助程序
https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/tag-helpers/built-in/anchor-tag-helper?view=aspnetcore-5.0#asp-route-value
Razor语法 使用@符号将c#转化为html代码提供展示 显式/隐式razor表达式 razor代码块 ​	Razor 代码块以开头 @ ，并由括起来 {} 。 代码块内的 C# 代码不会呈现，这点与表达式不同。 一个视图中的代码块和表达式共享相同的作用域并按顺序进行定义</description>
    </item>
    
    <item>
      <title>真会CSharp吗学习文档</title>
      <link>https://jianrongma.github.io/p/%E7%9C%9F%E4%BC%9Acsharp%E5%90%97%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sat, 30 Jan 2021 00:17:57 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/%E7%9C%9F%E4%BC%9Acsharp%E5%90%97%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</guid>
      <description>C#5.0+学习文档 特点：
通用性语言 类型安全 面向对象 目标：生产力
简洁性 表达力 高性能 平台中立，与平台无关
封装、继承、多态
统一的类型系统：
类型 共同的基类 类和接口
class interface 属性property、方法method和事件event
唯一一种函数成员(Function Member):方法(method)
方法还包括：属性(Property)和事件(Event)还有其他的
属性
事件
C#主要是一种面向对象的语言，但是也借用了不少函数式编程的特性
函数可以当做值来对待
委托Delegate 支持纯(purity)模式
避免使用值可变的变量 类型安全
c#主要来说是类型安全的 静态类型 static typing 动态类型 dynamic 强类型 strongly typed language 内存管理
依赖于运行时来执行自动内存管理 CLR:Common Language Runtime (公共语言运行时) GC： Garbage Collector (垃圾收集器) c#没有消灭指针 通常情况下不需要使用指针 unsafe 平台支持
原来c#主要是在window上面运行
现在可以在所有的平台上运行
windows macs linux ios android &amp;hellip; .Net Core
.Net/.Net Core 的核心就是CLR: Comman Language Runtime
CLR和语言无关</description>
    </item>
    
    <item>
      <title>windows服务开发备忘</title>
      <link>https://jianrongma.github.io/p/windows%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98/</link>
      <pubDate>Fri, 01 Oct 1999 09:17:59 +0800</pubDate>
      
      <guid>https://jianrongma.github.io/p/windows%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98/</guid>
      <description>windows服务开发备忘 先开个窗体来调试试试看
再新增一个service服务进来
修改默认服务名
添加安装程序 修改为本地
image-20210928105412125记得引入日志 并将config文件复制到输出目录
有时候install.bat命令不行可能是系统没有权限
跑服务的时候记得再program里改成服务,别泡成窗体应用了
服务的onstart里需要写的是异步方法或者新开一个线程,否则会出现无法服务进程无法连接到服务控制器上的错误
image-20210928105853916image-20210928105911601接口服务嘛,最好尝试ping一下服务器,服务器畅通才能工作
另外最好对间隔时间做到可配置</description>
    </item>
    
  </channel>
</rss>
