<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='docker学习   docker概述
  docker安装
  docker命令
 镜像命令 容器命令 操作命令 &amp;hellip;    docker镜像
  容器数据卷
  dockerfile
  docker网络原理
  idea整合docker
  以上单机版本docker
 集群 docker compose docker swarm 简化版k8s ci/cd jenkins  docker概述
开发&amp;ndash;上线 两套环境 应用环境，应用配置
开发人员 运维人员
开发即运维！
环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop&amp;hellip;）费事费力
发布项目 jar（redis mysql jdk es） war
jar带上环境进行发布，项目能不能带上环境安装打包
之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台
windows与linux
传统：开发提供jar 运维部署环境
现在：开发打包部署上线，一套流程做完'><title>DockerLearning</title>

<link rel='canonical' href='https://linjianshu.github.io/p/dockerlearning/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='DockerLearning'>
<meta property='og:description' content='docker学习   docker概述
  docker安装
  docker命令
 镜像命令 容器命令 操作命令 &amp;hellip;    docker镜像
  容器数据卷
  dockerfile
  docker网络原理
  idea整合docker
  以上单机版本docker
 集群 docker compose docker swarm 简化版k8s ci/cd jenkins  docker概述
开发&amp;ndash;上线 两套环境 应用环境，应用配置
开发人员 运维人员
开发即运维！
环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop&amp;hellip;）费事费力
发布项目 jar（redis mysql jdk es） war
jar带上环境进行发布，项目能不能带上环境安装打包
之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台
windows与linux
传统：开发提供jar 运维部署环境
现在：开发打包部署上线，一套流程做完'>
<meta property='og:url' content='https://linjianshu.github.io/p/dockerlearning/'>
<meta property='og:site_name' content='think hy how to learn'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2021-09-01T00:23:34&#43;08:00'/><meta property='article:modified_time' content='2021-09-01T00:23:34&#43;08:00'/><meta property='og:image' content='https://linjianshu.github.io/' />
<meta name="twitter:site" content="@ljs56495989">
    <meta name="twitter:creator" content="@ljs56495989"><meta name="twitter:title" content="DockerLearning">
<meta name="twitter:description" content="docker学习   docker概述
  docker安装
  docker命令
 镜像命令 容器命令 操作命令 &amp;hellip;    docker镜像
  容器数据卷
  dockerfile
  docker网络原理
  idea整合docker
  以上单机版本docker
 集群 docker compose docker swarm 简化版k8s ci/cd jenkins  docker概述
开发&amp;ndash;上线 两套环境 应用环境，应用配置
开发人员 运维人员
开发即运维！
环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop&amp;hellip;）费事费力
发布项目 jar（redis mysql jdk es） war
jar带上环境进行发布，项目能不能带上环境安装打包
之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台
windows与linux
传统：开发提供jar 运维部署环境
现在：开发打包部署上线，一套流程做完"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://linjianshu.github.io/' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://linjianshu.github.io/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="/p/dockerlearning/">DockerLearning</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 01, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 16 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h3 id="docker学习">docker学习</h3>
<ul>
<li>
<p>docker概述</p>
</li>
<li>
<p>docker安装</p>
</li>
<li>
<p>docker命令</p>
<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>&hellip;</li>
</ul>
</li>
<li>
<p>docker镜像</p>
</li>
<li>
<p>容器数据卷</p>
</li>
<li>
<p>dockerfile</p>
</li>
<li>
<p>docker网络原理</p>
</li>
<li>
<p>idea整合docker</p>
</li>
</ul>
<p>以上单机版本docker</p>
<ul>
<li>集群 docker compose</li>
<li>docker swarm  简化版k8s</li>
<li>ci/cd jenkins</li>
</ul>
<p>docker概述</p>
<p>开发&ndash;上线 两套环境 应用环境，应用配置</p>
<p>开发人员   运维人员</p>
<p>开发即运维！</p>
<p>环境配置麻烦，每个机器都要部署环境（集群redis、es、hadoop&hellip;）费事费力</p>
<p>发布项目 jar（redis mysql jdk es） war</p>
<p>jar带上环境进行发布，项目能不能带上环境安装打包</p>
<p>之前在服务器配置一个应用的环境 redis mysql jdk es hadoop ，配置超麻烦，不能跨平台</p>
<p>windows与linux</p>
<p>传统：开发提供jar 运维部署环境</p>
<p>现在：开发打包部署上线，一套流程做完</p>
<p>docker给以上的问题，提出解决方案</p>
<p>java&mdash;apk&mdash;发布（应用商店） &mdash;张三使用apk &mdash;安装即可用</p>
<p>java&mdash;jar（环境）&mdash;打包项目带上环境（镜像） &mdash;-docker仓库：商店 &mdash;- 下载我们发布的镜像 &ndash;直接运行即可</p>
<p>docker思想就来自于集装箱！</p>
<p>jre&mdash;多个应用 （端口冲突）&mdash;原来都是交叉的</p>
<p>隔离：Docker核心思想，打包装箱！每个箱子都是互相隔离的！</p>
<p>docker通过隔离机制，可以将服务器利用到极致</p>
<p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习。</p>
<p>docker历史</p>
<p>容器化技术命名就是docker</p>
<p>刚刚诞生的时候没有引起行业注意！dotcloud，开源</p>
<p>开源，docker优点</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术，</p>
<p>虚拟机：在windows中装一个虚拟机软件vmware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机：也是属于虚拟化技术，docker容器技术，也是一种虚拟化技术</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">vm：linux centos 原生镜像（一个电脑） 隔离：需要开启多个虚拟机  几分钟
docker：隔离  镜像机制（最核心的环境 4m +jdk+mysql）十分小巧，运行镜像就可以了 几M 几s
</code></pre></div><p>docker是基于go语言开发的！开源</p>
<p>docker的文档超级详细</p>
<p>仓库地址：pull push</p>
<p>docker能干嘛</p>
<p>之前的虚拟机技术！</p>
<p>从内核到库函数到app</p>
<p>虚拟机技术缺点：</p>
<p>1.资源占用十分多</p>
<p>2.冗余步骤多</p>
<p>3.启动很慢</p>
<p>容器化技术</p>
<p>容器化技术不是模拟一个完整的操作系统</p>
<p>比较docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<p>devops</p>
<p>更快速的交付和部署</p>
<p>传统：一堆帮助文档，安装程序</p>
<p>docker：一键运行，打包镜像，发布测试</p>
<p>更便捷的升级和扩缩容</p>
<p>使用了docker之后，我们部署应用就和搭积木一样</p>
<p>springboot1.5  redis5 tomcat8</p>
<p>项目打包为一个镜像，扩展，服务器A！开服务器B，做扩展</p>
<p>更简单的系统运维</p>
<p>在容器化之后，我们的开发，测试环境高度一致</p>
<p>更高效的利用计算资源：</p>
<p>1核 2g的服务器！</p>
<p>docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例，服务器的性能可以运行到极致</p>
<p>docker的基本组成</p>
<p>镜像：image  就是一个类，好比一个模版，可以通过这个模版来创建容器服务，tomcat镜像&ndash;&gt;run&mdash;&ndash;&gt;tomcat01容器（提供服务） 通过这个镜像可以创建多个容器（最终服务或者项目运行就是在容器中）</p>
<p>容器：container   docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动、停止、删除、基本命令！目前就可以吧容器理解为就是一个简易的linux系统</p>
<p>仓库：respository  仓库就是存放镜像的地方 仓库分为公有仓库和私有仓库！ dockerhub 阿里云 都有容器服务器（配置镜像加速）！</p>
<p>安装docker</p>
<p>1.需要linux基础</p>
<p>2.centos7</p>
<p>3.使用xshell连接远程服务器进行操作</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210607214021379.png" >
		<img src="/DockerLearning.assets/image-20210607214021379.png"
			
			
			
			loading="lazy"
			alt="image-20210607214021379">
	</a>
	
	<figcaption>image-20210607214021379</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210607214316440.png" >
		<img src="/DockerLearning.assets/image-20210607214316440.png"
			
			
			
			loading="lazy"
			alt="image-20210607214316440">
	</a>
	
	<figcaption>image-20210607214316440</figcaption>
	
</figure></p>
<p>查看一下下载的这个hello-world镜像</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210607214400376.png" >
		<img src="/DockerLearning.assets/image-20210607214400376.png"
			
			
			
			loading="lazy"
			alt="image-20210607214400376">
	</a>
	
	<figcaption>image-20210607214400376</figcaption>
	
</figure></p>
<p>阿里云镜像加速</p>
<p>1.登陆阿里云</p>
<p>2.容器镜像服务</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210607215031767.png" >
		<img src="/DockerLearning.assets/image-20210607215031767.png"
			
			
			
			loading="lazy"
			alt="image-20210607215031767">
	</a>
	
	<figcaption>image-20210607215031767</figcaption>
	
</figure></p>
<p>3.配置使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <span class="s">&lt;&lt;-&#39;EOF&#39;
</span><span class="s">{
</span><span class="s">  &#34;registry-mirrors&#34;: [&#34;https://lufuant6.mirror.aliyuncs.com&#34;]
</span><span class="s">}
</span><span class="s">EOF</span>
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre></div><p>回顾helloworld流程</p>
<p>开始&ndash;&gt;本地寻找镜像&ndash;&gt;如果有就使用这个镜像运行，如果没有就去仓库下载pull</p>
<p>底层原理</p>
<p>docker怎么工作的</p>
<p>docker是一个client&ndash;server结构的系统，docker的守护进程运行在主机上，通过socket从客户端访问</p>
<p>dockerserver接收到docker-client的指令，就会执行这个命令</p>
<p>docker为什么比vm快</p>
<p>1.docker有着比虚拟机更少的抽象层</p>
<p>2.docker利用的是宿主机的内核，vm需要guest OS</p>
<p>所以新建一个容器的时候， docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载guestOS，分钟级别的，而docker是利用宿主；机加的操作系统，省略了这个复杂的过程，妙级的</p>
<p>docker的常用命令</p>
<p>帮助命令</p>
<p>docker version</p>
<p>docker info</p>
<p>docker 命令 &ndash;help</p>
<p>镜像命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker images
docker search 
docker pull
docker rmi 
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210607222535947.png" >
		<img src="/DockerLearning.assets/image-20210607222535947.png"
			
			
			
			loading="lazy"
			alt="image-20210607222535947">
	</a>
	
	<figcaption>image-20210607222535947</figcaption>
	
</figure></p>
<p>容器命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker pull centos
</code></pre></div><p>新建容器并启动</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker run <span class="o">[]</span> image
--name <span class="o">=</span><span class="s2">&#34;&#34;</span> 容器名字

-d 后台方式运行
-i  使用交互方式运行， 进入容器查看内容 
-t
-p 指定容器的端口-p 8080:8080

主机端口：容器端口
-p 容器端口
-p ip：主机端口：容器端口

<span class="nb">exit</span> 从容器中退回主机
docker ps 列出所有运行容器
-a 所有正在运行的容器+运行过的容器
-n<span class="o">=</span>? 显示最近创建的容器
docker ps -q 只显示容器的编号

</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210608200503679.png" >
		<img src="/DockerLearning.assets/image-20210608200503679.png"
			
			
			
			loading="lazy"
			alt="image-20210608200503679">
	</a>
	
	<figcaption>image-20210608200503679</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210608200706097.png" >
		<img src="/DockerLearning.assets/image-20210608200706097.png"
			
			
			
			loading="lazy"
			alt="image-20210608200706097">
	</a>
	
	<figcaption>image-20210608200706097</figcaption>
	
</figure></p>
<p>退出容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">exit</span> 退出容器，并停止
ctrl+P+Q
</code></pre></div><p>删除容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker rm 容器id		
docker rm -f <span class="k">$(</span>docker ps -aq<span class="k">)</span>

</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210608201640486.png" >
		<img src="/DockerLearning.assets/image-20210608201640486.png"
			
			
			
			loading="lazy"
			alt="image-20210608201640486">
	</a>
	
	<figcaption>image-20210608201640486</figcaption>
	
</figure></p>
<p>启动停止容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker start 容器id
docker restart 容器id
docker stop 容器id
docker <span class="nb">kill</span> 容器id
 
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210608203048244.png" >
		<img src="/DockerLearning.assets/image-20210608203048244.png"
			
			
			
			loading="lazy"
			alt="image-20210608203048244">
	</a>
	
	<figcaption>image-20210608203048244</figcaption>
	
</figure></p>
<p>常用其他命令</p>
<p>后台启动</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker run -d centos docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止dockerlogs 
</code></pre></div><p>查看容器当中的进程信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker top 命令docker inspect 容器id 查看容器信息
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609223653271.png" >
		<img src="/DockerLearning.assets/image-20210609223653271.png"
			
			
			
			loading="lazy"
			alt="image-20210609223653271">
	</a>
	
	<figcaption>image-20210609223653271</figcaption>
	
</figure></p>
<p>进入当前正在进行的容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置docker <span class="nb">exec</span> -it 容器id docker attach 容器id正在执行当前的代码exec进入容器后开启一个新的终端，可以在里面操作（常用）attach 进入容器正在执行的终端，不会启动新的进程
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609224319430.png" >
		<img src="/DockerLearning.assets/image-20210609224319430.png"
			
			
			
			loading="lazy"
			alt="image-20210609224319430">
	</a>
	
	<figcaption>image-20210609224319430</figcaption>
	
</figure></p>
<p>从容器内拷贝文件到主机上</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker cp 容器id ：容器内路径  目的的主机路径 
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609230304773.png" >
		<img src="/DockerLearning.assets/image-20210609230304773.png"
			
			
			
			loading="lazy"
			alt="image-20210609230304773">
	</a>
	
	<figcaption>image-20210609230304773</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">当前主机目录root@yourtreedad:~# <span class="nb">cd</span> /homeroot@yourtreedad:/home#  lskuanshen.java  test.javaroot@yourtreedad:/home# touch kuangshen.javaroot@yourtreedad:/home#  lskuangshen.java  kuanshen.java  test.java进入容器内部root@yourtreedad:/home# docker attach 3a26ef468c27<span class="o">[</span>root@3a26ef468c27 /<span class="o">]</span><span class="c1"># cd /homebash: cd: $&#39;\343/home&#39;: No such file or directory[root@3a26ef468c27 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@3a26ef468c27 /]# cd /home[root@3a26ef468c27 home]# ls创建文件[root@3a26ef468c27 home]# touch test1.java[root@3a26ef468c27 home]# lstest1.java退出容器[root@3a26ef468c27 home]# exitexitroot@yourtreedad:/home# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESroot@yourtreedad:/home# docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                           PORTS               NAMES3a26ef468c27        centos              &#34;/bin/bash&#34;         20 minutes ago      Exited (0) 16 seconds ago                            suspicious_wilburcee72dcd9187        centos              &#34;-it /bin/bash&#34;     21 minutes ago      Created                                              eager_einstein73d060aad5ac        centos              &#34;/bin/bash&#34;         27 hours ago        Exited (255) About an hour ago                       optimistic_leakey从容器内拷贝文件至主机root@yourtreedad:/home# docker cp 3a26ef468c27:/home/test1.java /homeroot@yourtreedad:/home# lskuangshen.java  kuanshen.java  test.java  test1.java拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步</span>
</code></pre></div><p>docker命令很多，以上是最常用的</p>
<p>docker安装nginx</p>
<p>1.搜索镜像</p>
<p>2.下载镜像</p>
<p>3.启动镜像</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609233757534.png" >
		<img src="/DockerLearning.assets/image-20210609233757534.png"
			
			
			
			loading="lazy"
			alt="image-20210609233757534">
	</a>
	
	<figcaption>image-20210609233757534</figcaption>
	
</figure></p>
<p>测试</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609234211565.png" >
		<img src="/DockerLearning.assets/image-20210609234211565.png"
			
			
			
			loading="lazy"
			alt="image-20210609234211565">
	</a>
	
	<figcaption>image-20210609234211565</figcaption>
	
</figure></p>
<p>端口映射</p>
<p>进入容器，查看文件</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210609234650627.png" >
		<img src="/DockerLearning.assets/image-20210609234650627.png"
			
			
			
			loading="lazy"
			alt="image-20210609234650627">
	</a>
	
	<figcaption>image-20210609234650627</figcaption>
	
</figure></p>
<p>思考问题：每次改动nignx配置文件，都需要进入容器内部？都十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件，容器内部就可以自动修改？  -v 数据卷技术</p>
<p>docker装一个tomcat</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker run -it --rm tomcat:9.0之前的启动都是后台，停止了容器之后，容器还是可以查到docker run -it --rm 一般用来测试，用完就删除进入容器PS C:<span class="se">\U</span>sers<span class="se">\S</span>weetie&gt; docker run -d -p 3355:8080 --name tomcat01 tomcatc42f39b1590834eb3720faa3cee74b79a909550fe02bc2ed383676908c3accf2PS C:<span class="se">\U</span>sers<span class="se">\S</span>weetie&gt; docker <span class="nb">exec</span> -it tomcat01 /bin/bashroot@c42f39b15908:/usr/local/tomcat# lslinux命令少了没有webapps阿里云镜像原因，默认是最小的镜像，所有的不必要的都剔除了。保证最小可运行的环境root@c42f39b15908:/usr/local/tomcat/webapps# <span class="nb">cd</span> ..root@c42f39b15908:/usr/local/tomcat# lsBUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  workroot@c42f39b15908:/usr/local/tomcat# <span class="nb">cd</span> webapps.distroot@c42f39b15908:/usr/local/tomcat/webapps.dist# lsROOT  docs  examples  host-manager  managerroot@c42f39b15908:/usr/local/tomcat/webapps.dist# <span class="nb">cd</span> ..root@c42f39b15908:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@c42f39b15908:/usr/local/tomcat# <span class="nb">cd</span> webappsroot@c42f39b15908:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager
</code></pre></div><p>以后要部署项目，如果每次都要进入容器是不是十分麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷技术</p>
<p>webapps，在外部放置项目，就自动同步到内部就好了！！！</p>
<p>docker容器 tomcat+网站 docker+mysql</p>
<p>部署es+kibana</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">es暴露的端口很多es十分耗内存es的数据一般需要放置在安全目录！挂载--net somenetwork ? 网络配置下载启动docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e <span class="s2">&#34;discovery.type=single-node&#34;</span>elasticsearch:7.6.2一启动就顶不住了，很好内存docker statuc 查看cpu的状态赶紧关闭，增加内存的限制，修改配置文件 -e 配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class="s2">&#34;discovery.type=single-node&#34;</span> -e <span class="nv">ES_JAVA_OPTS</span><span class="o">=</span><span class="s2">&#34;-Xms64m -Xmx512m&#34;</span> elasticsearch:7.6.2环境配置
</code></pre></div><p>作业：使用kibana 连接elasticsearch</p>
<p>因为相互隔离，所以直接localhost来连不现实，可以使用linux内网ip来搞，需要了解docker网络原理，网络的基本知识</p>
<p>可视化</p>
<ul>
<li>
<p>portainer先用这个</p>
</li>
<li>
<p>rancher（CI、CD再用）</p>
</li>
</ul>
<p>什么是portainer</p>
<p>docker图形化界面管理工具！提供一个后台面板，供我们操作！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker run -d -p 8088:9000 --restart<span class="o">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="o">=</span><span class="nb">true</span> portainer/portainer访问测试 外网8088端口通过它来访问可视化面板，我们平时不会使用，测试玩玩即可
</code></pre></div><p>docker镜像讲解</p>
<p>镜像是什么</p>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件</p>
<p>所有的应用，直接打包docker镜像，就可以直接跑起来</p>
<p>如何得到镜像：</p>
<ul>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像 dockerfile</li>
</ul>
<p>unionFS联合文件系统</p>
<p>我们下载的时候看到的一层层的就是这个</p>
<p>unionfs联合文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改，作为一次提交来一层层叠加，同时可以将不同目录挂在到同一个虚拟文件系统下unite several directories into a single virtual filesystem 。union文件系统是docker 镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p>docker镜像加载原理</p>
<p>docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS</p>
<p>bootfs （boot file system ） 主要包含bootloader 和 kernel ，bootloader 主要是引导加载kernel ， linux 刚启动时会加载 bootfs 文件系统，在docker 镜像的最底层是bootfs。这一层与我们典型的linu/unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</p>
<p>rootfs（root file system），在bootfs之上，包含的就是典型linux系统中的 /dev , /proc / bin , /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如ubuntu，centos等等</p>
<p>平时我们安装进虚拟机的centos都是好几个G，为什么docker这里才200M</p>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版本可以共用bootfs</p>
<p>分层理解</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">PS C:<span class="se">\U</span>sers<span class="se">\S</span>weetie&gt; docker pull redisUsing default tag: latestlatest: Pulling from library/redis69692152171a: Already existsa4a46f2fd7e0: Pull completebcdf6fddc3bd: Pull complete2902e41faefa: Pull completedf3e1d63cdb1: Pull completefa57f005a60d: Pull <span class="nb">complete</span>
</code></pre></div><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层在下载的！</p>
<p>思考：为什么docker镜像要采用这种分层的结构呢？</p>
<p>最大的好处，我觉得莫过于是资源共享！比如有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">     <span class="o">}</span>,        <span class="s2">&#34;RootFS&#34;</span>: <span class="o">{</span>            <span class="s2">&#34;Type&#34;</span>: <span class="s2">&#34;layers&#34;</span>,            <span class="s2">&#34;Layers&#34;</span>: <span class="o">[</span>                <span class="s2">&#34;sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33&#34;</span>,                <span class="s2">&#34;sha256:ec5652c3523d96657d66169c0eb71b572ff065711c705a15ec02f60a21c212c3&#34;</span>,                <span class="s2">&#34;sha256:76d3e24d63f60e6a73af70be15959eb4021dd7a5a09da6925037d3b4a1673fca&#34;</span>,                <span class="s2">&#34;sha256:f06719b0aa43029f32c821c8f14f9f5941a8be6d3b61dcd9f3f884b39e9a4f23&#34;</span>,                <span class="s2">&#34;sha256:b896f490f2edc62cc9d190465bbeab871619590d1e9beeffb92e4ca9cc08116d&#34;</span>,                <span class="s2">&#34;sha256:e3f4077f577bf07c0940d6345ddd17014ff824d3f4f7f3effc9a8c4dae3e527b&#34;</span>            <span class="o">]</span>        <span class="o">}</span>,        <span class="s2">&#34;Metadata&#34;</span>: <span class="o">{</span>            <span class="s2">&#34;LastTagTime&#34;</span>: <span class="s2">&#34;0001-01-01T00:00:00Z&#34;</span>        <span class="o">}</span>
</code></pre></div><p>理解：</p>
<p>所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于ubuntu linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加python包，该镜像就会在基础镜像层之上创建第二个镜像层，如果继续添加一个安全不定，就会创建第三个镜像层。</p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。</p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像中。docker通过存储引擎（新版本采用快照机制）的方式来实现惊险层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种引擎都有其独有的性能特点。</p>
<p>Docker在windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和cow</p>
<p>docker镜像都是只读的，一个新的刻写层被加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像</p>
<p>如何提交一个自己的镜像</p>
<p>commit镜像</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker commit 提交容器成为一个新的副本docker commit -m<span class="o">=</span><span class="s2">&#34;提交的描述信息&#34;</span> -a<span class="o">=</span><span class="s2">&#34;作者&#34;</span> 容器id 目标镜像名:<span class="o">[</span>TAG<span class="o">]</span>  
</code></pre></div><p>测试</p>
<ul>
<li>启动默认tomcat</li>
<li>没有文件的webapps</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@e7c2f9ef26e4:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@e7c2f9ef26e4:/usr/local/tomcat# lsBUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  workroot@e7c2f9ef26e4:/usr/local/tomcat# <span class="nb">cd</span> webappsroot@e7c2f9ef26e4:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager
</code></pre></div><ul>
<li>cp命令拷贝进webapps</li>
</ul>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210612162156751.png" >
		<img src="/DockerLearning.assets/image-20210612162156751.png"
			
			
			
			loading="lazy"
			alt="image-20210612162156751">
	</a>
	
	<figcaption>image-20210612162156751</figcaption>
	
</figure></p>
<ul>
<li>浏览器可以访问</li>
<li>commit提交为一个新的镜像，我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改过的镜像</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">PS C:<span class="se">\U</span>sers<span class="se">\S</span>weetie&gt; docker commit -m<span class="o">=</span><span class="s2">&#34;add webapps app&#34;</span> -a<span class="o">=</span><span class="s2">&#34;ljs&#34;</span> e7c2f9ef26e4  tomcatupdate1.0sha256:2a308d5b7f5a2b5b471a193c596369ee1ec2168d04221397ced9c9201a94075ePS C:<span class="se">\U</span>sers<span class="se">\S</span>weetie&gt; docker imagesREPOSITORY            TAG       IMAGE ID       CREATED         SIZEtomcatupdate1.0       latest    2a308d5b7f5a   <span class="m">8</span> seconds ago   672MBredis                 latest    fad0ee7e917a   <span class="m">10</span> days ago     105MBnginx                 latest    d1a364dc548d   <span class="m">2</span> weeks ago     133MBtomcat                latest    c43a65faae57   <span class="m">4</span> weeks ago     667MBportainer/portainer   latest    580c0e4e98b0   <span class="m">2</span> months ago    79.1MBcentos                latest    300e315adb2f   <span class="m">6</span> months ago    209MBelasticsearch         7.6.2     f29a1ee41030   <span class="m">14</span> months ago   791MBelasticsearch         latest    5acf0e8da90b   <span class="m">2</span> years ago     486MB
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210612162537739.png" >
		<img src="/DockerLearning.assets/image-20210612162537739.png"
			
			
			
			loading="lazy"
			alt="image-20210612162537739">
	</a>
	
	<figcaption>image-20210612162537739</figcaption>
	
</figure></p>
<p>如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像。</p>
<p>就好比以前我们学习VM的时候，快照</p>
<p>到这里才算入门</p>
<p>容器数据卷、dockerfile、docker网络：docker精髓</p>
<p>企业实战</p>
<p>docker compose</p>
<p>docker swarm</p>
<p>ci 、 cd  jenkins 流水线</p>
<p>容器数据卷</p>
<p>什么是容器数据卷</p>
<p>docker的理念回顾：</p>
<p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们把容器删除，数据就会丢失！</p>
<p>需求：数据可以持久化</p>
<p>MYsql，容器删了，删库跑路!</p>
<p>需求：MYsql的数据可以存储在本地！</p>
<p>容器之间可以有一个容器共享的技术！docker容器中产生的数据，同步到本地！</p>
<p>这就是数据卷技术！目录的挂载，将容器内的目录挂载linux上</p>
<p>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</p>
<p>使用数据卷</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">方式一：直接使用命令挂载-v docker run -it -v 主机目录地址：容器内目录地址 -p 主机端口：容器端口root@yourtreedad:~# <span class="nb">cd</span> /homeroot@yourtreedad:/home# lskuangshen.java  kuanshen.java  test.java  test1.javaroot@yourtreedad:/home# <span class="nb">cd</span> ..root@yourtreedad:/# docker run -it -v /home/ceshi:/home centos /bin/bash
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210612164241555.png" >
		<img src="/DockerLearning.assets/image-20210612164241555.png"
			
			
			
			loading="lazy"
			alt="image-20210612164241555">
	</a>
	
	<figcaption>image-20210612164241555</figcaption>
	
</figure></p>
<p>使用 docker inspect 容器id 查看具体信息</p>
<p>在外面建立文件，可以看到里面也有</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@ffb011d1322a /<span class="o">]</span><span class="c1"># cd home[root@ffb011d1322a home]# lsouttoint.txt</span>
</code></pre></div><p>在里面见文件，可以看到里面也有</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@ffb011d1322a home<span class="o">]</span><span class="c1"># touch intoout.java[root@ffb011d1322a home]# lsintoout.java  outtoint.txt[root@ffb011d1322a home]# exitexitroot@yourtreedad:/# docker psCONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                       NAMESffb011d1322a        centos                &#34;/bin/bash&#34;         12 minutes ago      Up 10 minutes                                                   eager_heyrovskye7c2f9ef26e4        tomcat:latest         &#34;catalina.sh run&#34;   34 minutes ago      Up 34 minutes       0.0.0.0:5555-&gt;8080/tcp                      sweet_ramanujanb90d3528ae04        portainer/portainer   &#34;/portainer&#34;        6 hours ago         Up 37 minutes       0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp   confident_villaniroot@yourtreedad:/# cd homeroot@yourtreedad:/home# cd ceshiroot@yourtreedad:/home/ceshi# lsintoout.java  outtoint.txtroot@yourtreedad:/home/ceshi#</span>
</code></pre></div><p>容器停止了，但是只要容器还在，就能实现同步数据，类似双向绑定</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210612165925505.png" >
		<img src="/DockerLearning.assets/image-20210612165925505.png"
			
			
			
			loading="lazy"
			alt="image-20210612165925505">
	</a>
	
	<figcaption>image-20210612165925505</figcaption>
	
</figure></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<p>实战：安装mysql</p>
<p>思考：mysql的数据持久化的问题！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">获取镜像docker pull mysql运行容器，需要做数据挂载，需要配置密码，这需要注意官方测试：docker run --name some-mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>my-secret-pw -d mysql:tag-d 后台运行-p 端口映射-v 数据卷挂在-e 环境配置--namedocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="m">123456</span> --name mysql01 mysql:5.7启动成功之后，我们在本地使用 sqlyog 来测试一下sqlyog --h -u -p 连接到服务器的3310 ----3310 和容器内的3306进行映射，这个时候我们就可以连接上了 在本地测试创建一个数据库，查看一下映射的路径是否ok假设我们将容器删除，发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210612172111412.png" >
		<img src="/DockerLearning.assets/image-20210612172111412.png"
			
			
			
			loading="lazy"
			alt="image-20210612172111412">
	</a>
	
	<figcaption>image-20210612172111412</figcaption>
	
</figure></p>
<p>具名挂载和匿名挂载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">匿名挂载-v 容器内路径   相当于不指定主机的地址，直接指定容器地址root@yourtreedad:/# docker run -d -P --name nginx01 -v /etc/nginx nginx查看所有卷的情况docker volume ls这里发现 DRIVER              VOLUME NAMElocal               0faef3ffc2187555023c9a8e5dca5c11e47f0b436657e48f95e972e33c951c49这种就是匿名挂载，我们-v的时候只写了容器的路径，没有写容器外的路径！通过-v 卷名：容器内路径这就是具名挂载root@yourtreedad:/# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx11c306e0a80402c0c235042326f5db9da58570e01abac55379414d9d53abc797root@yourtreedad:/# docker volume lsDRIVER              VOLUME NAMElocal               0faef3ffc2187555023c9a8e5dca5c11e47f0b436657e48f95e972e33c951c49local               3c63eeef73128b24bbf1830f9cec7d383aae8413e232a857f1216456fb07fedflocal               941b4501fa7cefd9a341366fbe18cfeddd0f2d223c1eb87addf1a77a42c2ace8local               3826373b692739fc44eac10a00d8ddada7b0200c5833963c459d6db001384a70local               8440372a24dc57f1bcf100c1ef256abbff5713f1c96c2bd65276aea10f54864dlocal               cb64d53be430f816088a1f1bbd1f5aea8885a1be33ddd98a5fb98a9d452fa03clocal               juming-nginx查看一下这个卷挂载在主机的哪个位置了呢root@yourtreedad:/# docker volume inspect juming-nginx<span class="o">[</span>    <span class="o">{</span>        <span class="s2">&#34;CreatedAt&#34;</span>: <span class="s2">&#34;2021-06-13T02:11:30Z&#34;</span>,        <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;local&#34;</span>,        <span class="s2">&#34;Labels&#34;</span>: null,        <span class="s2">&#34;Mountpoint&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/juming-nginx/_data&#34;</span>,        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;juming-nginx&#34;</span>,        <span class="s2">&#34;Options&#34;</span>: null,        <span class="s2">&#34;Scope&#34;</span>: <span class="s2">&#34;local&#34;</span>    <span class="o">}]</span>所有docker容器内的卷，如果没有指定目录的情况下，都是在/var/lib/docker/volumes/xxxx下我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用的是具名挂载
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613100849422.png" >
		<img src="/DockerLearning.assets/image-20210613100849422.png"
			
			
			
			loading="lazy"
			alt="image-20210613100849422">
	</a>
	
	<figcaption>image-20210613100849422</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">如何确定是具名挂载还是匿名挂载 ，还是指定路径挂载-v 容器内路径 这就是匿名挂载-v 卷名：容器内路径 这就是具名挂载-v /宿主机路径：/容器内路径 这就是指定路径挂载拓展：通过 -v 容器内路径，ro 、 rw 改变读写权限docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx只读ro readonly可读可写rw readwrite一旦设置了ro 容器对我们挂载出来的内容就有限定了！ro只要看到ro，就说明这个路径只能通过宿主机来操作，容器内部是无法操作的
</code></pre></div><p>初识dockerfile</p>
<p>方式二：</p>
<p>dockerfile就是用来构建docker镜像的构建文件！命令脚本！先体验一下！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">ctrl+U 删除当前命令mkdir 生成文件夹rm -rf 文件夹名字 强制删除文件夹名字pwd  查看当前在那个目录中进入文件后 esc 再：wq就是保存并退出vim 使用文本编辑器进入文件a后就可以编辑通过脚本可以生成镜像，镜像是一层一层的 touch 创建一个文件##创建一个dockerfile文件，名字可以随机，建议 dockerfile##文件中的内容 指令都是大写  参数##这里的每个命令，都是镜像的一层FROM centosVOLUME<span class="o">[</span><span class="s2">&#34;volume01&#34;</span>,<span class="s2">&#34;volume02&#34;</span><span class="o">]</span>CMD <span class="nb">echo</span> <span class="s2">&#34;-----end-----&#34;</span>CMD /bin/bash好像要空行！！！！通过dockerfile 去构建镜像root@yourtreedad:/home/docker-test-volume# docker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos:1.0 .
</code></pre></div><p>启动一下自己的生成的容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker imagesREPOSITORY               TAG                 IMAGE ID            CREATED             SIZEtomcatupdate             1.0                 ee149e8cdc20        <span class="m">5</span> hours ago         672MBportainer/portainer-ce   latest              45be17a5903a        <span class="m">2</span> weeks ago         209MBnginx                    latest              d1a364dc548d        <span class="m">2</span> weeks ago         133MBtomcat                   latest              c43a65faae57        <span class="m">4</span> weeks ago         667MBmysql                    latest              c0cdc95609f1        <span class="m">4</span> weeks ago         556MBportainer/portainer      latest              580c0e4e98b0        <span class="m">2</span> months ago        79.1MBkuangshen/centos         1.0                 f75a47123694        <span class="m">6</span> months ago        209MBroot@yourtreedad:/# docker run -it f75a47123694 /bin/bash但是这个地方报错了，好象是说现在的destination 不能为相对路径 docker: Error response from daemon: OCI runtime create failed: invalid mount <span class="o">{</span>Destination:volume01 Type:bind Source:/var/lib/docker/volumes/67cb8e440bfc475a6b8e0f091779f2c56fed443d1ca4e6edd10ca37f37d09e05/_data Options:<span class="o">[</span>rbind<span class="o">]}</span>: mount destination volume01 not absolute: unknown.ERRO<span class="o">[</span>0000<span class="o">]</span> error waiting <span class="k">for</span> container: context canceled
</code></pre></div><p>查看一下卷挂载的路径</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613192809990.png" >
		<img src="/DockerLearning.assets/image-20210613192809990.png"
			
			
			
			loading="lazy"
			alt="image-20210613192809990">
	</a>
	
	<figcaption>image-20210613192809990</figcaption>
	
</figure></p>
<p>测试一下刚才的文件是否同步出去了，可以在卷里写个文件，在宿主机的挂载位置处查看是否有这个文件就可以辣</p>
<p>这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！</p>
<p>假设构建镜像的时候没有挂载卷，要手动镜像挂载 -v卷名：容器内路径</p>
<p>数据卷容器：多个容器之间同步数据</p>
<p>两个mysql同步数据！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">主从复制之类的就可能使用这个技术使用 --volumes-fromdocker run -it --name docker02 --volumes-from docker01 centosdocker run -it --name docker03 --volumes-from docker01 centos很像继承启动3个容器，通过我们刚才自己写的镜像启动
</code></pre></div><p>启动完了就测试，测试的时候在主docker01中创建文件看看docker0203中会不会有就好了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESdfb328e8f37f        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">3</span> minutes ago       Up <span class="m">2</span> minutes                            docker035787d6ea92e4        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">5</span> minutes ago       Up <span class="m">3</span> minutes                            docker02c8ba46a34155        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">13</span> minutes ago      Up <span class="m">12</span> minutes                           docker01root@yourtreedad:/# docker attach c8ba46a34155<span class="o">[</span>root@c8ba46a34155 /<span class="o">]</span><span class="c1"># cd bin[root@c8ba46a34155 bin]# cd bashbash: cd: bash: Not a directory[root@c8ba46a34155 bin]# cd ..[root@c8ba46a34155 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@c8ba46a34155 /]# mkdir ceshi[root@c8ba46a34155 /]# lsbin  ceshi  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@c8ba46a34155 /]# cd ceshi[root@c8ba46a34155 ceshi]# ls[root@c8ba46a34155 ceshi]# touch ceshi.java[root@c8ba46a34155 ceshi]# lsceshi.java[root@c8ba46a34155 ceshi]# cd ..[root@c8ba46a34155 /]# cd ..[root@c8ba46a34155 /]# exitexit</span>
</code></pre></div><p>没问题</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">oot@yourtreedad:/# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESdfb328e8f37f        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">6</span> minutes ago       Up <span class="m">6</span> minutes                            docker035787d6ea92e4        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">8</span> minutes ago       Up <span class="m">7</span> minutes                            docker02c8ba46a34155        centos              <span class="s2">&#34;/bin/bash&#34;</span>         <span class="m">17</span> minutes ago      Up <span class="m">41</span> seconds                           docker01root@yourtreedad:/# docker attach c8ba46a34155<span class="o">[</span>root@c8ba46a34155 /<span class="o">]</span><span class="c1"># lsbin  ceshi  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@c8ba46a34155 /]# cd ceshi[root@c8ba46a34155 ceshi]# lsceshi.java[root@c8ba46a34155 ceshi]#</span>
</code></pre></div><p>问题：如果docker01 删除了，那么数据还有在docker02和docker03上有吗</p>
<p>有的，它是一种拷贝的概念 ，可能是链接吧</p>
<p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用为止</p>
<p>但是一旦你持久化到了本地，那么数据就可以持久化保存了，本地的数据是不会删除的</p>
<p>dockerfile</p>
<p>dockerfile核心是用来构建docker images 的文件！命令参数脚本！</p>
<p>构建步骤：</p>
<p>1.编写一个dockerfile文件</p>
<p>2.docker build 构建一个镜像</p>
<p>3.docker run 运行镜像</p>
<p>4.docker push 发布镜像（dockerhub 、 阿里云镜像仓库）</p>
<p>查看一下官方是怎么做的</p>
<p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p>
<p>官方既然可以制作镜像，我们也可以！</p>
<p>dockerfile构建过程</p>
<p>很多指令：</p>
<p>基础知识：</p>
<p>1.每个保留关键字（指令） 都必须是大写字母</p>
<p>2.执行从上到下顺序执行</p>
<p>3.#表示注释</p>
<p>4.每个指令都会创建提交一个新的镜像层，并提交</p>
<p>dockerfile 是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单</p>
<p>docker 镜像 例如构建一个springboot 微服务 镜像</p>
<p>docker镜像主键成为企业交付的标准，必须要掌握</p>
<p>步骤：开发运维上线部署</p>
<p>dockerfile：构建文件，这个文件定义了一切的步骤，源代码</p>
<p>dockerimages：通过dockerfile构建生成的镜像，这就是最终发布和运行的产品</p>
<p>dockercontainer：容器就是镜像运行起来提供服务的</p>
<p>dockerfile的指令：</p>
<p>以前的话我们都是使用别人的，现在我们知道了这些指令后，我们来练习自己写一个镜像！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">FROM 基础镜像 一切从这里开始构建MAINTAINER 镜像是谁写的，有你的姓名+邮箱RUN docker镜像构建的时候需要运行的命令ADD  步骤：tomcat镜像，这个tomcat压缩包坑定要被添加进去嘛WORKDIR 镜像的工作目录 VOLUME 容器卷，要挂载的目录EXPOSE 指定暴露端口CMD 指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代ENTRYPOINT 指定这个容器启动的时候要运行的命令，可以追加的命令ONBUILD  当构建一个被继承的dockerfile时候 就会运行onbuild指令，触发指令COPY 类似ADD,将我们的文件拷贝到镜像中ENV	构建的时候设置环境变量
</code></pre></div><p>实战测试！</p>
<p>docker hub 中 99% 都是从这个基础镜像过来的 FROM scratch ， 然后配置需要的软件和配置来进行的构建</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613202655507.png" >
		<img src="/DockerLearning.assets/image-20210613202655507.png"
			
			
			
			loading="lazy"
			alt="image-20210613202655507">
	</a>
	
	<figcaption>image-20210613202655507</figcaption>
	
</figure></p>
<p>创建一个自己的centos</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613203001901.png" >
		<img src="/DockerLearning.assets/image-20210613203001901.png"
			
			
			
			loading="lazy"
			alt="image-20210613203001901">
	</a>
	
	<figcaption>image-20210613203001901</figcaption>
	
</figure></p>
<p>问题：vim clear 等命令都不支持，我们可以在此镜像的基础上在加一点完善一下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">1.编写dockerdile的文件root@yourtreedad:/# <span class="nb">cd</span> homeroot@yourtreedad:/home# lsdocker-test-volume  mysql  nginx  tomcatroot@yourtreedad:/home# mkdir dockerfileroot@yourtreedad:/home# lsdocker-test-volume  dockerfile  mysql  nginx  tomcatroot@yourtreedad:/home# <span class="nb">cd</span> dockerfileroot@yourtreedad:/home/dockerfile# lsroot@yourtreedad:/home/dockerfile# vim mydockerfileroot@yourtreedad:/home/dockerfile# cat mydockerfileFROM centosMAINTAINER ljs&lt;1018814650@qq.com&gt;ENV MYPATH /uer/localWORKDIR <span class="nv">$MYPATHRUN</span> yum -y install vimRUN yum -y install clearRUM yum -y install net-toolsEXPOSE 80CMD <span class="nb">echo</span> <span class="nv">$MYPATHCMD</span> <span class="nb">echo</span> <span class="s2">&#34;-----end-----&#34;</span>CMD /bin/bashroot@yourtreedad:/home/dockerfile#2.通过这个文件构建镜像docker build  -f dockerfile文件路径 -t 镜像名：<span class="o">[</span>tag<span class="o">]</span> root@yourtreedad:/home/dockerfile# docker build -f mydockerfile -t mycentos:0.1 .<span class="o">[</span>+<span class="o">]</span> Building 2.2s <span class="o">(</span>8/8<span class="o">)</span> <span class="nv">FINISHED</span> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load build definition from mydockerfile                                                                 0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring dockerfile: 245B                                                                                   0.0s <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load .dockerignore                                                                                      0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring context: 2B                                                                                        0.0s <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load metadata <span class="k">for</span> docker.io/library/centos:latest                                                       0.0s <span class="o">=</span>&gt; <span class="o">[</span>1/4<span class="o">]</span> FROM docker.io/library/centos                                                                                0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>2/4<span class="o">]</span> WORKDIR /uer/local                                                                                    0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>3/4<span class="o">]</span> RUN yum -y install vim                                                                                0.0s <span class="o">=</span>&gt; <span class="o">[</span>4/4<span class="o">]</span> RUN yum -y install net-tools                                                                                 1.8s <span class="o">=</span>&gt; exporting to image                                                                                                 0.3s <span class="o">=</span>&gt; <span class="o">=</span>&gt; exporting layers                                                                                                0.3s <span class="o">=</span>&gt; <span class="o">=</span>&gt; writing image sha256:2734e41a96b14a3e45a820363638a9f62dfd2c7d901757ea5e2a9ba25ababf50                           0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; naming to docker.io/library/mycentos:0.1	  3.测试 root@yourtreedad:/home/dockerfile# docker run -it --name mycentosdemo mycentos:0.1<span class="o">[</span>root@51e42c44c78d local<span class="o">]</span><span class="c1"># pwd/uer/local[root@51e42c44c78d local]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)        RX packets 9  bytes 726 (726.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  (Local Loopback)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0        </span>
</code></pre></div><p>对比:之前的原生的centos，工作目录默认根目录，没有vim ifconfig 命令</p>
<p>现在：基于原生centos，添加了这些命令</p>
<p>我们可以列出本地镜像的变更历史</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">docker <span class="nb">history</span> imageId
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613204852480.png" >
		<img src="/DockerLearning.assets/image-20210613204852480.png"
			
			
			
			loading="lazy"
			alt="image-20210613204852480">
	</a>
	
	<figcaption>image-20210613204852480</figcaption>
	
</figure></p>
<p>所以我们平时拿到一个镜像，可以研究一下他是怎么做的了</p>
<p>CMD 和 ENTRYPOINT 的区别</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">CMD  指定这个容器启动的时候需要运行的命令，只有最后一个会生效，可被替代cmd的情况下 -l 替换了CMD的<span class="o">[</span><span class="s2">&#34;ls&#34;</span>,<span class="s2">&#34;-a&#34;</span><span class="o">]</span>命令，-l 不是命令所以报错ENTRYPOINT  指定这个容器启动的时候需要运行的命令你，可以追加命令
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613235037903.png" >
		<img src="/DockerLearning.assets/image-20210613235037903.png"
			
			
			
			loading="lazy"
			alt="image-20210613235037903">
	</a>
	
	<figcaption>image-20210613235037903</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613235823435.png" >
		<img src="/DockerLearning.assets/image-20210613235823435.png"
			
			
			
			loading="lazy"
			alt="image-20210613235823435">
	</a>
	
	<figcaption>image-20210613235823435</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210613235940096.png" >
		<img src="/DockerLearning.assets/image-20210613235940096.png"
			
			
			
			loading="lazy"
			alt="image-20210613235940096">
	</a>
	
	<figcaption>image-20210613235940096</figcaption>
	
</figure></p>
<p>不会替换人家的命令</p>
<p>我们的追加命令，是直接凭借在我们的ENTRYPOINT 命令的后面！</p>
<p>dockerfile中很多命令都十分相似，我们需要了解她们的区别，我们最好的学习就是对比她们然后测试效果</p>
<p>实战：</p>
<p>tomcat镜像</p>
<p>1.准备镜像文件 tomcat压缩表，jdk的压缩包！</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614104621398.png" >
		<img src="/DockerLearning.assets/image-20210614104621398.png"
			
			
			
			loading="lazy"
			alt="image-20210614104621398">
	</a>
	
	<figcaption>image-20210614104621398</figcaption>
	
</figure></p>
<p>2.编写dockerfile文件 ， 官方命名Dockerfile ，build会自动寻找这个文件，就不需要-f 指定了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/kuangshen# cat DockerfileFROM centosMAINTAINER ljs&lt;1018814650@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u291-linux-aarch64.tar.gz /usr/local/ADD apache-tomcat-9.0.46.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR <span class="nv">$MYPATHENV</span> JAVA_HOME /usr/local/jdk1.8.0_291ENV CLASSPATH <span class="nv">$JAVA_HOME</span>/lib/dt.jar:<span class="nv">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.46ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.46ENV PATH <span class="nv">$PATH</span>:<span class="nv">$JAVA_HOME</span>/bin:<span class="nv">$CATALINA_HOME</span>/lib:<span class="nv">$CATALINA_HOME</span>/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.46/bin/startup.sh <span class="o">&amp;&amp;</span> tail -F /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.outroot@yourtreedad:/home/kuangshen#
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614112215796.png" >
		<img src="/DockerLearning.assets/image-20210614112215796.png"
			
			
			
			loading="lazy"
			alt="image-20210614112215796">
	</a>
	
	<figcaption>image-20210614112215796</figcaption>
	
</figure></p>
<p>3.构建镜像</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614110353773.png" >
		<img src="/DockerLearning.assets/image-20210614110353773.png"
			
			
			
			loading="lazy"
			alt="image-20210614110353773">
	</a>
	
	<figcaption>image-20210614110353773</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/kuangshen# docker build -f Dockerfile -t diytomcat .<span class="o">[</span>+<span class="o">]</span> Building 0.1s <span class="o">(</span>11/11<span class="o">)</span> <span class="nv">FINISHED</span> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load build definition from Dockerfile                                                               0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring dockerfile: 670B                                                                               0.0s <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load .dockerignore                                                                                  0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring context: 2B                                                                                    0.0s <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load metadata <span class="k">for</span> docker.io/library/centos:latest                                                   0.0s <span class="o">=</span>&gt; <span class="o">[</span>1/6<span class="o">]</span> FROM docker.io/library/centos                                                                            0.0s <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load build context                                                                                  0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring context: 130B                                                                                  0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>2/6<span class="o">]</span> COPY readme.txt /usr/local/readme.txt                                                             0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>3/6<span class="o">]</span> ADD jdk-8u291-linux-aarch64.tar.gz /usr/local/                                                    0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>4/6<span class="o">]</span> ADD apache-tomcat-9.0.46.tar.gz /usr/local/                                                       0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>5/6<span class="o">]</span> RUN yum -y install vim                                                                            0.0s <span class="o">=</span>&gt; CACHED <span class="o">[</span>6/6<span class="o">]</span> WORKDIR /usr/local                                                                                0.0s <span class="o">=</span>&gt; exporting to image                                                                                             0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; exporting layers                                                                                            0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; writing image sha256:d65fc7234bf254fb93a262a640dcfb543b6f4780fa36ef881bb9992d9705359f                       0.0s <span class="o">=</span>&gt; <span class="o">=</span>&gt; naming to docker.io/library/diytomcat
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">启动容器 分配端口 使用挂载 指定镜像root@yourtreedad:/home/kuangshen# docker run -d -p 9090:8080 --name kuangshendiytomcat -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.46/logs diytomcat:1.0
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614110934343.png" >
		<img src="/DockerLearning.assets/image-20210614110934343.png"
			
			
			
			loading="lazy"
			alt="image-20210614110934343">
	</a>
	
	<figcaption>image-20210614110934343</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/kuangshen# docker imagesREPOSITORY               TAG                 IMAGE ID            CREATED             SIZEdiytomcat                latest              d65fc7234bf2        <span class="m">4</span> hours ago         464MBmycentos                 0.1                 2734e41a96b1        <span class="m">20</span> hours ago        284MBtomcatupdate             1.0                 ee149e8cdc20        <span class="m">28</span> hours ago        672MBportainer/portainer-ce   latest              45be17a5903a        <span class="m">2</span> weeks ago         209MBnginx                    latest              d1a364dc548d        <span class="m">2</span> weeks ago         133MBtomcat                   latest              c43a65faae57        <span class="m">4</span> weeks ago         667MBmysql                    latest              c0cdc95609f1        <span class="m">4</span> weeks ago         556MBportainer/portainer      latest              580c0e4e98b0        <span class="m">2</span> months ago        79.1MBmycentosentrypointtest   1.0                 5198b187e833        <span class="m">6</span> months ago        209MBmycentostest             1.0                 be8cf7de8763        <span class="m">6</span> months ago        209MBkuangshen/centos         1.0                 f75a47123694        <span class="m">6</span> months ago        209MBcentos                   latest              300e315adb2f        <span class="m">6</span> months ago        209MBroot@yourtreedad:/home/kuangshen# docker run --name diytomcat01 -d -p 9090:8080 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.46/logs diytomcat174cd08dab23fce852cae1ac5e721c985b377d1ff85a1e769384cb9dd369bde0
</code></pre></div><p>进入容器查看</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/kuangshen/build/tomcat# docker <span class="nb">exec</span> -it c7cff52b8760  /bin/bash这里的bin/bash就会自动跳转到我们设定好的usr/local目录之下
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614111326218.png" >
		<img src="/DockerLearning.assets/image-20210614111326218.png"
			
			
			
			loading="lazy"
			alt="image-20210614111326218">
	</a>
	
	<figcaption>image-20210614111326218</figcaption>
	
</figure></p>
<p>4.启动镜像</p>
<p>5.访问测试</p>
<p>6.发布项目（由于做了卷挂载，我们直接在本地编写项目就可以直接发布了！）</p>
<p>发现项目部署成功，可以直接访问！</p>
<p>我们以后开发的步骤：需要掌握dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！！！</p>
<p>发布镜像</p>
<p>dockerhub</p>
<p>1.地址 注册自己的账号</p>
<p>2.确定这个账号可以登陆</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614162522282.png" >
		<img src="/DockerLearning.assets/image-20210614162522282.png"
			
			
			
			loading="lazy"
			alt="image-20210614162522282">
	</a>
	
	<figcaption>image-20210614162522282</figcaption>
	
</figure></p>
<p>3.在服务器上提交自己的镜像</p>
<p>在此之前需要打tag</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker tag --helpUsage:  docker tag SOURCE_IMAGE<span class="o">[</span>:TAG<span class="o">]</span> TARGET_IMAGE<span class="o">[</span>:TAG<span class="o">]</span>Create a tag TARGET_IMAGE that refers to SOURCE_IMAGEroot@yourtreedad:/# docker tag tomcatupdate:1.0 yourtreedad/tomcatupdate:2.0
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614165331722.png" >
		<img src="/DockerLearning.assets/image-20210614165331722.png"
			
			
			
			loading="lazy"
			alt="image-20210614165331722">
	</a>
	
	<figcaption>image-20210614165331722</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker push yourtreedad/tomcateupdatehub:1.0
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614165502602.png" >
		<img src="/DockerLearning.assets/image-20210614165502602.png"
			
			
			
			loading="lazy"
			alt="image-20210614165502602">
	</a>
	
	<figcaption>image-20210614165502602</figcaption>
	
</figure></p>
<p>提交的时候也是按照镜像的层级一层一层提交的</p>
<p>可以发布到阿里云镜像服务上嘻嘻</p>
<p>1.登陆阿里云</p>
<p>2.找到容器镜像服务</p>
<p>3.创建命名空间  为了隔离</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614170103181.png" >
		<img src="/DockerLearning.assets/image-20210614170103181.png"
			
			
			
			loading="lazy"
			alt="image-20210614170103181">
	</a>
	
	<figcaption>image-20210614170103181</figcaption>
	
</figure></p>
<p>4.创建容器镜像</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614170213918.png" >
		<img src="/DockerLearning.assets/image-20210614170213918.png"
			
			
			
			loading="lazy"
			alt="image-20210614170213918">
	</a>
	
	<figcaption>image-20210614170213918</figcaption>
	
</figure></p>
<p>5.浏览阿里云</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614170251978.png" >
		<img src="/DockerLearning.assets/image-20210614170251978.png"
			
			
			
			loading="lazy"
			alt="image-20210614170251978">
	</a>
	
	<figcaption>image-20210614170251978</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker login --username<span class="o">=</span>把书掏出来 registry.cn-hangzhou.aliyuncs.comPassword:Login Succeeded	
</code></pre></div><p>登陆</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker tag ee149e8cdc20 registry.cn-hangzhou.aliyuncs.com/hfutie/yourtree-test:1.0
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614171742651.png" >
		<img src="/DockerLearning.assets/image-20210614171742651.png"
			
			
			
			loading="lazy"
			alt="image-20210614171742651">
	</a>
	
	<figcaption>image-20210614171742651</figcaption>
	
</figure></p>
<p>上传</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker push registry.cn-hangzhou.aliyuncs.com/hfutie/yourtree-test:1.0
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614171949041.png" >
		<img src="/DockerLearning.assets/image-20210614171949041.png"
			
			
			
			loading="lazy"
			alt="image-20210614171949041">
	</a>
	
	<figcaption>image-20210614171949041</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614172425553.png" >
		<img src="/DockerLearning.assets/image-20210614172425553.png"
			
			
			
			loading="lazy"
			alt="image-20210614172425553">
	</a>
	
	<figcaption>image-20210614172425553</figcaption>
	
</figure></p>
<p>docker小结</p>
<p>dockerfile build</p>
<p>images tag、run/push/pull/save/load</p>
<p>containers stop/kill/start/restart/commit</p>
<p>dockerrepository</p>
<p>backup.tar</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614172933295.png" >
		<img src="/DockerLearning.assets/image-20210614172933295.png"
			
			
			
			loading="lazy"
			alt="image-20210614172933295">
	</a>
	
	<figcaption>image-20210614172933295</figcaption>
	
</figure></p>
<p>精通的话需要学会docker网络（铺垫、容器编排、集群部署）</p>
<p>docker网络</p>
<p>理解docker网络 docker0</p>
<p>清空所有环境</p>
<p>测试</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614185814918.png" >
		<img src="/DockerLearning.assets/image-20210614185814918.png"
			
			
			
			loading="lazy"
			alt="image-20210614185814918">
	</a>
	
	<figcaption>image-20210614185814918</figcaption>
	
</figure></p>
<p>好多个网络，docker是如何处理容器网络访问的？</p>
<p>ES之前的问题</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker run -d -P --name tomcat01 tomcat查看容器的内部网络地址 ip addr,发现容器启动的时候会得到一个eth0@if22 ip地址，docker分配的root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever2: sit0@NONE: &lt;NOARP&gt; mtu <span class="m">1480</span> qdisc noop state DOWN group default qlen <span class="m">1000</span>    link/sit 0.0.0.0 brd 0.0.0.021: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever       发现windows好像ping不通啊  linux可以ping通 docker容器内部
</code></pre></div><p>原理</p>
<p>192.168.0.1路由器</p>
<p>192.168.0.3 同一个网段是能ping通的</p>
<p>1.我们每安装一个docker容器 ， docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，（windows for docker好像咩有） ， 桥接模式，使用的技术是evth-pair技术！</p>
<p>再次测试 ip addr之后</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614190941605.png" >
		<img src="/DockerLearning.assets/image-20210614190941605.png"
			
			
			
			loading="lazy"
			alt="image-20210614190941605">
	</a>
	
	<figcaption>image-20210614190941605</figcaption>
	
</figure></p>
<p>网课里说的是又多了一个，但windows中没有发现</p>
<p>2.在启动一个容器测试</p>
<p>网课里说的是又多了一个，但windows中没有</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614191119464.png" >
		<img src="/DockerLearning.assets/image-20210614191119464.png"
			
			
			
			loading="lazy"
			alt="image-20210614191119464">
	</a>
	
	<figcaption>image-20210614191119464</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">我们发现这个容器带来的网卡，都是一对一对的veth-pair 就是一对的虚拟设备接口，她们都是成对出现的，一端连着协议，一端彼此相连正因为有这个特性 我们就使用veth-pair 充当一个桥梁，连接各种虚拟网络设备的OpenStac，Docker容器之间的链接，OVS的连接，都是使用 veth-pair技术
</code></pre></div><p>3.我们来测试一下tomca01 和 tomcat02 是否可以ping通</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614194957533.png" >
		<img src="/DockerLearning.assets/image-20210614194957533.png"
			
			
			
			loading="lazy"
			alt="image-20210614194957533">
	</a>
	
	<figcaption>image-20210614194957533</figcaption>
	
</figure></p>
<p>在linux中，tomcat01和宿主机和tomcat02可以相互ping通</p>
<p>在windows for docker中，tomcat01和tomcat02可以通，但是不能和宿主机ping通</p>
<p>结论：容器和容器之间是可以互相ping通的</p>
<p>在linux中，tomcat01和tomcat02是共用的一个路由器，即docker0</p>
<p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP</p>
<p>0-255  A   B   C</p>
<p>255.255.0.1/16  域</p>
<p>00000000.00000000.00000000.00000000</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>docker使用的是linux桥接，宿主机中是一个docker容器的网桥，docker0</p>
<p>docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！内网传递文件！</p>
<p>只要容器删除了，对应的网桥就没了</p>
<p>&ndash;link</p>
<blockquote>
<p>思考一个场景，我们编写了一个微服务，database url = ip：</p>
</blockquote>
<p>项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来进行访问容器？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">直接ping服务名是不行的root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known解决？通过--link 就可以解决了网络连通root@yourtreedad:~# docker run -d --name tomcat03 --link tomcat02 tomcat832afb5618b02262a5f9cbe48072941cc4784c009d0f91962b371c218afa31c0root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat02 ping tomcat03ping: tomcat03: Name or service not knownroot@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat03 ping tomcat02
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614200734188.png" >
		<img src="/DockerLearning.assets/image-20210614200734188.png"
			
			
			
			loading="lazy"
			alt="image-20210614200734188">
	</a>
	
	<figcaption>image-20210614200734188</figcaption>
	
</figure></p>
<p>默认网关docker0 ，就是这里的172.17.0.1</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614201015974.png" >
		<img src="/DockerLearning.assets/image-20210614201015974.png"
			
			
			
			loading="lazy"
			alt="image-20210614201015974">
	</a>
	
	<figcaption>image-20210614201015974</figcaption>
	
</figure></p>
<p>探究：inspect 容器id</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614201318560.png" >
		<img src="/DockerLearning.assets/image-20210614201318560.png"
			
			
			
			loading="lazy"
			alt="image-20210614201318560">
	</a>
	
	<figcaption>image-20210614201318560</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">link的本质查看hosts配置，在这里原理发现root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat03 cat /etc/hosts
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614201902916.png" >
		<img src="/DockerLearning.assets/image-20210614201902916.png"
			
			
			
			loading="lazy"
			alt="image-20210614201902916">
	</a>
	
	<figcaption>image-20210614201902916</figcaption>
	
</figure></p>
<p>&ndash;link 就是我们在hosts配置中，增加了一个172.18.0.3 tomcat02 的映射</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614202018329.png" >
		<img src="/DockerLearning.assets/image-20210614202018329.png"
			
			
			
			loading="lazy"
			alt="image-20210614202018329">
	</a>
	
	<figcaption>image-20210614202018329</figcaption>
	
</figure></p>
<p>由于02没有使用&ndash;link，所以不能直接使用 服务名字来跳转</p>
<p>实际上就是host映射</p>
<p>我们现在使用docker已经不建议使用&ndash;link了！</p>
<p>需要自定义网络！不适用docker0！</p>
<p>docker0问题：他不支持容器名连接访问！</p>
<p>自定义网络</p>
<p>容器互联：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">查看所有的docker网络docker network ls
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614202322526.png" >
		<img src="/DockerLearning.assets/image-20210614202322526.png"
			
			
			
			loading="lazy"
			alt="image-20210614202322526">
	</a>
	
	<figcaption>image-20210614202322526</figcaption>
	
</figure></p>
<p>网络模式</p>
<p>bridge 网络桥接模式 搭桥：（默认，自己创建的推荐使用bridge模式）</p>
<p>none ：不配置网络</p>
<p>host：和宿主机共享网络</p>
<p>container：容器内网络连通！（用得少，局限很大）</p>
<p>测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">我们直接启动的命令 默认，这个我们看了就是我们的docker0root@yourtreedad:~# docker run -d -P --name tomcat01 --net bridge tomcat实际上不写--net也是默认的docker0 特点，默认，域名不能访问 --link 可以打通连接！我们可以自定义一个网络！
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614202926510.png" >
		<img src="/DockerLearning.assets/image-20210614202926510.png"
			
			
			
			loading="lazy"
			alt="image-20210614202926510">
	</a>
	
	<figcaption>image-20210614202926510</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614203159484.png" >
		<img src="/DockerLearning.assets/image-20210614203159484.png"
			
			
			
			loading="lazy"
			alt="image-20210614203159484">
	</a>
	
	<figcaption>image-20210614203159484</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">创建一个自定义网络docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet 桥接、子网、网关设置我们自己的网络就创建好了！
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614203427052.png" >
		<img src="/DockerLearning.assets/image-20210614203427052.png"
			
			
			
			loading="lazy"
			alt="image-20210614203427052">
	</a>
	
	<figcaption>image-20210614203427052</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">使用自己构建的网络来创建容器，塞进去root@yourtreedad:~# docker run -d -P --name tomcat-net-01 --net mynet tomcat8d24df7fb899de77db6b600aedbfacc32fdd161836dd638b56666ca2014ff5bfroot@yourtreedad:~# docker run -d -P --name tomcat-net-02 --net mynet tomcateee0d29dbed8e780487fcc4bf93f1b3a9ab5ad8ffac194861a3c2ee948d8ea9e查看网络情况root@yourtreedad:~# docker inspect mynet
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614203821209.png" >
		<img src="/DockerLearning.assets/image-20210614203821209.png"
			
			
			
			loading="lazy"
			alt="image-20210614203821209">
	</a>
	
	<figcaption>image-20210614203821209</figcaption>
	
</figure></p>
<p>看看能不能ping通</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">现在不使用 --link也可以ping名字了！root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat-net-01 ping 192.168.0.3root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat-net-01 ping tomcat-net-02
</code></pre></div><p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络！</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614204033670.png" >
		<img src="/DockerLearning.assets/image-20210614204033670.png"
			
			
			
			loading="lazy"
			alt="image-20210614204033670">
	</a>
	
	<figcaption>image-20210614204033670</figcaption>
	
</figure></p>
<p>好处：</p>
<p>redis - 保证不同的集群使用不同的网络，保证集群是安全和健康的</p>
<p>mysql</p>
<p>网络连通</p>
<p>没有确保两个集群网络连通的情况下 ， 两个子网是无法相连的</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614204746483.png" >
		<img src="/DockerLearning.assets/image-20210614204746483.png"
			
			
			
			loading="lazy"
			alt="image-20210614204746483">
	</a>
	
	<figcaption>image-20210614204746483</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">构建两个tomcat 但是默认是docker0网络下的root@yourtreedad:~# docker run -d -P --name tomcat01 tomcat86e292de23f4c821375058608f49f6a5bbdcd0220a5c3e36999cafa86eb25f79root@yourtreedad:~# docker run -d -P --name tomcat02 tomcate45223474886d4f490ed66446c2eb1b7809b273c5b104fde27301d9746f4ebf6而tomcat-net-01是在mynet下的，所以连不通root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat02 ping 192.168.0.3不能让docker0和mynet连通，这样不安全，要单独让tomcat01 和mynet连通如何操作docker network connect测试打通 tomcat01 到 mynet
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614205014081.png" >
		<img src="/DockerLearning.assets/image-20210614205014081.png"
			
			
			
			loading="lazy"
			alt="image-20210614205014081">
	</a>
	
	<figcaption>image-20210614205014081</figcaption>
	
</figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:~# docker network connect mynet tomcat01root@yourtreedad:~# docker network inspect mynet连通之后就是将tomcat01 放置到了 mynet 网络下？一个容器两个ip地址！ 阿里云服务，公网ip 和 私网ip
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614205144180.png" >
		<img src="/DockerLearning.assets/image-20210614205144180.png"
			
			
			
			loading="lazy"
			alt="image-20210614205144180">
	</a>
	
	<figcaption>image-20210614205144180</figcaption>
	
</figure></p>
<p>再试试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:~# docker <span class="nb">exec</span> -it tomcat01 ping tomcat-net-01
</code></pre></div><p>0102好像都可以打通</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210614205634156.png" >
		<img src="/DockerLearning.assets/image-20210614205634156.png"
			
			
			
			loading="lazy"
			alt="image-20210614205634156">
	</a>
	
	<figcaption>image-20210614205634156</figcaption>
	
</figure></p>
<p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</p>
<p>实战：部署redis集群</p>
<p>分片+高可用+负载均衡</p>
<p>shell脚本建立！</p>
<p>3主3从</p>
<p>1.建立网络</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker network create redisnet --subnet 172.38.0.0/16root@yourtreedad:/# docker network lsroot@yourtreedad:/# docker network inspect redisnet
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617192710761.png" >
		<img src="/DockerLearning.assets/image-20210617192710761.png"
			
			
			
			loading="lazy"
			alt="image-20210617192710761">
	</a>
	
	<figcaption>image-20210617192710761</figcaption>
	
</figure></p>
<p>2.通过脚本创建六个redis配置</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# <span class="k">for</span> port in <span class="k">$(</span>seq <span class="m">1</span> 6<span class="k">)</span><span class="p">;</span>domkdir -p /mydata/redis/node-<span class="si">${</span><span class="nv">port</span><span class="si">}</span>/conftouch /mydata/redis/node-<span class="si">${</span><span class="nv">port</span><span class="si">}</span>/conf/redis.confcat <span class="s">&lt;&lt; EOF &gt;&gt;/mydata/redis/node-${port}/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1${port}cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yes EOF</span>done
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617194321734.png" >
		<img src="/DockerLearning.assets/image-20210617194321734.png"
			
			
			
			loading="lazy"
			alt="image-20210617194321734">
	</a>
	
	<figcaption>image-20210617194321734</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617194434797.png" >
		<img src="/DockerLearning.assets/image-20210617194434797.png"
			
			
			
			loading="lazy"
			alt="image-20210617194434797">
	</a>
	
	<figcaption>image-20210617194434797</figcaption>
	
</figure></p>
<p>3.拉取镜像，启动容器，分配端口，数据卷映射</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker run -p 6371:6379 -p 16371:16379 --name redis-1 -v /mydata/redis/node-1/data:/data -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6372:6379 -p 16372:16379 --name redis-2 -v /mydata/redis/node-2/data:/data -v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6373:6379 -p 16373:16379 --name redis-3 -v /mydata/redis/node-3/data:/data -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6374:6379 -p 16374:16379 --name redis-4 -v /mydata/redis/node-4/data:/data -v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6375:6379 -p 16375:16379 --name redis-5 -v /mydata/redis/node-5/data:/data -v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.confdocker run -p 6376:6379 -p 16376:16379 --name redis-6 -v /mydata/redis/node-6/data:/data -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redisnet --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617200000188.png" >
		<img src="/DockerLearning.assets/image-20210617200000188.png"
			
			
			
			loading="lazy"
			alt="image-20210617200000188">
	</a>
	
	<figcaption>image-20210617200000188</figcaption>
	
</figure></p>
<p>进入容器内部</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker <span class="nb">exec</span> -it redis-1 /bin/sh
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617200316068.png" >
		<img src="/DockerLearning.assets/image-20210617200316068.png"
			
			
			
			loading="lazy"
			alt="image-20210617200316068">
	</a>
	
	<figcaption>image-20210617200316068</figcaption>
	
</figure></p>
<p>建立集群 切片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">/data <span class="c1"># redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span>
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617200738182.png" >
		<img src="/DockerLearning.assets/image-20210617200738182.png"
			
			
			
			loading="lazy"
			alt="image-20210617200738182">
	</a>
	
	<figcaption>image-20210617200738182</figcaption>
	
</figure></p>
<p>查看集群信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">/data <span class="c1"># redis-cli -c127.0.0.1:6379&gt; cluster info127.0.0.1:6379&gt; cluster nodes127.0.0.1:6379&gt; set a b</span>
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617201019736.png" >
		<img src="/DockerLearning.assets/image-20210617201019736.png"
			
			
			
			loading="lazy"
			alt="image-20210617201019736">
	</a>
	
	<figcaption>image-20210617201019736</figcaption>
	
</figure></p>
<p>测试，停掉一个master主机redis会不会使用备机来顶替主机</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/# docker stop redis-3root@yourtreedad:/# docker <span class="nb">exec</span> -it redis-1 /bin/sh/data <span class="c1"># redis-cli -c127.0.0.1:6379&gt; cluster info127.0.0.1:6379&gt; get a</span>
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617201403193.png" >
		<img src="/DockerLearning.assets/image-20210617201403193.png"
			
			
			
			loading="lazy"
			alt="image-20210617201403193">
	</a>
	
	<figcaption>image-20210617201403193</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617201528497.png" >
		<img src="/DockerLearning.assets/image-20210617201528497.png"
			
			
			
			loading="lazy"
			alt="image-20210617201528497">
	</a>
	
	<figcaption>image-20210617201528497</figcaption>
	
</figure></p>
<p>docker 搭建 redis集群完成！</p>
<p>我们使用了docker之后，所有的技术都会慢慢变得简单起来</p>
<p>springboot 微服务打包docker镜像</p>
<p>1.架构springboot项目</p>
<p>2.打包应用</p>
<p>3.编写dockerfile</p>
<p>4.构建镜像</p>
<p>5.发布运行！</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617204707930.png" >
		<img src="/DockerLearning.assets/image-20210617204707930.png"
			
			
			
			loading="lazy"
			alt="image-20210617204707930">
	</a>
	
	<figcaption>image-20210617204707930</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617204834101.png" >
		<img src="/DockerLearning.assets/image-20210617204834101.png"
			
			
			
			loading="lazy"
			alt="image-20210617204834101">
	</a>
	
	<figcaption>image-20210617204834101</figcaption>
	
</figure></p>
<p>cmd测试</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617204915044.png" >
		<img src="/DockerLearning.assets/image-20210617204915044.png"
			
			
			
			loading="lazy"
			alt="image-20210617204915044">
	</a>
	
	<figcaption>image-20210617204915044</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617213140315.png" >
		<img src="/DockerLearning.assets/image-20210617213140315.png"
			
			
			
			loading="lazy"
			alt="image-20210617213140315">
	</a>
	
	<figcaption>image-20210617213140315</figcaption>
	
</figure></p>
<p>回到idea中编写dockerfile</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617224102830.png" >
		<img src="/DockerLearning.assets/image-20210617224102830.png"
			
			
			
			loading="lazy"
			alt="image-20210617224102830">
	</a>
	
	<figcaption>image-20210617224102830</figcaption>
	
</figure></p>
<p>弄好之后连接linux ， 吧windows上的dockerfile和jar包传到linux服务器上，需要使用filezilla软件传输</p>
<p>linux服务器ip地址指令   ifconfig</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617213836333.png" >
		<img src="/DockerLearning.assets/image-20210617213836333.png"
			
			
			
			loading="lazy"
			alt="image-20210617213836333">
	</a>
	
	<figcaption>image-20210617213836333</figcaption>
	
</figure></p>
<p>切换用户</p>
<p>把文件传到linux上</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617221920977.png" >
		<img src="/DockerLearning.assets/image-20210617221920977.png"
			
			
			
			loading="lazy"
			alt="image-20210617221920977">
	</a>
	
	<figcaption>image-20210617221920977</figcaption>
	
</figure></p>
<p>坑死了 ENTRYPOINT 与[]之间有个打空格</p>
<p>通过build 构建镜像</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/idea# docker build -f Dockerfile -t kuangshen666 .
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617224515040.png" >
		<img src="/DockerLearning.assets/image-20210617224515040.png"
			
			
			
			loading="lazy"
			alt="image-20210617224515040">
	</a>
	
	<figcaption>image-20210617224515040</figcaption>
	
</figure></p>
<p>测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:/home/idea# docker run -d --name kuangshen-springboot-web -P kuangshen666root@yourtreedad:/home/idea# curl localhost:49158/hello
</code></pre></div><p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617225833450.png" >
		<img src="/DockerLearning.assets/image-20210617225833450.png"
			
			
			
			loading="lazy"
			alt="image-20210617225833450">
	</a>
	
	<figcaption>image-20210617225833450</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210617230044609.png" >
		<img src="/DockerLearning.assets/image-20210617230044609.png"
			
			
			
			loading="lazy"
			alt="image-20210617230044609">
	</a>
	
	<figcaption>image-20210617230044609</figcaption>
	
</figure></p>
<p>以后我们使用了Docker之后，给别人交付的就是一个镜像即可</p>
<p>预告：如果我们有很多镜像？100个</p>
<p>还要学</p>
<p>Docker Compost</p>
<p>Docker Swarm</p>
<p>K8s</p>
<p>CI/CD 之 Jenkins</p>
<p>尝试基于ECS快速搭建docker环境</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210618223452399.png" >
		<img src="/DockerLearning.assets/image-20210618223452399.png"
			
			
			
			loading="lazy"
			alt="image-20210618223452399">
	</a>
	
	<figcaption>image-20210618223452399</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210618223539027.png" >
		<img src="/DockerLearning.assets/image-20210618223539027.png"
			
			
			
			loading="lazy"
			alt="image-20210618223539027">
	</a>
	
	<figcaption>image-20210618223539027</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210618223624125.png" >
		<img src="/DockerLearning.assets/image-20210618223624125.png"
			
			
			
			loading="lazy"
			alt="image-20210618223624125">
	</a>
	
	<figcaption>image-20210618223624125</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210618223650264.png" >
		<img src="/DockerLearning.assets/image-20210618223650264.png"
			
			
			
			loading="lazy"
			alt="image-20210618223650264">
	</a>
	
	<figcaption>image-20210618223650264</figcaption>
	
</figure></p>
<p>ECS云服务器新手上路</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210619103343896.png" >
		<img src="/DockerLearning.assets/image-20210619103343896.png"
			
			
			
			loading="lazy"
			alt="image-20210619103343896">
	</a>
	
	<figcaption>image-20210619103343896</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210619103400085.png" >
		<img src="/DockerLearning.assets/image-20210619103400085.png"
			
			
			
			loading="lazy"
			alt="image-20210619103400085">
	</a>
	
	<figcaption>image-20210619103400085</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210619103431630.png" >
		<img src="/DockerLearning.assets/image-20210619103431630.png"
			
			
			
			loading="lazy"
			alt="image-20210619103431630">
	</a>
	
	<figcaption>image-20210619103431630</figcaption>
	
</figure></p>
<p>下面尝试部署了一下继恩的vue和nginx</p>
<p>nginx使用挂载的方式-v 来实现对容器内部nginx配置文件的替换，</p>
<p>利用docker cp 来把dist文件拷贝进去</p>
<p>使用-p 的方式替换端口</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@yourtreedad:~# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxb4d181a07f80: Already exists66b1c490df3f: Pull completed0f91ae9b44c: Pull completebaf987068537: Pull complete6bbc76cbebeb: Pull complete32b766478bc2: Pull completeDigest: sha256:353c20f74d9b6aee359f30e8e4f69c3d7eaea2f610681c4a95849a2fd7c497f9Status: Downloaded newer image <span class="k">for</span> nginx:latestdocker.io/library/nginx:latestroot@yourtreedad:~#root@yourtreedad:~# docker imagesREPOSITORY               TAG                 IMAGE ID            CREATED             SIZEnginx                    latest              4cdc5dd7eaad        <span class="m">10</span> days ago         133MByourtreedad/blazordemo   latest              aa1397c0af05        <span class="m">2</span> weeks ago         207MBmysql                    latest              5c62e459e087        <span class="m">3</span> weeks ago         556MBroot@yourtreedad:~# <span class="nb">cd</span> ..root@yourtreedad:/# pwd/root@yourtreedad:/# <span class="nb">cd</span> homeroot@yourtreedad:/home# lsblazortest    haierDemo  ljs      mvcwindowstest  nginx      tomcatconsoletest1  kuangshen  mvctest  mysql           nginxdemo  webapitestroot@yourtreedad:/home# <span class="nb">cd</span> nginxdemoroot@yourtreedad:/home/nginxdemo# lsnginx-1.14.2  nginx-1.14.2.ziproot@yourtreedad:/home/nginxdemo# <span class="nb">cd</span> nginx-1.14.2root@yourtreedad:/home/nginxdemo/nginx-1.14.2# lsconf  contrib  dist  docs  html  logs  nginx.exe  temproot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker run --name nginxdemo2 -p 8889:8765 -v /home/nginxdemo/nginx-1.14.2/conf/myconf1.conf:/etc/nginx/nginx.conf:ro -d nginx6bed1ace8c9942f62e61ea18f7f632973fa1d7536ac3a6d1ada11e3d2c093b6eroot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker cp /home/nginxdemo/nginx-1.14.2/dist 6bed1ace8c9942f62e:/etc/nginxroot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker <span class="nb">exec</span> -it 6bed1ace8c9942f62e61ea18f7f632973fa1d7536ac3a6d1ada11e3d2c093b6e /bin/bashlslsroot@6bed1ace8c99:/# lsbin   docker-entrypoint.d   home   media  proc  sbin  tmpboot  docker-entrypoint.sh  lib    mnt    root  srv   usrdev   etc                   lib64  opt    run   sys   varroot@6bed1ace8c99:/# <span class="nb">cd</span> /etcroot@6bed1ace8c99:/etc# <span class="nb">cd</span> nginxroot@6bed1ace8c99:/etc/nginx# lsconf.d  dist  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_paramsroot@6bed1ace8c99:/etc/nginx# cat nginx.conf#user  nobody<span class="p">;</span>c553c6ba5f13: Pushed#error_log  logs/error.log<span class="p">;</span><span class="c1">#error_log  logs/error.log  notice;Head https://registry-1.docker.io/v2/yourtreedad/nginxcontaindist/blobs/sha256:4d7903a7ce4bdf92461e0dd87d1fb712facb6881df3cbce68f55f4ec54791546: dial tcp: lookup registry-1.docker.io on 192.168.65.5:53: no such hostroot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf#events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;    #                  &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;    #                  &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;    #access_log  logs/access.log  main;    # server {    #     listen 8765;    #     listen localhost;    #     location / {    #         root dist;    #         index index.html index.htm;    #     }    # }    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       8765;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   dist;            index  index.html index.htm;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}67f2e8eb8c87: Pushing [&gt;                                                  ]  77.82kB/4.758MB        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}root@6bed1ace8c99:/etc/nginx# exitexitroot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker commit -a=&#34;yourtreedad&#34; -m=&#34;jien&#39;s ui add ljs&#39;s deploy new nginx that contains dist&#34; 6bed1ace8c nginx:1.0sha256:4d7903a7ce4bdf92461e0dd87d1fb712facb6881df3cbce68f55f4ec54791546root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker push yourtreedad/nginx:1.0The push refers to repository [docker.io/yourtreedad/nginx]An image does not exist locally with the tag: yourtreedad/nginxroot@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker tag nginx:1.0 yourtreedad/nginxcontaindist:1.0root@yourtreedad:/home/nginxdemo/nginx-1.14.2/conf# docker push yourtreedad/nginxcontaindist:1.0The push refers to repository [docker.io/yourtreedad/nginxcontaindist]67f2e8eb8c87: Preparing9d1af766c818: Preparingd97733c0a3b6: Preparingc553c6ba5f13: Preparing48b4a40de359: Preparingace9ed9bcfaf: Waiting764055ebc9a7: Waiting</span>
</code></pre></div><p>这是部署在本地 ， 现在开始演示部署到云服务器上</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210718003213326.png" >
		<img src="/DockerLearning.assets/image-20210718003213326.png"
			
			
			
			loading="lazy"
			alt="image-20210718003213326">
	</a>
	
	<figcaption>image-20210718003213326</figcaption>
	
</figure></p>
<p>通过ssh把配置文件传进去</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210718003244110.png" >
		<img src="/DockerLearning.assets/image-20210718003244110.png"
			
			
			
			loading="lazy"
			alt="image-20210718003244110">
	</a>
	
	<figcaption>image-20210718003244110</figcaption>
	
</figure></p>
<p>从dockerhub上拉取镜像</p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210718003546820.png" >
		<img src="/DockerLearning.assets/image-20210718003546820.png"
			
			
			
			loading="lazy"
			alt="image-20210718003546820">
	</a>
	
	<figcaption>image-20210718003546820</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="/DockerLearning.assets/image-20210718003653954.png" >
		<img src="/DockerLearning.assets/image-20210718003653954.png"
			
			
			
			loading="lazy"
			alt="image-20210718003653954">
	</a>
	
	<figcaption>image-20210718003653954</figcaption>
	
</figure></p>
<p>http://47.106.218.61:8888/</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>

     
     
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 think hy how to learn
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#docker学习">docker学习</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
